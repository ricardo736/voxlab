(() => {
  var __create = Object.create;
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getProtoOf = Object.getPrototypeOf;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __esm = (fn, res) => function __init() {
    return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
  };
  var __commonJS = (cb, mod) => function __require() {
    return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
  };
  var __export = (target, all) => {
    for (var name in all)
      __defProp(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames(from))
        if (!__hasOwnProp.call(to, key) && key !== except)
          __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
    // If the importer is in node compatibility mode or this is not an ESM
    // file that has been converted to a CommonJS file using a Babel-
    // compatible transform (i.e. "__esModule" has not been set), then set
    // "default" to the CommonJS "module.exports" for node compatibility.
    isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
    mod
  ));

  // node_modules/react/cjs/react.production.js
  var require_react_production = __commonJS({
    "node_modules/react/cjs/react.production.js"(exports) {
      "use strict";
      var REACT_ELEMENT_TYPE = Symbol.for("react.transitional.element");
      var REACT_PORTAL_TYPE = Symbol.for("react.portal");
      var REACT_FRAGMENT_TYPE = Symbol.for("react.fragment");
      var REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode");
      var REACT_PROFILER_TYPE = Symbol.for("react.profiler");
      var REACT_CONSUMER_TYPE = Symbol.for("react.consumer");
      var REACT_CONTEXT_TYPE = Symbol.for("react.context");
      var REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref");
      var REACT_SUSPENSE_TYPE = Symbol.for("react.suspense");
      var REACT_MEMO_TYPE = Symbol.for("react.memo");
      var REACT_LAZY_TYPE = Symbol.for("react.lazy");
      var REACT_ACTIVITY_TYPE = Symbol.for("react.activity");
      var MAYBE_ITERATOR_SYMBOL = Symbol.iterator;
      function getIteratorFn(maybeIterable) {
        if (null === maybeIterable || "object" !== typeof maybeIterable)
          return null;
        maybeIterable = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable["@@iterator"];
        return "function" === typeof maybeIterable ? maybeIterable : null;
      }
      var ReactNoopUpdateQueue = {
        isMounted: function() {
          return false;
        },
        enqueueForceUpdate: function() {
        },
        enqueueReplaceState: function() {
        },
        enqueueSetState: function() {
        }
      };
      var assign = Object.assign;
      var emptyObject = {};
      function Component(props, context, updater) {
        this.props = props;
        this.context = context;
        this.refs = emptyObject;
        this.updater = updater || ReactNoopUpdateQueue;
      }
      Component.prototype.isReactComponent = {};
      Component.prototype.setState = function(partialState, callback) {
        if ("object" !== typeof partialState && "function" !== typeof partialState && null != partialState)
          throw Error(
            "takes an object of state variables to update or a function which returns an object of state variables."
          );
        this.updater.enqueueSetState(this, partialState, callback, "setState");
      };
      Component.prototype.forceUpdate = function(callback) {
        this.updater.enqueueForceUpdate(this, callback, "forceUpdate");
      };
      function ComponentDummy() {
      }
      ComponentDummy.prototype = Component.prototype;
      function PureComponent(props, context, updater) {
        this.props = props;
        this.context = context;
        this.refs = emptyObject;
        this.updater = updater || ReactNoopUpdateQueue;
      }
      var pureComponentPrototype = PureComponent.prototype = new ComponentDummy();
      pureComponentPrototype.constructor = PureComponent;
      assign(pureComponentPrototype, Component.prototype);
      pureComponentPrototype.isPureReactComponent = true;
      var isArrayImpl = Array.isArray;
      function noop() {
      }
      var ReactSharedInternals = { H: null, A: null, T: null, S: null };
      var hasOwnProperty = Object.prototype.hasOwnProperty;
      function ReactElement(type, key, props) {
        var refProp = props.ref;
        return {
          $$typeof: REACT_ELEMENT_TYPE,
          type,
          key,
          ref: void 0 !== refProp ? refProp : null,
          props
        };
      }
      function cloneAndReplaceKey(oldElement, newKey) {
        return ReactElement(oldElement.type, newKey, oldElement.props);
      }
      function isValidElement(object) {
        return "object" === typeof object && null !== object && object.$$typeof === REACT_ELEMENT_TYPE;
      }
      function escape(key) {
        var escaperLookup = { "=": "=0", ":": "=2" };
        return "$" + key.replace(/[=:]/g, function(match) {
          return escaperLookup[match];
        });
      }
      var userProvidedKeyEscapeRegex = /\/+/g;
      function getElementKey(element, index) {
        return "object" === typeof element && null !== element && null != element.key ? escape("" + element.key) : index.toString(36);
      }
      function resolveThenable(thenable) {
        switch (thenable.status) {
          case "fulfilled":
            return thenable.value;
          case "rejected":
            throw thenable.reason;
          default:
            switch ("string" === typeof thenable.status ? thenable.then(noop, noop) : (thenable.status = "pending", thenable.then(
              function(fulfilledValue) {
                "pending" === thenable.status && (thenable.status = "fulfilled", thenable.value = fulfilledValue);
              },
              function(error) {
                "pending" === thenable.status && (thenable.status = "rejected", thenable.reason = error);
              }
            )), thenable.status) {
              case "fulfilled":
                return thenable.value;
              case "rejected":
                throw thenable.reason;
            }
        }
        throw thenable;
      }
      function mapIntoArray(children, array, escapedPrefix, nameSoFar, callback) {
        var type = typeof children;
        if ("undefined" === type || "boolean" === type)
          children = null;
        var invokeCallback = false;
        if (null === children)
          invokeCallback = true;
        else
          switch (type) {
            case "bigint":
            case "string":
            case "number":
              invokeCallback = true;
              break;
            case "object":
              switch (children.$$typeof) {
                case REACT_ELEMENT_TYPE:
                case REACT_PORTAL_TYPE:
                  invokeCallback = true;
                  break;
                case REACT_LAZY_TYPE:
                  return invokeCallback = children._init, mapIntoArray(
                    invokeCallback(children._payload),
                    array,
                    escapedPrefix,
                    nameSoFar,
                    callback
                  );
              }
          }
        if (invokeCallback)
          return callback = callback(children), invokeCallback = "" === nameSoFar ? "." + getElementKey(children, 0) : nameSoFar, isArrayImpl(callback) ? (escapedPrefix = "", null != invokeCallback && (escapedPrefix = invokeCallback.replace(userProvidedKeyEscapeRegex, "$&/") + "/"), mapIntoArray(callback, array, escapedPrefix, "", function(c) {
            return c;
          })) : null != callback && (isValidElement(callback) && (callback = cloneAndReplaceKey(
            callback,
            escapedPrefix + (null == callback.key || children && children.key === callback.key ? "" : ("" + callback.key).replace(
              userProvidedKeyEscapeRegex,
              "$&/"
            ) + "/") + invokeCallback
          )), array.push(callback)), 1;
        invokeCallback = 0;
        var nextNamePrefix = "" === nameSoFar ? "." : nameSoFar + ":";
        if (isArrayImpl(children))
          for (var i = 0; i < children.length; i++)
            nameSoFar = children[i], type = nextNamePrefix + getElementKey(nameSoFar, i), invokeCallback += mapIntoArray(
              nameSoFar,
              array,
              escapedPrefix,
              type,
              callback
            );
        else if (i = getIteratorFn(children), "function" === typeof i)
          for (children = i.call(children), i = 0; !(nameSoFar = children.next()).done; )
            nameSoFar = nameSoFar.value, type = nextNamePrefix + getElementKey(nameSoFar, i++), invokeCallback += mapIntoArray(
              nameSoFar,
              array,
              escapedPrefix,
              type,
              callback
            );
        else if ("object" === type) {
          if ("function" === typeof children.then)
            return mapIntoArray(
              resolveThenable(children),
              array,
              escapedPrefix,
              nameSoFar,
              callback
            );
          array = String(children);
          throw Error(
            "Objects are not valid as a React child (found: " + ("[object Object]" === array ? "object with keys {" + Object.keys(children).join(", ") + "}" : array) + "). If you meant to render a collection of children, use an array instead."
          );
        }
        return invokeCallback;
      }
      function mapChildren(children, func, context) {
        if (null == children)
          return children;
        var result = [], count = 0;
        mapIntoArray(children, result, "", "", function(child) {
          return func.call(context, child, count++);
        });
        return result;
      }
      function lazyInitializer(payload) {
        if (-1 === payload._status) {
          var ctor = payload._result;
          ctor = ctor();
          ctor.then(
            function(moduleObject) {
              if (0 === payload._status || -1 === payload._status)
                payload._status = 1, payload._result = moduleObject;
            },
            function(error) {
              if (0 === payload._status || -1 === payload._status)
                payload._status = 2, payload._result = error;
            }
          );
          -1 === payload._status && (payload._status = 0, payload._result = ctor);
        }
        if (1 === payload._status)
          return payload._result.default;
        throw payload._result;
      }
      var reportGlobalError = "function" === typeof reportError ? reportError : function(error) {
        if ("object" === typeof window && "function" === typeof window.ErrorEvent) {
          var event = new window.ErrorEvent("error", {
            bubbles: true,
            cancelable: true,
            message: "object" === typeof error && null !== error && "string" === typeof error.message ? String(error.message) : String(error),
            error
          });
          if (!window.dispatchEvent(event))
            return;
        } else if ("object" === typeof process && "function" === typeof process.emit) {
          process.emit("uncaughtException", error);
          return;
        }
        console.error(error);
      };
      var Children = {
        map: mapChildren,
        forEach: function(children, forEachFunc, forEachContext) {
          mapChildren(
            children,
            function() {
              forEachFunc.apply(this, arguments);
            },
            forEachContext
          );
        },
        count: function(children) {
          var n = 0;
          mapChildren(children, function() {
            n++;
          });
          return n;
        },
        toArray: function(children) {
          return mapChildren(children, function(child) {
            return child;
          }) || [];
        },
        only: function(children) {
          if (!isValidElement(children))
            throw Error(
              "React.Children.only expected to receive a single React element child."
            );
          return children;
        }
      };
      exports.Activity = REACT_ACTIVITY_TYPE;
      exports.Children = Children;
      exports.Component = Component;
      exports.Fragment = REACT_FRAGMENT_TYPE;
      exports.Profiler = REACT_PROFILER_TYPE;
      exports.PureComponent = PureComponent;
      exports.StrictMode = REACT_STRICT_MODE_TYPE;
      exports.Suspense = REACT_SUSPENSE_TYPE;
      exports.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE = ReactSharedInternals;
      exports.__COMPILER_RUNTIME = {
        __proto__: null,
        c: function(size) {
          return ReactSharedInternals.H.useMemoCache(size);
        }
      };
      exports.cache = function(fn) {
        return function() {
          return fn.apply(null, arguments);
        };
      };
      exports.cacheSignal = function() {
        return null;
      };
      exports.cloneElement = function(element, config, children) {
        if (null === element || void 0 === element)
          throw Error(
            "The argument must be a React element, but you passed " + element + "."
          );
        var props = assign({}, element.props), key = element.key;
        if (null != config)
          for (propName in void 0 !== config.key && (key = "" + config.key), config)
            !hasOwnProperty.call(config, propName) || "key" === propName || "__self" === propName || "__source" === propName || "ref" === propName && void 0 === config.ref || (props[propName] = config[propName]);
        var propName = arguments.length - 2;
        if (1 === propName)
          props.children = children;
        else if (1 < propName) {
          for (var childArray = Array(propName), i = 0; i < propName; i++)
            childArray[i] = arguments[i + 2];
          props.children = childArray;
        }
        return ReactElement(element.type, key, props);
      };
      exports.createContext = function(defaultValue) {
        defaultValue = {
          $$typeof: REACT_CONTEXT_TYPE,
          _currentValue: defaultValue,
          _currentValue2: defaultValue,
          _threadCount: 0,
          Provider: null,
          Consumer: null
        };
        defaultValue.Provider = defaultValue;
        defaultValue.Consumer = {
          $$typeof: REACT_CONSUMER_TYPE,
          _context: defaultValue
        };
        return defaultValue;
      };
      exports.createElement = function(type, config, children) {
        var propName, props = {}, key = null;
        if (null != config)
          for (propName in void 0 !== config.key && (key = "" + config.key), config)
            hasOwnProperty.call(config, propName) && "key" !== propName && "__self" !== propName && "__source" !== propName && (props[propName] = config[propName]);
        var childrenLength = arguments.length - 2;
        if (1 === childrenLength)
          props.children = children;
        else if (1 < childrenLength) {
          for (var childArray = Array(childrenLength), i = 0; i < childrenLength; i++)
            childArray[i] = arguments[i + 2];
          props.children = childArray;
        }
        if (type && type.defaultProps)
          for (propName in childrenLength = type.defaultProps, childrenLength)
            void 0 === props[propName] && (props[propName] = childrenLength[propName]);
        return ReactElement(type, key, props);
      };
      exports.createRef = function() {
        return { current: null };
      };
      exports.forwardRef = function(render) {
        return { $$typeof: REACT_FORWARD_REF_TYPE, render };
      };
      exports.isValidElement = isValidElement;
      exports.lazy = function(ctor) {
        return {
          $$typeof: REACT_LAZY_TYPE,
          _payload: { _status: -1, _result: ctor },
          _init: lazyInitializer
        };
      };
      exports.memo = function(type, compare) {
        return {
          $$typeof: REACT_MEMO_TYPE,
          type,
          compare: void 0 === compare ? null : compare
        };
      };
      exports.startTransition = function(scope) {
        var prevTransition = ReactSharedInternals.T, currentTransition = {};
        ReactSharedInternals.T = currentTransition;
        try {
          var returnValue = scope(), onStartTransitionFinish = ReactSharedInternals.S;
          null !== onStartTransitionFinish && onStartTransitionFinish(currentTransition, returnValue);
          "object" === typeof returnValue && null !== returnValue && "function" === typeof returnValue.then && returnValue.then(noop, reportGlobalError);
        } catch (error) {
          reportGlobalError(error);
        } finally {
          null !== prevTransition && null !== currentTransition.types && (prevTransition.types = currentTransition.types), ReactSharedInternals.T = prevTransition;
        }
      };
      exports.unstable_useCacheRefresh = function() {
        return ReactSharedInternals.H.useCacheRefresh();
      };
      exports.use = function(usable) {
        return ReactSharedInternals.H.use(usable);
      };
      exports.useActionState = function(action, initialState, permalink) {
        return ReactSharedInternals.H.useActionState(action, initialState, permalink);
      };
      exports.useCallback = function(callback, deps) {
        return ReactSharedInternals.H.useCallback(callback, deps);
      };
      exports.useContext = function(Context) {
        return ReactSharedInternals.H.useContext(Context);
      };
      exports.useDebugValue = function() {
      };
      exports.useDeferredValue = function(value, initialValue) {
        return ReactSharedInternals.H.useDeferredValue(value, initialValue);
      };
      exports.useEffect = function(create, deps) {
        return ReactSharedInternals.H.useEffect(create, deps);
      };
      exports.useEffectEvent = function(callback) {
        return ReactSharedInternals.H.useEffectEvent(callback);
      };
      exports.useId = function() {
        return ReactSharedInternals.H.useId();
      };
      exports.useImperativeHandle = function(ref, create, deps) {
        return ReactSharedInternals.H.useImperativeHandle(ref, create, deps);
      };
      exports.useInsertionEffect = function(create, deps) {
        return ReactSharedInternals.H.useInsertionEffect(create, deps);
      };
      exports.useLayoutEffect = function(create, deps) {
        return ReactSharedInternals.H.useLayoutEffect(create, deps);
      };
      exports.useMemo = function(create, deps) {
        return ReactSharedInternals.H.useMemo(create, deps);
      };
      exports.useOptimistic = function(passthrough, reducer) {
        return ReactSharedInternals.H.useOptimistic(passthrough, reducer);
      };
      exports.useReducer = function(reducer, initialArg, init) {
        return ReactSharedInternals.H.useReducer(reducer, initialArg, init);
      };
      exports.useRef = function(initialValue) {
        return ReactSharedInternals.H.useRef(initialValue);
      };
      exports.useState = function(initialState) {
        return ReactSharedInternals.H.useState(initialState);
      };
      exports.useSyncExternalStore = function(subscribe, getSnapshot, getServerSnapshot) {
        return ReactSharedInternals.H.useSyncExternalStore(
          subscribe,
          getSnapshot,
          getServerSnapshot
        );
      };
      exports.useTransition = function() {
        return ReactSharedInternals.H.useTransition();
      };
      exports.version = "19.2.0";
    }
  });

  // node_modules/react/index.js
  var require_react = __commonJS({
    "node_modules/react/index.js"(exports, module) {
      "use strict";
      if (true) {
        module.exports = require_react_production();
      } else {
        module.exports = null;
      }
    }
  });

  // node_modules/scheduler/cjs/scheduler.production.js
  var require_scheduler_production = __commonJS({
    "node_modules/scheduler/cjs/scheduler.production.js"(exports) {
      "use strict";
      function push(heap, node) {
        var index = heap.length;
        heap.push(node);
        a:
          for (; 0 < index; ) {
            var parentIndex = index - 1 >>> 1, parent = heap[parentIndex];
            if (0 < compare(parent, node))
              heap[parentIndex] = node, heap[index] = parent, index = parentIndex;
            else
              break a;
          }
      }
      function peek(heap) {
        return 0 === heap.length ? null : heap[0];
      }
      function pop(heap) {
        if (0 === heap.length)
          return null;
        var first = heap[0], last = heap.pop();
        if (last !== first) {
          heap[0] = last;
          a:
            for (var index = 0, length = heap.length, halfLength = length >>> 1; index < halfLength; ) {
              var leftIndex = 2 * (index + 1) - 1, left = heap[leftIndex], rightIndex = leftIndex + 1, right = heap[rightIndex];
              if (0 > compare(left, last))
                rightIndex < length && 0 > compare(right, left) ? (heap[index] = right, heap[rightIndex] = last, index = rightIndex) : (heap[index] = left, heap[leftIndex] = last, index = leftIndex);
              else if (rightIndex < length && 0 > compare(right, last))
                heap[index] = right, heap[rightIndex] = last, index = rightIndex;
              else
                break a;
            }
        }
        return first;
      }
      function compare(a, b) {
        var diff = a.sortIndex - b.sortIndex;
        return 0 !== diff ? diff : a.id - b.id;
      }
      exports.unstable_now = void 0;
      if ("object" === typeof performance && "function" === typeof performance.now) {
        localPerformance = performance;
        exports.unstable_now = function() {
          return localPerformance.now();
        };
      } else {
        localDate = Date, initialTime = localDate.now();
        exports.unstable_now = function() {
          return localDate.now() - initialTime;
        };
      }
      var localPerformance;
      var localDate;
      var initialTime;
      var taskQueue = [];
      var timerQueue = [];
      var taskIdCounter = 1;
      var currentTask = null;
      var currentPriorityLevel = 3;
      var isPerformingWork = false;
      var isHostCallbackScheduled = false;
      var isHostTimeoutScheduled = false;
      var needsPaint = false;
      var localSetTimeout = "function" === typeof setTimeout ? setTimeout : null;
      var localClearTimeout = "function" === typeof clearTimeout ? clearTimeout : null;
      var localSetImmediate = "undefined" !== typeof setImmediate ? setImmediate : null;
      function advanceTimers(currentTime) {
        for (var timer = peek(timerQueue); null !== timer; ) {
          if (null === timer.callback)
            pop(timerQueue);
          else if (timer.startTime <= currentTime)
            pop(timerQueue), timer.sortIndex = timer.expirationTime, push(taskQueue, timer);
          else
            break;
          timer = peek(timerQueue);
        }
      }
      function handleTimeout(currentTime) {
        isHostTimeoutScheduled = false;
        advanceTimers(currentTime);
        if (!isHostCallbackScheduled)
          if (null !== peek(taskQueue))
            isHostCallbackScheduled = true, isMessageLoopRunning || (isMessageLoopRunning = true, schedulePerformWorkUntilDeadline());
          else {
            var firstTimer = peek(timerQueue);
            null !== firstTimer && requestHostTimeout(handleTimeout, firstTimer.startTime - currentTime);
          }
      }
      var isMessageLoopRunning = false;
      var taskTimeoutID = -1;
      var frameInterval = 5;
      var startTime = -1;
      function shouldYieldToHost() {
        return needsPaint ? true : exports.unstable_now() - startTime < frameInterval ? false : true;
      }
      function performWorkUntilDeadline() {
        needsPaint = false;
        if (isMessageLoopRunning) {
          var currentTime = exports.unstable_now();
          startTime = currentTime;
          var hasMoreWork = true;
          try {
            a: {
              isHostCallbackScheduled = false;
              isHostTimeoutScheduled && (isHostTimeoutScheduled = false, localClearTimeout(taskTimeoutID), taskTimeoutID = -1);
              isPerformingWork = true;
              var previousPriorityLevel = currentPriorityLevel;
              try {
                b: {
                  advanceTimers(currentTime);
                  for (currentTask = peek(taskQueue); null !== currentTask && !(currentTask.expirationTime > currentTime && shouldYieldToHost()); ) {
                    var callback = currentTask.callback;
                    if ("function" === typeof callback) {
                      currentTask.callback = null;
                      currentPriorityLevel = currentTask.priorityLevel;
                      var continuationCallback = callback(
                        currentTask.expirationTime <= currentTime
                      );
                      currentTime = exports.unstable_now();
                      if ("function" === typeof continuationCallback) {
                        currentTask.callback = continuationCallback;
                        advanceTimers(currentTime);
                        hasMoreWork = true;
                        break b;
                      }
                      currentTask === peek(taskQueue) && pop(taskQueue);
                      advanceTimers(currentTime);
                    } else
                      pop(taskQueue);
                    currentTask = peek(taskQueue);
                  }
                  if (null !== currentTask)
                    hasMoreWork = true;
                  else {
                    var firstTimer = peek(timerQueue);
                    null !== firstTimer && requestHostTimeout(
                      handleTimeout,
                      firstTimer.startTime - currentTime
                    );
                    hasMoreWork = false;
                  }
                }
                break a;
              } finally {
                currentTask = null, currentPriorityLevel = previousPriorityLevel, isPerformingWork = false;
              }
              hasMoreWork = void 0;
            }
          } finally {
            hasMoreWork ? schedulePerformWorkUntilDeadline() : isMessageLoopRunning = false;
          }
        }
      }
      var schedulePerformWorkUntilDeadline;
      if ("function" === typeof localSetImmediate)
        schedulePerformWorkUntilDeadline = function() {
          localSetImmediate(performWorkUntilDeadline);
        };
      else if ("undefined" !== typeof MessageChannel) {
        channel = new MessageChannel(), port = channel.port2;
        channel.port1.onmessage = performWorkUntilDeadline;
        schedulePerformWorkUntilDeadline = function() {
          port.postMessage(null);
        };
      } else
        schedulePerformWorkUntilDeadline = function() {
          localSetTimeout(performWorkUntilDeadline, 0);
        };
      var channel;
      var port;
      function requestHostTimeout(callback, ms) {
        taskTimeoutID = localSetTimeout(function() {
          callback(exports.unstable_now());
        }, ms);
      }
      exports.unstable_IdlePriority = 5;
      exports.unstable_ImmediatePriority = 1;
      exports.unstable_LowPriority = 4;
      exports.unstable_NormalPriority = 3;
      exports.unstable_Profiling = null;
      exports.unstable_UserBlockingPriority = 2;
      exports.unstable_cancelCallback = function(task) {
        task.callback = null;
      };
      exports.unstable_forceFrameRate = function(fps) {
        0 > fps || 125 < fps ? console.error(
          "forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported"
        ) : frameInterval = 0 < fps ? Math.floor(1e3 / fps) : 5;
      };
      exports.unstable_getCurrentPriorityLevel = function() {
        return currentPriorityLevel;
      };
      exports.unstable_next = function(eventHandler) {
        switch (currentPriorityLevel) {
          case 1:
          case 2:
          case 3:
            var priorityLevel = 3;
            break;
          default:
            priorityLevel = currentPriorityLevel;
        }
        var previousPriorityLevel = currentPriorityLevel;
        currentPriorityLevel = priorityLevel;
        try {
          return eventHandler();
        } finally {
          currentPriorityLevel = previousPriorityLevel;
        }
      };
      exports.unstable_requestPaint = function() {
        needsPaint = true;
      };
      exports.unstable_runWithPriority = function(priorityLevel, eventHandler) {
        switch (priorityLevel) {
          case 1:
          case 2:
          case 3:
          case 4:
          case 5:
            break;
          default:
            priorityLevel = 3;
        }
        var previousPriorityLevel = currentPriorityLevel;
        currentPriorityLevel = priorityLevel;
        try {
          return eventHandler();
        } finally {
          currentPriorityLevel = previousPriorityLevel;
        }
      };
      exports.unstable_scheduleCallback = function(priorityLevel, callback, options) {
        var currentTime = exports.unstable_now();
        "object" === typeof options && null !== options ? (options = options.delay, options = "number" === typeof options && 0 < options ? currentTime + options : currentTime) : options = currentTime;
        switch (priorityLevel) {
          case 1:
            var timeout = -1;
            break;
          case 2:
            timeout = 250;
            break;
          case 5:
            timeout = 1073741823;
            break;
          case 4:
            timeout = 1e4;
            break;
          default:
            timeout = 5e3;
        }
        timeout = options + timeout;
        priorityLevel = {
          id: taskIdCounter++,
          callback,
          priorityLevel,
          startTime: options,
          expirationTime: timeout,
          sortIndex: -1
        };
        options > currentTime ? (priorityLevel.sortIndex = options, push(timerQueue, priorityLevel), null === peek(taskQueue) && priorityLevel === peek(timerQueue) && (isHostTimeoutScheduled ? (localClearTimeout(taskTimeoutID), taskTimeoutID = -1) : isHostTimeoutScheduled = true, requestHostTimeout(handleTimeout, options - currentTime))) : (priorityLevel.sortIndex = timeout, push(taskQueue, priorityLevel), isHostCallbackScheduled || isPerformingWork || (isHostCallbackScheduled = true, isMessageLoopRunning || (isMessageLoopRunning = true, schedulePerformWorkUntilDeadline())));
        return priorityLevel;
      };
      exports.unstable_shouldYield = shouldYieldToHost;
      exports.unstable_wrapCallback = function(callback) {
        var parentPriorityLevel = currentPriorityLevel;
        return function() {
          var previousPriorityLevel = currentPriorityLevel;
          currentPriorityLevel = parentPriorityLevel;
          try {
            return callback.apply(this, arguments);
          } finally {
            currentPriorityLevel = previousPriorityLevel;
          }
        };
      };
    }
  });

  // node_modules/scheduler/index.js
  var require_scheduler = __commonJS({
    "node_modules/scheduler/index.js"(exports, module) {
      "use strict";
      if (true) {
        module.exports = require_scheduler_production();
      } else {
        module.exports = null;
      }
    }
  });

  // node_modules/react-dom/cjs/react-dom.production.js
  var require_react_dom_production = __commonJS({
    "node_modules/react-dom/cjs/react-dom.production.js"(exports) {
      "use strict";
      var React16 = require_react();
      function formatProdErrorMessage(code) {
        var url = "https://react.dev/errors/" + code;
        if (1 < arguments.length) {
          url += "?args[]=" + encodeURIComponent(arguments[1]);
          for (var i = 2; i < arguments.length; i++)
            url += "&args[]=" + encodeURIComponent(arguments[i]);
        }
        return "Minified React error #" + code + "; visit " + url + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
      }
      function noop() {
      }
      var Internals = {
        d: {
          f: noop,
          r: function() {
            throw Error(formatProdErrorMessage(522));
          },
          D: noop,
          C: noop,
          L: noop,
          m: noop,
          X: noop,
          S: noop,
          M: noop
        },
        p: 0,
        findDOMNode: null
      };
      var REACT_PORTAL_TYPE = Symbol.for("react.portal");
      function createPortal$1(children, containerInfo, implementation) {
        var key = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : null;
        return {
          $$typeof: REACT_PORTAL_TYPE,
          key: null == key ? null : "" + key,
          children,
          containerInfo,
          implementation
        };
      }
      var ReactSharedInternals = React16.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE;
      function getCrossOriginStringAs(as, input) {
        if ("font" === as)
          return "";
        if ("string" === typeof input)
          return "use-credentials" === input ? input : "";
      }
      exports.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE = Internals;
      exports.createPortal = function(children, container) {
        var key = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : null;
        if (!container || 1 !== container.nodeType && 9 !== container.nodeType && 11 !== container.nodeType)
          throw Error(formatProdErrorMessage(299));
        return createPortal$1(children, container, null, key);
      };
      exports.flushSync = function(fn) {
        var previousTransition = ReactSharedInternals.T, previousUpdatePriority = Internals.p;
        try {
          if (ReactSharedInternals.T = null, Internals.p = 2, fn)
            return fn();
        } finally {
          ReactSharedInternals.T = previousTransition, Internals.p = previousUpdatePriority, Internals.d.f();
        }
      };
      exports.preconnect = function(href, options) {
        "string" === typeof href && (options ? (options = options.crossOrigin, options = "string" === typeof options ? "use-credentials" === options ? options : "" : void 0) : options = null, Internals.d.C(href, options));
      };
      exports.prefetchDNS = function(href) {
        "string" === typeof href && Internals.d.D(href);
      };
      exports.preinit = function(href, options) {
        if ("string" === typeof href && options && "string" === typeof options.as) {
          var as = options.as, crossOrigin = getCrossOriginStringAs(as, options.crossOrigin), integrity = "string" === typeof options.integrity ? options.integrity : void 0, fetchPriority = "string" === typeof options.fetchPriority ? options.fetchPriority : void 0;
          "style" === as ? Internals.d.S(
            href,
            "string" === typeof options.precedence ? options.precedence : void 0,
            {
              crossOrigin,
              integrity,
              fetchPriority
            }
          ) : "script" === as && Internals.d.X(href, {
            crossOrigin,
            integrity,
            fetchPriority,
            nonce: "string" === typeof options.nonce ? options.nonce : void 0
          });
        }
      };
      exports.preinitModule = function(href, options) {
        if ("string" === typeof href)
          if ("object" === typeof options && null !== options) {
            if (null == options.as || "script" === options.as) {
              var crossOrigin = getCrossOriginStringAs(
                options.as,
                options.crossOrigin
              );
              Internals.d.M(href, {
                crossOrigin,
                integrity: "string" === typeof options.integrity ? options.integrity : void 0,
                nonce: "string" === typeof options.nonce ? options.nonce : void 0
              });
            }
          } else
            null == options && Internals.d.M(href);
      };
      exports.preload = function(href, options) {
        if ("string" === typeof href && "object" === typeof options && null !== options && "string" === typeof options.as) {
          var as = options.as, crossOrigin = getCrossOriginStringAs(as, options.crossOrigin);
          Internals.d.L(href, as, {
            crossOrigin,
            integrity: "string" === typeof options.integrity ? options.integrity : void 0,
            nonce: "string" === typeof options.nonce ? options.nonce : void 0,
            type: "string" === typeof options.type ? options.type : void 0,
            fetchPriority: "string" === typeof options.fetchPriority ? options.fetchPriority : void 0,
            referrerPolicy: "string" === typeof options.referrerPolicy ? options.referrerPolicy : void 0,
            imageSrcSet: "string" === typeof options.imageSrcSet ? options.imageSrcSet : void 0,
            imageSizes: "string" === typeof options.imageSizes ? options.imageSizes : void 0,
            media: "string" === typeof options.media ? options.media : void 0
          });
        }
      };
      exports.preloadModule = function(href, options) {
        if ("string" === typeof href)
          if (options) {
            var crossOrigin = getCrossOriginStringAs(options.as, options.crossOrigin);
            Internals.d.m(href, {
              as: "string" === typeof options.as && "script" !== options.as ? options.as : void 0,
              crossOrigin,
              integrity: "string" === typeof options.integrity ? options.integrity : void 0
            });
          } else
            Internals.d.m(href);
      };
      exports.requestFormReset = function(form) {
        Internals.d.r(form);
      };
      exports.unstable_batchedUpdates = function(fn, a) {
        return fn(a);
      };
      exports.useFormState = function(action, initialState, permalink) {
        return ReactSharedInternals.H.useFormState(action, initialState, permalink);
      };
      exports.useFormStatus = function() {
        return ReactSharedInternals.H.useHostTransitionStatus();
      };
      exports.version = "19.2.0";
    }
  });

  // node_modules/react-dom/index.js
  var require_react_dom = __commonJS({
    "node_modules/react-dom/index.js"(exports, module) {
      "use strict";
      function checkDCE() {
        if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === "undefined" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE !== "function") {
          return;
        }
        if (false) {
          throw new Error("^_^");
        }
        try {
          __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE);
        } catch (err) {
          console.error(err);
        }
      }
      if (true) {
        checkDCE();
        module.exports = require_react_dom_production();
      } else {
        module.exports = null;
      }
    }
  });

  // node_modules/react-dom/cjs/react-dom-client.production.js
  var require_react_dom_client_production = __commonJS({
    "node_modules/react-dom/cjs/react-dom-client.production.js"(exports) {
      "use strict";
      var Scheduler = require_scheduler();
      var React16 = require_react();
      var ReactDOM2 = require_react_dom();
      function formatProdErrorMessage(code) {
        var url = "https://react.dev/errors/" + code;
        if (1 < arguments.length) {
          url += "?args[]=" + encodeURIComponent(arguments[1]);
          for (var i = 2; i < arguments.length; i++)
            url += "&args[]=" + encodeURIComponent(arguments[i]);
        }
        return "Minified React error #" + code + "; visit " + url + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
      }
      function isValidContainer(node) {
        return !(!node || 1 !== node.nodeType && 9 !== node.nodeType && 11 !== node.nodeType);
      }
      function getNearestMountedFiber(fiber) {
        var node = fiber, nearestMounted = fiber;
        if (fiber.alternate)
          for (; node.return; )
            node = node.return;
        else {
          fiber = node;
          do
            node = fiber, 0 !== (node.flags & 4098) && (nearestMounted = node.return), fiber = node.return;
          while (fiber);
        }
        return 3 === node.tag ? nearestMounted : null;
      }
      function getSuspenseInstanceFromFiber(fiber) {
        if (13 === fiber.tag) {
          var suspenseState = fiber.memoizedState;
          null === suspenseState && (fiber = fiber.alternate, null !== fiber && (suspenseState = fiber.memoizedState));
          if (null !== suspenseState)
            return suspenseState.dehydrated;
        }
        return null;
      }
      function getActivityInstanceFromFiber(fiber) {
        if (31 === fiber.tag) {
          var activityState = fiber.memoizedState;
          null === activityState && (fiber = fiber.alternate, null !== fiber && (activityState = fiber.memoizedState));
          if (null !== activityState)
            return activityState.dehydrated;
        }
        return null;
      }
      function assertIsMounted(fiber) {
        if (getNearestMountedFiber(fiber) !== fiber)
          throw Error(formatProdErrorMessage(188));
      }
      function findCurrentFiberUsingSlowPath(fiber) {
        var alternate = fiber.alternate;
        if (!alternate) {
          alternate = getNearestMountedFiber(fiber);
          if (null === alternate)
            throw Error(formatProdErrorMessage(188));
          return alternate !== fiber ? null : fiber;
        }
        for (var a = fiber, b = alternate; ; ) {
          var parentA = a.return;
          if (null === parentA)
            break;
          var parentB = parentA.alternate;
          if (null === parentB) {
            b = parentA.return;
            if (null !== b) {
              a = b;
              continue;
            }
            break;
          }
          if (parentA.child === parentB.child) {
            for (parentB = parentA.child; parentB; ) {
              if (parentB === a)
                return assertIsMounted(parentA), fiber;
              if (parentB === b)
                return assertIsMounted(parentA), alternate;
              parentB = parentB.sibling;
            }
            throw Error(formatProdErrorMessage(188));
          }
          if (a.return !== b.return)
            a = parentA, b = parentB;
          else {
            for (var didFindChild = false, child$0 = parentA.child; child$0; ) {
              if (child$0 === a) {
                didFindChild = true;
                a = parentA;
                b = parentB;
                break;
              }
              if (child$0 === b) {
                didFindChild = true;
                b = parentA;
                a = parentB;
                break;
              }
              child$0 = child$0.sibling;
            }
            if (!didFindChild) {
              for (child$0 = parentB.child; child$0; ) {
                if (child$0 === a) {
                  didFindChild = true;
                  a = parentB;
                  b = parentA;
                  break;
                }
                if (child$0 === b) {
                  didFindChild = true;
                  b = parentB;
                  a = parentA;
                  break;
                }
                child$0 = child$0.sibling;
              }
              if (!didFindChild)
                throw Error(formatProdErrorMessage(189));
            }
          }
          if (a.alternate !== b)
            throw Error(formatProdErrorMessage(190));
        }
        if (3 !== a.tag)
          throw Error(formatProdErrorMessage(188));
        return a.stateNode.current === a ? fiber : alternate;
      }
      function findCurrentHostFiberImpl(node) {
        var tag = node.tag;
        if (5 === tag || 26 === tag || 27 === tag || 6 === tag)
          return node;
        for (node = node.child; null !== node; ) {
          tag = findCurrentHostFiberImpl(node);
          if (null !== tag)
            return tag;
          node = node.sibling;
        }
        return null;
      }
      var assign = Object.assign;
      var REACT_LEGACY_ELEMENT_TYPE = Symbol.for("react.element");
      var REACT_ELEMENT_TYPE = Symbol.for("react.transitional.element");
      var REACT_PORTAL_TYPE = Symbol.for("react.portal");
      var REACT_FRAGMENT_TYPE = Symbol.for("react.fragment");
      var REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode");
      var REACT_PROFILER_TYPE = Symbol.for("react.profiler");
      var REACT_CONSUMER_TYPE = Symbol.for("react.consumer");
      var REACT_CONTEXT_TYPE = Symbol.for("react.context");
      var REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref");
      var REACT_SUSPENSE_TYPE = Symbol.for("react.suspense");
      var REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list");
      var REACT_MEMO_TYPE = Symbol.for("react.memo");
      var REACT_LAZY_TYPE = Symbol.for("react.lazy");
      Symbol.for("react.scope");
      var REACT_ACTIVITY_TYPE = Symbol.for("react.activity");
      Symbol.for("react.legacy_hidden");
      Symbol.for("react.tracing_marker");
      var REACT_MEMO_CACHE_SENTINEL = Symbol.for("react.memo_cache_sentinel");
      Symbol.for("react.view_transition");
      var MAYBE_ITERATOR_SYMBOL = Symbol.iterator;
      function getIteratorFn(maybeIterable) {
        if (null === maybeIterable || "object" !== typeof maybeIterable)
          return null;
        maybeIterable = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable["@@iterator"];
        return "function" === typeof maybeIterable ? maybeIterable : null;
      }
      var REACT_CLIENT_REFERENCE = Symbol.for("react.client.reference");
      function getComponentNameFromType(type) {
        if (null == type)
          return null;
        if ("function" === typeof type)
          return type.$$typeof === REACT_CLIENT_REFERENCE ? null : type.displayName || type.name || null;
        if ("string" === typeof type)
          return type;
        switch (type) {
          case REACT_FRAGMENT_TYPE:
            return "Fragment";
          case REACT_PROFILER_TYPE:
            return "Profiler";
          case REACT_STRICT_MODE_TYPE:
            return "StrictMode";
          case REACT_SUSPENSE_TYPE:
            return "Suspense";
          case REACT_SUSPENSE_LIST_TYPE:
            return "SuspenseList";
          case REACT_ACTIVITY_TYPE:
            return "Activity";
        }
        if ("object" === typeof type)
          switch (type.$$typeof) {
            case REACT_PORTAL_TYPE:
              return "Portal";
            case REACT_CONTEXT_TYPE:
              return type.displayName || "Context";
            case REACT_CONSUMER_TYPE:
              return (type._context.displayName || "Context") + ".Consumer";
            case REACT_FORWARD_REF_TYPE:
              var innerType = type.render;
              type = type.displayName;
              type || (type = innerType.displayName || innerType.name || "", type = "" !== type ? "ForwardRef(" + type + ")" : "ForwardRef");
              return type;
            case REACT_MEMO_TYPE:
              return innerType = type.displayName || null, null !== innerType ? innerType : getComponentNameFromType(type.type) || "Memo";
            case REACT_LAZY_TYPE:
              innerType = type._payload;
              type = type._init;
              try {
                return getComponentNameFromType(type(innerType));
              } catch (x) {
              }
          }
        return null;
      }
      var isArrayImpl = Array.isArray;
      var ReactSharedInternals = React16.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE;
      var ReactDOMSharedInternals = ReactDOM2.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE;
      var sharedNotPendingObject = {
        pending: false,
        data: null,
        method: null,
        action: null
      };
      var valueStack = [];
      var index = -1;
      function createCursor(defaultValue) {
        return { current: defaultValue };
      }
      function pop(cursor) {
        0 > index || (cursor.current = valueStack[index], valueStack[index] = null, index--);
      }
      function push(cursor, value) {
        index++;
        valueStack[index] = cursor.current;
        cursor.current = value;
      }
      var contextStackCursor = createCursor(null);
      var contextFiberStackCursor = createCursor(null);
      var rootInstanceStackCursor = createCursor(null);
      var hostTransitionProviderCursor = createCursor(null);
      function pushHostContainer(fiber, nextRootInstance) {
        push(rootInstanceStackCursor, nextRootInstance);
        push(contextFiberStackCursor, fiber);
        push(contextStackCursor, null);
        switch (nextRootInstance.nodeType) {
          case 9:
          case 11:
            fiber = (fiber = nextRootInstance.documentElement) ? (fiber = fiber.namespaceURI) ? getOwnHostContext(fiber) : 0 : 0;
            break;
          default:
            if (fiber = nextRootInstance.tagName, nextRootInstance = nextRootInstance.namespaceURI)
              nextRootInstance = getOwnHostContext(nextRootInstance), fiber = getChildHostContextProd(nextRootInstance, fiber);
            else
              switch (fiber) {
                case "svg":
                  fiber = 1;
                  break;
                case "math":
                  fiber = 2;
                  break;
                default:
                  fiber = 0;
              }
        }
        pop(contextStackCursor);
        push(contextStackCursor, fiber);
      }
      function popHostContainer() {
        pop(contextStackCursor);
        pop(contextFiberStackCursor);
        pop(rootInstanceStackCursor);
      }
      function pushHostContext(fiber) {
        null !== fiber.memoizedState && push(hostTransitionProviderCursor, fiber);
        var context = contextStackCursor.current;
        var JSCompiler_inline_result = getChildHostContextProd(context, fiber.type);
        context !== JSCompiler_inline_result && (push(contextFiberStackCursor, fiber), push(contextStackCursor, JSCompiler_inline_result));
      }
      function popHostContext(fiber) {
        contextFiberStackCursor.current === fiber && (pop(contextStackCursor), pop(contextFiberStackCursor));
        hostTransitionProviderCursor.current === fiber && (pop(hostTransitionProviderCursor), HostTransitionContext._currentValue = sharedNotPendingObject);
      }
      var prefix;
      var suffix;
      function describeBuiltInComponentFrame(name) {
        if (void 0 === prefix)
          try {
            throw Error();
          } catch (x) {
            var match = x.stack.trim().match(/\n( *(at )?)/);
            prefix = match && match[1] || "";
            suffix = -1 < x.stack.indexOf("\n    at") ? " (<anonymous>)" : -1 < x.stack.indexOf("@") ? "@unknown:0:0" : "";
          }
        return "\n" + prefix + name + suffix;
      }
      var reentry = false;
      function describeNativeComponentFrame(fn, construct) {
        if (!fn || reentry)
          return "";
        reentry = true;
        var previousPrepareStackTrace = Error.prepareStackTrace;
        Error.prepareStackTrace = void 0;
        try {
          var RunInRootFrame = {
            DetermineComponentFrameRoot: function() {
              try {
                if (construct) {
                  var Fake = function() {
                    throw Error();
                  };
                  Object.defineProperty(Fake.prototype, "props", {
                    set: function() {
                      throw Error();
                    }
                  });
                  if ("object" === typeof Reflect && Reflect.construct) {
                    try {
                      Reflect.construct(Fake, []);
                    } catch (x) {
                      var control = x;
                    }
                    Reflect.construct(fn, [], Fake);
                  } else {
                    try {
                      Fake.call();
                    } catch (x$1) {
                      control = x$1;
                    }
                    fn.call(Fake.prototype);
                  }
                } else {
                  try {
                    throw Error();
                  } catch (x$2) {
                    control = x$2;
                  }
                  (Fake = fn()) && "function" === typeof Fake.catch && Fake.catch(function() {
                  });
                }
              } catch (sample) {
                if (sample && control && "string" === typeof sample.stack)
                  return [sample.stack, control.stack];
              }
              return [null, null];
            }
          };
          RunInRootFrame.DetermineComponentFrameRoot.displayName = "DetermineComponentFrameRoot";
          var namePropDescriptor = Object.getOwnPropertyDescriptor(
            RunInRootFrame.DetermineComponentFrameRoot,
            "name"
          );
          namePropDescriptor && namePropDescriptor.configurable && Object.defineProperty(
            RunInRootFrame.DetermineComponentFrameRoot,
            "name",
            { value: "DetermineComponentFrameRoot" }
          );
          var _RunInRootFrame$Deter = RunInRootFrame.DetermineComponentFrameRoot(), sampleStack = _RunInRootFrame$Deter[0], controlStack = _RunInRootFrame$Deter[1];
          if (sampleStack && controlStack) {
            var sampleLines = sampleStack.split("\n"), controlLines = controlStack.split("\n");
            for (namePropDescriptor = RunInRootFrame = 0; RunInRootFrame < sampleLines.length && !sampleLines[RunInRootFrame].includes("DetermineComponentFrameRoot"); )
              RunInRootFrame++;
            for (; namePropDescriptor < controlLines.length && !controlLines[namePropDescriptor].includes(
              "DetermineComponentFrameRoot"
            ); )
              namePropDescriptor++;
            if (RunInRootFrame === sampleLines.length || namePropDescriptor === controlLines.length)
              for (RunInRootFrame = sampleLines.length - 1, namePropDescriptor = controlLines.length - 1; 1 <= RunInRootFrame && 0 <= namePropDescriptor && sampleLines[RunInRootFrame] !== controlLines[namePropDescriptor]; )
                namePropDescriptor--;
            for (; 1 <= RunInRootFrame && 0 <= namePropDescriptor; RunInRootFrame--, namePropDescriptor--)
              if (sampleLines[RunInRootFrame] !== controlLines[namePropDescriptor]) {
                if (1 !== RunInRootFrame || 1 !== namePropDescriptor) {
                  do
                    if (RunInRootFrame--, namePropDescriptor--, 0 > namePropDescriptor || sampleLines[RunInRootFrame] !== controlLines[namePropDescriptor]) {
                      var frame = "\n" + sampleLines[RunInRootFrame].replace(" at new ", " at ");
                      fn.displayName && frame.includes("<anonymous>") && (frame = frame.replace("<anonymous>", fn.displayName));
                      return frame;
                    }
                  while (1 <= RunInRootFrame && 0 <= namePropDescriptor);
                }
                break;
              }
          }
        } finally {
          reentry = false, Error.prepareStackTrace = previousPrepareStackTrace;
        }
        return (previousPrepareStackTrace = fn ? fn.displayName || fn.name : "") ? describeBuiltInComponentFrame(previousPrepareStackTrace) : "";
      }
      function describeFiber(fiber, childFiber) {
        switch (fiber.tag) {
          case 26:
          case 27:
          case 5:
            return describeBuiltInComponentFrame(fiber.type);
          case 16:
            return describeBuiltInComponentFrame("Lazy");
          case 13:
            return fiber.child !== childFiber && null !== childFiber ? describeBuiltInComponentFrame("Suspense Fallback") : describeBuiltInComponentFrame("Suspense");
          case 19:
            return describeBuiltInComponentFrame("SuspenseList");
          case 0:
          case 15:
            return describeNativeComponentFrame(fiber.type, false);
          case 11:
            return describeNativeComponentFrame(fiber.type.render, false);
          case 1:
            return describeNativeComponentFrame(fiber.type, true);
          case 31:
            return describeBuiltInComponentFrame("Activity");
          default:
            return "";
        }
      }
      function getStackByFiberInDevAndProd(workInProgress2) {
        try {
          var info = "", previous = null;
          do
            info += describeFiber(workInProgress2, previous), previous = workInProgress2, workInProgress2 = workInProgress2.return;
          while (workInProgress2);
          return info;
        } catch (x) {
          return "\nError generating stack: " + x.message + "\n" + x.stack;
        }
      }
      var hasOwnProperty = Object.prototype.hasOwnProperty;
      var scheduleCallback$3 = Scheduler.unstable_scheduleCallback;
      var cancelCallback$1 = Scheduler.unstable_cancelCallback;
      var shouldYield = Scheduler.unstable_shouldYield;
      var requestPaint = Scheduler.unstable_requestPaint;
      var now = Scheduler.unstable_now;
      var getCurrentPriorityLevel = Scheduler.unstable_getCurrentPriorityLevel;
      var ImmediatePriority = Scheduler.unstable_ImmediatePriority;
      var UserBlockingPriority = Scheduler.unstable_UserBlockingPriority;
      var NormalPriority$1 = Scheduler.unstable_NormalPriority;
      var LowPriority = Scheduler.unstable_LowPriority;
      var IdlePriority = Scheduler.unstable_IdlePriority;
      var log$1 = Scheduler.log;
      var unstable_setDisableYieldValue = Scheduler.unstable_setDisableYieldValue;
      var rendererID = null;
      var injectedHook = null;
      function setIsStrictModeForDevtools(newIsStrictMode) {
        "function" === typeof log$1 && unstable_setDisableYieldValue(newIsStrictMode);
        if (injectedHook && "function" === typeof injectedHook.setStrictMode)
          try {
            injectedHook.setStrictMode(rendererID, newIsStrictMode);
          } catch (err) {
          }
      }
      var clz32 = Math.clz32 ? Math.clz32 : clz32Fallback;
      var log = Math.log;
      var LN2 = Math.LN2;
      function clz32Fallback(x) {
        x >>>= 0;
        return 0 === x ? 32 : 31 - (log(x) / LN2 | 0) | 0;
      }
      var nextTransitionUpdateLane = 256;
      var nextTransitionDeferredLane = 262144;
      var nextRetryLane = 4194304;
      function getHighestPriorityLanes(lanes) {
        var pendingSyncLanes = lanes & 42;
        if (0 !== pendingSyncLanes)
          return pendingSyncLanes;
        switch (lanes & -lanes) {
          case 1:
            return 1;
          case 2:
            return 2;
          case 4:
            return 4;
          case 8:
            return 8;
          case 16:
            return 16;
          case 32:
            return 32;
          case 64:
            return 64;
          case 128:
            return 128;
          case 256:
          case 512:
          case 1024:
          case 2048:
          case 4096:
          case 8192:
          case 16384:
          case 32768:
          case 65536:
          case 131072:
            return lanes & 261888;
          case 262144:
          case 524288:
          case 1048576:
          case 2097152:
            return lanes & 3932160;
          case 4194304:
          case 8388608:
          case 16777216:
          case 33554432:
            return lanes & 62914560;
          case 67108864:
            return 67108864;
          case 134217728:
            return 134217728;
          case 268435456:
            return 268435456;
          case 536870912:
            return 536870912;
          case 1073741824:
            return 0;
          default:
            return lanes;
        }
      }
      function getNextLanes(root3, wipLanes, rootHasPendingCommit) {
        var pendingLanes = root3.pendingLanes;
        if (0 === pendingLanes)
          return 0;
        var nextLanes = 0, suspendedLanes = root3.suspendedLanes, pingedLanes = root3.pingedLanes;
        root3 = root3.warmLanes;
        var nonIdlePendingLanes = pendingLanes & 134217727;
        0 !== nonIdlePendingLanes ? (pendingLanes = nonIdlePendingLanes & ~suspendedLanes, 0 !== pendingLanes ? nextLanes = getHighestPriorityLanes(pendingLanes) : (pingedLanes &= nonIdlePendingLanes, 0 !== pingedLanes ? nextLanes = getHighestPriorityLanes(pingedLanes) : rootHasPendingCommit || (rootHasPendingCommit = nonIdlePendingLanes & ~root3, 0 !== rootHasPendingCommit && (nextLanes = getHighestPriorityLanes(rootHasPendingCommit))))) : (nonIdlePendingLanes = pendingLanes & ~suspendedLanes, 0 !== nonIdlePendingLanes ? nextLanes = getHighestPriorityLanes(nonIdlePendingLanes) : 0 !== pingedLanes ? nextLanes = getHighestPriorityLanes(pingedLanes) : rootHasPendingCommit || (rootHasPendingCommit = pendingLanes & ~root3, 0 !== rootHasPendingCommit && (nextLanes = getHighestPriorityLanes(rootHasPendingCommit))));
        return 0 === nextLanes ? 0 : 0 !== wipLanes && wipLanes !== nextLanes && 0 === (wipLanes & suspendedLanes) && (suspendedLanes = nextLanes & -nextLanes, rootHasPendingCommit = wipLanes & -wipLanes, suspendedLanes >= rootHasPendingCommit || 32 === suspendedLanes && 0 !== (rootHasPendingCommit & 4194048)) ? wipLanes : nextLanes;
      }
      function checkIfRootIsPrerendering(root3, renderLanes2) {
        return 0 === (root3.pendingLanes & ~(root3.suspendedLanes & ~root3.pingedLanes) & renderLanes2);
      }
      function computeExpirationTime(lane, currentTime) {
        switch (lane) {
          case 1:
          case 2:
          case 4:
          case 8:
          case 64:
            return currentTime + 250;
          case 16:
          case 32:
          case 128:
          case 256:
          case 512:
          case 1024:
          case 2048:
          case 4096:
          case 8192:
          case 16384:
          case 32768:
          case 65536:
          case 131072:
          case 262144:
          case 524288:
          case 1048576:
          case 2097152:
            return currentTime + 5e3;
          case 4194304:
          case 8388608:
          case 16777216:
          case 33554432:
            return -1;
          case 67108864:
          case 134217728:
          case 268435456:
          case 536870912:
          case 1073741824:
            return -1;
          default:
            return -1;
        }
      }
      function claimNextRetryLane() {
        var lane = nextRetryLane;
        nextRetryLane <<= 1;
        0 === (nextRetryLane & 62914560) && (nextRetryLane = 4194304);
        return lane;
      }
      function createLaneMap(initial) {
        for (var laneMap = [], i = 0; 31 > i; i++)
          laneMap.push(initial);
        return laneMap;
      }
      function markRootUpdated$1(root3, updateLane) {
        root3.pendingLanes |= updateLane;
        268435456 !== updateLane && (root3.suspendedLanes = 0, root3.pingedLanes = 0, root3.warmLanes = 0);
      }
      function markRootFinished(root3, finishedLanes, remainingLanes, spawnedLane, updatedLanes, suspendedRetryLanes) {
        var previouslyPendingLanes = root3.pendingLanes;
        root3.pendingLanes = remainingLanes;
        root3.suspendedLanes = 0;
        root3.pingedLanes = 0;
        root3.warmLanes = 0;
        root3.expiredLanes &= remainingLanes;
        root3.entangledLanes &= remainingLanes;
        root3.errorRecoveryDisabledLanes &= remainingLanes;
        root3.shellSuspendCounter = 0;
        var entanglements = root3.entanglements, expirationTimes = root3.expirationTimes, hiddenUpdates = root3.hiddenUpdates;
        for (remainingLanes = previouslyPendingLanes & ~remainingLanes; 0 < remainingLanes; ) {
          var index$7 = 31 - clz32(remainingLanes), lane = 1 << index$7;
          entanglements[index$7] = 0;
          expirationTimes[index$7] = -1;
          var hiddenUpdatesForLane = hiddenUpdates[index$7];
          if (null !== hiddenUpdatesForLane)
            for (hiddenUpdates[index$7] = null, index$7 = 0; index$7 < hiddenUpdatesForLane.length; index$7++) {
              var update = hiddenUpdatesForLane[index$7];
              null !== update && (update.lane &= -536870913);
            }
          remainingLanes &= ~lane;
        }
        0 !== spawnedLane && markSpawnedDeferredLane(root3, spawnedLane, 0);
        0 !== suspendedRetryLanes && 0 === updatedLanes && 0 !== root3.tag && (root3.suspendedLanes |= suspendedRetryLanes & ~(previouslyPendingLanes & ~finishedLanes));
      }
      function markSpawnedDeferredLane(root3, spawnedLane, entangledLanes) {
        root3.pendingLanes |= spawnedLane;
        root3.suspendedLanes &= ~spawnedLane;
        var spawnedLaneIndex = 31 - clz32(spawnedLane);
        root3.entangledLanes |= spawnedLane;
        root3.entanglements[spawnedLaneIndex] = root3.entanglements[spawnedLaneIndex] | 1073741824 | entangledLanes & 261930;
      }
      function markRootEntangled(root3, entangledLanes) {
        var rootEntangledLanes = root3.entangledLanes |= entangledLanes;
        for (root3 = root3.entanglements; rootEntangledLanes; ) {
          var index$8 = 31 - clz32(rootEntangledLanes), lane = 1 << index$8;
          lane & entangledLanes | root3[index$8] & entangledLanes && (root3[index$8] |= entangledLanes);
          rootEntangledLanes &= ~lane;
        }
      }
      function getBumpedLaneForHydration(root3, renderLanes2) {
        var renderLane = renderLanes2 & -renderLanes2;
        renderLane = 0 !== (renderLane & 42) ? 1 : getBumpedLaneForHydrationByLane(renderLane);
        return 0 !== (renderLane & (root3.suspendedLanes | renderLanes2)) ? 0 : renderLane;
      }
      function getBumpedLaneForHydrationByLane(lane) {
        switch (lane) {
          case 2:
            lane = 1;
            break;
          case 8:
            lane = 4;
            break;
          case 32:
            lane = 16;
            break;
          case 256:
          case 512:
          case 1024:
          case 2048:
          case 4096:
          case 8192:
          case 16384:
          case 32768:
          case 65536:
          case 131072:
          case 262144:
          case 524288:
          case 1048576:
          case 2097152:
          case 4194304:
          case 8388608:
          case 16777216:
          case 33554432:
            lane = 128;
            break;
          case 268435456:
            lane = 134217728;
            break;
          default:
            lane = 0;
        }
        return lane;
      }
      function lanesToEventPriority(lanes) {
        lanes &= -lanes;
        return 2 < lanes ? 8 < lanes ? 0 !== (lanes & 134217727) ? 32 : 268435456 : 8 : 2;
      }
      function resolveUpdatePriority() {
        var updatePriority = ReactDOMSharedInternals.p;
        if (0 !== updatePriority)
          return updatePriority;
        updatePriority = window.event;
        return void 0 === updatePriority ? 32 : getEventPriority(updatePriority.type);
      }
      function runWithPriority(priority, fn) {
        var previousPriority = ReactDOMSharedInternals.p;
        try {
          return ReactDOMSharedInternals.p = priority, fn();
        } finally {
          ReactDOMSharedInternals.p = previousPriority;
        }
      }
      var randomKey = Math.random().toString(36).slice(2);
      var internalInstanceKey = "__reactFiber$" + randomKey;
      var internalPropsKey = "__reactProps$" + randomKey;
      var internalContainerInstanceKey = "__reactContainer$" + randomKey;
      var internalEventHandlersKey = "__reactEvents$" + randomKey;
      var internalEventHandlerListenersKey = "__reactListeners$" + randomKey;
      var internalEventHandlesSetKey = "__reactHandles$" + randomKey;
      var internalRootNodeResourcesKey = "__reactResources$" + randomKey;
      var internalHoistableMarker = "__reactMarker$" + randomKey;
      function detachDeletedInstance(node) {
        delete node[internalInstanceKey];
        delete node[internalPropsKey];
        delete node[internalEventHandlersKey];
        delete node[internalEventHandlerListenersKey];
        delete node[internalEventHandlesSetKey];
      }
      function getClosestInstanceFromNode(targetNode) {
        var targetInst = targetNode[internalInstanceKey];
        if (targetInst)
          return targetInst;
        for (var parentNode = targetNode.parentNode; parentNode; ) {
          if (targetInst = parentNode[internalContainerInstanceKey] || parentNode[internalInstanceKey]) {
            parentNode = targetInst.alternate;
            if (null !== targetInst.child || null !== parentNode && null !== parentNode.child)
              for (targetNode = getParentHydrationBoundary(targetNode); null !== targetNode; ) {
                if (parentNode = targetNode[internalInstanceKey])
                  return parentNode;
                targetNode = getParentHydrationBoundary(targetNode);
              }
            return targetInst;
          }
          targetNode = parentNode;
          parentNode = targetNode.parentNode;
        }
        return null;
      }
      function getInstanceFromNode(node) {
        if (node = node[internalInstanceKey] || node[internalContainerInstanceKey]) {
          var tag = node.tag;
          if (5 === tag || 6 === tag || 13 === tag || 31 === tag || 26 === tag || 27 === tag || 3 === tag)
            return node;
        }
        return null;
      }
      function getNodeFromInstance(inst) {
        var tag = inst.tag;
        if (5 === tag || 26 === tag || 27 === tag || 6 === tag)
          return inst.stateNode;
        throw Error(formatProdErrorMessage(33));
      }
      function getResourcesFromRoot(root3) {
        var resources = root3[internalRootNodeResourcesKey];
        resources || (resources = root3[internalRootNodeResourcesKey] = { hoistableStyles: /* @__PURE__ */ new Map(), hoistableScripts: /* @__PURE__ */ new Map() });
        return resources;
      }
      function markNodeAsHoistable(node) {
        node[internalHoistableMarker] = true;
      }
      var allNativeEvents = /* @__PURE__ */ new Set();
      var registrationNameDependencies = {};
      function registerTwoPhaseEvent(registrationName, dependencies) {
        registerDirectEvent(registrationName, dependencies);
        registerDirectEvent(registrationName + "Capture", dependencies);
      }
      function registerDirectEvent(registrationName, dependencies) {
        registrationNameDependencies[registrationName] = dependencies;
        for (registrationName = 0; registrationName < dependencies.length; registrationName++)
          allNativeEvents.add(dependencies[registrationName]);
      }
      var VALID_ATTRIBUTE_NAME_REGEX = RegExp(
        "^[:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD][:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$"
      );
      var illegalAttributeNameCache = {};
      var validatedAttributeNameCache = {};
      function isAttributeNameSafe(attributeName) {
        if (hasOwnProperty.call(validatedAttributeNameCache, attributeName))
          return true;
        if (hasOwnProperty.call(illegalAttributeNameCache, attributeName))
          return false;
        if (VALID_ATTRIBUTE_NAME_REGEX.test(attributeName))
          return validatedAttributeNameCache[attributeName] = true;
        illegalAttributeNameCache[attributeName] = true;
        return false;
      }
      function setValueForAttribute(node, name, value) {
        if (isAttributeNameSafe(name))
          if (null === value)
            node.removeAttribute(name);
          else {
            switch (typeof value) {
              case "undefined":
              case "function":
              case "symbol":
                node.removeAttribute(name);
                return;
              case "boolean":
                var prefix$10 = name.toLowerCase().slice(0, 5);
                if ("data-" !== prefix$10 && "aria-" !== prefix$10) {
                  node.removeAttribute(name);
                  return;
                }
            }
            node.setAttribute(name, "" + value);
          }
      }
      function setValueForKnownAttribute(node, name, value) {
        if (null === value)
          node.removeAttribute(name);
        else {
          switch (typeof value) {
            case "undefined":
            case "function":
            case "symbol":
            case "boolean":
              node.removeAttribute(name);
              return;
          }
          node.setAttribute(name, "" + value);
        }
      }
      function setValueForNamespacedAttribute(node, namespace, name, value) {
        if (null === value)
          node.removeAttribute(name);
        else {
          switch (typeof value) {
            case "undefined":
            case "function":
            case "symbol":
            case "boolean":
              node.removeAttribute(name);
              return;
          }
          node.setAttributeNS(namespace, name, "" + value);
        }
      }
      function getToStringValue(value) {
        switch (typeof value) {
          case "bigint":
          case "boolean":
          case "number":
          case "string":
          case "undefined":
            return value;
          case "object":
            return value;
          default:
            return "";
        }
      }
      function isCheckable(elem) {
        var type = elem.type;
        return (elem = elem.nodeName) && "input" === elem.toLowerCase() && ("checkbox" === type || "radio" === type);
      }
      function trackValueOnNode(node, valueField, currentValue) {
        var descriptor = Object.getOwnPropertyDescriptor(
          node.constructor.prototype,
          valueField
        );
        if (!node.hasOwnProperty(valueField) && "undefined" !== typeof descriptor && "function" === typeof descriptor.get && "function" === typeof descriptor.set) {
          var get = descriptor.get, set = descriptor.set;
          Object.defineProperty(node, valueField, {
            configurable: true,
            get: function() {
              return get.call(this);
            },
            set: function(value) {
              currentValue = "" + value;
              set.call(this, value);
            }
          });
          Object.defineProperty(node, valueField, {
            enumerable: descriptor.enumerable
          });
          return {
            getValue: function() {
              return currentValue;
            },
            setValue: function(value) {
              currentValue = "" + value;
            },
            stopTracking: function() {
              node._valueTracker = null;
              delete node[valueField];
            }
          };
        }
      }
      function track(node) {
        if (!node._valueTracker) {
          var valueField = isCheckable(node) ? "checked" : "value";
          node._valueTracker = trackValueOnNode(
            node,
            valueField,
            "" + node[valueField]
          );
        }
      }
      function updateValueIfChanged(node) {
        if (!node)
          return false;
        var tracker = node._valueTracker;
        if (!tracker)
          return true;
        var lastValue = tracker.getValue();
        var value = "";
        node && (value = isCheckable(node) ? node.checked ? "true" : "false" : node.value);
        node = value;
        return node !== lastValue ? (tracker.setValue(node), true) : false;
      }
      function getActiveElement(doc) {
        doc = doc || ("undefined" !== typeof document ? document : void 0);
        if ("undefined" === typeof doc)
          return null;
        try {
          return doc.activeElement || doc.body;
        } catch (e) {
          return doc.body;
        }
      }
      var escapeSelectorAttributeValueInsideDoubleQuotesRegex = /[\n"\\]/g;
      function escapeSelectorAttributeValueInsideDoubleQuotes(value) {
        return value.replace(
          escapeSelectorAttributeValueInsideDoubleQuotesRegex,
          function(ch) {
            return "\\" + ch.charCodeAt(0).toString(16) + " ";
          }
        );
      }
      function updateInput(element, value, defaultValue, lastDefaultValue, checked, defaultChecked, type, name) {
        element.name = "";
        null != type && "function" !== typeof type && "symbol" !== typeof type && "boolean" !== typeof type ? element.type = type : element.removeAttribute("type");
        if (null != value)
          if ("number" === type) {
            if (0 === value && "" === element.value || element.value != value)
              element.value = "" + getToStringValue(value);
          } else
            element.value !== "" + getToStringValue(value) && (element.value = "" + getToStringValue(value));
        else
          "submit" !== type && "reset" !== type || element.removeAttribute("value");
        null != value ? setDefaultValue(element, type, getToStringValue(value)) : null != defaultValue ? setDefaultValue(element, type, getToStringValue(defaultValue)) : null != lastDefaultValue && element.removeAttribute("value");
        null == checked && null != defaultChecked && (element.defaultChecked = !!defaultChecked);
        null != checked && (element.checked = checked && "function" !== typeof checked && "symbol" !== typeof checked);
        null != name && "function" !== typeof name && "symbol" !== typeof name && "boolean" !== typeof name ? element.name = "" + getToStringValue(name) : element.removeAttribute("name");
      }
      function initInput(element, value, defaultValue, checked, defaultChecked, type, name, isHydrating2) {
        null != type && "function" !== typeof type && "symbol" !== typeof type && "boolean" !== typeof type && (element.type = type);
        if (null != value || null != defaultValue) {
          if (!("submit" !== type && "reset" !== type || void 0 !== value && null !== value)) {
            track(element);
            return;
          }
          defaultValue = null != defaultValue ? "" + getToStringValue(defaultValue) : "";
          value = null != value ? "" + getToStringValue(value) : defaultValue;
          isHydrating2 || value === element.value || (element.value = value);
          element.defaultValue = value;
        }
        checked = null != checked ? checked : defaultChecked;
        checked = "function" !== typeof checked && "symbol" !== typeof checked && !!checked;
        element.checked = isHydrating2 ? element.checked : !!checked;
        element.defaultChecked = !!checked;
        null != name && "function" !== typeof name && "symbol" !== typeof name && "boolean" !== typeof name && (element.name = name);
        track(element);
      }
      function setDefaultValue(node, type, value) {
        "number" === type && getActiveElement(node.ownerDocument) === node || node.defaultValue === "" + value || (node.defaultValue = "" + value);
      }
      function updateOptions(node, multiple, propValue, setDefaultSelected) {
        node = node.options;
        if (multiple) {
          multiple = {};
          for (var i = 0; i < propValue.length; i++)
            multiple["$" + propValue[i]] = true;
          for (propValue = 0; propValue < node.length; propValue++)
            i = multiple.hasOwnProperty("$" + node[propValue].value), node[propValue].selected !== i && (node[propValue].selected = i), i && setDefaultSelected && (node[propValue].defaultSelected = true);
        } else {
          propValue = "" + getToStringValue(propValue);
          multiple = null;
          for (i = 0; i < node.length; i++) {
            if (node[i].value === propValue) {
              node[i].selected = true;
              setDefaultSelected && (node[i].defaultSelected = true);
              return;
            }
            null !== multiple || node[i].disabled || (multiple = node[i]);
          }
          null !== multiple && (multiple.selected = true);
        }
      }
      function updateTextarea(element, value, defaultValue) {
        if (null != value && (value = "" + getToStringValue(value), value !== element.value && (element.value = value), null == defaultValue)) {
          element.defaultValue !== value && (element.defaultValue = value);
          return;
        }
        element.defaultValue = null != defaultValue ? "" + getToStringValue(defaultValue) : "";
      }
      function initTextarea(element, value, defaultValue, children) {
        if (null == value) {
          if (null != children) {
            if (null != defaultValue)
              throw Error(formatProdErrorMessage(92));
            if (isArrayImpl(children)) {
              if (1 < children.length)
                throw Error(formatProdErrorMessage(93));
              children = children[0];
            }
            defaultValue = children;
          }
          null == defaultValue && (defaultValue = "");
          value = defaultValue;
        }
        defaultValue = getToStringValue(value);
        element.defaultValue = defaultValue;
        children = element.textContent;
        children === defaultValue && "" !== children && null !== children && (element.value = children);
        track(element);
      }
      function setTextContent(node, text) {
        if (text) {
          var firstChild = node.firstChild;
          if (firstChild && firstChild === node.lastChild && 3 === firstChild.nodeType) {
            firstChild.nodeValue = text;
            return;
          }
        }
        node.textContent = text;
      }
      var unitlessNumbers = new Set(
        "animationIterationCount aspectRatio borderImageOutset borderImageSlice borderImageWidth boxFlex boxFlexGroup boxOrdinalGroup columnCount columns flex flexGrow flexPositive flexShrink flexNegative flexOrder gridArea gridRow gridRowEnd gridRowSpan gridRowStart gridColumn gridColumnEnd gridColumnSpan gridColumnStart fontWeight lineClamp lineHeight opacity order orphans scale tabSize widows zIndex zoom fillOpacity floodOpacity stopOpacity strokeDasharray strokeDashoffset strokeMiterlimit strokeOpacity strokeWidth MozAnimationIterationCount MozBoxFlex MozBoxFlexGroup MozLineClamp msAnimationIterationCount msFlex msZoom msFlexGrow msFlexNegative msFlexOrder msFlexPositive msFlexShrink msGridColumn msGridColumnSpan msGridRow msGridRowSpan WebkitAnimationIterationCount WebkitBoxFlex WebKitBoxFlexGroup WebkitBoxOrdinalGroup WebkitColumnCount WebkitColumns WebkitFlex WebkitFlexGrow WebkitFlexPositive WebkitFlexShrink WebkitLineClamp".split(
          " "
        )
      );
      function setValueForStyle(style2, styleName, value) {
        var isCustomProperty = 0 === styleName.indexOf("--");
        null == value || "boolean" === typeof value || "" === value ? isCustomProperty ? style2.setProperty(styleName, "") : "float" === styleName ? style2.cssFloat = "" : style2[styleName] = "" : isCustomProperty ? style2.setProperty(styleName, value) : "number" !== typeof value || 0 === value || unitlessNumbers.has(styleName) ? "float" === styleName ? style2.cssFloat = value : style2[styleName] = ("" + value).trim() : style2[styleName] = value + "px";
      }
      function setValueForStyles(node, styles, prevStyles) {
        if (null != styles && "object" !== typeof styles)
          throw Error(formatProdErrorMessage(62));
        node = node.style;
        if (null != prevStyles) {
          for (var styleName in prevStyles)
            !prevStyles.hasOwnProperty(styleName) || null != styles && styles.hasOwnProperty(styleName) || (0 === styleName.indexOf("--") ? node.setProperty(styleName, "") : "float" === styleName ? node.cssFloat = "" : node[styleName] = "");
          for (var styleName$16 in styles)
            styleName = styles[styleName$16], styles.hasOwnProperty(styleName$16) && prevStyles[styleName$16] !== styleName && setValueForStyle(node, styleName$16, styleName);
        } else
          for (var styleName$17 in styles)
            styles.hasOwnProperty(styleName$17) && setValueForStyle(node, styleName$17, styles[styleName$17]);
      }
      function isCustomElement(tagName) {
        if (-1 === tagName.indexOf("-"))
          return false;
        switch (tagName) {
          case "annotation-xml":
          case "color-profile":
          case "font-face":
          case "font-face-src":
          case "font-face-uri":
          case "font-face-format":
          case "font-face-name":
          case "missing-glyph":
            return false;
          default:
            return true;
        }
      }
      var aliases = /* @__PURE__ */ new Map([
        ["acceptCharset", "accept-charset"],
        ["htmlFor", "for"],
        ["httpEquiv", "http-equiv"],
        ["crossOrigin", "crossorigin"],
        ["accentHeight", "accent-height"],
        ["alignmentBaseline", "alignment-baseline"],
        ["arabicForm", "arabic-form"],
        ["baselineShift", "baseline-shift"],
        ["capHeight", "cap-height"],
        ["clipPath", "clip-path"],
        ["clipRule", "clip-rule"],
        ["colorInterpolation", "color-interpolation"],
        ["colorInterpolationFilters", "color-interpolation-filters"],
        ["colorProfile", "color-profile"],
        ["colorRendering", "color-rendering"],
        ["dominantBaseline", "dominant-baseline"],
        ["enableBackground", "enable-background"],
        ["fillOpacity", "fill-opacity"],
        ["fillRule", "fill-rule"],
        ["floodColor", "flood-color"],
        ["floodOpacity", "flood-opacity"],
        ["fontFamily", "font-family"],
        ["fontSize", "font-size"],
        ["fontSizeAdjust", "font-size-adjust"],
        ["fontStretch", "font-stretch"],
        ["fontStyle", "font-style"],
        ["fontVariant", "font-variant"],
        ["fontWeight", "font-weight"],
        ["glyphName", "glyph-name"],
        ["glyphOrientationHorizontal", "glyph-orientation-horizontal"],
        ["glyphOrientationVertical", "glyph-orientation-vertical"],
        ["horizAdvX", "horiz-adv-x"],
        ["horizOriginX", "horiz-origin-x"],
        ["imageRendering", "image-rendering"],
        ["letterSpacing", "letter-spacing"],
        ["lightingColor", "lighting-color"],
        ["markerEnd", "marker-end"],
        ["markerMid", "marker-mid"],
        ["markerStart", "marker-start"],
        ["overlinePosition", "overline-position"],
        ["overlineThickness", "overline-thickness"],
        ["paintOrder", "paint-order"],
        ["panose-1", "panose-1"],
        ["pointerEvents", "pointer-events"],
        ["renderingIntent", "rendering-intent"],
        ["shapeRendering", "shape-rendering"],
        ["stopColor", "stop-color"],
        ["stopOpacity", "stop-opacity"],
        ["strikethroughPosition", "strikethrough-position"],
        ["strikethroughThickness", "strikethrough-thickness"],
        ["strokeDasharray", "stroke-dasharray"],
        ["strokeDashoffset", "stroke-dashoffset"],
        ["strokeLinecap", "stroke-linecap"],
        ["strokeLinejoin", "stroke-linejoin"],
        ["strokeMiterlimit", "stroke-miterlimit"],
        ["strokeOpacity", "stroke-opacity"],
        ["strokeWidth", "stroke-width"],
        ["textAnchor", "text-anchor"],
        ["textDecoration", "text-decoration"],
        ["textRendering", "text-rendering"],
        ["transformOrigin", "transform-origin"],
        ["underlinePosition", "underline-position"],
        ["underlineThickness", "underline-thickness"],
        ["unicodeBidi", "unicode-bidi"],
        ["unicodeRange", "unicode-range"],
        ["unitsPerEm", "units-per-em"],
        ["vAlphabetic", "v-alphabetic"],
        ["vHanging", "v-hanging"],
        ["vIdeographic", "v-ideographic"],
        ["vMathematical", "v-mathematical"],
        ["vectorEffect", "vector-effect"],
        ["vertAdvY", "vert-adv-y"],
        ["vertOriginX", "vert-origin-x"],
        ["vertOriginY", "vert-origin-y"],
        ["wordSpacing", "word-spacing"],
        ["writingMode", "writing-mode"],
        ["xmlnsXlink", "xmlns:xlink"],
        ["xHeight", "x-height"]
      ]);
      var isJavaScriptProtocol = /^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*:/i;
      function sanitizeURL(url) {
        return isJavaScriptProtocol.test("" + url) ? "javascript:throw new Error('React has blocked a javascript: URL as a security precaution.')" : url;
      }
      function noop$1() {
      }
      var currentReplayingEvent = null;
      function getEventTarget(nativeEvent) {
        nativeEvent = nativeEvent.target || nativeEvent.srcElement || window;
        nativeEvent.correspondingUseElement && (nativeEvent = nativeEvent.correspondingUseElement);
        return 3 === nativeEvent.nodeType ? nativeEvent.parentNode : nativeEvent;
      }
      var restoreTarget = null;
      var restoreQueue = null;
      function restoreStateOfTarget(target) {
        var internalInstance = getInstanceFromNode(target);
        if (internalInstance && (target = internalInstance.stateNode)) {
          var props = target[internalPropsKey] || null;
          a:
            switch (target = internalInstance.stateNode, internalInstance.type) {
              case "input":
                updateInput(
                  target,
                  props.value,
                  props.defaultValue,
                  props.defaultValue,
                  props.checked,
                  props.defaultChecked,
                  props.type,
                  props.name
                );
                internalInstance = props.name;
                if ("radio" === props.type && null != internalInstance) {
                  for (props = target; props.parentNode; )
                    props = props.parentNode;
                  props = props.querySelectorAll(
                    'input[name="' + escapeSelectorAttributeValueInsideDoubleQuotes(
                      "" + internalInstance
                    ) + '"][type="radio"]'
                  );
                  for (internalInstance = 0; internalInstance < props.length; internalInstance++) {
                    var otherNode = props[internalInstance];
                    if (otherNode !== target && otherNode.form === target.form) {
                      var otherProps = otherNode[internalPropsKey] || null;
                      if (!otherProps)
                        throw Error(formatProdErrorMessage(90));
                      updateInput(
                        otherNode,
                        otherProps.value,
                        otherProps.defaultValue,
                        otherProps.defaultValue,
                        otherProps.checked,
                        otherProps.defaultChecked,
                        otherProps.type,
                        otherProps.name
                      );
                    }
                  }
                  for (internalInstance = 0; internalInstance < props.length; internalInstance++)
                    otherNode = props[internalInstance], otherNode.form === target.form && updateValueIfChanged(otherNode);
                }
                break a;
              case "textarea":
                updateTextarea(target, props.value, props.defaultValue);
                break a;
              case "select":
                internalInstance = props.value, null != internalInstance && updateOptions(target, !!props.multiple, internalInstance, false);
            }
        }
      }
      var isInsideEventHandler = false;
      function batchedUpdates$1(fn, a, b) {
        if (isInsideEventHandler)
          return fn(a, b);
        isInsideEventHandler = true;
        try {
          var JSCompiler_inline_result = fn(a);
          return JSCompiler_inline_result;
        } finally {
          if (isInsideEventHandler = false, null !== restoreTarget || null !== restoreQueue) {
            if (flushSyncWork$1(), restoreTarget && (a = restoreTarget, fn = restoreQueue, restoreQueue = restoreTarget = null, restoreStateOfTarget(a), fn))
              for (a = 0; a < fn.length; a++)
                restoreStateOfTarget(fn[a]);
          }
        }
      }
      function getListener(inst, registrationName) {
        var stateNode = inst.stateNode;
        if (null === stateNode)
          return null;
        var props = stateNode[internalPropsKey] || null;
        if (null === props)
          return null;
        stateNode = props[registrationName];
        a:
          switch (registrationName) {
            case "onClick":
            case "onClickCapture":
            case "onDoubleClick":
            case "onDoubleClickCapture":
            case "onMouseDown":
            case "onMouseDownCapture":
            case "onMouseMove":
            case "onMouseMoveCapture":
            case "onMouseUp":
            case "onMouseUpCapture":
            case "onMouseEnter":
              (props = !props.disabled) || (inst = inst.type, props = !("button" === inst || "input" === inst || "select" === inst || "textarea" === inst));
              inst = !props;
              break a;
            default:
              inst = false;
          }
        if (inst)
          return null;
        if (stateNode && "function" !== typeof stateNode)
          throw Error(
            formatProdErrorMessage(231, registrationName, typeof stateNode)
          );
        return stateNode;
      }
      var canUseDOM = !("undefined" === typeof window || "undefined" === typeof window.document || "undefined" === typeof window.document.createElement);
      var passiveBrowserEventsSupported = false;
      if (canUseDOM)
        try {
          options = {};
          Object.defineProperty(options, "passive", {
            get: function() {
              passiveBrowserEventsSupported = true;
            }
          });
          window.addEventListener("test", options, options);
          window.removeEventListener("test", options, options);
        } catch (e) {
          passiveBrowserEventsSupported = false;
        }
      var options;
      var root2 = null;
      var startText = null;
      var fallbackText = null;
      function getData() {
        if (fallbackText)
          return fallbackText;
        var start, startValue = startText, startLength = startValue.length, end, endValue = "value" in root2 ? root2.value : root2.textContent, endLength = endValue.length;
        for (start = 0; start < startLength && startValue[start] === endValue[start]; start++)
          ;
        var minEnd = startLength - start;
        for (end = 1; end <= minEnd && startValue[startLength - end] === endValue[endLength - end]; end++)
          ;
        return fallbackText = endValue.slice(start, 1 < end ? 1 - end : void 0);
      }
      function getEventCharCode(nativeEvent) {
        var keyCode = nativeEvent.keyCode;
        "charCode" in nativeEvent ? (nativeEvent = nativeEvent.charCode, 0 === nativeEvent && 13 === keyCode && (nativeEvent = 13)) : nativeEvent = keyCode;
        10 === nativeEvent && (nativeEvent = 13);
        return 32 <= nativeEvent || 13 === nativeEvent ? nativeEvent : 0;
      }
      function functionThatReturnsTrue() {
        return true;
      }
      function functionThatReturnsFalse() {
        return false;
      }
      function createSyntheticEvent(Interface) {
        function SyntheticBaseEvent(reactName, reactEventType, targetInst, nativeEvent, nativeEventTarget) {
          this._reactName = reactName;
          this._targetInst = targetInst;
          this.type = reactEventType;
          this.nativeEvent = nativeEvent;
          this.target = nativeEventTarget;
          this.currentTarget = null;
          for (var propName in Interface)
            Interface.hasOwnProperty(propName) && (reactName = Interface[propName], this[propName] = reactName ? reactName(nativeEvent) : nativeEvent[propName]);
          this.isDefaultPrevented = (null != nativeEvent.defaultPrevented ? nativeEvent.defaultPrevented : false === nativeEvent.returnValue) ? functionThatReturnsTrue : functionThatReturnsFalse;
          this.isPropagationStopped = functionThatReturnsFalse;
          return this;
        }
        assign(SyntheticBaseEvent.prototype, {
          preventDefault: function() {
            this.defaultPrevented = true;
            var event = this.nativeEvent;
            event && (event.preventDefault ? event.preventDefault() : "unknown" !== typeof event.returnValue && (event.returnValue = false), this.isDefaultPrevented = functionThatReturnsTrue);
          },
          stopPropagation: function() {
            var event = this.nativeEvent;
            event && (event.stopPropagation ? event.stopPropagation() : "unknown" !== typeof event.cancelBubble && (event.cancelBubble = true), this.isPropagationStopped = functionThatReturnsTrue);
          },
          persist: function() {
          },
          isPersistent: functionThatReturnsTrue
        });
        return SyntheticBaseEvent;
      }
      var EventInterface = {
        eventPhase: 0,
        bubbles: 0,
        cancelable: 0,
        timeStamp: function(event) {
          return event.timeStamp || Date.now();
        },
        defaultPrevented: 0,
        isTrusted: 0
      };
      var SyntheticEvent = createSyntheticEvent(EventInterface);
      var UIEventInterface = assign({}, EventInterface, { view: 0, detail: 0 });
      var SyntheticUIEvent = createSyntheticEvent(UIEventInterface);
      var lastMovementX;
      var lastMovementY;
      var lastMouseEvent;
      var MouseEventInterface = assign({}, UIEventInterface, {
        screenX: 0,
        screenY: 0,
        clientX: 0,
        clientY: 0,
        pageX: 0,
        pageY: 0,
        ctrlKey: 0,
        shiftKey: 0,
        altKey: 0,
        metaKey: 0,
        getModifierState: getEventModifierState,
        button: 0,
        buttons: 0,
        relatedTarget: function(event) {
          return void 0 === event.relatedTarget ? event.fromElement === event.srcElement ? event.toElement : event.fromElement : event.relatedTarget;
        },
        movementX: function(event) {
          if ("movementX" in event)
            return event.movementX;
          event !== lastMouseEvent && (lastMouseEvent && "mousemove" === event.type ? (lastMovementX = event.screenX - lastMouseEvent.screenX, lastMovementY = event.screenY - lastMouseEvent.screenY) : lastMovementY = lastMovementX = 0, lastMouseEvent = event);
          return lastMovementX;
        },
        movementY: function(event) {
          return "movementY" in event ? event.movementY : lastMovementY;
        }
      });
      var SyntheticMouseEvent = createSyntheticEvent(MouseEventInterface);
      var DragEventInterface = assign({}, MouseEventInterface, { dataTransfer: 0 });
      var SyntheticDragEvent = createSyntheticEvent(DragEventInterface);
      var FocusEventInterface = assign({}, UIEventInterface, { relatedTarget: 0 });
      var SyntheticFocusEvent = createSyntheticEvent(FocusEventInterface);
      var AnimationEventInterface = assign({}, EventInterface, {
        animationName: 0,
        elapsedTime: 0,
        pseudoElement: 0
      });
      var SyntheticAnimationEvent = createSyntheticEvent(AnimationEventInterface);
      var ClipboardEventInterface = assign({}, EventInterface, {
        clipboardData: function(event) {
          return "clipboardData" in event ? event.clipboardData : window.clipboardData;
        }
      });
      var SyntheticClipboardEvent = createSyntheticEvent(ClipboardEventInterface);
      var CompositionEventInterface = assign({}, EventInterface, { data: 0 });
      var SyntheticCompositionEvent = createSyntheticEvent(CompositionEventInterface);
      var normalizeKey = {
        Esc: "Escape",
        Spacebar: " ",
        Left: "ArrowLeft",
        Up: "ArrowUp",
        Right: "ArrowRight",
        Down: "ArrowDown",
        Del: "Delete",
        Win: "OS",
        Menu: "ContextMenu",
        Apps: "ContextMenu",
        Scroll: "ScrollLock",
        MozPrintableKey: "Unidentified"
      };
      var translateToKey = {
        8: "Backspace",
        9: "Tab",
        12: "Clear",
        13: "Enter",
        16: "Shift",
        17: "Control",
        18: "Alt",
        19: "Pause",
        20: "CapsLock",
        27: "Escape",
        32: " ",
        33: "PageUp",
        34: "PageDown",
        35: "End",
        36: "Home",
        37: "ArrowLeft",
        38: "ArrowUp",
        39: "ArrowRight",
        40: "ArrowDown",
        45: "Insert",
        46: "Delete",
        112: "F1",
        113: "F2",
        114: "F3",
        115: "F4",
        116: "F5",
        117: "F6",
        118: "F7",
        119: "F8",
        120: "F9",
        121: "F10",
        122: "F11",
        123: "F12",
        144: "NumLock",
        145: "ScrollLock",
        224: "Meta"
      };
      var modifierKeyToProp = {
        Alt: "altKey",
        Control: "ctrlKey",
        Meta: "metaKey",
        Shift: "shiftKey"
      };
      function modifierStateGetter(keyArg) {
        var nativeEvent = this.nativeEvent;
        return nativeEvent.getModifierState ? nativeEvent.getModifierState(keyArg) : (keyArg = modifierKeyToProp[keyArg]) ? !!nativeEvent[keyArg] : false;
      }
      function getEventModifierState() {
        return modifierStateGetter;
      }
      var KeyboardEventInterface = assign({}, UIEventInterface, {
        key: function(nativeEvent) {
          if (nativeEvent.key) {
            var key = normalizeKey[nativeEvent.key] || nativeEvent.key;
            if ("Unidentified" !== key)
              return key;
          }
          return "keypress" === nativeEvent.type ? (nativeEvent = getEventCharCode(nativeEvent), 13 === nativeEvent ? "Enter" : String.fromCharCode(nativeEvent)) : "keydown" === nativeEvent.type || "keyup" === nativeEvent.type ? translateToKey[nativeEvent.keyCode] || "Unidentified" : "";
        },
        code: 0,
        location: 0,
        ctrlKey: 0,
        shiftKey: 0,
        altKey: 0,
        metaKey: 0,
        repeat: 0,
        locale: 0,
        getModifierState: getEventModifierState,
        charCode: function(event) {
          return "keypress" === event.type ? getEventCharCode(event) : 0;
        },
        keyCode: function(event) {
          return "keydown" === event.type || "keyup" === event.type ? event.keyCode : 0;
        },
        which: function(event) {
          return "keypress" === event.type ? getEventCharCode(event) : "keydown" === event.type || "keyup" === event.type ? event.keyCode : 0;
        }
      });
      var SyntheticKeyboardEvent = createSyntheticEvent(KeyboardEventInterface);
      var PointerEventInterface = assign({}, MouseEventInterface, {
        pointerId: 0,
        width: 0,
        height: 0,
        pressure: 0,
        tangentialPressure: 0,
        tiltX: 0,
        tiltY: 0,
        twist: 0,
        pointerType: 0,
        isPrimary: 0
      });
      var SyntheticPointerEvent = createSyntheticEvent(PointerEventInterface);
      var TouchEventInterface = assign({}, UIEventInterface, {
        touches: 0,
        targetTouches: 0,
        changedTouches: 0,
        altKey: 0,
        metaKey: 0,
        ctrlKey: 0,
        shiftKey: 0,
        getModifierState: getEventModifierState
      });
      var SyntheticTouchEvent = createSyntheticEvent(TouchEventInterface);
      var TransitionEventInterface = assign({}, EventInterface, {
        propertyName: 0,
        elapsedTime: 0,
        pseudoElement: 0
      });
      var SyntheticTransitionEvent = createSyntheticEvent(TransitionEventInterface);
      var WheelEventInterface = assign({}, MouseEventInterface, {
        deltaX: function(event) {
          return "deltaX" in event ? event.deltaX : "wheelDeltaX" in event ? -event.wheelDeltaX : 0;
        },
        deltaY: function(event) {
          return "deltaY" in event ? event.deltaY : "wheelDeltaY" in event ? -event.wheelDeltaY : "wheelDelta" in event ? -event.wheelDelta : 0;
        },
        deltaZ: 0,
        deltaMode: 0
      });
      var SyntheticWheelEvent = createSyntheticEvent(WheelEventInterface);
      var ToggleEventInterface = assign({}, EventInterface, {
        newState: 0,
        oldState: 0
      });
      var SyntheticToggleEvent = createSyntheticEvent(ToggleEventInterface);
      var END_KEYCODES = [9, 13, 27, 32];
      var canUseCompositionEvent = canUseDOM && "CompositionEvent" in window;
      var documentMode = null;
      canUseDOM && "documentMode" in document && (documentMode = document.documentMode);
      var canUseTextInputEvent = canUseDOM && "TextEvent" in window && !documentMode;
      var useFallbackCompositionData = canUseDOM && (!canUseCompositionEvent || documentMode && 8 < documentMode && 11 >= documentMode);
      var SPACEBAR_CHAR = String.fromCharCode(32);
      var hasSpaceKeypress = false;
      function isFallbackCompositionEnd(domEventName, nativeEvent) {
        switch (domEventName) {
          case "keyup":
            return -1 !== END_KEYCODES.indexOf(nativeEvent.keyCode);
          case "keydown":
            return 229 !== nativeEvent.keyCode;
          case "keypress":
          case "mousedown":
          case "focusout":
            return true;
          default:
            return false;
        }
      }
      function getDataFromCustomEvent(nativeEvent) {
        nativeEvent = nativeEvent.detail;
        return "object" === typeof nativeEvent && "data" in nativeEvent ? nativeEvent.data : null;
      }
      var isComposing = false;
      function getNativeBeforeInputChars(domEventName, nativeEvent) {
        switch (domEventName) {
          case "compositionend":
            return getDataFromCustomEvent(nativeEvent);
          case "keypress":
            if (32 !== nativeEvent.which)
              return null;
            hasSpaceKeypress = true;
            return SPACEBAR_CHAR;
          case "textInput":
            return domEventName = nativeEvent.data, domEventName === SPACEBAR_CHAR && hasSpaceKeypress ? null : domEventName;
          default:
            return null;
        }
      }
      function getFallbackBeforeInputChars(domEventName, nativeEvent) {
        if (isComposing)
          return "compositionend" === domEventName || !canUseCompositionEvent && isFallbackCompositionEnd(domEventName, nativeEvent) ? (domEventName = getData(), fallbackText = startText = root2 = null, isComposing = false, domEventName) : null;
        switch (domEventName) {
          case "paste":
            return null;
          case "keypress":
            if (!(nativeEvent.ctrlKey || nativeEvent.altKey || nativeEvent.metaKey) || nativeEvent.ctrlKey && nativeEvent.altKey) {
              if (nativeEvent.char && 1 < nativeEvent.char.length)
                return nativeEvent.char;
              if (nativeEvent.which)
                return String.fromCharCode(nativeEvent.which);
            }
            return null;
          case "compositionend":
            return useFallbackCompositionData && "ko" !== nativeEvent.locale ? null : nativeEvent.data;
          default:
            return null;
        }
      }
      var supportedInputTypes = {
        color: true,
        date: true,
        datetime: true,
        "datetime-local": true,
        email: true,
        month: true,
        number: true,
        password: true,
        range: true,
        search: true,
        tel: true,
        text: true,
        time: true,
        url: true,
        week: true
      };
      function isTextInputElement(elem) {
        var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();
        return "input" === nodeName ? !!supportedInputTypes[elem.type] : "textarea" === nodeName ? true : false;
      }
      function createAndAccumulateChangeEvent(dispatchQueue, inst, nativeEvent, target) {
        restoreTarget ? restoreQueue ? restoreQueue.push(target) : restoreQueue = [target] : restoreTarget = target;
        inst = accumulateTwoPhaseListeners(inst, "onChange");
        0 < inst.length && (nativeEvent = new SyntheticEvent(
          "onChange",
          "change",
          null,
          nativeEvent,
          target
        ), dispatchQueue.push({ event: nativeEvent, listeners: inst }));
      }
      var activeElement$1 = null;
      var activeElementInst$1 = null;
      function runEventInBatch(dispatchQueue) {
        processDispatchQueue(dispatchQueue, 0);
      }
      function getInstIfValueChanged(targetInst) {
        var targetNode = getNodeFromInstance(targetInst);
        if (updateValueIfChanged(targetNode))
          return targetInst;
      }
      function getTargetInstForChangeEvent(domEventName, targetInst) {
        if ("change" === domEventName)
          return targetInst;
      }
      var isInputEventSupported = false;
      if (canUseDOM) {
        if (canUseDOM) {
          isSupported$jscomp$inline_427 = "oninput" in document;
          if (!isSupported$jscomp$inline_427) {
            element$jscomp$inline_428 = document.createElement("div");
            element$jscomp$inline_428.setAttribute("oninput", "return;");
            isSupported$jscomp$inline_427 = "function" === typeof element$jscomp$inline_428.oninput;
          }
          JSCompiler_inline_result$jscomp$286 = isSupported$jscomp$inline_427;
        } else
          JSCompiler_inline_result$jscomp$286 = false;
        isInputEventSupported = JSCompiler_inline_result$jscomp$286 && (!document.documentMode || 9 < document.documentMode);
      }
      var JSCompiler_inline_result$jscomp$286;
      var isSupported$jscomp$inline_427;
      var element$jscomp$inline_428;
      function stopWatchingForValueChange() {
        activeElement$1 && (activeElement$1.detachEvent("onpropertychange", handlePropertyChange), activeElementInst$1 = activeElement$1 = null);
      }
      function handlePropertyChange(nativeEvent) {
        if ("value" === nativeEvent.propertyName && getInstIfValueChanged(activeElementInst$1)) {
          var dispatchQueue = [];
          createAndAccumulateChangeEvent(
            dispatchQueue,
            activeElementInst$1,
            nativeEvent,
            getEventTarget(nativeEvent)
          );
          batchedUpdates$1(runEventInBatch, dispatchQueue);
        }
      }
      function handleEventsForInputEventPolyfill(domEventName, target, targetInst) {
        "focusin" === domEventName ? (stopWatchingForValueChange(), activeElement$1 = target, activeElementInst$1 = targetInst, activeElement$1.attachEvent("onpropertychange", handlePropertyChange)) : "focusout" === domEventName && stopWatchingForValueChange();
      }
      function getTargetInstForInputEventPolyfill(domEventName) {
        if ("selectionchange" === domEventName || "keyup" === domEventName || "keydown" === domEventName)
          return getInstIfValueChanged(activeElementInst$1);
      }
      function getTargetInstForClickEvent(domEventName, targetInst) {
        if ("click" === domEventName)
          return getInstIfValueChanged(targetInst);
      }
      function getTargetInstForInputOrChangeEvent(domEventName, targetInst) {
        if ("input" === domEventName || "change" === domEventName)
          return getInstIfValueChanged(targetInst);
      }
      function is(x, y) {
        return x === y && (0 !== x || 1 / x === 1 / y) || x !== x && y !== y;
      }
      var objectIs = "function" === typeof Object.is ? Object.is : is;
      function shallowEqual(objA, objB) {
        if (objectIs(objA, objB))
          return true;
        if ("object" !== typeof objA || null === objA || "object" !== typeof objB || null === objB)
          return false;
        var keysA = Object.keys(objA), keysB = Object.keys(objB);
        if (keysA.length !== keysB.length)
          return false;
        for (keysB = 0; keysB < keysA.length; keysB++) {
          var currentKey = keysA[keysB];
          if (!hasOwnProperty.call(objB, currentKey) || !objectIs(objA[currentKey], objB[currentKey]))
            return false;
        }
        return true;
      }
      function getLeafNode(node) {
        for (; node && node.firstChild; )
          node = node.firstChild;
        return node;
      }
      function getNodeForCharacterOffset(root3, offset) {
        var node = getLeafNode(root3);
        root3 = 0;
        for (var nodeEnd; node; ) {
          if (3 === node.nodeType) {
            nodeEnd = root3 + node.textContent.length;
            if (root3 <= offset && nodeEnd >= offset)
              return { node, offset: offset - root3 };
            root3 = nodeEnd;
          }
          a: {
            for (; node; ) {
              if (node.nextSibling) {
                node = node.nextSibling;
                break a;
              }
              node = node.parentNode;
            }
            node = void 0;
          }
          node = getLeafNode(node);
        }
      }
      function containsNode(outerNode, innerNode) {
        return outerNode && innerNode ? outerNode === innerNode ? true : outerNode && 3 === outerNode.nodeType ? false : innerNode && 3 === innerNode.nodeType ? containsNode(outerNode, innerNode.parentNode) : "contains" in outerNode ? outerNode.contains(innerNode) : outerNode.compareDocumentPosition ? !!(outerNode.compareDocumentPosition(innerNode) & 16) : false : false;
      }
      function getActiveElementDeep(containerInfo) {
        containerInfo = null != containerInfo && null != containerInfo.ownerDocument && null != containerInfo.ownerDocument.defaultView ? containerInfo.ownerDocument.defaultView : window;
        for (var element = getActiveElement(containerInfo.document); element instanceof containerInfo.HTMLIFrameElement; ) {
          try {
            var JSCompiler_inline_result = "string" === typeof element.contentWindow.location.href;
          } catch (err) {
            JSCompiler_inline_result = false;
          }
          if (JSCompiler_inline_result)
            containerInfo = element.contentWindow;
          else
            break;
          element = getActiveElement(containerInfo.document);
        }
        return element;
      }
      function hasSelectionCapabilities(elem) {
        var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();
        return nodeName && ("input" === nodeName && ("text" === elem.type || "search" === elem.type || "tel" === elem.type || "url" === elem.type || "password" === elem.type) || "textarea" === nodeName || "true" === elem.contentEditable);
      }
      var skipSelectionChangeEvent = canUseDOM && "documentMode" in document && 11 >= document.documentMode;
      var activeElement = null;
      var activeElementInst = null;
      var lastSelection = null;
      var mouseDown = false;
      function constructSelectEvent(dispatchQueue, nativeEvent, nativeEventTarget) {
        var doc = nativeEventTarget.window === nativeEventTarget ? nativeEventTarget.document : 9 === nativeEventTarget.nodeType ? nativeEventTarget : nativeEventTarget.ownerDocument;
        mouseDown || null == activeElement || activeElement !== getActiveElement(doc) || (doc = activeElement, "selectionStart" in doc && hasSelectionCapabilities(doc) ? doc = { start: doc.selectionStart, end: doc.selectionEnd } : (doc = (doc.ownerDocument && doc.ownerDocument.defaultView || window).getSelection(), doc = {
          anchorNode: doc.anchorNode,
          anchorOffset: doc.anchorOffset,
          focusNode: doc.focusNode,
          focusOffset: doc.focusOffset
        }), lastSelection && shallowEqual(lastSelection, doc) || (lastSelection = doc, doc = accumulateTwoPhaseListeners(activeElementInst, "onSelect"), 0 < doc.length && (nativeEvent = new SyntheticEvent(
          "onSelect",
          "select",
          null,
          nativeEvent,
          nativeEventTarget
        ), dispatchQueue.push({ event: nativeEvent, listeners: doc }), nativeEvent.target = activeElement)));
      }
      function makePrefixMap(styleProp, eventName) {
        var prefixes = {};
        prefixes[styleProp.toLowerCase()] = eventName.toLowerCase();
        prefixes["Webkit" + styleProp] = "webkit" + eventName;
        prefixes["Moz" + styleProp] = "moz" + eventName;
        return prefixes;
      }
      var vendorPrefixes = {
        animationend: makePrefixMap("Animation", "AnimationEnd"),
        animationiteration: makePrefixMap("Animation", "AnimationIteration"),
        animationstart: makePrefixMap("Animation", "AnimationStart"),
        transitionrun: makePrefixMap("Transition", "TransitionRun"),
        transitionstart: makePrefixMap("Transition", "TransitionStart"),
        transitioncancel: makePrefixMap("Transition", "TransitionCancel"),
        transitionend: makePrefixMap("Transition", "TransitionEnd")
      };
      var prefixedEventNames = {};
      var style = {};
      canUseDOM && (style = document.createElement("div").style, "AnimationEvent" in window || (delete vendorPrefixes.animationend.animation, delete vendorPrefixes.animationiteration.animation, delete vendorPrefixes.animationstart.animation), "TransitionEvent" in window || delete vendorPrefixes.transitionend.transition);
      function getVendorPrefixedEventName(eventName) {
        if (prefixedEventNames[eventName])
          return prefixedEventNames[eventName];
        if (!vendorPrefixes[eventName])
          return eventName;
        var prefixMap = vendorPrefixes[eventName], styleProp;
        for (styleProp in prefixMap)
          if (prefixMap.hasOwnProperty(styleProp) && styleProp in style)
            return prefixedEventNames[eventName] = prefixMap[styleProp];
        return eventName;
      }
      var ANIMATION_END = getVendorPrefixedEventName("animationend");
      var ANIMATION_ITERATION = getVendorPrefixedEventName("animationiteration");
      var ANIMATION_START = getVendorPrefixedEventName("animationstart");
      var TRANSITION_RUN = getVendorPrefixedEventName("transitionrun");
      var TRANSITION_START = getVendorPrefixedEventName("transitionstart");
      var TRANSITION_CANCEL = getVendorPrefixedEventName("transitioncancel");
      var TRANSITION_END = getVendorPrefixedEventName("transitionend");
      var topLevelEventsToReactNames = /* @__PURE__ */ new Map();
      var simpleEventPluginEvents = "abort auxClick beforeToggle cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(
        " "
      );
      simpleEventPluginEvents.push("scrollEnd");
      function registerSimpleEvent(domEventName, reactName) {
        topLevelEventsToReactNames.set(domEventName, reactName);
        registerTwoPhaseEvent(reactName, [domEventName]);
      }
      var reportGlobalError = "function" === typeof reportError ? reportError : function(error) {
        if ("object" === typeof window && "function" === typeof window.ErrorEvent) {
          var event = new window.ErrorEvent("error", {
            bubbles: true,
            cancelable: true,
            message: "object" === typeof error && null !== error && "string" === typeof error.message ? String(error.message) : String(error),
            error
          });
          if (!window.dispatchEvent(event))
            return;
        } else if ("object" === typeof process && "function" === typeof process.emit) {
          process.emit("uncaughtException", error);
          return;
        }
        console.error(error);
      };
      var concurrentQueues = [];
      var concurrentQueuesIndex = 0;
      var concurrentlyUpdatedLanes = 0;
      function finishQueueingConcurrentUpdates() {
        for (var endIndex = concurrentQueuesIndex, i = concurrentlyUpdatedLanes = concurrentQueuesIndex = 0; i < endIndex; ) {
          var fiber = concurrentQueues[i];
          concurrentQueues[i++] = null;
          var queue = concurrentQueues[i];
          concurrentQueues[i++] = null;
          var update = concurrentQueues[i];
          concurrentQueues[i++] = null;
          var lane = concurrentQueues[i];
          concurrentQueues[i++] = null;
          if (null !== queue && null !== update) {
            var pending = queue.pending;
            null === pending ? update.next = update : (update.next = pending.next, pending.next = update);
            queue.pending = update;
          }
          0 !== lane && markUpdateLaneFromFiberToRoot(fiber, update, lane);
        }
      }
      function enqueueUpdate$1(fiber, queue, update, lane) {
        concurrentQueues[concurrentQueuesIndex++] = fiber;
        concurrentQueues[concurrentQueuesIndex++] = queue;
        concurrentQueues[concurrentQueuesIndex++] = update;
        concurrentQueues[concurrentQueuesIndex++] = lane;
        concurrentlyUpdatedLanes |= lane;
        fiber.lanes |= lane;
        fiber = fiber.alternate;
        null !== fiber && (fiber.lanes |= lane);
      }
      function enqueueConcurrentHookUpdate(fiber, queue, update, lane) {
        enqueueUpdate$1(fiber, queue, update, lane);
        return getRootForUpdatedFiber(fiber);
      }
      function enqueueConcurrentRenderForLane(fiber, lane) {
        enqueueUpdate$1(fiber, null, null, lane);
        return getRootForUpdatedFiber(fiber);
      }
      function markUpdateLaneFromFiberToRoot(sourceFiber, update, lane) {
        sourceFiber.lanes |= lane;
        var alternate = sourceFiber.alternate;
        null !== alternate && (alternate.lanes |= lane);
        for (var isHidden = false, parent = sourceFiber.return; null !== parent; )
          parent.childLanes |= lane, alternate = parent.alternate, null !== alternate && (alternate.childLanes |= lane), 22 === parent.tag && (sourceFiber = parent.stateNode, null === sourceFiber || sourceFiber._visibility & 1 || (isHidden = true)), sourceFiber = parent, parent = parent.return;
        return 3 === sourceFiber.tag ? (parent = sourceFiber.stateNode, isHidden && null !== update && (isHidden = 31 - clz32(lane), sourceFiber = parent.hiddenUpdates, alternate = sourceFiber[isHidden], null === alternate ? sourceFiber[isHidden] = [update] : alternate.push(update), update.lane = lane | 536870912), parent) : null;
      }
      function getRootForUpdatedFiber(sourceFiber) {
        if (50 < nestedUpdateCount)
          throw nestedUpdateCount = 0, rootWithNestedUpdates = null, Error(formatProdErrorMessage(185));
        for (var parent = sourceFiber.return; null !== parent; )
          sourceFiber = parent, parent = sourceFiber.return;
        return 3 === sourceFiber.tag ? sourceFiber.stateNode : null;
      }
      var emptyContextObject = {};
      function FiberNode(tag, pendingProps, key, mode) {
        this.tag = tag;
        this.key = key;
        this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null;
        this.index = 0;
        this.refCleanup = this.ref = null;
        this.pendingProps = pendingProps;
        this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null;
        this.mode = mode;
        this.subtreeFlags = this.flags = 0;
        this.deletions = null;
        this.childLanes = this.lanes = 0;
        this.alternate = null;
      }
      function createFiberImplClass(tag, pendingProps, key, mode) {
        return new FiberNode(tag, pendingProps, key, mode);
      }
      function shouldConstruct(Component) {
        Component = Component.prototype;
        return !(!Component || !Component.isReactComponent);
      }
      function createWorkInProgress(current, pendingProps) {
        var workInProgress2 = current.alternate;
        null === workInProgress2 ? (workInProgress2 = createFiberImplClass(
          current.tag,
          pendingProps,
          current.key,
          current.mode
        ), workInProgress2.elementType = current.elementType, workInProgress2.type = current.type, workInProgress2.stateNode = current.stateNode, workInProgress2.alternate = current, current.alternate = workInProgress2) : (workInProgress2.pendingProps = pendingProps, workInProgress2.type = current.type, workInProgress2.flags = 0, workInProgress2.subtreeFlags = 0, workInProgress2.deletions = null);
        workInProgress2.flags = current.flags & 65011712;
        workInProgress2.childLanes = current.childLanes;
        workInProgress2.lanes = current.lanes;
        workInProgress2.child = current.child;
        workInProgress2.memoizedProps = current.memoizedProps;
        workInProgress2.memoizedState = current.memoizedState;
        workInProgress2.updateQueue = current.updateQueue;
        pendingProps = current.dependencies;
        workInProgress2.dependencies = null === pendingProps ? null : { lanes: pendingProps.lanes, firstContext: pendingProps.firstContext };
        workInProgress2.sibling = current.sibling;
        workInProgress2.index = current.index;
        workInProgress2.ref = current.ref;
        workInProgress2.refCleanup = current.refCleanup;
        return workInProgress2;
      }
      function resetWorkInProgress(workInProgress2, renderLanes2) {
        workInProgress2.flags &= 65011714;
        var current = workInProgress2.alternate;
        null === current ? (workInProgress2.childLanes = 0, workInProgress2.lanes = renderLanes2, workInProgress2.child = null, workInProgress2.subtreeFlags = 0, workInProgress2.memoizedProps = null, workInProgress2.memoizedState = null, workInProgress2.updateQueue = null, workInProgress2.dependencies = null, workInProgress2.stateNode = null) : (workInProgress2.childLanes = current.childLanes, workInProgress2.lanes = current.lanes, workInProgress2.child = current.child, workInProgress2.subtreeFlags = 0, workInProgress2.deletions = null, workInProgress2.memoizedProps = current.memoizedProps, workInProgress2.memoizedState = current.memoizedState, workInProgress2.updateQueue = current.updateQueue, workInProgress2.type = current.type, renderLanes2 = current.dependencies, workInProgress2.dependencies = null === renderLanes2 ? null : {
          lanes: renderLanes2.lanes,
          firstContext: renderLanes2.firstContext
        });
        return workInProgress2;
      }
      function createFiberFromTypeAndProps(type, key, pendingProps, owner, mode, lanes) {
        var fiberTag = 0;
        owner = type;
        if ("function" === typeof type)
          shouldConstruct(type) && (fiberTag = 1);
        else if ("string" === typeof type)
          fiberTag = isHostHoistableType(
            type,
            pendingProps,
            contextStackCursor.current
          ) ? 26 : "html" === type || "head" === type || "body" === type ? 27 : 5;
        else
          a:
            switch (type) {
              case REACT_ACTIVITY_TYPE:
                return type = createFiberImplClass(31, pendingProps, key, mode), type.elementType = REACT_ACTIVITY_TYPE, type.lanes = lanes, type;
              case REACT_FRAGMENT_TYPE:
                return createFiberFromFragment(pendingProps.children, mode, lanes, key);
              case REACT_STRICT_MODE_TYPE:
                fiberTag = 8;
                mode |= 24;
                break;
              case REACT_PROFILER_TYPE:
                return type = createFiberImplClass(12, pendingProps, key, mode | 2), type.elementType = REACT_PROFILER_TYPE, type.lanes = lanes, type;
              case REACT_SUSPENSE_TYPE:
                return type = createFiberImplClass(13, pendingProps, key, mode), type.elementType = REACT_SUSPENSE_TYPE, type.lanes = lanes, type;
              case REACT_SUSPENSE_LIST_TYPE:
                return type = createFiberImplClass(19, pendingProps, key, mode), type.elementType = REACT_SUSPENSE_LIST_TYPE, type.lanes = lanes, type;
              default:
                if ("object" === typeof type && null !== type)
                  switch (type.$$typeof) {
                    case REACT_CONTEXT_TYPE:
                      fiberTag = 10;
                      break a;
                    case REACT_CONSUMER_TYPE:
                      fiberTag = 9;
                      break a;
                    case REACT_FORWARD_REF_TYPE:
                      fiberTag = 11;
                      break a;
                    case REACT_MEMO_TYPE:
                      fiberTag = 14;
                      break a;
                    case REACT_LAZY_TYPE:
                      fiberTag = 16;
                      owner = null;
                      break a;
                  }
                fiberTag = 29;
                pendingProps = Error(
                  formatProdErrorMessage(130, null === type ? "null" : typeof type, "")
                );
                owner = null;
            }
        key = createFiberImplClass(fiberTag, pendingProps, key, mode);
        key.elementType = type;
        key.type = owner;
        key.lanes = lanes;
        return key;
      }
      function createFiberFromFragment(elements, mode, lanes, key) {
        elements = createFiberImplClass(7, elements, key, mode);
        elements.lanes = lanes;
        return elements;
      }
      function createFiberFromText(content, mode, lanes) {
        content = createFiberImplClass(6, content, null, mode);
        content.lanes = lanes;
        return content;
      }
      function createFiberFromDehydratedFragment(dehydratedNode) {
        var fiber = createFiberImplClass(18, null, null, 0);
        fiber.stateNode = dehydratedNode;
        return fiber;
      }
      function createFiberFromPortal(portal, mode, lanes) {
        mode = createFiberImplClass(
          4,
          null !== portal.children ? portal.children : [],
          portal.key,
          mode
        );
        mode.lanes = lanes;
        mode.stateNode = {
          containerInfo: portal.containerInfo,
          pendingChildren: null,
          implementation: portal.implementation
        };
        return mode;
      }
      var CapturedStacks = /* @__PURE__ */ new WeakMap();
      function createCapturedValueAtFiber(value, source) {
        if ("object" === typeof value && null !== value) {
          var existing = CapturedStacks.get(value);
          if (void 0 !== existing)
            return existing;
          source = {
            value,
            source,
            stack: getStackByFiberInDevAndProd(source)
          };
          CapturedStacks.set(value, source);
          return source;
        }
        return {
          value,
          source,
          stack: getStackByFiberInDevAndProd(source)
        };
      }
      var forkStack = [];
      var forkStackIndex = 0;
      var treeForkProvider = null;
      var treeForkCount = 0;
      var idStack = [];
      var idStackIndex = 0;
      var treeContextProvider = null;
      var treeContextId = 1;
      var treeContextOverflow = "";
      function pushTreeFork(workInProgress2, totalChildren) {
        forkStack[forkStackIndex++] = treeForkCount;
        forkStack[forkStackIndex++] = treeForkProvider;
        treeForkProvider = workInProgress2;
        treeForkCount = totalChildren;
      }
      function pushTreeId(workInProgress2, totalChildren, index2) {
        idStack[idStackIndex++] = treeContextId;
        idStack[idStackIndex++] = treeContextOverflow;
        idStack[idStackIndex++] = treeContextProvider;
        treeContextProvider = workInProgress2;
        var baseIdWithLeadingBit = treeContextId;
        workInProgress2 = treeContextOverflow;
        var baseLength = 32 - clz32(baseIdWithLeadingBit) - 1;
        baseIdWithLeadingBit &= ~(1 << baseLength);
        index2 += 1;
        var length = 32 - clz32(totalChildren) + baseLength;
        if (30 < length) {
          var numberOfOverflowBits = baseLength - baseLength % 5;
          length = (baseIdWithLeadingBit & (1 << numberOfOverflowBits) - 1).toString(32);
          baseIdWithLeadingBit >>= numberOfOverflowBits;
          baseLength -= numberOfOverflowBits;
          treeContextId = 1 << 32 - clz32(totalChildren) + baseLength | index2 << baseLength | baseIdWithLeadingBit;
          treeContextOverflow = length + workInProgress2;
        } else
          treeContextId = 1 << length | index2 << baseLength | baseIdWithLeadingBit, treeContextOverflow = workInProgress2;
      }
      function pushMaterializedTreeId(workInProgress2) {
        null !== workInProgress2.return && (pushTreeFork(workInProgress2, 1), pushTreeId(workInProgress2, 1, 0));
      }
      function popTreeContext(workInProgress2) {
        for (; workInProgress2 === treeForkProvider; )
          treeForkProvider = forkStack[--forkStackIndex], forkStack[forkStackIndex] = null, treeForkCount = forkStack[--forkStackIndex], forkStack[forkStackIndex] = null;
        for (; workInProgress2 === treeContextProvider; )
          treeContextProvider = idStack[--idStackIndex], idStack[idStackIndex] = null, treeContextOverflow = idStack[--idStackIndex], idStack[idStackIndex] = null, treeContextId = idStack[--idStackIndex], idStack[idStackIndex] = null;
      }
      function restoreSuspendedTreeContext(workInProgress2, suspendedContext) {
        idStack[idStackIndex++] = treeContextId;
        idStack[idStackIndex++] = treeContextOverflow;
        idStack[idStackIndex++] = treeContextProvider;
        treeContextId = suspendedContext.id;
        treeContextOverflow = suspendedContext.overflow;
        treeContextProvider = workInProgress2;
      }
      var hydrationParentFiber = null;
      var nextHydratableInstance = null;
      var isHydrating = false;
      var hydrationErrors = null;
      var rootOrSingletonContext = false;
      var HydrationMismatchException = Error(formatProdErrorMessage(519));
      function throwOnHydrationMismatch(fiber) {
        var error = Error(
          formatProdErrorMessage(
            418,
            1 < arguments.length && void 0 !== arguments[1] && arguments[1] ? "text" : "HTML",
            ""
          )
        );
        queueHydrationError(createCapturedValueAtFiber(error, fiber));
        throw HydrationMismatchException;
      }
      function prepareToHydrateHostInstance(fiber) {
        var instance = fiber.stateNode, type = fiber.type, props = fiber.memoizedProps;
        instance[internalInstanceKey] = fiber;
        instance[internalPropsKey] = props;
        switch (type) {
          case "dialog":
            listenToNonDelegatedEvent("cancel", instance);
            listenToNonDelegatedEvent("close", instance);
            break;
          case "iframe":
          case "object":
          case "embed":
            listenToNonDelegatedEvent("load", instance);
            break;
          case "video":
          case "audio":
            for (type = 0; type < mediaEventTypes.length; type++)
              listenToNonDelegatedEvent(mediaEventTypes[type], instance);
            break;
          case "source":
            listenToNonDelegatedEvent("error", instance);
            break;
          case "img":
          case "image":
          case "link":
            listenToNonDelegatedEvent("error", instance);
            listenToNonDelegatedEvent("load", instance);
            break;
          case "details":
            listenToNonDelegatedEvent("toggle", instance);
            break;
          case "input":
            listenToNonDelegatedEvent("invalid", instance);
            initInput(
              instance,
              props.value,
              props.defaultValue,
              props.checked,
              props.defaultChecked,
              props.type,
              props.name,
              true
            );
            break;
          case "select":
            listenToNonDelegatedEvent("invalid", instance);
            break;
          case "textarea":
            listenToNonDelegatedEvent("invalid", instance), initTextarea(instance, props.value, props.defaultValue, props.children);
        }
        type = props.children;
        "string" !== typeof type && "number" !== typeof type && "bigint" !== typeof type || instance.textContent === "" + type || true === props.suppressHydrationWarning || checkForUnmatchedText(instance.textContent, type) ? (null != props.popover && (listenToNonDelegatedEvent("beforetoggle", instance), listenToNonDelegatedEvent("toggle", instance)), null != props.onScroll && listenToNonDelegatedEvent("scroll", instance), null != props.onScrollEnd && listenToNonDelegatedEvent("scrollend", instance), null != props.onClick && (instance.onclick = noop$1), instance = true) : instance = false;
        instance || throwOnHydrationMismatch(fiber, true);
      }
      function popToNextHostParent(fiber) {
        for (hydrationParentFiber = fiber.return; hydrationParentFiber; )
          switch (hydrationParentFiber.tag) {
            case 5:
            case 31:
            case 13:
              rootOrSingletonContext = false;
              return;
            case 27:
            case 3:
              rootOrSingletonContext = true;
              return;
            default:
              hydrationParentFiber = hydrationParentFiber.return;
          }
      }
      function popHydrationState(fiber) {
        if (fiber !== hydrationParentFiber)
          return false;
        if (!isHydrating)
          return popToNextHostParent(fiber), isHydrating = true, false;
        var tag = fiber.tag, JSCompiler_temp;
        if (JSCompiler_temp = 3 !== tag && 27 !== tag) {
          if (JSCompiler_temp = 5 === tag)
            JSCompiler_temp = fiber.type, JSCompiler_temp = !("form" !== JSCompiler_temp && "button" !== JSCompiler_temp) || shouldSetTextContent(fiber.type, fiber.memoizedProps);
          JSCompiler_temp = !JSCompiler_temp;
        }
        JSCompiler_temp && nextHydratableInstance && throwOnHydrationMismatch(fiber);
        popToNextHostParent(fiber);
        if (13 === tag) {
          fiber = fiber.memoizedState;
          fiber = null !== fiber ? fiber.dehydrated : null;
          if (!fiber)
            throw Error(formatProdErrorMessage(317));
          nextHydratableInstance = getNextHydratableInstanceAfterHydrationBoundary(fiber);
        } else if (31 === tag) {
          fiber = fiber.memoizedState;
          fiber = null !== fiber ? fiber.dehydrated : null;
          if (!fiber)
            throw Error(formatProdErrorMessage(317));
          nextHydratableInstance = getNextHydratableInstanceAfterHydrationBoundary(fiber);
        } else
          27 === tag ? (tag = nextHydratableInstance, isSingletonScope(fiber.type) ? (fiber = previousHydratableOnEnteringScopedSingleton, previousHydratableOnEnteringScopedSingleton = null, nextHydratableInstance = fiber) : nextHydratableInstance = tag) : nextHydratableInstance = hydrationParentFiber ? getNextHydratable(fiber.stateNode.nextSibling) : null;
        return true;
      }
      function resetHydrationState() {
        nextHydratableInstance = hydrationParentFiber = null;
        isHydrating = false;
      }
      function upgradeHydrationErrorsToRecoverable() {
        var queuedErrors = hydrationErrors;
        null !== queuedErrors && (null === workInProgressRootRecoverableErrors ? workInProgressRootRecoverableErrors = queuedErrors : workInProgressRootRecoverableErrors.push.apply(
          workInProgressRootRecoverableErrors,
          queuedErrors
        ), hydrationErrors = null);
        return queuedErrors;
      }
      function queueHydrationError(error) {
        null === hydrationErrors ? hydrationErrors = [error] : hydrationErrors.push(error);
      }
      var valueCursor = createCursor(null);
      var currentlyRenderingFiber$1 = null;
      var lastContextDependency = null;
      function pushProvider(providerFiber, context, nextValue) {
        push(valueCursor, context._currentValue);
        context._currentValue = nextValue;
      }
      function popProvider(context) {
        context._currentValue = valueCursor.current;
        pop(valueCursor);
      }
      function scheduleContextWorkOnParentPath(parent, renderLanes2, propagationRoot) {
        for (; null !== parent; ) {
          var alternate = parent.alternate;
          (parent.childLanes & renderLanes2) !== renderLanes2 ? (parent.childLanes |= renderLanes2, null !== alternate && (alternate.childLanes |= renderLanes2)) : null !== alternate && (alternate.childLanes & renderLanes2) !== renderLanes2 && (alternate.childLanes |= renderLanes2);
          if (parent === propagationRoot)
            break;
          parent = parent.return;
        }
      }
      function propagateContextChanges(workInProgress2, contexts, renderLanes2, forcePropagateEntireTree) {
        var fiber = workInProgress2.child;
        null !== fiber && (fiber.return = workInProgress2);
        for (; null !== fiber; ) {
          var list = fiber.dependencies;
          if (null !== list) {
            var nextFiber = fiber.child;
            list = list.firstContext;
            a:
              for (; null !== list; ) {
                var dependency = list;
                list = fiber;
                for (var i = 0; i < contexts.length; i++)
                  if (dependency.context === contexts[i]) {
                    list.lanes |= renderLanes2;
                    dependency = list.alternate;
                    null !== dependency && (dependency.lanes |= renderLanes2);
                    scheduleContextWorkOnParentPath(
                      list.return,
                      renderLanes2,
                      workInProgress2
                    );
                    forcePropagateEntireTree || (nextFiber = null);
                    break a;
                  }
                list = dependency.next;
              }
          } else if (18 === fiber.tag) {
            nextFiber = fiber.return;
            if (null === nextFiber)
              throw Error(formatProdErrorMessage(341));
            nextFiber.lanes |= renderLanes2;
            list = nextFiber.alternate;
            null !== list && (list.lanes |= renderLanes2);
            scheduleContextWorkOnParentPath(nextFiber, renderLanes2, workInProgress2);
            nextFiber = null;
          } else
            nextFiber = fiber.child;
          if (null !== nextFiber)
            nextFiber.return = fiber;
          else
            for (nextFiber = fiber; null !== nextFiber; ) {
              if (nextFiber === workInProgress2) {
                nextFiber = null;
                break;
              }
              fiber = nextFiber.sibling;
              if (null !== fiber) {
                fiber.return = nextFiber.return;
                nextFiber = fiber;
                break;
              }
              nextFiber = nextFiber.return;
            }
          fiber = nextFiber;
        }
      }
      function propagateParentContextChanges(current, workInProgress2, renderLanes2, forcePropagateEntireTree) {
        current = null;
        for (var parent = workInProgress2, isInsidePropagationBailout = false; null !== parent; ) {
          if (!isInsidePropagationBailout) {
            if (0 !== (parent.flags & 524288))
              isInsidePropagationBailout = true;
            else if (0 !== (parent.flags & 262144))
              break;
          }
          if (10 === parent.tag) {
            var currentParent = parent.alternate;
            if (null === currentParent)
              throw Error(formatProdErrorMessage(387));
            currentParent = currentParent.memoizedProps;
            if (null !== currentParent) {
              var context = parent.type;
              objectIs(parent.pendingProps.value, currentParent.value) || (null !== current ? current.push(context) : current = [context]);
            }
          } else if (parent === hostTransitionProviderCursor.current) {
            currentParent = parent.alternate;
            if (null === currentParent)
              throw Error(formatProdErrorMessage(387));
            currentParent.memoizedState.memoizedState !== parent.memoizedState.memoizedState && (null !== current ? current.push(HostTransitionContext) : current = [HostTransitionContext]);
          }
          parent = parent.return;
        }
        null !== current && propagateContextChanges(
          workInProgress2,
          current,
          renderLanes2,
          forcePropagateEntireTree
        );
        workInProgress2.flags |= 262144;
      }
      function checkIfContextChanged(currentDependencies) {
        for (currentDependencies = currentDependencies.firstContext; null !== currentDependencies; ) {
          if (!objectIs(
            currentDependencies.context._currentValue,
            currentDependencies.memoizedValue
          ))
            return true;
          currentDependencies = currentDependencies.next;
        }
        return false;
      }
      function prepareToReadContext(workInProgress2) {
        currentlyRenderingFiber$1 = workInProgress2;
        lastContextDependency = null;
        workInProgress2 = workInProgress2.dependencies;
        null !== workInProgress2 && (workInProgress2.firstContext = null);
      }
      function readContext(context) {
        return readContextForConsumer(currentlyRenderingFiber$1, context);
      }
      function readContextDuringReconciliation(consumer, context) {
        null === currentlyRenderingFiber$1 && prepareToReadContext(consumer);
        return readContextForConsumer(consumer, context);
      }
      function readContextForConsumer(consumer, context) {
        var value = context._currentValue;
        context = { context, memoizedValue: value, next: null };
        if (null === lastContextDependency) {
          if (null === consumer)
            throw Error(formatProdErrorMessage(308));
          lastContextDependency = context;
          consumer.dependencies = { lanes: 0, firstContext: context };
          consumer.flags |= 524288;
        } else
          lastContextDependency = lastContextDependency.next = context;
        return value;
      }
      var AbortControllerLocal = "undefined" !== typeof AbortController ? AbortController : function() {
        var listeners = [], signal = this.signal = {
          aborted: false,
          addEventListener: function(type, listener) {
            listeners.push(listener);
          }
        };
        this.abort = function() {
          signal.aborted = true;
          listeners.forEach(function(listener) {
            return listener();
          });
        };
      };
      var scheduleCallback$2 = Scheduler.unstable_scheduleCallback;
      var NormalPriority = Scheduler.unstable_NormalPriority;
      var CacheContext = {
        $$typeof: REACT_CONTEXT_TYPE,
        Consumer: null,
        Provider: null,
        _currentValue: null,
        _currentValue2: null,
        _threadCount: 0
      };
      function createCache() {
        return {
          controller: new AbortControllerLocal(),
          data: /* @__PURE__ */ new Map(),
          refCount: 0
        };
      }
      function releaseCache(cache) {
        cache.refCount--;
        0 === cache.refCount && scheduleCallback$2(NormalPriority, function() {
          cache.controller.abort();
        });
      }
      var currentEntangledListeners = null;
      var currentEntangledPendingCount = 0;
      var currentEntangledLane = 0;
      var currentEntangledActionThenable = null;
      function entangleAsyncAction(transition, thenable) {
        if (null === currentEntangledListeners) {
          var entangledListeners = currentEntangledListeners = [];
          currentEntangledPendingCount = 0;
          currentEntangledLane = requestTransitionLane();
          currentEntangledActionThenable = {
            status: "pending",
            value: void 0,
            then: function(resolve) {
              entangledListeners.push(resolve);
            }
          };
        }
        currentEntangledPendingCount++;
        thenable.then(pingEngtangledActionScope, pingEngtangledActionScope);
        return thenable;
      }
      function pingEngtangledActionScope() {
        if (0 === --currentEntangledPendingCount && null !== currentEntangledListeners) {
          null !== currentEntangledActionThenable && (currentEntangledActionThenable.status = "fulfilled");
          var listeners = currentEntangledListeners;
          currentEntangledListeners = null;
          currentEntangledLane = 0;
          currentEntangledActionThenable = null;
          for (var i = 0; i < listeners.length; i++)
            (0, listeners[i])();
        }
      }
      function chainThenableValue(thenable, result) {
        var listeners = [], thenableWithOverride = {
          status: "pending",
          value: null,
          reason: null,
          then: function(resolve) {
            listeners.push(resolve);
          }
        };
        thenable.then(
          function() {
            thenableWithOverride.status = "fulfilled";
            thenableWithOverride.value = result;
            for (var i = 0; i < listeners.length; i++)
              (0, listeners[i])(result);
          },
          function(error) {
            thenableWithOverride.status = "rejected";
            thenableWithOverride.reason = error;
            for (error = 0; error < listeners.length; error++)
              (0, listeners[error])(void 0);
          }
        );
        return thenableWithOverride;
      }
      var prevOnStartTransitionFinish = ReactSharedInternals.S;
      ReactSharedInternals.S = function(transition, returnValue) {
        globalMostRecentTransitionTime = now();
        "object" === typeof returnValue && null !== returnValue && "function" === typeof returnValue.then && entangleAsyncAction(transition, returnValue);
        null !== prevOnStartTransitionFinish && prevOnStartTransitionFinish(transition, returnValue);
      };
      var resumedCache = createCursor(null);
      function peekCacheFromPool() {
        var cacheResumedFromPreviousRender = resumedCache.current;
        return null !== cacheResumedFromPreviousRender ? cacheResumedFromPreviousRender : workInProgressRoot.pooledCache;
      }
      function pushTransition(offscreenWorkInProgress, prevCachePool) {
        null === prevCachePool ? push(resumedCache, resumedCache.current) : push(resumedCache, prevCachePool.pool);
      }
      function getSuspendedCache() {
        var cacheFromPool = peekCacheFromPool();
        return null === cacheFromPool ? null : { parent: CacheContext._currentValue, pool: cacheFromPool };
      }
      var SuspenseException = Error(formatProdErrorMessage(460));
      var SuspenseyCommitException = Error(formatProdErrorMessage(474));
      var SuspenseActionException = Error(formatProdErrorMessage(542));
      var noopSuspenseyCommitThenable = { then: function() {
      } };
      function isThenableResolved(thenable) {
        thenable = thenable.status;
        return "fulfilled" === thenable || "rejected" === thenable;
      }
      function trackUsedThenable(thenableState2, thenable, index2) {
        index2 = thenableState2[index2];
        void 0 === index2 ? thenableState2.push(thenable) : index2 !== thenable && (thenable.then(noop$1, noop$1), thenable = index2);
        switch (thenable.status) {
          case "fulfilled":
            return thenable.value;
          case "rejected":
            throw thenableState2 = thenable.reason, checkIfUseWrappedInAsyncCatch(thenableState2), thenableState2;
          default:
            if ("string" === typeof thenable.status)
              thenable.then(noop$1, noop$1);
            else {
              thenableState2 = workInProgressRoot;
              if (null !== thenableState2 && 100 < thenableState2.shellSuspendCounter)
                throw Error(formatProdErrorMessage(482));
              thenableState2 = thenable;
              thenableState2.status = "pending";
              thenableState2.then(
                function(fulfilledValue) {
                  if ("pending" === thenable.status) {
                    var fulfilledThenable = thenable;
                    fulfilledThenable.status = "fulfilled";
                    fulfilledThenable.value = fulfilledValue;
                  }
                },
                function(error) {
                  if ("pending" === thenable.status) {
                    var rejectedThenable = thenable;
                    rejectedThenable.status = "rejected";
                    rejectedThenable.reason = error;
                  }
                }
              );
            }
            switch (thenable.status) {
              case "fulfilled":
                return thenable.value;
              case "rejected":
                throw thenableState2 = thenable.reason, checkIfUseWrappedInAsyncCatch(thenableState2), thenableState2;
            }
            suspendedThenable = thenable;
            throw SuspenseException;
        }
      }
      function resolveLazy(lazyType) {
        try {
          var init = lazyType._init;
          return init(lazyType._payload);
        } catch (x) {
          if (null !== x && "object" === typeof x && "function" === typeof x.then)
            throw suspendedThenable = x, SuspenseException;
          throw x;
        }
      }
      var suspendedThenable = null;
      function getSuspendedThenable() {
        if (null === suspendedThenable)
          throw Error(formatProdErrorMessage(459));
        var thenable = suspendedThenable;
        suspendedThenable = null;
        return thenable;
      }
      function checkIfUseWrappedInAsyncCatch(rejectedReason) {
        if (rejectedReason === SuspenseException || rejectedReason === SuspenseActionException)
          throw Error(formatProdErrorMessage(483));
      }
      var thenableState$1 = null;
      var thenableIndexCounter$1 = 0;
      function unwrapThenable(thenable) {
        var index2 = thenableIndexCounter$1;
        thenableIndexCounter$1 += 1;
        null === thenableState$1 && (thenableState$1 = []);
        return trackUsedThenable(thenableState$1, thenable, index2);
      }
      function coerceRef(workInProgress2, element) {
        element = element.props.ref;
        workInProgress2.ref = void 0 !== element ? element : null;
      }
      function throwOnInvalidObjectTypeImpl(returnFiber, newChild) {
        if (newChild.$$typeof === REACT_LEGACY_ELEMENT_TYPE)
          throw Error(formatProdErrorMessage(525));
        returnFiber = Object.prototype.toString.call(newChild);
        throw Error(
          formatProdErrorMessage(
            31,
            "[object Object]" === returnFiber ? "object with keys {" + Object.keys(newChild).join(", ") + "}" : returnFiber
          )
        );
      }
      function createChildReconciler(shouldTrackSideEffects) {
        function deleteChild(returnFiber, childToDelete) {
          if (shouldTrackSideEffects) {
            var deletions = returnFiber.deletions;
            null === deletions ? (returnFiber.deletions = [childToDelete], returnFiber.flags |= 16) : deletions.push(childToDelete);
          }
        }
        function deleteRemainingChildren(returnFiber, currentFirstChild) {
          if (!shouldTrackSideEffects)
            return null;
          for (; null !== currentFirstChild; )
            deleteChild(returnFiber, currentFirstChild), currentFirstChild = currentFirstChild.sibling;
          return null;
        }
        function mapRemainingChildren(currentFirstChild) {
          for (var existingChildren = /* @__PURE__ */ new Map(); null !== currentFirstChild; )
            null !== currentFirstChild.key ? existingChildren.set(currentFirstChild.key, currentFirstChild) : existingChildren.set(currentFirstChild.index, currentFirstChild), currentFirstChild = currentFirstChild.sibling;
          return existingChildren;
        }
        function useFiber(fiber, pendingProps) {
          fiber = createWorkInProgress(fiber, pendingProps);
          fiber.index = 0;
          fiber.sibling = null;
          return fiber;
        }
        function placeChild(newFiber, lastPlacedIndex, newIndex) {
          newFiber.index = newIndex;
          if (!shouldTrackSideEffects)
            return newFiber.flags |= 1048576, lastPlacedIndex;
          newIndex = newFiber.alternate;
          if (null !== newIndex)
            return newIndex = newIndex.index, newIndex < lastPlacedIndex ? (newFiber.flags |= 67108866, lastPlacedIndex) : newIndex;
          newFiber.flags |= 67108866;
          return lastPlacedIndex;
        }
        function placeSingleChild(newFiber) {
          shouldTrackSideEffects && null === newFiber.alternate && (newFiber.flags |= 67108866);
          return newFiber;
        }
        function updateTextNode(returnFiber, current, textContent, lanes) {
          if (null === current || 6 !== current.tag)
            return current = createFiberFromText(textContent, returnFiber.mode, lanes), current.return = returnFiber, current;
          current = useFiber(current, textContent);
          current.return = returnFiber;
          return current;
        }
        function updateElement(returnFiber, current, element, lanes) {
          var elementType = element.type;
          if (elementType === REACT_FRAGMENT_TYPE)
            return updateFragment(
              returnFiber,
              current,
              element.props.children,
              lanes,
              element.key
            );
          if (null !== current && (current.elementType === elementType || "object" === typeof elementType && null !== elementType && elementType.$$typeof === REACT_LAZY_TYPE && resolveLazy(elementType) === current.type))
            return current = useFiber(current, element.props), coerceRef(current, element), current.return = returnFiber, current;
          current = createFiberFromTypeAndProps(
            element.type,
            element.key,
            element.props,
            null,
            returnFiber.mode,
            lanes
          );
          coerceRef(current, element);
          current.return = returnFiber;
          return current;
        }
        function updatePortal(returnFiber, current, portal, lanes) {
          if (null === current || 4 !== current.tag || current.stateNode.containerInfo !== portal.containerInfo || current.stateNode.implementation !== portal.implementation)
            return current = createFiberFromPortal(portal, returnFiber.mode, lanes), current.return = returnFiber, current;
          current = useFiber(current, portal.children || []);
          current.return = returnFiber;
          return current;
        }
        function updateFragment(returnFiber, current, fragment, lanes, key) {
          if (null === current || 7 !== current.tag)
            return current = createFiberFromFragment(
              fragment,
              returnFiber.mode,
              lanes,
              key
            ), current.return = returnFiber, current;
          current = useFiber(current, fragment);
          current.return = returnFiber;
          return current;
        }
        function createChild(returnFiber, newChild, lanes) {
          if ("string" === typeof newChild && "" !== newChild || "number" === typeof newChild || "bigint" === typeof newChild)
            return newChild = createFiberFromText(
              "" + newChild,
              returnFiber.mode,
              lanes
            ), newChild.return = returnFiber, newChild;
          if ("object" === typeof newChild && null !== newChild) {
            switch (newChild.$$typeof) {
              case REACT_ELEMENT_TYPE:
                return lanes = createFiberFromTypeAndProps(
                  newChild.type,
                  newChild.key,
                  newChild.props,
                  null,
                  returnFiber.mode,
                  lanes
                ), coerceRef(lanes, newChild), lanes.return = returnFiber, lanes;
              case REACT_PORTAL_TYPE:
                return newChild = createFiberFromPortal(
                  newChild,
                  returnFiber.mode,
                  lanes
                ), newChild.return = returnFiber, newChild;
              case REACT_LAZY_TYPE:
                return newChild = resolveLazy(newChild), createChild(returnFiber, newChild, lanes);
            }
            if (isArrayImpl(newChild) || getIteratorFn(newChild))
              return newChild = createFiberFromFragment(
                newChild,
                returnFiber.mode,
                lanes,
                null
              ), newChild.return = returnFiber, newChild;
            if ("function" === typeof newChild.then)
              return createChild(returnFiber, unwrapThenable(newChild), lanes);
            if (newChild.$$typeof === REACT_CONTEXT_TYPE)
              return createChild(
                returnFiber,
                readContextDuringReconciliation(returnFiber, newChild),
                lanes
              );
            throwOnInvalidObjectTypeImpl(returnFiber, newChild);
          }
          return null;
        }
        function updateSlot(returnFiber, oldFiber, newChild, lanes) {
          var key = null !== oldFiber ? oldFiber.key : null;
          if ("string" === typeof newChild && "" !== newChild || "number" === typeof newChild || "bigint" === typeof newChild)
            return null !== key ? null : updateTextNode(returnFiber, oldFiber, "" + newChild, lanes);
          if ("object" === typeof newChild && null !== newChild) {
            switch (newChild.$$typeof) {
              case REACT_ELEMENT_TYPE:
                return newChild.key === key ? updateElement(returnFiber, oldFiber, newChild, lanes) : null;
              case REACT_PORTAL_TYPE:
                return newChild.key === key ? updatePortal(returnFiber, oldFiber, newChild, lanes) : null;
              case REACT_LAZY_TYPE:
                return newChild = resolveLazy(newChild), updateSlot(returnFiber, oldFiber, newChild, lanes);
            }
            if (isArrayImpl(newChild) || getIteratorFn(newChild))
              return null !== key ? null : updateFragment(returnFiber, oldFiber, newChild, lanes, null);
            if ("function" === typeof newChild.then)
              return updateSlot(
                returnFiber,
                oldFiber,
                unwrapThenable(newChild),
                lanes
              );
            if (newChild.$$typeof === REACT_CONTEXT_TYPE)
              return updateSlot(
                returnFiber,
                oldFiber,
                readContextDuringReconciliation(returnFiber, newChild),
                lanes
              );
            throwOnInvalidObjectTypeImpl(returnFiber, newChild);
          }
          return null;
        }
        function updateFromMap(existingChildren, returnFiber, newIdx, newChild, lanes) {
          if ("string" === typeof newChild && "" !== newChild || "number" === typeof newChild || "bigint" === typeof newChild)
            return existingChildren = existingChildren.get(newIdx) || null, updateTextNode(returnFiber, existingChildren, "" + newChild, lanes);
          if ("object" === typeof newChild && null !== newChild) {
            switch (newChild.$$typeof) {
              case REACT_ELEMENT_TYPE:
                return existingChildren = existingChildren.get(
                  null === newChild.key ? newIdx : newChild.key
                ) || null, updateElement(returnFiber, existingChildren, newChild, lanes);
              case REACT_PORTAL_TYPE:
                return existingChildren = existingChildren.get(
                  null === newChild.key ? newIdx : newChild.key
                ) || null, updatePortal(returnFiber, existingChildren, newChild, lanes);
              case REACT_LAZY_TYPE:
                return newChild = resolveLazy(newChild), updateFromMap(
                  existingChildren,
                  returnFiber,
                  newIdx,
                  newChild,
                  lanes
                );
            }
            if (isArrayImpl(newChild) || getIteratorFn(newChild))
              return existingChildren = existingChildren.get(newIdx) || null, updateFragment(returnFiber, existingChildren, newChild, lanes, null);
            if ("function" === typeof newChild.then)
              return updateFromMap(
                existingChildren,
                returnFiber,
                newIdx,
                unwrapThenable(newChild),
                lanes
              );
            if (newChild.$$typeof === REACT_CONTEXT_TYPE)
              return updateFromMap(
                existingChildren,
                returnFiber,
                newIdx,
                readContextDuringReconciliation(returnFiber, newChild),
                lanes
              );
            throwOnInvalidObjectTypeImpl(returnFiber, newChild);
          }
          return null;
        }
        function reconcileChildrenArray(returnFiber, currentFirstChild, newChildren, lanes) {
          for (var resultingFirstChild = null, previousNewFiber = null, oldFiber = currentFirstChild, newIdx = currentFirstChild = 0, nextOldFiber = null; null !== oldFiber && newIdx < newChildren.length; newIdx++) {
            oldFiber.index > newIdx ? (nextOldFiber = oldFiber, oldFiber = null) : nextOldFiber = oldFiber.sibling;
            var newFiber = updateSlot(
              returnFiber,
              oldFiber,
              newChildren[newIdx],
              lanes
            );
            if (null === newFiber) {
              null === oldFiber && (oldFiber = nextOldFiber);
              break;
            }
            shouldTrackSideEffects && oldFiber && null === newFiber.alternate && deleteChild(returnFiber, oldFiber);
            currentFirstChild = placeChild(newFiber, currentFirstChild, newIdx);
            null === previousNewFiber ? resultingFirstChild = newFiber : previousNewFiber.sibling = newFiber;
            previousNewFiber = newFiber;
            oldFiber = nextOldFiber;
          }
          if (newIdx === newChildren.length)
            return deleteRemainingChildren(returnFiber, oldFiber), isHydrating && pushTreeFork(returnFiber, newIdx), resultingFirstChild;
          if (null === oldFiber) {
            for (; newIdx < newChildren.length; newIdx++)
              oldFiber = createChild(returnFiber, newChildren[newIdx], lanes), null !== oldFiber && (currentFirstChild = placeChild(
                oldFiber,
                currentFirstChild,
                newIdx
              ), null === previousNewFiber ? resultingFirstChild = oldFiber : previousNewFiber.sibling = oldFiber, previousNewFiber = oldFiber);
            isHydrating && pushTreeFork(returnFiber, newIdx);
            return resultingFirstChild;
          }
          for (oldFiber = mapRemainingChildren(oldFiber); newIdx < newChildren.length; newIdx++)
            nextOldFiber = updateFromMap(
              oldFiber,
              returnFiber,
              newIdx,
              newChildren[newIdx],
              lanes
            ), null !== nextOldFiber && (shouldTrackSideEffects && null !== nextOldFiber.alternate && oldFiber.delete(
              null === nextOldFiber.key ? newIdx : nextOldFiber.key
            ), currentFirstChild = placeChild(
              nextOldFiber,
              currentFirstChild,
              newIdx
            ), null === previousNewFiber ? resultingFirstChild = nextOldFiber : previousNewFiber.sibling = nextOldFiber, previousNewFiber = nextOldFiber);
          shouldTrackSideEffects && oldFiber.forEach(function(child) {
            return deleteChild(returnFiber, child);
          });
          isHydrating && pushTreeFork(returnFiber, newIdx);
          return resultingFirstChild;
        }
        function reconcileChildrenIterator(returnFiber, currentFirstChild, newChildren, lanes) {
          if (null == newChildren)
            throw Error(formatProdErrorMessage(151));
          for (var resultingFirstChild = null, previousNewFiber = null, oldFiber = currentFirstChild, newIdx = currentFirstChild = 0, nextOldFiber = null, step = newChildren.next(); null !== oldFiber && !step.done; newIdx++, step = newChildren.next()) {
            oldFiber.index > newIdx ? (nextOldFiber = oldFiber, oldFiber = null) : nextOldFiber = oldFiber.sibling;
            var newFiber = updateSlot(returnFiber, oldFiber, step.value, lanes);
            if (null === newFiber) {
              null === oldFiber && (oldFiber = nextOldFiber);
              break;
            }
            shouldTrackSideEffects && oldFiber && null === newFiber.alternate && deleteChild(returnFiber, oldFiber);
            currentFirstChild = placeChild(newFiber, currentFirstChild, newIdx);
            null === previousNewFiber ? resultingFirstChild = newFiber : previousNewFiber.sibling = newFiber;
            previousNewFiber = newFiber;
            oldFiber = nextOldFiber;
          }
          if (step.done)
            return deleteRemainingChildren(returnFiber, oldFiber), isHydrating && pushTreeFork(returnFiber, newIdx), resultingFirstChild;
          if (null === oldFiber) {
            for (; !step.done; newIdx++, step = newChildren.next())
              step = createChild(returnFiber, step.value, lanes), null !== step && (currentFirstChild = placeChild(step, currentFirstChild, newIdx), null === previousNewFiber ? resultingFirstChild = step : previousNewFiber.sibling = step, previousNewFiber = step);
            isHydrating && pushTreeFork(returnFiber, newIdx);
            return resultingFirstChild;
          }
          for (oldFiber = mapRemainingChildren(oldFiber); !step.done; newIdx++, step = newChildren.next())
            step = updateFromMap(oldFiber, returnFiber, newIdx, step.value, lanes), null !== step && (shouldTrackSideEffects && null !== step.alternate && oldFiber.delete(null === step.key ? newIdx : step.key), currentFirstChild = placeChild(step, currentFirstChild, newIdx), null === previousNewFiber ? resultingFirstChild = step : previousNewFiber.sibling = step, previousNewFiber = step);
          shouldTrackSideEffects && oldFiber.forEach(function(child) {
            return deleteChild(returnFiber, child);
          });
          isHydrating && pushTreeFork(returnFiber, newIdx);
          return resultingFirstChild;
        }
        function reconcileChildFibersImpl(returnFiber, currentFirstChild, newChild, lanes) {
          "object" === typeof newChild && null !== newChild && newChild.type === REACT_FRAGMENT_TYPE && null === newChild.key && (newChild = newChild.props.children);
          if ("object" === typeof newChild && null !== newChild) {
            switch (newChild.$$typeof) {
              case REACT_ELEMENT_TYPE:
                a: {
                  for (var key = newChild.key; null !== currentFirstChild; ) {
                    if (currentFirstChild.key === key) {
                      key = newChild.type;
                      if (key === REACT_FRAGMENT_TYPE) {
                        if (7 === currentFirstChild.tag) {
                          deleteRemainingChildren(
                            returnFiber,
                            currentFirstChild.sibling
                          );
                          lanes = useFiber(
                            currentFirstChild,
                            newChild.props.children
                          );
                          lanes.return = returnFiber;
                          returnFiber = lanes;
                          break a;
                        }
                      } else if (currentFirstChild.elementType === key || "object" === typeof key && null !== key && key.$$typeof === REACT_LAZY_TYPE && resolveLazy(key) === currentFirstChild.type) {
                        deleteRemainingChildren(
                          returnFiber,
                          currentFirstChild.sibling
                        );
                        lanes = useFiber(currentFirstChild, newChild.props);
                        coerceRef(lanes, newChild);
                        lanes.return = returnFiber;
                        returnFiber = lanes;
                        break a;
                      }
                      deleteRemainingChildren(returnFiber, currentFirstChild);
                      break;
                    } else
                      deleteChild(returnFiber, currentFirstChild);
                    currentFirstChild = currentFirstChild.sibling;
                  }
                  newChild.type === REACT_FRAGMENT_TYPE ? (lanes = createFiberFromFragment(
                    newChild.props.children,
                    returnFiber.mode,
                    lanes,
                    newChild.key
                  ), lanes.return = returnFiber, returnFiber = lanes) : (lanes = createFiberFromTypeAndProps(
                    newChild.type,
                    newChild.key,
                    newChild.props,
                    null,
                    returnFiber.mode,
                    lanes
                  ), coerceRef(lanes, newChild), lanes.return = returnFiber, returnFiber = lanes);
                }
                return placeSingleChild(returnFiber);
              case REACT_PORTAL_TYPE:
                a: {
                  for (key = newChild.key; null !== currentFirstChild; ) {
                    if (currentFirstChild.key === key)
                      if (4 === currentFirstChild.tag && currentFirstChild.stateNode.containerInfo === newChild.containerInfo && currentFirstChild.stateNode.implementation === newChild.implementation) {
                        deleteRemainingChildren(
                          returnFiber,
                          currentFirstChild.sibling
                        );
                        lanes = useFiber(currentFirstChild, newChild.children || []);
                        lanes.return = returnFiber;
                        returnFiber = lanes;
                        break a;
                      } else {
                        deleteRemainingChildren(returnFiber, currentFirstChild);
                        break;
                      }
                    else
                      deleteChild(returnFiber, currentFirstChild);
                    currentFirstChild = currentFirstChild.sibling;
                  }
                  lanes = createFiberFromPortal(newChild, returnFiber.mode, lanes);
                  lanes.return = returnFiber;
                  returnFiber = lanes;
                }
                return placeSingleChild(returnFiber);
              case REACT_LAZY_TYPE:
                return newChild = resolveLazy(newChild), reconcileChildFibersImpl(
                  returnFiber,
                  currentFirstChild,
                  newChild,
                  lanes
                );
            }
            if (isArrayImpl(newChild))
              return reconcileChildrenArray(
                returnFiber,
                currentFirstChild,
                newChild,
                lanes
              );
            if (getIteratorFn(newChild)) {
              key = getIteratorFn(newChild);
              if ("function" !== typeof key)
                throw Error(formatProdErrorMessage(150));
              newChild = key.call(newChild);
              return reconcileChildrenIterator(
                returnFiber,
                currentFirstChild,
                newChild,
                lanes
              );
            }
            if ("function" === typeof newChild.then)
              return reconcileChildFibersImpl(
                returnFiber,
                currentFirstChild,
                unwrapThenable(newChild),
                lanes
              );
            if (newChild.$$typeof === REACT_CONTEXT_TYPE)
              return reconcileChildFibersImpl(
                returnFiber,
                currentFirstChild,
                readContextDuringReconciliation(returnFiber, newChild),
                lanes
              );
            throwOnInvalidObjectTypeImpl(returnFiber, newChild);
          }
          return "string" === typeof newChild && "" !== newChild || "number" === typeof newChild || "bigint" === typeof newChild ? (newChild = "" + newChild, null !== currentFirstChild && 6 === currentFirstChild.tag ? (deleteRemainingChildren(returnFiber, currentFirstChild.sibling), lanes = useFiber(currentFirstChild, newChild), lanes.return = returnFiber, returnFiber = lanes) : (deleteRemainingChildren(returnFiber, currentFirstChild), lanes = createFiberFromText(newChild, returnFiber.mode, lanes), lanes.return = returnFiber, returnFiber = lanes), placeSingleChild(returnFiber)) : deleteRemainingChildren(returnFiber, currentFirstChild);
        }
        return function(returnFiber, currentFirstChild, newChild, lanes) {
          try {
            thenableIndexCounter$1 = 0;
            var firstChildFiber = reconcileChildFibersImpl(
              returnFiber,
              currentFirstChild,
              newChild,
              lanes
            );
            thenableState$1 = null;
            return firstChildFiber;
          } catch (x) {
            if (x === SuspenseException || x === SuspenseActionException)
              throw x;
            var fiber = createFiberImplClass(29, x, null, returnFiber.mode);
            fiber.lanes = lanes;
            fiber.return = returnFiber;
            return fiber;
          } finally {
          }
        };
      }
      var reconcileChildFibers = createChildReconciler(true);
      var mountChildFibers = createChildReconciler(false);
      var hasForceUpdate = false;
      function initializeUpdateQueue(fiber) {
        fiber.updateQueue = {
          baseState: fiber.memoizedState,
          firstBaseUpdate: null,
          lastBaseUpdate: null,
          shared: { pending: null, lanes: 0, hiddenCallbacks: null },
          callbacks: null
        };
      }
      function cloneUpdateQueue(current, workInProgress2) {
        current = current.updateQueue;
        workInProgress2.updateQueue === current && (workInProgress2.updateQueue = {
          baseState: current.baseState,
          firstBaseUpdate: current.firstBaseUpdate,
          lastBaseUpdate: current.lastBaseUpdate,
          shared: current.shared,
          callbacks: null
        });
      }
      function createUpdate(lane) {
        return { lane, tag: 0, payload: null, callback: null, next: null };
      }
      function enqueueUpdate(fiber, update, lane) {
        var updateQueue = fiber.updateQueue;
        if (null === updateQueue)
          return null;
        updateQueue = updateQueue.shared;
        if (0 !== (executionContext & 2)) {
          var pending = updateQueue.pending;
          null === pending ? update.next = update : (update.next = pending.next, pending.next = update);
          updateQueue.pending = update;
          update = getRootForUpdatedFiber(fiber);
          markUpdateLaneFromFiberToRoot(fiber, null, lane);
          return update;
        }
        enqueueUpdate$1(fiber, updateQueue, update, lane);
        return getRootForUpdatedFiber(fiber);
      }
      function entangleTransitions(root3, fiber, lane) {
        fiber = fiber.updateQueue;
        if (null !== fiber && (fiber = fiber.shared, 0 !== (lane & 4194048))) {
          var queueLanes = fiber.lanes;
          queueLanes &= root3.pendingLanes;
          lane |= queueLanes;
          fiber.lanes = lane;
          markRootEntangled(root3, lane);
        }
      }
      function enqueueCapturedUpdate(workInProgress2, capturedUpdate) {
        var queue = workInProgress2.updateQueue, current = workInProgress2.alternate;
        if (null !== current && (current = current.updateQueue, queue === current)) {
          var newFirst = null, newLast = null;
          queue = queue.firstBaseUpdate;
          if (null !== queue) {
            do {
              var clone = {
                lane: queue.lane,
                tag: queue.tag,
                payload: queue.payload,
                callback: null,
                next: null
              };
              null === newLast ? newFirst = newLast = clone : newLast = newLast.next = clone;
              queue = queue.next;
            } while (null !== queue);
            null === newLast ? newFirst = newLast = capturedUpdate : newLast = newLast.next = capturedUpdate;
          } else
            newFirst = newLast = capturedUpdate;
          queue = {
            baseState: current.baseState,
            firstBaseUpdate: newFirst,
            lastBaseUpdate: newLast,
            shared: current.shared,
            callbacks: current.callbacks
          };
          workInProgress2.updateQueue = queue;
          return;
        }
        workInProgress2 = queue.lastBaseUpdate;
        null === workInProgress2 ? queue.firstBaseUpdate = capturedUpdate : workInProgress2.next = capturedUpdate;
        queue.lastBaseUpdate = capturedUpdate;
      }
      var didReadFromEntangledAsyncAction = false;
      function suspendIfUpdateReadFromEntangledAsyncAction() {
        if (didReadFromEntangledAsyncAction) {
          var entangledActionThenable = currentEntangledActionThenable;
          if (null !== entangledActionThenable)
            throw entangledActionThenable;
        }
      }
      function processUpdateQueue(workInProgress$jscomp$0, props, instance$jscomp$0, renderLanes2) {
        didReadFromEntangledAsyncAction = false;
        var queue = workInProgress$jscomp$0.updateQueue;
        hasForceUpdate = false;
        var firstBaseUpdate = queue.firstBaseUpdate, lastBaseUpdate = queue.lastBaseUpdate, pendingQueue = queue.shared.pending;
        if (null !== pendingQueue) {
          queue.shared.pending = null;
          var lastPendingUpdate = pendingQueue, firstPendingUpdate = lastPendingUpdate.next;
          lastPendingUpdate.next = null;
          null === lastBaseUpdate ? firstBaseUpdate = firstPendingUpdate : lastBaseUpdate.next = firstPendingUpdate;
          lastBaseUpdate = lastPendingUpdate;
          var current = workInProgress$jscomp$0.alternate;
          null !== current && (current = current.updateQueue, pendingQueue = current.lastBaseUpdate, pendingQueue !== lastBaseUpdate && (null === pendingQueue ? current.firstBaseUpdate = firstPendingUpdate : pendingQueue.next = firstPendingUpdate, current.lastBaseUpdate = lastPendingUpdate));
        }
        if (null !== firstBaseUpdate) {
          var newState = queue.baseState;
          lastBaseUpdate = 0;
          current = firstPendingUpdate = lastPendingUpdate = null;
          pendingQueue = firstBaseUpdate;
          do {
            var updateLane = pendingQueue.lane & -536870913, isHiddenUpdate = updateLane !== pendingQueue.lane;
            if (isHiddenUpdate ? (workInProgressRootRenderLanes & updateLane) === updateLane : (renderLanes2 & updateLane) === updateLane) {
              0 !== updateLane && updateLane === currentEntangledLane && (didReadFromEntangledAsyncAction = true);
              null !== current && (current = current.next = {
                lane: 0,
                tag: pendingQueue.tag,
                payload: pendingQueue.payload,
                callback: null,
                next: null
              });
              a: {
                var workInProgress2 = workInProgress$jscomp$0, update = pendingQueue;
                updateLane = props;
                var instance = instance$jscomp$0;
                switch (update.tag) {
                  case 1:
                    workInProgress2 = update.payload;
                    if ("function" === typeof workInProgress2) {
                      newState = workInProgress2.call(instance, newState, updateLane);
                      break a;
                    }
                    newState = workInProgress2;
                    break a;
                  case 3:
                    workInProgress2.flags = workInProgress2.flags & -65537 | 128;
                  case 0:
                    workInProgress2 = update.payload;
                    updateLane = "function" === typeof workInProgress2 ? workInProgress2.call(instance, newState, updateLane) : workInProgress2;
                    if (null === updateLane || void 0 === updateLane)
                      break a;
                    newState = assign({}, newState, updateLane);
                    break a;
                  case 2:
                    hasForceUpdate = true;
                }
              }
              updateLane = pendingQueue.callback;
              null !== updateLane && (workInProgress$jscomp$0.flags |= 64, isHiddenUpdate && (workInProgress$jscomp$0.flags |= 8192), isHiddenUpdate = queue.callbacks, null === isHiddenUpdate ? queue.callbacks = [updateLane] : isHiddenUpdate.push(updateLane));
            } else
              isHiddenUpdate = {
                lane: updateLane,
                tag: pendingQueue.tag,
                payload: pendingQueue.payload,
                callback: pendingQueue.callback,
                next: null
              }, null === current ? (firstPendingUpdate = current = isHiddenUpdate, lastPendingUpdate = newState) : current = current.next = isHiddenUpdate, lastBaseUpdate |= updateLane;
            pendingQueue = pendingQueue.next;
            if (null === pendingQueue)
              if (pendingQueue = queue.shared.pending, null === pendingQueue)
                break;
              else
                isHiddenUpdate = pendingQueue, pendingQueue = isHiddenUpdate.next, isHiddenUpdate.next = null, queue.lastBaseUpdate = isHiddenUpdate, queue.shared.pending = null;
          } while (1);
          null === current && (lastPendingUpdate = newState);
          queue.baseState = lastPendingUpdate;
          queue.firstBaseUpdate = firstPendingUpdate;
          queue.lastBaseUpdate = current;
          null === firstBaseUpdate && (queue.shared.lanes = 0);
          workInProgressRootSkippedLanes |= lastBaseUpdate;
          workInProgress$jscomp$0.lanes = lastBaseUpdate;
          workInProgress$jscomp$0.memoizedState = newState;
        }
      }
      function callCallback(callback, context) {
        if ("function" !== typeof callback)
          throw Error(formatProdErrorMessage(191, callback));
        callback.call(context);
      }
      function commitCallbacks(updateQueue, context) {
        var callbacks = updateQueue.callbacks;
        if (null !== callbacks)
          for (updateQueue.callbacks = null, updateQueue = 0; updateQueue < callbacks.length; updateQueue++)
            callCallback(callbacks[updateQueue], context);
      }
      var currentTreeHiddenStackCursor = createCursor(null);
      var prevEntangledRenderLanesCursor = createCursor(0);
      function pushHiddenContext(fiber, context) {
        fiber = entangledRenderLanes;
        push(prevEntangledRenderLanesCursor, fiber);
        push(currentTreeHiddenStackCursor, context);
        entangledRenderLanes = fiber | context.baseLanes;
      }
      function reuseHiddenContextOnStack() {
        push(prevEntangledRenderLanesCursor, entangledRenderLanes);
        push(currentTreeHiddenStackCursor, currentTreeHiddenStackCursor.current);
      }
      function popHiddenContext() {
        entangledRenderLanes = prevEntangledRenderLanesCursor.current;
        pop(currentTreeHiddenStackCursor);
        pop(prevEntangledRenderLanesCursor);
      }
      var suspenseHandlerStackCursor = createCursor(null);
      var shellBoundary = null;
      function pushPrimaryTreeSuspenseHandler(handler) {
        var current = handler.alternate;
        push(suspenseStackCursor, suspenseStackCursor.current & 1);
        push(suspenseHandlerStackCursor, handler);
        null === shellBoundary && (null === current || null !== currentTreeHiddenStackCursor.current ? shellBoundary = handler : null !== current.memoizedState && (shellBoundary = handler));
      }
      function pushDehydratedActivitySuspenseHandler(fiber) {
        push(suspenseStackCursor, suspenseStackCursor.current);
        push(suspenseHandlerStackCursor, fiber);
        null === shellBoundary && (shellBoundary = fiber);
      }
      function pushOffscreenSuspenseHandler(fiber) {
        22 === fiber.tag ? (push(suspenseStackCursor, suspenseStackCursor.current), push(suspenseHandlerStackCursor, fiber), null === shellBoundary && (shellBoundary = fiber)) : reuseSuspenseHandlerOnStack(fiber);
      }
      function reuseSuspenseHandlerOnStack() {
        push(suspenseStackCursor, suspenseStackCursor.current);
        push(suspenseHandlerStackCursor, suspenseHandlerStackCursor.current);
      }
      function popSuspenseHandler(fiber) {
        pop(suspenseHandlerStackCursor);
        shellBoundary === fiber && (shellBoundary = null);
        pop(suspenseStackCursor);
      }
      var suspenseStackCursor = createCursor(0);
      function findFirstSuspended(row) {
        for (var node = row; null !== node; ) {
          if (13 === node.tag) {
            var state = node.memoizedState;
            if (null !== state && (state = state.dehydrated, null === state || isSuspenseInstancePending(state) || isSuspenseInstanceFallback(state)))
              return node;
          } else if (19 === node.tag && ("forwards" === node.memoizedProps.revealOrder || "backwards" === node.memoizedProps.revealOrder || "unstable_legacy-backwards" === node.memoizedProps.revealOrder || "together" === node.memoizedProps.revealOrder)) {
            if (0 !== (node.flags & 128))
              return node;
          } else if (null !== node.child) {
            node.child.return = node;
            node = node.child;
            continue;
          }
          if (node === row)
            break;
          for (; null === node.sibling; ) {
            if (null === node.return || node.return === row)
              return null;
            node = node.return;
          }
          node.sibling.return = node.return;
          node = node.sibling;
        }
        return null;
      }
      var renderLanes = 0;
      var currentlyRenderingFiber = null;
      var currentHook = null;
      var workInProgressHook = null;
      var didScheduleRenderPhaseUpdate = false;
      var didScheduleRenderPhaseUpdateDuringThisPass = false;
      var shouldDoubleInvokeUserFnsInHooksDEV = false;
      var localIdCounter = 0;
      var thenableIndexCounter = 0;
      var thenableState = null;
      var globalClientIdCounter = 0;
      function throwInvalidHookError() {
        throw Error(formatProdErrorMessage(321));
      }
      function areHookInputsEqual(nextDeps, prevDeps) {
        if (null === prevDeps)
          return false;
        for (var i = 0; i < prevDeps.length && i < nextDeps.length; i++)
          if (!objectIs(nextDeps[i], prevDeps[i]))
            return false;
        return true;
      }
      function renderWithHooks(current, workInProgress2, Component, props, secondArg, nextRenderLanes) {
        renderLanes = nextRenderLanes;
        currentlyRenderingFiber = workInProgress2;
        workInProgress2.memoizedState = null;
        workInProgress2.updateQueue = null;
        workInProgress2.lanes = 0;
        ReactSharedInternals.H = null === current || null === current.memoizedState ? HooksDispatcherOnMount : HooksDispatcherOnUpdate;
        shouldDoubleInvokeUserFnsInHooksDEV = false;
        nextRenderLanes = Component(props, secondArg);
        shouldDoubleInvokeUserFnsInHooksDEV = false;
        didScheduleRenderPhaseUpdateDuringThisPass && (nextRenderLanes = renderWithHooksAgain(
          workInProgress2,
          Component,
          props,
          secondArg
        ));
        finishRenderingHooks(current);
        return nextRenderLanes;
      }
      function finishRenderingHooks(current) {
        ReactSharedInternals.H = ContextOnlyDispatcher;
        var didRenderTooFewHooks = null !== currentHook && null !== currentHook.next;
        renderLanes = 0;
        workInProgressHook = currentHook = currentlyRenderingFiber = null;
        didScheduleRenderPhaseUpdate = false;
        thenableIndexCounter = 0;
        thenableState = null;
        if (didRenderTooFewHooks)
          throw Error(formatProdErrorMessage(300));
        null === current || didReceiveUpdate || (current = current.dependencies, null !== current && checkIfContextChanged(current) && (didReceiveUpdate = true));
      }
      function renderWithHooksAgain(workInProgress2, Component, props, secondArg) {
        currentlyRenderingFiber = workInProgress2;
        var numberOfReRenders = 0;
        do {
          didScheduleRenderPhaseUpdateDuringThisPass && (thenableState = null);
          thenableIndexCounter = 0;
          didScheduleRenderPhaseUpdateDuringThisPass = false;
          if (25 <= numberOfReRenders)
            throw Error(formatProdErrorMessage(301));
          numberOfReRenders += 1;
          workInProgressHook = currentHook = null;
          if (null != workInProgress2.updateQueue) {
            var children = workInProgress2.updateQueue;
            children.lastEffect = null;
            children.events = null;
            children.stores = null;
            null != children.memoCache && (children.memoCache.index = 0);
          }
          ReactSharedInternals.H = HooksDispatcherOnRerender;
          children = Component(props, secondArg);
        } while (didScheduleRenderPhaseUpdateDuringThisPass);
        return children;
      }
      function TransitionAwareHostComponent() {
        var dispatcher = ReactSharedInternals.H, maybeThenable = dispatcher.useState()[0];
        maybeThenable = "function" === typeof maybeThenable.then ? useThenable(maybeThenable) : maybeThenable;
        dispatcher = dispatcher.useState()[0];
        (null !== currentHook ? currentHook.memoizedState : null) !== dispatcher && (currentlyRenderingFiber.flags |= 1024);
        return maybeThenable;
      }
      function checkDidRenderIdHook() {
        var didRenderIdHook = 0 !== localIdCounter;
        localIdCounter = 0;
        return didRenderIdHook;
      }
      function bailoutHooks(current, workInProgress2, lanes) {
        workInProgress2.updateQueue = current.updateQueue;
        workInProgress2.flags &= -2053;
        current.lanes &= ~lanes;
      }
      function resetHooksOnUnwind(workInProgress2) {
        if (didScheduleRenderPhaseUpdate) {
          for (workInProgress2 = workInProgress2.memoizedState; null !== workInProgress2; ) {
            var queue = workInProgress2.queue;
            null !== queue && (queue.pending = null);
            workInProgress2 = workInProgress2.next;
          }
          didScheduleRenderPhaseUpdate = false;
        }
        renderLanes = 0;
        workInProgressHook = currentHook = currentlyRenderingFiber = null;
        didScheduleRenderPhaseUpdateDuringThisPass = false;
        thenableIndexCounter = localIdCounter = 0;
        thenableState = null;
      }
      function mountWorkInProgressHook() {
        var hook = {
          memoizedState: null,
          baseState: null,
          baseQueue: null,
          queue: null,
          next: null
        };
        null === workInProgressHook ? currentlyRenderingFiber.memoizedState = workInProgressHook = hook : workInProgressHook = workInProgressHook.next = hook;
        return workInProgressHook;
      }
      function updateWorkInProgressHook() {
        if (null === currentHook) {
          var nextCurrentHook = currentlyRenderingFiber.alternate;
          nextCurrentHook = null !== nextCurrentHook ? nextCurrentHook.memoizedState : null;
        } else
          nextCurrentHook = currentHook.next;
        var nextWorkInProgressHook = null === workInProgressHook ? currentlyRenderingFiber.memoizedState : workInProgressHook.next;
        if (null !== nextWorkInProgressHook)
          workInProgressHook = nextWorkInProgressHook, currentHook = nextCurrentHook;
        else {
          if (null === nextCurrentHook) {
            if (null === currentlyRenderingFiber.alternate)
              throw Error(formatProdErrorMessage(467));
            throw Error(formatProdErrorMessage(310));
          }
          currentHook = nextCurrentHook;
          nextCurrentHook = {
            memoizedState: currentHook.memoizedState,
            baseState: currentHook.baseState,
            baseQueue: currentHook.baseQueue,
            queue: currentHook.queue,
            next: null
          };
          null === workInProgressHook ? currentlyRenderingFiber.memoizedState = workInProgressHook = nextCurrentHook : workInProgressHook = workInProgressHook.next = nextCurrentHook;
        }
        return workInProgressHook;
      }
      function createFunctionComponentUpdateQueue() {
        return { lastEffect: null, events: null, stores: null, memoCache: null };
      }
      function useThenable(thenable) {
        var index2 = thenableIndexCounter;
        thenableIndexCounter += 1;
        null === thenableState && (thenableState = []);
        thenable = trackUsedThenable(thenableState, thenable, index2);
        index2 = currentlyRenderingFiber;
        null === (null === workInProgressHook ? index2.memoizedState : workInProgressHook.next) && (index2 = index2.alternate, ReactSharedInternals.H = null === index2 || null === index2.memoizedState ? HooksDispatcherOnMount : HooksDispatcherOnUpdate);
        return thenable;
      }
      function use(usable) {
        if (null !== usable && "object" === typeof usable) {
          if ("function" === typeof usable.then)
            return useThenable(usable);
          if (usable.$$typeof === REACT_CONTEXT_TYPE)
            return readContext(usable);
        }
        throw Error(formatProdErrorMessage(438, String(usable)));
      }
      function useMemoCache(size) {
        var memoCache = null, updateQueue = currentlyRenderingFiber.updateQueue;
        null !== updateQueue && (memoCache = updateQueue.memoCache);
        if (null == memoCache) {
          var current = currentlyRenderingFiber.alternate;
          null !== current && (current = current.updateQueue, null !== current && (current = current.memoCache, null != current && (memoCache = {
            data: current.data.map(function(array) {
              return array.slice();
            }),
            index: 0
          })));
        }
        null == memoCache && (memoCache = { data: [], index: 0 });
        null === updateQueue && (updateQueue = createFunctionComponentUpdateQueue(), currentlyRenderingFiber.updateQueue = updateQueue);
        updateQueue.memoCache = memoCache;
        updateQueue = memoCache.data[memoCache.index];
        if (void 0 === updateQueue)
          for (updateQueue = memoCache.data[memoCache.index] = Array(size), current = 0; current < size; current++)
            updateQueue[current] = REACT_MEMO_CACHE_SENTINEL;
        memoCache.index++;
        return updateQueue;
      }
      function basicStateReducer(state, action) {
        return "function" === typeof action ? action(state) : action;
      }
      function updateReducer(reducer) {
        var hook = updateWorkInProgressHook();
        return updateReducerImpl(hook, currentHook, reducer);
      }
      function updateReducerImpl(hook, current, reducer) {
        var queue = hook.queue;
        if (null === queue)
          throw Error(formatProdErrorMessage(311));
        queue.lastRenderedReducer = reducer;
        var baseQueue = hook.baseQueue, pendingQueue = queue.pending;
        if (null !== pendingQueue) {
          if (null !== baseQueue) {
            var baseFirst = baseQueue.next;
            baseQueue.next = pendingQueue.next;
            pendingQueue.next = baseFirst;
          }
          current.baseQueue = baseQueue = pendingQueue;
          queue.pending = null;
        }
        pendingQueue = hook.baseState;
        if (null === baseQueue)
          hook.memoizedState = pendingQueue;
        else {
          current = baseQueue.next;
          var newBaseQueueFirst = baseFirst = null, newBaseQueueLast = null, update = current, didReadFromEntangledAsyncAction$60 = false;
          do {
            var updateLane = update.lane & -536870913;
            if (updateLane !== update.lane ? (workInProgressRootRenderLanes & updateLane) === updateLane : (renderLanes & updateLane) === updateLane) {
              var revertLane = update.revertLane;
              if (0 === revertLane)
                null !== newBaseQueueLast && (newBaseQueueLast = newBaseQueueLast.next = {
                  lane: 0,
                  revertLane: 0,
                  gesture: null,
                  action: update.action,
                  hasEagerState: update.hasEagerState,
                  eagerState: update.eagerState,
                  next: null
                }), updateLane === currentEntangledLane && (didReadFromEntangledAsyncAction$60 = true);
              else if ((renderLanes & revertLane) === revertLane) {
                update = update.next;
                revertLane === currentEntangledLane && (didReadFromEntangledAsyncAction$60 = true);
                continue;
              } else
                updateLane = {
                  lane: 0,
                  revertLane: update.revertLane,
                  gesture: null,
                  action: update.action,
                  hasEagerState: update.hasEagerState,
                  eagerState: update.eagerState,
                  next: null
                }, null === newBaseQueueLast ? (newBaseQueueFirst = newBaseQueueLast = updateLane, baseFirst = pendingQueue) : newBaseQueueLast = newBaseQueueLast.next = updateLane, currentlyRenderingFiber.lanes |= revertLane, workInProgressRootSkippedLanes |= revertLane;
              updateLane = update.action;
              shouldDoubleInvokeUserFnsInHooksDEV && reducer(pendingQueue, updateLane);
              pendingQueue = update.hasEagerState ? update.eagerState : reducer(pendingQueue, updateLane);
            } else
              revertLane = {
                lane: updateLane,
                revertLane: update.revertLane,
                gesture: update.gesture,
                action: update.action,
                hasEagerState: update.hasEagerState,
                eagerState: update.eagerState,
                next: null
              }, null === newBaseQueueLast ? (newBaseQueueFirst = newBaseQueueLast = revertLane, baseFirst = pendingQueue) : newBaseQueueLast = newBaseQueueLast.next = revertLane, currentlyRenderingFiber.lanes |= updateLane, workInProgressRootSkippedLanes |= updateLane;
            update = update.next;
          } while (null !== update && update !== current);
          null === newBaseQueueLast ? baseFirst = pendingQueue : newBaseQueueLast.next = newBaseQueueFirst;
          if (!objectIs(pendingQueue, hook.memoizedState) && (didReceiveUpdate = true, didReadFromEntangledAsyncAction$60 && (reducer = currentEntangledActionThenable, null !== reducer)))
            throw reducer;
          hook.memoizedState = pendingQueue;
          hook.baseState = baseFirst;
          hook.baseQueue = newBaseQueueLast;
          queue.lastRenderedState = pendingQueue;
        }
        null === baseQueue && (queue.lanes = 0);
        return [hook.memoizedState, queue.dispatch];
      }
      function rerenderReducer(reducer) {
        var hook = updateWorkInProgressHook(), queue = hook.queue;
        if (null === queue)
          throw Error(formatProdErrorMessage(311));
        queue.lastRenderedReducer = reducer;
        var dispatch = queue.dispatch, lastRenderPhaseUpdate = queue.pending, newState = hook.memoizedState;
        if (null !== lastRenderPhaseUpdate) {
          queue.pending = null;
          var update = lastRenderPhaseUpdate = lastRenderPhaseUpdate.next;
          do
            newState = reducer(newState, update.action), update = update.next;
          while (update !== lastRenderPhaseUpdate);
          objectIs(newState, hook.memoizedState) || (didReceiveUpdate = true);
          hook.memoizedState = newState;
          null === hook.baseQueue && (hook.baseState = newState);
          queue.lastRenderedState = newState;
        }
        return [newState, dispatch];
      }
      function updateSyncExternalStore(subscribe, getSnapshot, getServerSnapshot) {
        var fiber = currentlyRenderingFiber, hook = updateWorkInProgressHook(), isHydrating$jscomp$0 = isHydrating;
        if (isHydrating$jscomp$0) {
          if (void 0 === getServerSnapshot)
            throw Error(formatProdErrorMessage(407));
          getServerSnapshot = getServerSnapshot();
        } else
          getServerSnapshot = getSnapshot();
        var snapshotChanged = !objectIs(
          (currentHook || hook).memoizedState,
          getServerSnapshot
        );
        snapshotChanged && (hook.memoizedState = getServerSnapshot, didReceiveUpdate = true);
        hook = hook.queue;
        updateEffect(subscribeToStore.bind(null, fiber, hook, subscribe), [
          subscribe
        ]);
        if (hook.getSnapshot !== getSnapshot || snapshotChanged || null !== workInProgressHook && workInProgressHook.memoizedState.tag & 1) {
          fiber.flags |= 2048;
          pushSimpleEffect(
            9,
            { destroy: void 0 },
            updateStoreInstance.bind(
              null,
              fiber,
              hook,
              getServerSnapshot,
              getSnapshot
            ),
            null
          );
          if (null === workInProgressRoot)
            throw Error(formatProdErrorMessage(349));
          isHydrating$jscomp$0 || 0 !== (renderLanes & 127) || pushStoreConsistencyCheck(fiber, getSnapshot, getServerSnapshot);
        }
        return getServerSnapshot;
      }
      function pushStoreConsistencyCheck(fiber, getSnapshot, renderedSnapshot) {
        fiber.flags |= 16384;
        fiber = { getSnapshot, value: renderedSnapshot };
        getSnapshot = currentlyRenderingFiber.updateQueue;
        null === getSnapshot ? (getSnapshot = createFunctionComponentUpdateQueue(), currentlyRenderingFiber.updateQueue = getSnapshot, getSnapshot.stores = [fiber]) : (renderedSnapshot = getSnapshot.stores, null === renderedSnapshot ? getSnapshot.stores = [fiber] : renderedSnapshot.push(fiber));
      }
      function updateStoreInstance(fiber, inst, nextSnapshot, getSnapshot) {
        inst.value = nextSnapshot;
        inst.getSnapshot = getSnapshot;
        checkIfSnapshotChanged(inst) && forceStoreRerender(fiber);
      }
      function subscribeToStore(fiber, inst, subscribe) {
        return subscribe(function() {
          checkIfSnapshotChanged(inst) && forceStoreRerender(fiber);
        });
      }
      function checkIfSnapshotChanged(inst) {
        var latestGetSnapshot = inst.getSnapshot;
        inst = inst.value;
        try {
          var nextValue = latestGetSnapshot();
          return !objectIs(inst, nextValue);
        } catch (error) {
          return true;
        }
      }
      function forceStoreRerender(fiber) {
        var root3 = enqueueConcurrentRenderForLane(fiber, 2);
        null !== root3 && scheduleUpdateOnFiber(root3, fiber, 2);
      }
      function mountStateImpl(initialState) {
        var hook = mountWorkInProgressHook();
        if ("function" === typeof initialState) {
          var initialStateInitializer = initialState;
          initialState = initialStateInitializer();
          if (shouldDoubleInvokeUserFnsInHooksDEV) {
            setIsStrictModeForDevtools(true);
            try {
              initialStateInitializer();
            } finally {
              setIsStrictModeForDevtools(false);
            }
          }
        }
        hook.memoizedState = hook.baseState = initialState;
        hook.queue = {
          pending: null,
          lanes: 0,
          dispatch: null,
          lastRenderedReducer: basicStateReducer,
          lastRenderedState: initialState
        };
        return hook;
      }
      function updateOptimisticImpl(hook, current, passthrough, reducer) {
        hook.baseState = passthrough;
        return updateReducerImpl(
          hook,
          currentHook,
          "function" === typeof reducer ? reducer : basicStateReducer
        );
      }
      function dispatchActionState(fiber, actionQueue, setPendingState, setState, payload) {
        if (isRenderPhaseUpdate(fiber))
          throw Error(formatProdErrorMessage(485));
        fiber = actionQueue.action;
        if (null !== fiber) {
          var actionNode = {
            payload,
            action: fiber,
            next: null,
            isTransition: true,
            status: "pending",
            value: null,
            reason: null,
            listeners: [],
            then: function(listener) {
              actionNode.listeners.push(listener);
            }
          };
          null !== ReactSharedInternals.T ? setPendingState(true) : actionNode.isTransition = false;
          setState(actionNode);
          setPendingState = actionQueue.pending;
          null === setPendingState ? (actionNode.next = actionQueue.pending = actionNode, runActionStateAction(actionQueue, actionNode)) : (actionNode.next = setPendingState.next, actionQueue.pending = setPendingState.next = actionNode);
        }
      }
      function runActionStateAction(actionQueue, node) {
        var action = node.action, payload = node.payload, prevState = actionQueue.state;
        if (node.isTransition) {
          var prevTransition = ReactSharedInternals.T, currentTransition = {};
          ReactSharedInternals.T = currentTransition;
          try {
            var returnValue = action(prevState, payload), onStartTransitionFinish = ReactSharedInternals.S;
            null !== onStartTransitionFinish && onStartTransitionFinish(currentTransition, returnValue);
            handleActionReturnValue(actionQueue, node, returnValue);
          } catch (error) {
            onActionError(actionQueue, node, error);
          } finally {
            null !== prevTransition && null !== currentTransition.types && (prevTransition.types = currentTransition.types), ReactSharedInternals.T = prevTransition;
          }
        } else
          try {
            prevTransition = action(prevState, payload), handleActionReturnValue(actionQueue, node, prevTransition);
          } catch (error$66) {
            onActionError(actionQueue, node, error$66);
          }
      }
      function handleActionReturnValue(actionQueue, node, returnValue) {
        null !== returnValue && "object" === typeof returnValue && "function" === typeof returnValue.then ? returnValue.then(
          function(nextState) {
            onActionSuccess(actionQueue, node, nextState);
          },
          function(error) {
            return onActionError(actionQueue, node, error);
          }
        ) : onActionSuccess(actionQueue, node, returnValue);
      }
      function onActionSuccess(actionQueue, actionNode, nextState) {
        actionNode.status = "fulfilled";
        actionNode.value = nextState;
        notifyActionListeners(actionNode);
        actionQueue.state = nextState;
        actionNode = actionQueue.pending;
        null !== actionNode && (nextState = actionNode.next, nextState === actionNode ? actionQueue.pending = null : (nextState = nextState.next, actionNode.next = nextState, runActionStateAction(actionQueue, nextState)));
      }
      function onActionError(actionQueue, actionNode, error) {
        var last = actionQueue.pending;
        actionQueue.pending = null;
        if (null !== last) {
          last = last.next;
          do
            actionNode.status = "rejected", actionNode.reason = error, notifyActionListeners(actionNode), actionNode = actionNode.next;
          while (actionNode !== last);
        }
        actionQueue.action = null;
      }
      function notifyActionListeners(actionNode) {
        actionNode = actionNode.listeners;
        for (var i = 0; i < actionNode.length; i++)
          (0, actionNode[i])();
      }
      function actionStateReducer(oldState, newState) {
        return newState;
      }
      function mountActionState(action, initialStateProp) {
        if (isHydrating) {
          var ssrFormState = workInProgressRoot.formState;
          if (null !== ssrFormState) {
            a: {
              var JSCompiler_inline_result = currentlyRenderingFiber;
              if (isHydrating) {
                if (nextHydratableInstance) {
                  b: {
                    var JSCompiler_inline_result$jscomp$0 = nextHydratableInstance;
                    for (var inRootOrSingleton = rootOrSingletonContext; 8 !== JSCompiler_inline_result$jscomp$0.nodeType; ) {
                      if (!inRootOrSingleton) {
                        JSCompiler_inline_result$jscomp$0 = null;
                        break b;
                      }
                      JSCompiler_inline_result$jscomp$0 = getNextHydratable(
                        JSCompiler_inline_result$jscomp$0.nextSibling
                      );
                      if (null === JSCompiler_inline_result$jscomp$0) {
                        JSCompiler_inline_result$jscomp$0 = null;
                        break b;
                      }
                    }
                    inRootOrSingleton = JSCompiler_inline_result$jscomp$0.data;
                    JSCompiler_inline_result$jscomp$0 = "F!" === inRootOrSingleton || "F" === inRootOrSingleton ? JSCompiler_inline_result$jscomp$0 : null;
                  }
                  if (JSCompiler_inline_result$jscomp$0) {
                    nextHydratableInstance = getNextHydratable(
                      JSCompiler_inline_result$jscomp$0.nextSibling
                    );
                    JSCompiler_inline_result = "F!" === JSCompiler_inline_result$jscomp$0.data;
                    break a;
                  }
                }
                throwOnHydrationMismatch(JSCompiler_inline_result);
              }
              JSCompiler_inline_result = false;
            }
            JSCompiler_inline_result && (initialStateProp = ssrFormState[0]);
          }
        }
        ssrFormState = mountWorkInProgressHook();
        ssrFormState.memoizedState = ssrFormState.baseState = initialStateProp;
        JSCompiler_inline_result = {
          pending: null,
          lanes: 0,
          dispatch: null,
          lastRenderedReducer: actionStateReducer,
          lastRenderedState: initialStateProp
        };
        ssrFormState.queue = JSCompiler_inline_result;
        ssrFormState = dispatchSetState.bind(
          null,
          currentlyRenderingFiber,
          JSCompiler_inline_result
        );
        JSCompiler_inline_result.dispatch = ssrFormState;
        JSCompiler_inline_result = mountStateImpl(false);
        inRootOrSingleton = dispatchOptimisticSetState.bind(
          null,
          currentlyRenderingFiber,
          false,
          JSCompiler_inline_result.queue
        );
        JSCompiler_inline_result = mountWorkInProgressHook();
        JSCompiler_inline_result$jscomp$0 = {
          state: initialStateProp,
          dispatch: null,
          action,
          pending: null
        };
        JSCompiler_inline_result.queue = JSCompiler_inline_result$jscomp$0;
        ssrFormState = dispatchActionState.bind(
          null,
          currentlyRenderingFiber,
          JSCompiler_inline_result$jscomp$0,
          inRootOrSingleton,
          ssrFormState
        );
        JSCompiler_inline_result$jscomp$0.dispatch = ssrFormState;
        JSCompiler_inline_result.memoizedState = action;
        return [initialStateProp, ssrFormState, false];
      }
      function updateActionState(action) {
        var stateHook = updateWorkInProgressHook();
        return updateActionStateImpl(stateHook, currentHook, action);
      }
      function updateActionStateImpl(stateHook, currentStateHook, action) {
        currentStateHook = updateReducerImpl(
          stateHook,
          currentStateHook,
          actionStateReducer
        )[0];
        stateHook = updateReducer(basicStateReducer)[0];
        if ("object" === typeof currentStateHook && null !== currentStateHook && "function" === typeof currentStateHook.then)
          try {
            var state = useThenable(currentStateHook);
          } catch (x) {
            if (x === SuspenseException)
              throw SuspenseActionException;
            throw x;
          }
        else
          state = currentStateHook;
        currentStateHook = updateWorkInProgressHook();
        var actionQueue = currentStateHook.queue, dispatch = actionQueue.dispatch;
        action !== currentStateHook.memoizedState && (currentlyRenderingFiber.flags |= 2048, pushSimpleEffect(
          9,
          { destroy: void 0 },
          actionStateActionEffect.bind(null, actionQueue, action),
          null
        ));
        return [state, dispatch, stateHook];
      }
      function actionStateActionEffect(actionQueue, action) {
        actionQueue.action = action;
      }
      function rerenderActionState(action) {
        var stateHook = updateWorkInProgressHook(), currentStateHook = currentHook;
        if (null !== currentStateHook)
          return updateActionStateImpl(stateHook, currentStateHook, action);
        updateWorkInProgressHook();
        stateHook = stateHook.memoizedState;
        currentStateHook = updateWorkInProgressHook();
        var dispatch = currentStateHook.queue.dispatch;
        currentStateHook.memoizedState = action;
        return [stateHook, dispatch, false];
      }
      function pushSimpleEffect(tag, inst, create, deps) {
        tag = { tag, create, deps, inst, next: null };
        inst = currentlyRenderingFiber.updateQueue;
        null === inst && (inst = createFunctionComponentUpdateQueue(), currentlyRenderingFiber.updateQueue = inst);
        create = inst.lastEffect;
        null === create ? inst.lastEffect = tag.next = tag : (deps = create.next, create.next = tag, tag.next = deps, inst.lastEffect = tag);
        return tag;
      }
      function updateRef() {
        return updateWorkInProgressHook().memoizedState;
      }
      function mountEffectImpl(fiberFlags, hookFlags, create, deps) {
        var hook = mountWorkInProgressHook();
        currentlyRenderingFiber.flags |= fiberFlags;
        hook.memoizedState = pushSimpleEffect(
          1 | hookFlags,
          { destroy: void 0 },
          create,
          void 0 === deps ? null : deps
        );
      }
      function updateEffectImpl(fiberFlags, hookFlags, create, deps) {
        var hook = updateWorkInProgressHook();
        deps = void 0 === deps ? null : deps;
        var inst = hook.memoizedState.inst;
        null !== currentHook && null !== deps && areHookInputsEqual(deps, currentHook.memoizedState.deps) ? hook.memoizedState = pushSimpleEffect(hookFlags, inst, create, deps) : (currentlyRenderingFiber.flags |= fiberFlags, hook.memoizedState = pushSimpleEffect(
          1 | hookFlags,
          inst,
          create,
          deps
        ));
      }
      function mountEffect(create, deps) {
        mountEffectImpl(8390656, 8, create, deps);
      }
      function updateEffect(create, deps) {
        updateEffectImpl(2048, 8, create, deps);
      }
      function useEffectEventImpl(payload) {
        currentlyRenderingFiber.flags |= 4;
        var componentUpdateQueue = currentlyRenderingFiber.updateQueue;
        if (null === componentUpdateQueue)
          componentUpdateQueue = createFunctionComponentUpdateQueue(), currentlyRenderingFiber.updateQueue = componentUpdateQueue, componentUpdateQueue.events = [payload];
        else {
          var events = componentUpdateQueue.events;
          null === events ? componentUpdateQueue.events = [payload] : events.push(payload);
        }
      }
      function updateEvent(callback) {
        var ref = updateWorkInProgressHook().memoizedState;
        useEffectEventImpl({ ref, nextImpl: callback });
        return function() {
          if (0 !== (executionContext & 2))
            throw Error(formatProdErrorMessage(440));
          return ref.impl.apply(void 0, arguments);
        };
      }
      function updateInsertionEffect(create, deps) {
        return updateEffectImpl(4, 2, create, deps);
      }
      function updateLayoutEffect(create, deps) {
        return updateEffectImpl(4, 4, create, deps);
      }
      function imperativeHandleEffect(create, ref) {
        if ("function" === typeof ref) {
          create = create();
          var refCleanup = ref(create);
          return function() {
            "function" === typeof refCleanup ? refCleanup() : ref(null);
          };
        }
        if (null !== ref && void 0 !== ref)
          return create = create(), ref.current = create, function() {
            ref.current = null;
          };
      }
      function updateImperativeHandle(ref, create, deps) {
        deps = null !== deps && void 0 !== deps ? deps.concat([ref]) : null;
        updateEffectImpl(4, 4, imperativeHandleEffect.bind(null, create, ref), deps);
      }
      function mountDebugValue() {
      }
      function updateCallback(callback, deps) {
        var hook = updateWorkInProgressHook();
        deps = void 0 === deps ? null : deps;
        var prevState = hook.memoizedState;
        if (null !== deps && areHookInputsEqual(deps, prevState[1]))
          return prevState[0];
        hook.memoizedState = [callback, deps];
        return callback;
      }
      function updateMemo(nextCreate, deps) {
        var hook = updateWorkInProgressHook();
        deps = void 0 === deps ? null : deps;
        var prevState = hook.memoizedState;
        if (null !== deps && areHookInputsEqual(deps, prevState[1]))
          return prevState[0];
        prevState = nextCreate();
        if (shouldDoubleInvokeUserFnsInHooksDEV) {
          setIsStrictModeForDevtools(true);
          try {
            nextCreate();
          } finally {
            setIsStrictModeForDevtools(false);
          }
        }
        hook.memoizedState = [prevState, deps];
        return prevState;
      }
      function mountDeferredValueImpl(hook, value, initialValue) {
        if (void 0 === initialValue || 0 !== (renderLanes & 1073741824) && 0 === (workInProgressRootRenderLanes & 261930))
          return hook.memoizedState = value;
        hook.memoizedState = initialValue;
        hook = requestDeferredLane();
        currentlyRenderingFiber.lanes |= hook;
        workInProgressRootSkippedLanes |= hook;
        return initialValue;
      }
      function updateDeferredValueImpl(hook, prevValue, value, initialValue) {
        if (objectIs(value, prevValue))
          return value;
        if (null !== currentTreeHiddenStackCursor.current)
          return hook = mountDeferredValueImpl(hook, value, initialValue), objectIs(hook, prevValue) || (didReceiveUpdate = true), hook;
        if (0 === (renderLanes & 42) || 0 !== (renderLanes & 1073741824) && 0 === (workInProgressRootRenderLanes & 261930))
          return didReceiveUpdate = true, hook.memoizedState = value;
        hook = requestDeferredLane();
        currentlyRenderingFiber.lanes |= hook;
        workInProgressRootSkippedLanes |= hook;
        return prevValue;
      }
      function startTransition(fiber, queue, pendingState, finishedState, callback) {
        var previousPriority = ReactDOMSharedInternals.p;
        ReactDOMSharedInternals.p = 0 !== previousPriority && 8 > previousPriority ? previousPriority : 8;
        var prevTransition = ReactSharedInternals.T, currentTransition = {};
        ReactSharedInternals.T = currentTransition;
        dispatchOptimisticSetState(fiber, false, queue, pendingState);
        try {
          var returnValue = callback(), onStartTransitionFinish = ReactSharedInternals.S;
          null !== onStartTransitionFinish && onStartTransitionFinish(currentTransition, returnValue);
          if (null !== returnValue && "object" === typeof returnValue && "function" === typeof returnValue.then) {
            var thenableForFinishedState = chainThenableValue(
              returnValue,
              finishedState
            );
            dispatchSetStateInternal(
              fiber,
              queue,
              thenableForFinishedState,
              requestUpdateLane(fiber)
            );
          } else
            dispatchSetStateInternal(
              fiber,
              queue,
              finishedState,
              requestUpdateLane(fiber)
            );
        } catch (error) {
          dispatchSetStateInternal(
            fiber,
            queue,
            { then: function() {
            }, status: "rejected", reason: error },
            requestUpdateLane()
          );
        } finally {
          ReactDOMSharedInternals.p = previousPriority, null !== prevTransition && null !== currentTransition.types && (prevTransition.types = currentTransition.types), ReactSharedInternals.T = prevTransition;
        }
      }
      function noop() {
      }
      function startHostTransition(formFiber, pendingState, action, formData) {
        if (5 !== formFiber.tag)
          throw Error(formatProdErrorMessage(476));
        var queue = ensureFormComponentIsStateful(formFiber).queue;
        startTransition(
          formFiber,
          queue,
          pendingState,
          sharedNotPendingObject,
          null === action ? noop : function() {
            requestFormReset$1(formFiber);
            return action(formData);
          }
        );
      }
      function ensureFormComponentIsStateful(formFiber) {
        var existingStateHook = formFiber.memoizedState;
        if (null !== existingStateHook)
          return existingStateHook;
        existingStateHook = {
          memoizedState: sharedNotPendingObject,
          baseState: sharedNotPendingObject,
          baseQueue: null,
          queue: {
            pending: null,
            lanes: 0,
            dispatch: null,
            lastRenderedReducer: basicStateReducer,
            lastRenderedState: sharedNotPendingObject
          },
          next: null
        };
        var initialResetState = {};
        existingStateHook.next = {
          memoizedState: initialResetState,
          baseState: initialResetState,
          baseQueue: null,
          queue: {
            pending: null,
            lanes: 0,
            dispatch: null,
            lastRenderedReducer: basicStateReducer,
            lastRenderedState: initialResetState
          },
          next: null
        };
        formFiber.memoizedState = existingStateHook;
        formFiber = formFiber.alternate;
        null !== formFiber && (formFiber.memoizedState = existingStateHook);
        return existingStateHook;
      }
      function requestFormReset$1(formFiber) {
        var stateHook = ensureFormComponentIsStateful(formFiber);
        null === stateHook.next && (stateHook = formFiber.alternate.memoizedState);
        dispatchSetStateInternal(
          formFiber,
          stateHook.next.queue,
          {},
          requestUpdateLane()
        );
      }
      function useHostTransitionStatus() {
        return readContext(HostTransitionContext);
      }
      function updateId() {
        return updateWorkInProgressHook().memoizedState;
      }
      function updateRefresh() {
        return updateWorkInProgressHook().memoizedState;
      }
      function refreshCache(fiber) {
        for (var provider = fiber.return; null !== provider; ) {
          switch (provider.tag) {
            case 24:
            case 3:
              var lane = requestUpdateLane();
              fiber = createUpdate(lane);
              var root$69 = enqueueUpdate(provider, fiber, lane);
              null !== root$69 && (scheduleUpdateOnFiber(root$69, provider, lane), entangleTransitions(root$69, provider, lane));
              provider = { cache: createCache() };
              fiber.payload = provider;
              return;
          }
          provider = provider.return;
        }
      }
      function dispatchReducerAction(fiber, queue, action) {
        var lane = requestUpdateLane();
        action = {
          lane,
          revertLane: 0,
          gesture: null,
          action,
          hasEagerState: false,
          eagerState: null,
          next: null
        };
        isRenderPhaseUpdate(fiber) ? enqueueRenderPhaseUpdate(queue, action) : (action = enqueueConcurrentHookUpdate(fiber, queue, action, lane), null !== action && (scheduleUpdateOnFiber(action, fiber, lane), entangleTransitionUpdate(action, queue, lane)));
      }
      function dispatchSetState(fiber, queue, action) {
        var lane = requestUpdateLane();
        dispatchSetStateInternal(fiber, queue, action, lane);
      }
      function dispatchSetStateInternal(fiber, queue, action, lane) {
        var update = {
          lane,
          revertLane: 0,
          gesture: null,
          action,
          hasEagerState: false,
          eagerState: null,
          next: null
        };
        if (isRenderPhaseUpdate(fiber))
          enqueueRenderPhaseUpdate(queue, update);
        else {
          var alternate = fiber.alternate;
          if (0 === fiber.lanes && (null === alternate || 0 === alternate.lanes) && (alternate = queue.lastRenderedReducer, null !== alternate))
            try {
              var currentState = queue.lastRenderedState, eagerState = alternate(currentState, action);
              update.hasEagerState = true;
              update.eagerState = eagerState;
              if (objectIs(eagerState, currentState))
                return enqueueUpdate$1(fiber, queue, update, 0), null === workInProgressRoot && finishQueueingConcurrentUpdates(), false;
            } catch (error) {
            } finally {
            }
          action = enqueueConcurrentHookUpdate(fiber, queue, update, lane);
          if (null !== action)
            return scheduleUpdateOnFiber(action, fiber, lane), entangleTransitionUpdate(action, queue, lane), true;
        }
        return false;
      }
      function dispatchOptimisticSetState(fiber, throwIfDuringRender, queue, action) {
        action = {
          lane: 2,
          revertLane: requestTransitionLane(),
          gesture: null,
          action,
          hasEagerState: false,
          eagerState: null,
          next: null
        };
        if (isRenderPhaseUpdate(fiber)) {
          if (throwIfDuringRender)
            throw Error(formatProdErrorMessage(479));
        } else
          throwIfDuringRender = enqueueConcurrentHookUpdate(
            fiber,
            queue,
            action,
            2
          ), null !== throwIfDuringRender && scheduleUpdateOnFiber(throwIfDuringRender, fiber, 2);
      }
      function isRenderPhaseUpdate(fiber) {
        var alternate = fiber.alternate;
        return fiber === currentlyRenderingFiber || null !== alternate && alternate === currentlyRenderingFiber;
      }
      function enqueueRenderPhaseUpdate(queue, update) {
        didScheduleRenderPhaseUpdateDuringThisPass = didScheduleRenderPhaseUpdate = true;
        var pending = queue.pending;
        null === pending ? update.next = update : (update.next = pending.next, pending.next = update);
        queue.pending = update;
      }
      function entangleTransitionUpdate(root3, queue, lane) {
        if (0 !== (lane & 4194048)) {
          var queueLanes = queue.lanes;
          queueLanes &= root3.pendingLanes;
          lane |= queueLanes;
          queue.lanes = lane;
          markRootEntangled(root3, lane);
        }
      }
      var ContextOnlyDispatcher = {
        readContext,
        use,
        useCallback: throwInvalidHookError,
        useContext: throwInvalidHookError,
        useEffect: throwInvalidHookError,
        useImperativeHandle: throwInvalidHookError,
        useLayoutEffect: throwInvalidHookError,
        useInsertionEffect: throwInvalidHookError,
        useMemo: throwInvalidHookError,
        useReducer: throwInvalidHookError,
        useRef: throwInvalidHookError,
        useState: throwInvalidHookError,
        useDebugValue: throwInvalidHookError,
        useDeferredValue: throwInvalidHookError,
        useTransition: throwInvalidHookError,
        useSyncExternalStore: throwInvalidHookError,
        useId: throwInvalidHookError,
        useHostTransitionStatus: throwInvalidHookError,
        useFormState: throwInvalidHookError,
        useActionState: throwInvalidHookError,
        useOptimistic: throwInvalidHookError,
        useMemoCache: throwInvalidHookError,
        useCacheRefresh: throwInvalidHookError
      };
      ContextOnlyDispatcher.useEffectEvent = throwInvalidHookError;
      var HooksDispatcherOnMount = {
        readContext,
        use,
        useCallback: function(callback, deps) {
          mountWorkInProgressHook().memoizedState = [
            callback,
            void 0 === deps ? null : deps
          ];
          return callback;
        },
        useContext: readContext,
        useEffect: mountEffect,
        useImperativeHandle: function(ref, create, deps) {
          deps = null !== deps && void 0 !== deps ? deps.concat([ref]) : null;
          mountEffectImpl(
            4194308,
            4,
            imperativeHandleEffect.bind(null, create, ref),
            deps
          );
        },
        useLayoutEffect: function(create, deps) {
          return mountEffectImpl(4194308, 4, create, deps);
        },
        useInsertionEffect: function(create, deps) {
          mountEffectImpl(4, 2, create, deps);
        },
        useMemo: function(nextCreate, deps) {
          var hook = mountWorkInProgressHook();
          deps = void 0 === deps ? null : deps;
          var nextValue = nextCreate();
          if (shouldDoubleInvokeUserFnsInHooksDEV) {
            setIsStrictModeForDevtools(true);
            try {
              nextCreate();
            } finally {
              setIsStrictModeForDevtools(false);
            }
          }
          hook.memoizedState = [nextValue, deps];
          return nextValue;
        },
        useReducer: function(reducer, initialArg, init) {
          var hook = mountWorkInProgressHook();
          if (void 0 !== init) {
            var initialState = init(initialArg);
            if (shouldDoubleInvokeUserFnsInHooksDEV) {
              setIsStrictModeForDevtools(true);
              try {
                init(initialArg);
              } finally {
                setIsStrictModeForDevtools(false);
              }
            }
          } else
            initialState = initialArg;
          hook.memoizedState = hook.baseState = initialState;
          reducer = {
            pending: null,
            lanes: 0,
            dispatch: null,
            lastRenderedReducer: reducer,
            lastRenderedState: initialState
          };
          hook.queue = reducer;
          reducer = reducer.dispatch = dispatchReducerAction.bind(
            null,
            currentlyRenderingFiber,
            reducer
          );
          return [hook.memoizedState, reducer];
        },
        useRef: function(initialValue) {
          var hook = mountWorkInProgressHook();
          initialValue = { current: initialValue };
          return hook.memoizedState = initialValue;
        },
        useState: function(initialState) {
          initialState = mountStateImpl(initialState);
          var queue = initialState.queue, dispatch = dispatchSetState.bind(null, currentlyRenderingFiber, queue);
          queue.dispatch = dispatch;
          return [initialState.memoizedState, dispatch];
        },
        useDebugValue: mountDebugValue,
        useDeferredValue: function(value, initialValue) {
          var hook = mountWorkInProgressHook();
          return mountDeferredValueImpl(hook, value, initialValue);
        },
        useTransition: function() {
          var stateHook = mountStateImpl(false);
          stateHook = startTransition.bind(
            null,
            currentlyRenderingFiber,
            stateHook.queue,
            true,
            false
          );
          mountWorkInProgressHook().memoizedState = stateHook;
          return [false, stateHook];
        },
        useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {
          var fiber = currentlyRenderingFiber, hook = mountWorkInProgressHook();
          if (isHydrating) {
            if (void 0 === getServerSnapshot)
              throw Error(formatProdErrorMessage(407));
            getServerSnapshot = getServerSnapshot();
          } else {
            getServerSnapshot = getSnapshot();
            if (null === workInProgressRoot)
              throw Error(formatProdErrorMessage(349));
            0 !== (workInProgressRootRenderLanes & 127) || pushStoreConsistencyCheck(fiber, getSnapshot, getServerSnapshot);
          }
          hook.memoizedState = getServerSnapshot;
          var inst = { value: getServerSnapshot, getSnapshot };
          hook.queue = inst;
          mountEffect(subscribeToStore.bind(null, fiber, inst, subscribe), [
            subscribe
          ]);
          fiber.flags |= 2048;
          pushSimpleEffect(
            9,
            { destroy: void 0 },
            updateStoreInstance.bind(
              null,
              fiber,
              inst,
              getServerSnapshot,
              getSnapshot
            ),
            null
          );
          return getServerSnapshot;
        },
        useId: function() {
          var hook = mountWorkInProgressHook(), identifierPrefix = workInProgressRoot.identifierPrefix;
          if (isHydrating) {
            var JSCompiler_inline_result = treeContextOverflow;
            var idWithLeadingBit = treeContextId;
            JSCompiler_inline_result = (idWithLeadingBit & ~(1 << 32 - clz32(idWithLeadingBit) - 1)).toString(32) + JSCompiler_inline_result;
            identifierPrefix = "_" + identifierPrefix + "R_" + JSCompiler_inline_result;
            JSCompiler_inline_result = localIdCounter++;
            0 < JSCompiler_inline_result && (identifierPrefix += "H" + JSCompiler_inline_result.toString(32));
            identifierPrefix += "_";
          } else
            JSCompiler_inline_result = globalClientIdCounter++, identifierPrefix = "_" + identifierPrefix + "r_" + JSCompiler_inline_result.toString(32) + "_";
          return hook.memoizedState = identifierPrefix;
        },
        useHostTransitionStatus,
        useFormState: mountActionState,
        useActionState: mountActionState,
        useOptimistic: function(passthrough) {
          var hook = mountWorkInProgressHook();
          hook.memoizedState = hook.baseState = passthrough;
          var queue = {
            pending: null,
            lanes: 0,
            dispatch: null,
            lastRenderedReducer: null,
            lastRenderedState: null
          };
          hook.queue = queue;
          hook = dispatchOptimisticSetState.bind(
            null,
            currentlyRenderingFiber,
            true,
            queue
          );
          queue.dispatch = hook;
          return [passthrough, hook];
        },
        useMemoCache,
        useCacheRefresh: function() {
          return mountWorkInProgressHook().memoizedState = refreshCache.bind(
            null,
            currentlyRenderingFiber
          );
        },
        useEffectEvent: function(callback) {
          var hook = mountWorkInProgressHook(), ref = { impl: callback };
          hook.memoizedState = ref;
          return function() {
            if (0 !== (executionContext & 2))
              throw Error(formatProdErrorMessage(440));
            return ref.impl.apply(void 0, arguments);
          };
        }
      };
      var HooksDispatcherOnUpdate = {
        readContext,
        use,
        useCallback: updateCallback,
        useContext: readContext,
        useEffect: updateEffect,
        useImperativeHandle: updateImperativeHandle,
        useInsertionEffect: updateInsertionEffect,
        useLayoutEffect: updateLayoutEffect,
        useMemo: updateMemo,
        useReducer: updateReducer,
        useRef: updateRef,
        useState: function() {
          return updateReducer(basicStateReducer);
        },
        useDebugValue: mountDebugValue,
        useDeferredValue: function(value, initialValue) {
          var hook = updateWorkInProgressHook();
          return updateDeferredValueImpl(
            hook,
            currentHook.memoizedState,
            value,
            initialValue
          );
        },
        useTransition: function() {
          var booleanOrThenable = updateReducer(basicStateReducer)[0], start = updateWorkInProgressHook().memoizedState;
          return [
            "boolean" === typeof booleanOrThenable ? booleanOrThenable : useThenable(booleanOrThenable),
            start
          ];
        },
        useSyncExternalStore: updateSyncExternalStore,
        useId: updateId,
        useHostTransitionStatus,
        useFormState: updateActionState,
        useActionState: updateActionState,
        useOptimistic: function(passthrough, reducer) {
          var hook = updateWorkInProgressHook();
          return updateOptimisticImpl(hook, currentHook, passthrough, reducer);
        },
        useMemoCache,
        useCacheRefresh: updateRefresh
      };
      HooksDispatcherOnUpdate.useEffectEvent = updateEvent;
      var HooksDispatcherOnRerender = {
        readContext,
        use,
        useCallback: updateCallback,
        useContext: readContext,
        useEffect: updateEffect,
        useImperativeHandle: updateImperativeHandle,
        useInsertionEffect: updateInsertionEffect,
        useLayoutEffect: updateLayoutEffect,
        useMemo: updateMemo,
        useReducer: rerenderReducer,
        useRef: updateRef,
        useState: function() {
          return rerenderReducer(basicStateReducer);
        },
        useDebugValue: mountDebugValue,
        useDeferredValue: function(value, initialValue) {
          var hook = updateWorkInProgressHook();
          return null === currentHook ? mountDeferredValueImpl(hook, value, initialValue) : updateDeferredValueImpl(
            hook,
            currentHook.memoizedState,
            value,
            initialValue
          );
        },
        useTransition: function() {
          var booleanOrThenable = rerenderReducer(basicStateReducer)[0], start = updateWorkInProgressHook().memoizedState;
          return [
            "boolean" === typeof booleanOrThenable ? booleanOrThenable : useThenable(booleanOrThenable),
            start
          ];
        },
        useSyncExternalStore: updateSyncExternalStore,
        useId: updateId,
        useHostTransitionStatus,
        useFormState: rerenderActionState,
        useActionState: rerenderActionState,
        useOptimistic: function(passthrough, reducer) {
          var hook = updateWorkInProgressHook();
          if (null !== currentHook)
            return updateOptimisticImpl(hook, currentHook, passthrough, reducer);
          hook.baseState = passthrough;
          return [passthrough, hook.queue.dispatch];
        },
        useMemoCache,
        useCacheRefresh: updateRefresh
      };
      HooksDispatcherOnRerender.useEffectEvent = updateEvent;
      function applyDerivedStateFromProps(workInProgress2, ctor, getDerivedStateFromProps, nextProps) {
        ctor = workInProgress2.memoizedState;
        getDerivedStateFromProps = getDerivedStateFromProps(nextProps, ctor);
        getDerivedStateFromProps = null === getDerivedStateFromProps || void 0 === getDerivedStateFromProps ? ctor : assign({}, ctor, getDerivedStateFromProps);
        workInProgress2.memoizedState = getDerivedStateFromProps;
        0 === workInProgress2.lanes && (workInProgress2.updateQueue.baseState = getDerivedStateFromProps);
      }
      var classComponentUpdater = {
        enqueueSetState: function(inst, payload, callback) {
          inst = inst._reactInternals;
          var lane = requestUpdateLane(), update = createUpdate(lane);
          update.payload = payload;
          void 0 !== callback && null !== callback && (update.callback = callback);
          payload = enqueueUpdate(inst, update, lane);
          null !== payload && (scheduleUpdateOnFiber(payload, inst, lane), entangleTransitions(payload, inst, lane));
        },
        enqueueReplaceState: function(inst, payload, callback) {
          inst = inst._reactInternals;
          var lane = requestUpdateLane(), update = createUpdate(lane);
          update.tag = 1;
          update.payload = payload;
          void 0 !== callback && null !== callback && (update.callback = callback);
          payload = enqueueUpdate(inst, update, lane);
          null !== payload && (scheduleUpdateOnFiber(payload, inst, lane), entangleTransitions(payload, inst, lane));
        },
        enqueueForceUpdate: function(inst, callback) {
          inst = inst._reactInternals;
          var lane = requestUpdateLane(), update = createUpdate(lane);
          update.tag = 2;
          void 0 !== callback && null !== callback && (update.callback = callback);
          callback = enqueueUpdate(inst, update, lane);
          null !== callback && (scheduleUpdateOnFiber(callback, inst, lane), entangleTransitions(callback, inst, lane));
        }
      };
      function checkShouldComponentUpdate(workInProgress2, ctor, oldProps, newProps, oldState, newState, nextContext) {
        workInProgress2 = workInProgress2.stateNode;
        return "function" === typeof workInProgress2.shouldComponentUpdate ? workInProgress2.shouldComponentUpdate(newProps, newState, nextContext) : ctor.prototype && ctor.prototype.isPureReactComponent ? !shallowEqual(oldProps, newProps) || !shallowEqual(oldState, newState) : true;
      }
      function callComponentWillReceiveProps(workInProgress2, instance, newProps, nextContext) {
        workInProgress2 = instance.state;
        "function" === typeof instance.componentWillReceiveProps && instance.componentWillReceiveProps(newProps, nextContext);
        "function" === typeof instance.UNSAFE_componentWillReceiveProps && instance.UNSAFE_componentWillReceiveProps(newProps, nextContext);
        instance.state !== workInProgress2 && classComponentUpdater.enqueueReplaceState(instance, instance.state, null);
      }
      function resolveClassComponentProps(Component, baseProps) {
        var newProps = baseProps;
        if ("ref" in baseProps) {
          newProps = {};
          for (var propName in baseProps)
            "ref" !== propName && (newProps[propName] = baseProps[propName]);
        }
        if (Component = Component.defaultProps) {
          newProps === baseProps && (newProps = assign({}, newProps));
          for (var propName$73 in Component)
            void 0 === newProps[propName$73] && (newProps[propName$73] = Component[propName$73]);
        }
        return newProps;
      }
      function defaultOnUncaughtError(error) {
        reportGlobalError(error);
      }
      function defaultOnCaughtError(error) {
        console.error(error);
      }
      function defaultOnRecoverableError(error) {
        reportGlobalError(error);
      }
      function logUncaughtError(root3, errorInfo) {
        try {
          var onUncaughtError = root3.onUncaughtError;
          onUncaughtError(errorInfo.value, { componentStack: errorInfo.stack });
        } catch (e$74) {
          setTimeout(function() {
            throw e$74;
          });
        }
      }
      function logCaughtError(root3, boundary, errorInfo) {
        try {
          var onCaughtError = root3.onCaughtError;
          onCaughtError(errorInfo.value, {
            componentStack: errorInfo.stack,
            errorBoundary: 1 === boundary.tag ? boundary.stateNode : null
          });
        } catch (e$75) {
          setTimeout(function() {
            throw e$75;
          });
        }
      }
      function createRootErrorUpdate(root3, errorInfo, lane) {
        lane = createUpdate(lane);
        lane.tag = 3;
        lane.payload = { element: null };
        lane.callback = function() {
          logUncaughtError(root3, errorInfo);
        };
        return lane;
      }
      function createClassErrorUpdate(lane) {
        lane = createUpdate(lane);
        lane.tag = 3;
        return lane;
      }
      function initializeClassErrorUpdate(update, root3, fiber, errorInfo) {
        var getDerivedStateFromError = fiber.type.getDerivedStateFromError;
        if ("function" === typeof getDerivedStateFromError) {
          var error = errorInfo.value;
          update.payload = function() {
            return getDerivedStateFromError(error);
          };
          update.callback = function() {
            logCaughtError(root3, fiber, errorInfo);
          };
        }
        var inst = fiber.stateNode;
        null !== inst && "function" === typeof inst.componentDidCatch && (update.callback = function() {
          logCaughtError(root3, fiber, errorInfo);
          "function" !== typeof getDerivedStateFromError && (null === legacyErrorBoundariesThatAlreadyFailed ? legacyErrorBoundariesThatAlreadyFailed = /* @__PURE__ */ new Set([this]) : legacyErrorBoundariesThatAlreadyFailed.add(this));
          var stack = errorInfo.stack;
          this.componentDidCatch(errorInfo.value, {
            componentStack: null !== stack ? stack : ""
          });
        });
      }
      function throwException(root3, returnFiber, sourceFiber, value, rootRenderLanes) {
        sourceFiber.flags |= 32768;
        if (null !== value && "object" === typeof value && "function" === typeof value.then) {
          returnFiber = sourceFiber.alternate;
          null !== returnFiber && propagateParentContextChanges(
            returnFiber,
            sourceFiber,
            rootRenderLanes,
            true
          );
          sourceFiber = suspenseHandlerStackCursor.current;
          if (null !== sourceFiber) {
            switch (sourceFiber.tag) {
              case 31:
              case 13:
                return null === shellBoundary ? renderDidSuspendDelayIfPossible() : null === sourceFiber.alternate && 0 === workInProgressRootExitStatus && (workInProgressRootExitStatus = 3), sourceFiber.flags &= -257, sourceFiber.flags |= 65536, sourceFiber.lanes = rootRenderLanes, value === noopSuspenseyCommitThenable ? sourceFiber.flags |= 16384 : (returnFiber = sourceFiber.updateQueue, null === returnFiber ? sourceFiber.updateQueue = /* @__PURE__ */ new Set([value]) : returnFiber.add(value), attachPingListener(root3, value, rootRenderLanes)), false;
              case 22:
                return sourceFiber.flags |= 65536, value === noopSuspenseyCommitThenable ? sourceFiber.flags |= 16384 : (returnFiber = sourceFiber.updateQueue, null === returnFiber ? (returnFiber = {
                  transitions: null,
                  markerInstances: null,
                  retryQueue: /* @__PURE__ */ new Set([value])
                }, sourceFiber.updateQueue = returnFiber) : (sourceFiber = returnFiber.retryQueue, null === sourceFiber ? returnFiber.retryQueue = /* @__PURE__ */ new Set([value]) : sourceFiber.add(value)), attachPingListener(root3, value, rootRenderLanes)), false;
            }
            throw Error(formatProdErrorMessage(435, sourceFiber.tag));
          }
          attachPingListener(root3, value, rootRenderLanes);
          renderDidSuspendDelayIfPossible();
          return false;
        }
        if (isHydrating)
          return returnFiber = suspenseHandlerStackCursor.current, null !== returnFiber ? (0 === (returnFiber.flags & 65536) && (returnFiber.flags |= 256), returnFiber.flags |= 65536, returnFiber.lanes = rootRenderLanes, value !== HydrationMismatchException && (root3 = Error(formatProdErrorMessage(422), { cause: value }), queueHydrationError(createCapturedValueAtFiber(root3, sourceFiber)))) : (value !== HydrationMismatchException && (returnFiber = Error(formatProdErrorMessage(423), {
            cause: value
          }), queueHydrationError(
            createCapturedValueAtFiber(returnFiber, sourceFiber)
          )), root3 = root3.current.alternate, root3.flags |= 65536, rootRenderLanes &= -rootRenderLanes, root3.lanes |= rootRenderLanes, value = createCapturedValueAtFiber(value, sourceFiber), rootRenderLanes = createRootErrorUpdate(
            root3.stateNode,
            value,
            rootRenderLanes
          ), enqueueCapturedUpdate(root3, rootRenderLanes), 4 !== workInProgressRootExitStatus && (workInProgressRootExitStatus = 2)), false;
        var wrapperError = Error(formatProdErrorMessage(520), { cause: value });
        wrapperError = createCapturedValueAtFiber(wrapperError, sourceFiber);
        null === workInProgressRootConcurrentErrors ? workInProgressRootConcurrentErrors = [wrapperError] : workInProgressRootConcurrentErrors.push(wrapperError);
        4 !== workInProgressRootExitStatus && (workInProgressRootExitStatus = 2);
        if (null === returnFiber)
          return true;
        value = createCapturedValueAtFiber(value, sourceFiber);
        sourceFiber = returnFiber;
        do {
          switch (sourceFiber.tag) {
            case 3:
              return sourceFiber.flags |= 65536, root3 = rootRenderLanes & -rootRenderLanes, sourceFiber.lanes |= root3, root3 = createRootErrorUpdate(sourceFiber.stateNode, value, root3), enqueueCapturedUpdate(sourceFiber, root3), false;
            case 1:
              if (returnFiber = sourceFiber.type, wrapperError = sourceFiber.stateNode, 0 === (sourceFiber.flags & 128) && ("function" === typeof returnFiber.getDerivedStateFromError || null !== wrapperError && "function" === typeof wrapperError.componentDidCatch && (null === legacyErrorBoundariesThatAlreadyFailed || !legacyErrorBoundariesThatAlreadyFailed.has(wrapperError))))
                return sourceFiber.flags |= 65536, rootRenderLanes &= -rootRenderLanes, sourceFiber.lanes |= rootRenderLanes, rootRenderLanes = createClassErrorUpdate(rootRenderLanes), initializeClassErrorUpdate(
                  rootRenderLanes,
                  root3,
                  sourceFiber,
                  value
                ), enqueueCapturedUpdate(sourceFiber, rootRenderLanes), false;
          }
          sourceFiber = sourceFiber.return;
        } while (null !== sourceFiber);
        return false;
      }
      var SelectiveHydrationException = Error(formatProdErrorMessage(461));
      var didReceiveUpdate = false;
      function reconcileChildren(current, workInProgress2, nextChildren, renderLanes2) {
        workInProgress2.child = null === current ? mountChildFibers(workInProgress2, null, nextChildren, renderLanes2) : reconcileChildFibers(
          workInProgress2,
          current.child,
          nextChildren,
          renderLanes2
        );
      }
      function updateForwardRef(current, workInProgress2, Component, nextProps, renderLanes2) {
        Component = Component.render;
        var ref = workInProgress2.ref;
        if ("ref" in nextProps) {
          var propsWithoutRef = {};
          for (var key in nextProps)
            "ref" !== key && (propsWithoutRef[key] = nextProps[key]);
        } else
          propsWithoutRef = nextProps;
        prepareToReadContext(workInProgress2);
        nextProps = renderWithHooks(
          current,
          workInProgress2,
          Component,
          propsWithoutRef,
          ref,
          renderLanes2
        );
        key = checkDidRenderIdHook();
        if (null !== current && !didReceiveUpdate)
          return bailoutHooks(current, workInProgress2, renderLanes2), bailoutOnAlreadyFinishedWork(current, workInProgress2, renderLanes2);
        isHydrating && key && pushMaterializedTreeId(workInProgress2);
        workInProgress2.flags |= 1;
        reconcileChildren(current, workInProgress2, nextProps, renderLanes2);
        return workInProgress2.child;
      }
      function updateMemoComponent(current, workInProgress2, Component, nextProps, renderLanes2) {
        if (null === current) {
          var type = Component.type;
          if ("function" === typeof type && !shouldConstruct(type) && void 0 === type.defaultProps && null === Component.compare)
            return workInProgress2.tag = 15, workInProgress2.type = type, updateSimpleMemoComponent(
              current,
              workInProgress2,
              type,
              nextProps,
              renderLanes2
            );
          current = createFiberFromTypeAndProps(
            Component.type,
            null,
            nextProps,
            workInProgress2,
            workInProgress2.mode,
            renderLanes2
          );
          current.ref = workInProgress2.ref;
          current.return = workInProgress2;
          return workInProgress2.child = current;
        }
        type = current.child;
        if (!checkScheduledUpdateOrContext(current, renderLanes2)) {
          var prevProps = type.memoizedProps;
          Component = Component.compare;
          Component = null !== Component ? Component : shallowEqual;
          if (Component(prevProps, nextProps) && current.ref === workInProgress2.ref)
            return bailoutOnAlreadyFinishedWork(current, workInProgress2, renderLanes2);
        }
        workInProgress2.flags |= 1;
        current = createWorkInProgress(type, nextProps);
        current.ref = workInProgress2.ref;
        current.return = workInProgress2;
        return workInProgress2.child = current;
      }
      function updateSimpleMemoComponent(current, workInProgress2, Component, nextProps, renderLanes2) {
        if (null !== current) {
          var prevProps = current.memoizedProps;
          if (shallowEqual(prevProps, nextProps) && current.ref === workInProgress2.ref)
            if (didReceiveUpdate = false, workInProgress2.pendingProps = nextProps = prevProps, checkScheduledUpdateOrContext(current, renderLanes2))
              0 !== (current.flags & 131072) && (didReceiveUpdate = true);
            else
              return workInProgress2.lanes = current.lanes, bailoutOnAlreadyFinishedWork(current, workInProgress2, renderLanes2);
        }
        return updateFunctionComponent(
          current,
          workInProgress2,
          Component,
          nextProps,
          renderLanes2
        );
      }
      function updateOffscreenComponent(current, workInProgress2, renderLanes2, nextProps) {
        var nextChildren = nextProps.children, prevState = null !== current ? current.memoizedState : null;
        null === current && null === workInProgress2.stateNode && (workInProgress2.stateNode = {
          _visibility: 1,
          _pendingMarkers: null,
          _retryCache: null,
          _transitions: null
        });
        if ("hidden" === nextProps.mode) {
          if (0 !== (workInProgress2.flags & 128)) {
            prevState = null !== prevState ? prevState.baseLanes | renderLanes2 : renderLanes2;
            if (null !== current) {
              nextProps = workInProgress2.child = current.child;
              for (nextChildren = 0; null !== nextProps; )
                nextChildren = nextChildren | nextProps.lanes | nextProps.childLanes, nextProps = nextProps.sibling;
              nextProps = nextChildren & ~prevState;
            } else
              nextProps = 0, workInProgress2.child = null;
            return deferHiddenOffscreenComponent(
              current,
              workInProgress2,
              prevState,
              renderLanes2,
              nextProps
            );
          }
          if (0 !== (renderLanes2 & 536870912))
            workInProgress2.memoizedState = { baseLanes: 0, cachePool: null }, null !== current && pushTransition(
              workInProgress2,
              null !== prevState ? prevState.cachePool : null
            ), null !== prevState ? pushHiddenContext(workInProgress2, prevState) : reuseHiddenContextOnStack(), pushOffscreenSuspenseHandler(workInProgress2);
          else
            return nextProps = workInProgress2.lanes = 536870912, deferHiddenOffscreenComponent(
              current,
              workInProgress2,
              null !== prevState ? prevState.baseLanes | renderLanes2 : renderLanes2,
              renderLanes2,
              nextProps
            );
        } else
          null !== prevState ? (pushTransition(workInProgress2, prevState.cachePool), pushHiddenContext(workInProgress2, prevState), reuseSuspenseHandlerOnStack(workInProgress2), workInProgress2.memoizedState = null) : (null !== current && pushTransition(workInProgress2, null), reuseHiddenContextOnStack(), reuseSuspenseHandlerOnStack(workInProgress2));
        reconcileChildren(current, workInProgress2, nextChildren, renderLanes2);
        return workInProgress2.child;
      }
      function bailoutOffscreenComponent(current, workInProgress2) {
        null !== current && 22 === current.tag || null !== workInProgress2.stateNode || (workInProgress2.stateNode = {
          _visibility: 1,
          _pendingMarkers: null,
          _retryCache: null,
          _transitions: null
        });
        return workInProgress2.sibling;
      }
      function deferHiddenOffscreenComponent(current, workInProgress2, nextBaseLanes, renderLanes2, remainingChildLanes) {
        var JSCompiler_inline_result = peekCacheFromPool();
        JSCompiler_inline_result = null === JSCompiler_inline_result ? null : { parent: CacheContext._currentValue, pool: JSCompiler_inline_result };
        workInProgress2.memoizedState = {
          baseLanes: nextBaseLanes,
          cachePool: JSCompiler_inline_result
        };
        null !== current && pushTransition(workInProgress2, null);
        reuseHiddenContextOnStack();
        pushOffscreenSuspenseHandler(workInProgress2);
        null !== current && propagateParentContextChanges(current, workInProgress2, renderLanes2, true);
        workInProgress2.childLanes = remainingChildLanes;
        return null;
      }
      function mountActivityChildren(workInProgress2, nextProps) {
        nextProps = mountWorkInProgressOffscreenFiber(
          { mode: nextProps.mode, children: nextProps.children },
          workInProgress2.mode
        );
        nextProps.ref = workInProgress2.ref;
        workInProgress2.child = nextProps;
        nextProps.return = workInProgress2;
        return nextProps;
      }
      function retryActivityComponentWithoutHydrating(current, workInProgress2, renderLanes2) {
        reconcileChildFibers(workInProgress2, current.child, null, renderLanes2);
        current = mountActivityChildren(workInProgress2, workInProgress2.pendingProps);
        current.flags |= 2;
        popSuspenseHandler(workInProgress2);
        workInProgress2.memoizedState = null;
        return current;
      }
      function updateActivityComponent(current, workInProgress2, renderLanes2) {
        var nextProps = workInProgress2.pendingProps, didSuspend = 0 !== (workInProgress2.flags & 128);
        workInProgress2.flags &= -129;
        if (null === current) {
          if (isHydrating) {
            if ("hidden" === nextProps.mode)
              return current = mountActivityChildren(workInProgress2, nextProps), workInProgress2.lanes = 536870912, bailoutOffscreenComponent(null, current);
            pushDehydratedActivitySuspenseHandler(workInProgress2);
            (current = nextHydratableInstance) ? (current = canHydrateHydrationBoundary(
              current,
              rootOrSingletonContext
            ), current = null !== current && "&" === current.data ? current : null, null !== current && (workInProgress2.memoizedState = {
              dehydrated: current,
              treeContext: null !== treeContextProvider ? { id: treeContextId, overflow: treeContextOverflow } : null,
              retryLane: 536870912,
              hydrationErrors: null
            }, renderLanes2 = createFiberFromDehydratedFragment(current), renderLanes2.return = workInProgress2, workInProgress2.child = renderLanes2, hydrationParentFiber = workInProgress2, nextHydratableInstance = null)) : current = null;
            if (null === current)
              throw throwOnHydrationMismatch(workInProgress2);
            workInProgress2.lanes = 536870912;
            return null;
          }
          return mountActivityChildren(workInProgress2, nextProps);
        }
        var prevState = current.memoizedState;
        if (null !== prevState) {
          var dehydrated = prevState.dehydrated;
          pushDehydratedActivitySuspenseHandler(workInProgress2);
          if (didSuspend)
            if (workInProgress2.flags & 256)
              workInProgress2.flags &= -257, workInProgress2 = retryActivityComponentWithoutHydrating(
                current,
                workInProgress2,
                renderLanes2
              );
            else if (null !== workInProgress2.memoizedState)
              workInProgress2.child = current.child, workInProgress2.flags |= 128, workInProgress2 = null;
            else
              throw Error(formatProdErrorMessage(558));
          else if (didReceiveUpdate || propagateParentContextChanges(current, workInProgress2, renderLanes2, false), didSuspend = 0 !== (renderLanes2 & current.childLanes), didReceiveUpdate || didSuspend) {
            nextProps = workInProgressRoot;
            if (null !== nextProps && (dehydrated = getBumpedLaneForHydration(nextProps, renderLanes2), 0 !== dehydrated && dehydrated !== prevState.retryLane))
              throw prevState.retryLane = dehydrated, enqueueConcurrentRenderForLane(current, dehydrated), scheduleUpdateOnFiber(nextProps, current, dehydrated), SelectiveHydrationException;
            renderDidSuspendDelayIfPossible();
            workInProgress2 = retryActivityComponentWithoutHydrating(
              current,
              workInProgress2,
              renderLanes2
            );
          } else
            current = prevState.treeContext, nextHydratableInstance = getNextHydratable(dehydrated.nextSibling), hydrationParentFiber = workInProgress2, isHydrating = true, hydrationErrors = null, rootOrSingletonContext = false, null !== current && restoreSuspendedTreeContext(workInProgress2, current), workInProgress2 = mountActivityChildren(workInProgress2, nextProps), workInProgress2.flags |= 4096;
          return workInProgress2;
        }
        current = createWorkInProgress(current.child, {
          mode: nextProps.mode,
          children: nextProps.children
        });
        current.ref = workInProgress2.ref;
        workInProgress2.child = current;
        current.return = workInProgress2;
        return current;
      }
      function markRef(current, workInProgress2) {
        var ref = workInProgress2.ref;
        if (null === ref)
          null !== current && null !== current.ref && (workInProgress2.flags |= 4194816);
        else {
          if ("function" !== typeof ref && "object" !== typeof ref)
            throw Error(formatProdErrorMessage(284));
          if (null === current || current.ref !== ref)
            workInProgress2.flags |= 4194816;
        }
      }
      function updateFunctionComponent(current, workInProgress2, Component, nextProps, renderLanes2) {
        prepareToReadContext(workInProgress2);
        Component = renderWithHooks(
          current,
          workInProgress2,
          Component,
          nextProps,
          void 0,
          renderLanes2
        );
        nextProps = checkDidRenderIdHook();
        if (null !== current && !didReceiveUpdate)
          return bailoutHooks(current, workInProgress2, renderLanes2), bailoutOnAlreadyFinishedWork(current, workInProgress2, renderLanes2);
        isHydrating && nextProps && pushMaterializedTreeId(workInProgress2);
        workInProgress2.flags |= 1;
        reconcileChildren(current, workInProgress2, Component, renderLanes2);
        return workInProgress2.child;
      }
      function replayFunctionComponent(current, workInProgress2, nextProps, Component, secondArg, renderLanes2) {
        prepareToReadContext(workInProgress2);
        workInProgress2.updateQueue = null;
        nextProps = renderWithHooksAgain(
          workInProgress2,
          Component,
          nextProps,
          secondArg
        );
        finishRenderingHooks(current);
        Component = checkDidRenderIdHook();
        if (null !== current && !didReceiveUpdate)
          return bailoutHooks(current, workInProgress2, renderLanes2), bailoutOnAlreadyFinishedWork(current, workInProgress2, renderLanes2);
        isHydrating && Component && pushMaterializedTreeId(workInProgress2);
        workInProgress2.flags |= 1;
        reconcileChildren(current, workInProgress2, nextProps, renderLanes2);
        return workInProgress2.child;
      }
      function updateClassComponent(current, workInProgress2, Component, nextProps, renderLanes2) {
        prepareToReadContext(workInProgress2);
        if (null === workInProgress2.stateNode) {
          var context = emptyContextObject, contextType = Component.contextType;
          "object" === typeof contextType && null !== contextType && (context = readContext(contextType));
          context = new Component(nextProps, context);
          workInProgress2.memoizedState = null !== context.state && void 0 !== context.state ? context.state : null;
          context.updater = classComponentUpdater;
          workInProgress2.stateNode = context;
          context._reactInternals = workInProgress2;
          context = workInProgress2.stateNode;
          context.props = nextProps;
          context.state = workInProgress2.memoizedState;
          context.refs = {};
          initializeUpdateQueue(workInProgress2);
          contextType = Component.contextType;
          context.context = "object" === typeof contextType && null !== contextType ? readContext(contextType) : emptyContextObject;
          context.state = workInProgress2.memoizedState;
          contextType = Component.getDerivedStateFromProps;
          "function" === typeof contextType && (applyDerivedStateFromProps(
            workInProgress2,
            Component,
            contextType,
            nextProps
          ), context.state = workInProgress2.memoizedState);
          "function" === typeof Component.getDerivedStateFromProps || "function" === typeof context.getSnapshotBeforeUpdate || "function" !== typeof context.UNSAFE_componentWillMount && "function" !== typeof context.componentWillMount || (contextType = context.state, "function" === typeof context.componentWillMount && context.componentWillMount(), "function" === typeof context.UNSAFE_componentWillMount && context.UNSAFE_componentWillMount(), contextType !== context.state && classComponentUpdater.enqueueReplaceState(context, context.state, null), processUpdateQueue(workInProgress2, nextProps, context, renderLanes2), suspendIfUpdateReadFromEntangledAsyncAction(), context.state = workInProgress2.memoizedState);
          "function" === typeof context.componentDidMount && (workInProgress2.flags |= 4194308);
          nextProps = true;
        } else if (null === current) {
          context = workInProgress2.stateNode;
          var unresolvedOldProps = workInProgress2.memoizedProps, oldProps = resolveClassComponentProps(Component, unresolvedOldProps);
          context.props = oldProps;
          var oldContext = context.context, contextType$jscomp$0 = Component.contextType;
          contextType = emptyContextObject;
          "object" === typeof contextType$jscomp$0 && null !== contextType$jscomp$0 && (contextType = readContext(contextType$jscomp$0));
          var getDerivedStateFromProps = Component.getDerivedStateFromProps;
          contextType$jscomp$0 = "function" === typeof getDerivedStateFromProps || "function" === typeof context.getSnapshotBeforeUpdate;
          unresolvedOldProps = workInProgress2.pendingProps !== unresolvedOldProps;
          contextType$jscomp$0 || "function" !== typeof context.UNSAFE_componentWillReceiveProps && "function" !== typeof context.componentWillReceiveProps || (unresolvedOldProps || oldContext !== contextType) && callComponentWillReceiveProps(
            workInProgress2,
            context,
            nextProps,
            contextType
          );
          hasForceUpdate = false;
          var oldState = workInProgress2.memoizedState;
          context.state = oldState;
          processUpdateQueue(workInProgress2, nextProps, context, renderLanes2);
          suspendIfUpdateReadFromEntangledAsyncAction();
          oldContext = workInProgress2.memoizedState;
          unresolvedOldProps || oldState !== oldContext || hasForceUpdate ? ("function" === typeof getDerivedStateFromProps && (applyDerivedStateFromProps(
            workInProgress2,
            Component,
            getDerivedStateFromProps,
            nextProps
          ), oldContext = workInProgress2.memoizedState), (oldProps = hasForceUpdate || checkShouldComponentUpdate(
            workInProgress2,
            Component,
            oldProps,
            nextProps,
            oldState,
            oldContext,
            contextType
          )) ? (contextType$jscomp$0 || "function" !== typeof context.UNSAFE_componentWillMount && "function" !== typeof context.componentWillMount || ("function" === typeof context.componentWillMount && context.componentWillMount(), "function" === typeof context.UNSAFE_componentWillMount && context.UNSAFE_componentWillMount()), "function" === typeof context.componentDidMount && (workInProgress2.flags |= 4194308)) : ("function" === typeof context.componentDidMount && (workInProgress2.flags |= 4194308), workInProgress2.memoizedProps = nextProps, workInProgress2.memoizedState = oldContext), context.props = nextProps, context.state = oldContext, context.context = contextType, nextProps = oldProps) : ("function" === typeof context.componentDidMount && (workInProgress2.flags |= 4194308), nextProps = false);
        } else {
          context = workInProgress2.stateNode;
          cloneUpdateQueue(current, workInProgress2);
          contextType = workInProgress2.memoizedProps;
          contextType$jscomp$0 = resolveClassComponentProps(Component, contextType);
          context.props = contextType$jscomp$0;
          getDerivedStateFromProps = workInProgress2.pendingProps;
          oldState = context.context;
          oldContext = Component.contextType;
          oldProps = emptyContextObject;
          "object" === typeof oldContext && null !== oldContext && (oldProps = readContext(oldContext));
          unresolvedOldProps = Component.getDerivedStateFromProps;
          (oldContext = "function" === typeof unresolvedOldProps || "function" === typeof context.getSnapshotBeforeUpdate) || "function" !== typeof context.UNSAFE_componentWillReceiveProps && "function" !== typeof context.componentWillReceiveProps || (contextType !== getDerivedStateFromProps || oldState !== oldProps) && callComponentWillReceiveProps(
            workInProgress2,
            context,
            nextProps,
            oldProps
          );
          hasForceUpdate = false;
          oldState = workInProgress2.memoizedState;
          context.state = oldState;
          processUpdateQueue(workInProgress2, nextProps, context, renderLanes2);
          suspendIfUpdateReadFromEntangledAsyncAction();
          var newState = workInProgress2.memoizedState;
          contextType !== getDerivedStateFromProps || oldState !== newState || hasForceUpdate || null !== current && null !== current.dependencies && checkIfContextChanged(current.dependencies) ? ("function" === typeof unresolvedOldProps && (applyDerivedStateFromProps(
            workInProgress2,
            Component,
            unresolvedOldProps,
            nextProps
          ), newState = workInProgress2.memoizedState), (contextType$jscomp$0 = hasForceUpdate || checkShouldComponentUpdate(
            workInProgress2,
            Component,
            contextType$jscomp$0,
            nextProps,
            oldState,
            newState,
            oldProps
          ) || null !== current && null !== current.dependencies && checkIfContextChanged(current.dependencies)) ? (oldContext || "function" !== typeof context.UNSAFE_componentWillUpdate && "function" !== typeof context.componentWillUpdate || ("function" === typeof context.componentWillUpdate && context.componentWillUpdate(nextProps, newState, oldProps), "function" === typeof context.UNSAFE_componentWillUpdate && context.UNSAFE_componentWillUpdate(
            nextProps,
            newState,
            oldProps
          )), "function" === typeof context.componentDidUpdate && (workInProgress2.flags |= 4), "function" === typeof context.getSnapshotBeforeUpdate && (workInProgress2.flags |= 1024)) : ("function" !== typeof context.componentDidUpdate || contextType === current.memoizedProps && oldState === current.memoizedState || (workInProgress2.flags |= 4), "function" !== typeof context.getSnapshotBeforeUpdate || contextType === current.memoizedProps && oldState === current.memoizedState || (workInProgress2.flags |= 1024), workInProgress2.memoizedProps = nextProps, workInProgress2.memoizedState = newState), context.props = nextProps, context.state = newState, context.context = oldProps, nextProps = contextType$jscomp$0) : ("function" !== typeof context.componentDidUpdate || contextType === current.memoizedProps && oldState === current.memoizedState || (workInProgress2.flags |= 4), "function" !== typeof context.getSnapshotBeforeUpdate || contextType === current.memoizedProps && oldState === current.memoizedState || (workInProgress2.flags |= 1024), nextProps = false);
        }
        context = nextProps;
        markRef(current, workInProgress2);
        nextProps = 0 !== (workInProgress2.flags & 128);
        context || nextProps ? (context = workInProgress2.stateNode, Component = nextProps && "function" !== typeof Component.getDerivedStateFromError ? null : context.render(), workInProgress2.flags |= 1, null !== current && nextProps ? (workInProgress2.child = reconcileChildFibers(
          workInProgress2,
          current.child,
          null,
          renderLanes2
        ), workInProgress2.child = reconcileChildFibers(
          workInProgress2,
          null,
          Component,
          renderLanes2
        )) : reconcileChildren(current, workInProgress2, Component, renderLanes2), workInProgress2.memoizedState = context.state, current = workInProgress2.child) : current = bailoutOnAlreadyFinishedWork(
          current,
          workInProgress2,
          renderLanes2
        );
        return current;
      }
      function mountHostRootWithoutHydrating(current, workInProgress2, nextChildren, renderLanes2) {
        resetHydrationState();
        workInProgress2.flags |= 256;
        reconcileChildren(current, workInProgress2, nextChildren, renderLanes2);
        return workInProgress2.child;
      }
      var SUSPENDED_MARKER = {
        dehydrated: null,
        treeContext: null,
        retryLane: 0,
        hydrationErrors: null
      };
      function mountSuspenseOffscreenState(renderLanes2) {
        return { baseLanes: renderLanes2, cachePool: getSuspendedCache() };
      }
      function getRemainingWorkInPrimaryTree(current, primaryTreeDidDefer, renderLanes2) {
        current = null !== current ? current.childLanes & ~renderLanes2 : 0;
        primaryTreeDidDefer && (current |= workInProgressDeferredLane);
        return current;
      }
      function updateSuspenseComponent(current, workInProgress2, renderLanes2) {
        var nextProps = workInProgress2.pendingProps, showFallback = false, didSuspend = 0 !== (workInProgress2.flags & 128), JSCompiler_temp;
        (JSCompiler_temp = didSuspend) || (JSCompiler_temp = null !== current && null === current.memoizedState ? false : 0 !== (suspenseStackCursor.current & 2));
        JSCompiler_temp && (showFallback = true, workInProgress2.flags &= -129);
        JSCompiler_temp = 0 !== (workInProgress2.flags & 32);
        workInProgress2.flags &= -33;
        if (null === current) {
          if (isHydrating) {
            showFallback ? pushPrimaryTreeSuspenseHandler(workInProgress2) : reuseSuspenseHandlerOnStack(workInProgress2);
            (current = nextHydratableInstance) ? (current = canHydrateHydrationBoundary(
              current,
              rootOrSingletonContext
            ), current = null !== current && "&" !== current.data ? current : null, null !== current && (workInProgress2.memoizedState = {
              dehydrated: current,
              treeContext: null !== treeContextProvider ? { id: treeContextId, overflow: treeContextOverflow } : null,
              retryLane: 536870912,
              hydrationErrors: null
            }, renderLanes2 = createFiberFromDehydratedFragment(current), renderLanes2.return = workInProgress2, workInProgress2.child = renderLanes2, hydrationParentFiber = workInProgress2, nextHydratableInstance = null)) : current = null;
            if (null === current)
              throw throwOnHydrationMismatch(workInProgress2);
            isSuspenseInstanceFallback(current) ? workInProgress2.lanes = 32 : workInProgress2.lanes = 536870912;
            return null;
          }
          var nextPrimaryChildren = nextProps.children;
          nextProps = nextProps.fallback;
          if (showFallback)
            return reuseSuspenseHandlerOnStack(workInProgress2), showFallback = workInProgress2.mode, nextPrimaryChildren = mountWorkInProgressOffscreenFiber(
              { mode: "hidden", children: nextPrimaryChildren },
              showFallback
            ), nextProps = createFiberFromFragment(
              nextProps,
              showFallback,
              renderLanes2,
              null
            ), nextPrimaryChildren.return = workInProgress2, nextProps.return = workInProgress2, nextPrimaryChildren.sibling = nextProps, workInProgress2.child = nextPrimaryChildren, nextProps = workInProgress2.child, nextProps.memoizedState = mountSuspenseOffscreenState(renderLanes2), nextProps.childLanes = getRemainingWorkInPrimaryTree(
              current,
              JSCompiler_temp,
              renderLanes2
            ), workInProgress2.memoizedState = SUSPENDED_MARKER, bailoutOffscreenComponent(null, nextProps);
          pushPrimaryTreeSuspenseHandler(workInProgress2);
          return mountSuspensePrimaryChildren(workInProgress2, nextPrimaryChildren);
        }
        var prevState = current.memoizedState;
        if (null !== prevState && (nextPrimaryChildren = prevState.dehydrated, null !== nextPrimaryChildren)) {
          if (didSuspend)
            workInProgress2.flags & 256 ? (pushPrimaryTreeSuspenseHandler(workInProgress2), workInProgress2.flags &= -257, workInProgress2 = retrySuspenseComponentWithoutHydrating(
              current,
              workInProgress2,
              renderLanes2
            )) : null !== workInProgress2.memoizedState ? (reuseSuspenseHandlerOnStack(workInProgress2), workInProgress2.child = current.child, workInProgress2.flags |= 128, workInProgress2 = null) : (reuseSuspenseHandlerOnStack(workInProgress2), nextPrimaryChildren = nextProps.fallback, showFallback = workInProgress2.mode, nextProps = mountWorkInProgressOffscreenFiber(
              { mode: "visible", children: nextProps.children },
              showFallback
            ), nextPrimaryChildren = createFiberFromFragment(
              nextPrimaryChildren,
              showFallback,
              renderLanes2,
              null
            ), nextPrimaryChildren.flags |= 2, nextProps.return = workInProgress2, nextPrimaryChildren.return = workInProgress2, nextProps.sibling = nextPrimaryChildren, workInProgress2.child = nextProps, reconcileChildFibers(
              workInProgress2,
              current.child,
              null,
              renderLanes2
            ), nextProps = workInProgress2.child, nextProps.memoizedState = mountSuspenseOffscreenState(renderLanes2), nextProps.childLanes = getRemainingWorkInPrimaryTree(
              current,
              JSCompiler_temp,
              renderLanes2
            ), workInProgress2.memoizedState = SUSPENDED_MARKER, workInProgress2 = bailoutOffscreenComponent(null, nextProps));
          else if (pushPrimaryTreeSuspenseHandler(workInProgress2), isSuspenseInstanceFallback(nextPrimaryChildren)) {
            JSCompiler_temp = nextPrimaryChildren.nextSibling && nextPrimaryChildren.nextSibling.dataset;
            if (JSCompiler_temp)
              var digest = JSCompiler_temp.dgst;
            JSCompiler_temp = digest;
            nextProps = Error(formatProdErrorMessage(419));
            nextProps.stack = "";
            nextProps.digest = JSCompiler_temp;
            queueHydrationError({ value: nextProps, source: null, stack: null });
            workInProgress2 = retrySuspenseComponentWithoutHydrating(
              current,
              workInProgress2,
              renderLanes2
            );
          } else if (didReceiveUpdate || propagateParentContextChanges(current, workInProgress2, renderLanes2, false), JSCompiler_temp = 0 !== (renderLanes2 & current.childLanes), didReceiveUpdate || JSCompiler_temp) {
            JSCompiler_temp = workInProgressRoot;
            if (null !== JSCompiler_temp && (nextProps = getBumpedLaneForHydration(JSCompiler_temp, renderLanes2), 0 !== nextProps && nextProps !== prevState.retryLane))
              throw prevState.retryLane = nextProps, enqueueConcurrentRenderForLane(current, nextProps), scheduleUpdateOnFiber(JSCompiler_temp, current, nextProps), SelectiveHydrationException;
            isSuspenseInstancePending(nextPrimaryChildren) || renderDidSuspendDelayIfPossible();
            workInProgress2 = retrySuspenseComponentWithoutHydrating(
              current,
              workInProgress2,
              renderLanes2
            );
          } else
            isSuspenseInstancePending(nextPrimaryChildren) ? (workInProgress2.flags |= 192, workInProgress2.child = current.child, workInProgress2 = null) : (current = prevState.treeContext, nextHydratableInstance = getNextHydratable(
              nextPrimaryChildren.nextSibling
            ), hydrationParentFiber = workInProgress2, isHydrating = true, hydrationErrors = null, rootOrSingletonContext = false, null !== current && restoreSuspendedTreeContext(workInProgress2, current), workInProgress2 = mountSuspensePrimaryChildren(
              workInProgress2,
              nextProps.children
            ), workInProgress2.flags |= 4096);
          return workInProgress2;
        }
        if (showFallback)
          return reuseSuspenseHandlerOnStack(workInProgress2), nextPrimaryChildren = nextProps.fallback, showFallback = workInProgress2.mode, prevState = current.child, digest = prevState.sibling, nextProps = createWorkInProgress(prevState, {
            mode: "hidden",
            children: nextProps.children
          }), nextProps.subtreeFlags = prevState.subtreeFlags & 65011712, null !== digest ? nextPrimaryChildren = createWorkInProgress(
            digest,
            nextPrimaryChildren
          ) : (nextPrimaryChildren = createFiberFromFragment(
            nextPrimaryChildren,
            showFallback,
            renderLanes2,
            null
          ), nextPrimaryChildren.flags |= 2), nextPrimaryChildren.return = workInProgress2, nextProps.return = workInProgress2, nextProps.sibling = nextPrimaryChildren, workInProgress2.child = nextProps, bailoutOffscreenComponent(null, nextProps), nextProps = workInProgress2.child, nextPrimaryChildren = current.child.memoizedState, null === nextPrimaryChildren ? nextPrimaryChildren = mountSuspenseOffscreenState(renderLanes2) : (showFallback = nextPrimaryChildren.cachePool, null !== showFallback ? (prevState = CacheContext._currentValue, showFallback = showFallback.parent !== prevState ? { parent: prevState, pool: prevState } : showFallback) : showFallback = getSuspendedCache(), nextPrimaryChildren = {
            baseLanes: nextPrimaryChildren.baseLanes | renderLanes2,
            cachePool: showFallback
          }), nextProps.memoizedState = nextPrimaryChildren, nextProps.childLanes = getRemainingWorkInPrimaryTree(
            current,
            JSCompiler_temp,
            renderLanes2
          ), workInProgress2.memoizedState = SUSPENDED_MARKER, bailoutOffscreenComponent(current.child, nextProps);
        pushPrimaryTreeSuspenseHandler(workInProgress2);
        renderLanes2 = current.child;
        current = renderLanes2.sibling;
        renderLanes2 = createWorkInProgress(renderLanes2, {
          mode: "visible",
          children: nextProps.children
        });
        renderLanes2.return = workInProgress2;
        renderLanes2.sibling = null;
        null !== current && (JSCompiler_temp = workInProgress2.deletions, null === JSCompiler_temp ? (workInProgress2.deletions = [current], workInProgress2.flags |= 16) : JSCompiler_temp.push(current));
        workInProgress2.child = renderLanes2;
        workInProgress2.memoizedState = null;
        return renderLanes2;
      }
      function mountSuspensePrimaryChildren(workInProgress2, primaryChildren) {
        primaryChildren = mountWorkInProgressOffscreenFiber(
          { mode: "visible", children: primaryChildren },
          workInProgress2.mode
        );
        primaryChildren.return = workInProgress2;
        return workInProgress2.child = primaryChildren;
      }
      function mountWorkInProgressOffscreenFiber(offscreenProps, mode) {
        offscreenProps = createFiberImplClass(22, offscreenProps, null, mode);
        offscreenProps.lanes = 0;
        return offscreenProps;
      }
      function retrySuspenseComponentWithoutHydrating(current, workInProgress2, renderLanes2) {
        reconcileChildFibers(workInProgress2, current.child, null, renderLanes2);
        current = mountSuspensePrimaryChildren(
          workInProgress2,
          workInProgress2.pendingProps.children
        );
        current.flags |= 2;
        workInProgress2.memoizedState = null;
        return current;
      }
      function scheduleSuspenseWorkOnFiber(fiber, renderLanes2, propagationRoot) {
        fiber.lanes |= renderLanes2;
        var alternate = fiber.alternate;
        null !== alternate && (alternate.lanes |= renderLanes2);
        scheduleContextWorkOnParentPath(fiber.return, renderLanes2, propagationRoot);
      }
      function initSuspenseListRenderState(workInProgress2, isBackwards, tail, lastContentRow, tailMode, treeForkCount2) {
        var renderState = workInProgress2.memoizedState;
        null === renderState ? workInProgress2.memoizedState = {
          isBackwards,
          rendering: null,
          renderingStartTime: 0,
          last: lastContentRow,
          tail,
          tailMode,
          treeForkCount: treeForkCount2
        } : (renderState.isBackwards = isBackwards, renderState.rendering = null, renderState.renderingStartTime = 0, renderState.last = lastContentRow, renderState.tail = tail, renderState.tailMode = tailMode, renderState.treeForkCount = treeForkCount2);
      }
      function updateSuspenseListComponent(current, workInProgress2, renderLanes2) {
        var nextProps = workInProgress2.pendingProps, revealOrder = nextProps.revealOrder, tailMode = nextProps.tail;
        nextProps = nextProps.children;
        var suspenseContext = suspenseStackCursor.current, shouldForceFallback = 0 !== (suspenseContext & 2);
        shouldForceFallback ? (suspenseContext = suspenseContext & 1 | 2, workInProgress2.flags |= 128) : suspenseContext &= 1;
        push(suspenseStackCursor, suspenseContext);
        reconcileChildren(current, workInProgress2, nextProps, renderLanes2);
        nextProps = isHydrating ? treeForkCount : 0;
        if (!shouldForceFallback && null !== current && 0 !== (current.flags & 128))
          a:
            for (current = workInProgress2.child; null !== current; ) {
              if (13 === current.tag)
                null !== current.memoizedState && scheduleSuspenseWorkOnFiber(current, renderLanes2, workInProgress2);
              else if (19 === current.tag)
                scheduleSuspenseWorkOnFiber(current, renderLanes2, workInProgress2);
              else if (null !== current.child) {
                current.child.return = current;
                current = current.child;
                continue;
              }
              if (current === workInProgress2)
                break a;
              for (; null === current.sibling; ) {
                if (null === current.return || current.return === workInProgress2)
                  break a;
                current = current.return;
              }
              current.sibling.return = current.return;
              current = current.sibling;
            }
        switch (revealOrder) {
          case "forwards":
            renderLanes2 = workInProgress2.child;
            for (revealOrder = null; null !== renderLanes2; )
              current = renderLanes2.alternate, null !== current && null === findFirstSuspended(current) && (revealOrder = renderLanes2), renderLanes2 = renderLanes2.sibling;
            renderLanes2 = revealOrder;
            null === renderLanes2 ? (revealOrder = workInProgress2.child, workInProgress2.child = null) : (revealOrder = renderLanes2.sibling, renderLanes2.sibling = null);
            initSuspenseListRenderState(
              workInProgress2,
              false,
              revealOrder,
              renderLanes2,
              tailMode,
              nextProps
            );
            break;
          case "backwards":
          case "unstable_legacy-backwards":
            renderLanes2 = null;
            revealOrder = workInProgress2.child;
            for (workInProgress2.child = null; null !== revealOrder; ) {
              current = revealOrder.alternate;
              if (null !== current && null === findFirstSuspended(current)) {
                workInProgress2.child = revealOrder;
                break;
              }
              current = revealOrder.sibling;
              revealOrder.sibling = renderLanes2;
              renderLanes2 = revealOrder;
              revealOrder = current;
            }
            initSuspenseListRenderState(
              workInProgress2,
              true,
              renderLanes2,
              null,
              tailMode,
              nextProps
            );
            break;
          case "together":
            initSuspenseListRenderState(
              workInProgress2,
              false,
              null,
              null,
              void 0,
              nextProps
            );
            break;
          default:
            workInProgress2.memoizedState = null;
        }
        return workInProgress2.child;
      }
      function bailoutOnAlreadyFinishedWork(current, workInProgress2, renderLanes2) {
        null !== current && (workInProgress2.dependencies = current.dependencies);
        workInProgressRootSkippedLanes |= workInProgress2.lanes;
        if (0 === (renderLanes2 & workInProgress2.childLanes))
          if (null !== current) {
            if (propagateParentContextChanges(
              current,
              workInProgress2,
              renderLanes2,
              false
            ), 0 === (renderLanes2 & workInProgress2.childLanes))
              return null;
          } else
            return null;
        if (null !== current && workInProgress2.child !== current.child)
          throw Error(formatProdErrorMessage(153));
        if (null !== workInProgress2.child) {
          current = workInProgress2.child;
          renderLanes2 = createWorkInProgress(current, current.pendingProps);
          workInProgress2.child = renderLanes2;
          for (renderLanes2.return = workInProgress2; null !== current.sibling; )
            current = current.sibling, renderLanes2 = renderLanes2.sibling = createWorkInProgress(current, current.pendingProps), renderLanes2.return = workInProgress2;
          renderLanes2.sibling = null;
        }
        return workInProgress2.child;
      }
      function checkScheduledUpdateOrContext(current, renderLanes2) {
        if (0 !== (current.lanes & renderLanes2))
          return true;
        current = current.dependencies;
        return null !== current && checkIfContextChanged(current) ? true : false;
      }
      function attemptEarlyBailoutIfNoScheduledUpdate(current, workInProgress2, renderLanes2) {
        switch (workInProgress2.tag) {
          case 3:
            pushHostContainer(workInProgress2, workInProgress2.stateNode.containerInfo);
            pushProvider(workInProgress2, CacheContext, current.memoizedState.cache);
            resetHydrationState();
            break;
          case 27:
          case 5:
            pushHostContext(workInProgress2);
            break;
          case 4:
            pushHostContainer(workInProgress2, workInProgress2.stateNode.containerInfo);
            break;
          case 10:
            pushProvider(
              workInProgress2,
              workInProgress2.type,
              workInProgress2.memoizedProps.value
            );
            break;
          case 31:
            if (null !== workInProgress2.memoizedState)
              return workInProgress2.flags |= 128, pushDehydratedActivitySuspenseHandler(workInProgress2), null;
            break;
          case 13:
            var state$102 = workInProgress2.memoizedState;
            if (null !== state$102) {
              if (null !== state$102.dehydrated)
                return pushPrimaryTreeSuspenseHandler(workInProgress2), workInProgress2.flags |= 128, null;
              if (0 !== (renderLanes2 & workInProgress2.child.childLanes))
                return updateSuspenseComponent(current, workInProgress2, renderLanes2);
              pushPrimaryTreeSuspenseHandler(workInProgress2);
              current = bailoutOnAlreadyFinishedWork(
                current,
                workInProgress2,
                renderLanes2
              );
              return null !== current ? current.sibling : null;
            }
            pushPrimaryTreeSuspenseHandler(workInProgress2);
            break;
          case 19:
            var didSuspendBefore = 0 !== (current.flags & 128);
            state$102 = 0 !== (renderLanes2 & workInProgress2.childLanes);
            state$102 || (propagateParentContextChanges(
              current,
              workInProgress2,
              renderLanes2,
              false
            ), state$102 = 0 !== (renderLanes2 & workInProgress2.childLanes));
            if (didSuspendBefore) {
              if (state$102)
                return updateSuspenseListComponent(
                  current,
                  workInProgress2,
                  renderLanes2
                );
              workInProgress2.flags |= 128;
            }
            didSuspendBefore = workInProgress2.memoizedState;
            null !== didSuspendBefore && (didSuspendBefore.rendering = null, didSuspendBefore.tail = null, didSuspendBefore.lastEffect = null);
            push(suspenseStackCursor, suspenseStackCursor.current);
            if (state$102)
              break;
            else
              return null;
          case 22:
            return workInProgress2.lanes = 0, updateOffscreenComponent(
              current,
              workInProgress2,
              renderLanes2,
              workInProgress2.pendingProps
            );
          case 24:
            pushProvider(workInProgress2, CacheContext, current.memoizedState.cache);
        }
        return bailoutOnAlreadyFinishedWork(current, workInProgress2, renderLanes2);
      }
      function beginWork(current, workInProgress2, renderLanes2) {
        if (null !== current)
          if (current.memoizedProps !== workInProgress2.pendingProps)
            didReceiveUpdate = true;
          else {
            if (!checkScheduledUpdateOrContext(current, renderLanes2) && 0 === (workInProgress2.flags & 128))
              return didReceiveUpdate = false, attemptEarlyBailoutIfNoScheduledUpdate(
                current,
                workInProgress2,
                renderLanes2
              );
            didReceiveUpdate = 0 !== (current.flags & 131072) ? true : false;
          }
        else
          didReceiveUpdate = false, isHydrating && 0 !== (workInProgress2.flags & 1048576) && pushTreeId(workInProgress2, treeForkCount, workInProgress2.index);
        workInProgress2.lanes = 0;
        switch (workInProgress2.tag) {
          case 16:
            a: {
              var props = workInProgress2.pendingProps;
              current = resolveLazy(workInProgress2.elementType);
              workInProgress2.type = current;
              if ("function" === typeof current)
                shouldConstruct(current) ? (props = resolveClassComponentProps(current, props), workInProgress2.tag = 1, workInProgress2 = updateClassComponent(
                  null,
                  workInProgress2,
                  current,
                  props,
                  renderLanes2
                )) : (workInProgress2.tag = 0, workInProgress2 = updateFunctionComponent(
                  null,
                  workInProgress2,
                  current,
                  props,
                  renderLanes2
                ));
              else {
                if (void 0 !== current && null !== current) {
                  var $$typeof = current.$$typeof;
                  if ($$typeof === REACT_FORWARD_REF_TYPE) {
                    workInProgress2.tag = 11;
                    workInProgress2 = updateForwardRef(
                      null,
                      workInProgress2,
                      current,
                      props,
                      renderLanes2
                    );
                    break a;
                  } else if ($$typeof === REACT_MEMO_TYPE) {
                    workInProgress2.tag = 14;
                    workInProgress2 = updateMemoComponent(
                      null,
                      workInProgress2,
                      current,
                      props,
                      renderLanes2
                    );
                    break a;
                  }
                }
                workInProgress2 = getComponentNameFromType(current) || current;
                throw Error(formatProdErrorMessage(306, workInProgress2, ""));
              }
            }
            return workInProgress2;
          case 0:
            return updateFunctionComponent(
              current,
              workInProgress2,
              workInProgress2.type,
              workInProgress2.pendingProps,
              renderLanes2
            );
          case 1:
            return props = workInProgress2.type, $$typeof = resolveClassComponentProps(
              props,
              workInProgress2.pendingProps
            ), updateClassComponent(
              current,
              workInProgress2,
              props,
              $$typeof,
              renderLanes2
            );
          case 3:
            a: {
              pushHostContainer(
                workInProgress2,
                workInProgress2.stateNode.containerInfo
              );
              if (null === current)
                throw Error(formatProdErrorMessage(387));
              props = workInProgress2.pendingProps;
              var prevState = workInProgress2.memoizedState;
              $$typeof = prevState.element;
              cloneUpdateQueue(current, workInProgress2);
              processUpdateQueue(workInProgress2, props, null, renderLanes2);
              var nextState = workInProgress2.memoizedState;
              props = nextState.cache;
              pushProvider(workInProgress2, CacheContext, props);
              props !== prevState.cache && propagateContextChanges(
                workInProgress2,
                [CacheContext],
                renderLanes2,
                true
              );
              suspendIfUpdateReadFromEntangledAsyncAction();
              props = nextState.element;
              if (prevState.isDehydrated)
                if (prevState = {
                  element: props,
                  isDehydrated: false,
                  cache: nextState.cache
                }, workInProgress2.updateQueue.baseState = prevState, workInProgress2.memoizedState = prevState, workInProgress2.flags & 256) {
                  workInProgress2 = mountHostRootWithoutHydrating(
                    current,
                    workInProgress2,
                    props,
                    renderLanes2
                  );
                  break a;
                } else if (props !== $$typeof) {
                  $$typeof = createCapturedValueAtFiber(
                    Error(formatProdErrorMessage(424)),
                    workInProgress2
                  );
                  queueHydrationError($$typeof);
                  workInProgress2 = mountHostRootWithoutHydrating(
                    current,
                    workInProgress2,
                    props,
                    renderLanes2
                  );
                  break a;
                } else {
                  current = workInProgress2.stateNode.containerInfo;
                  switch (current.nodeType) {
                    case 9:
                      current = current.body;
                      break;
                    default:
                      current = "HTML" === current.nodeName ? current.ownerDocument.body : current;
                  }
                  nextHydratableInstance = getNextHydratable(current.firstChild);
                  hydrationParentFiber = workInProgress2;
                  isHydrating = true;
                  hydrationErrors = null;
                  rootOrSingletonContext = true;
                  renderLanes2 = mountChildFibers(
                    workInProgress2,
                    null,
                    props,
                    renderLanes2
                  );
                  for (workInProgress2.child = renderLanes2; renderLanes2; )
                    renderLanes2.flags = renderLanes2.flags & -3 | 4096, renderLanes2 = renderLanes2.sibling;
                }
              else {
                resetHydrationState();
                if (props === $$typeof) {
                  workInProgress2 = bailoutOnAlreadyFinishedWork(
                    current,
                    workInProgress2,
                    renderLanes2
                  );
                  break a;
                }
                reconcileChildren(current, workInProgress2, props, renderLanes2);
              }
              workInProgress2 = workInProgress2.child;
            }
            return workInProgress2;
          case 26:
            return markRef(current, workInProgress2), null === current ? (renderLanes2 = getResource(
              workInProgress2.type,
              null,
              workInProgress2.pendingProps,
              null
            )) ? workInProgress2.memoizedState = renderLanes2 : isHydrating || (renderLanes2 = workInProgress2.type, current = workInProgress2.pendingProps, props = getOwnerDocumentFromRootContainer(
              rootInstanceStackCursor.current
            ).createElement(renderLanes2), props[internalInstanceKey] = workInProgress2, props[internalPropsKey] = current, setInitialProperties(props, renderLanes2, current), markNodeAsHoistable(props), workInProgress2.stateNode = props) : workInProgress2.memoizedState = getResource(
              workInProgress2.type,
              current.memoizedProps,
              workInProgress2.pendingProps,
              current.memoizedState
            ), null;
          case 27:
            return pushHostContext(workInProgress2), null === current && isHydrating && (props = workInProgress2.stateNode = resolveSingletonInstance(
              workInProgress2.type,
              workInProgress2.pendingProps,
              rootInstanceStackCursor.current
            ), hydrationParentFiber = workInProgress2, rootOrSingletonContext = true, $$typeof = nextHydratableInstance, isSingletonScope(workInProgress2.type) ? (previousHydratableOnEnteringScopedSingleton = $$typeof, nextHydratableInstance = getNextHydratable(props.firstChild)) : nextHydratableInstance = $$typeof), reconcileChildren(
              current,
              workInProgress2,
              workInProgress2.pendingProps.children,
              renderLanes2
            ), markRef(current, workInProgress2), null === current && (workInProgress2.flags |= 4194304), workInProgress2.child;
          case 5:
            if (null === current && isHydrating) {
              if ($$typeof = props = nextHydratableInstance)
                props = canHydrateInstance(
                  props,
                  workInProgress2.type,
                  workInProgress2.pendingProps,
                  rootOrSingletonContext
                ), null !== props ? (workInProgress2.stateNode = props, hydrationParentFiber = workInProgress2, nextHydratableInstance = getNextHydratable(props.firstChild), rootOrSingletonContext = false, $$typeof = true) : $$typeof = false;
              $$typeof || throwOnHydrationMismatch(workInProgress2);
            }
            pushHostContext(workInProgress2);
            $$typeof = workInProgress2.type;
            prevState = workInProgress2.pendingProps;
            nextState = null !== current ? current.memoizedProps : null;
            props = prevState.children;
            shouldSetTextContent($$typeof, prevState) ? props = null : null !== nextState && shouldSetTextContent($$typeof, nextState) && (workInProgress2.flags |= 32);
            null !== workInProgress2.memoizedState && ($$typeof = renderWithHooks(
              current,
              workInProgress2,
              TransitionAwareHostComponent,
              null,
              null,
              renderLanes2
            ), HostTransitionContext._currentValue = $$typeof);
            markRef(current, workInProgress2);
            reconcileChildren(current, workInProgress2, props, renderLanes2);
            return workInProgress2.child;
          case 6:
            if (null === current && isHydrating) {
              if (current = renderLanes2 = nextHydratableInstance)
                renderLanes2 = canHydrateTextInstance(
                  renderLanes2,
                  workInProgress2.pendingProps,
                  rootOrSingletonContext
                ), null !== renderLanes2 ? (workInProgress2.stateNode = renderLanes2, hydrationParentFiber = workInProgress2, nextHydratableInstance = null, current = true) : current = false;
              current || throwOnHydrationMismatch(workInProgress2);
            }
            return null;
          case 13:
            return updateSuspenseComponent(current, workInProgress2, renderLanes2);
          case 4:
            return pushHostContainer(
              workInProgress2,
              workInProgress2.stateNode.containerInfo
            ), props = workInProgress2.pendingProps, null === current ? workInProgress2.child = reconcileChildFibers(
              workInProgress2,
              null,
              props,
              renderLanes2
            ) : reconcileChildren(current, workInProgress2, props, renderLanes2), workInProgress2.child;
          case 11:
            return updateForwardRef(
              current,
              workInProgress2,
              workInProgress2.type,
              workInProgress2.pendingProps,
              renderLanes2
            );
          case 7:
            return reconcileChildren(
              current,
              workInProgress2,
              workInProgress2.pendingProps,
              renderLanes2
            ), workInProgress2.child;
          case 8:
            return reconcileChildren(
              current,
              workInProgress2,
              workInProgress2.pendingProps.children,
              renderLanes2
            ), workInProgress2.child;
          case 12:
            return reconcileChildren(
              current,
              workInProgress2,
              workInProgress2.pendingProps.children,
              renderLanes2
            ), workInProgress2.child;
          case 10:
            return props = workInProgress2.pendingProps, pushProvider(workInProgress2, workInProgress2.type, props.value), reconcileChildren(current, workInProgress2, props.children, renderLanes2), workInProgress2.child;
          case 9:
            return $$typeof = workInProgress2.type._context, props = workInProgress2.pendingProps.children, prepareToReadContext(workInProgress2), $$typeof = readContext($$typeof), props = props($$typeof), workInProgress2.flags |= 1, reconcileChildren(current, workInProgress2, props, renderLanes2), workInProgress2.child;
          case 14:
            return updateMemoComponent(
              current,
              workInProgress2,
              workInProgress2.type,
              workInProgress2.pendingProps,
              renderLanes2
            );
          case 15:
            return updateSimpleMemoComponent(
              current,
              workInProgress2,
              workInProgress2.type,
              workInProgress2.pendingProps,
              renderLanes2
            );
          case 19:
            return updateSuspenseListComponent(current, workInProgress2, renderLanes2);
          case 31:
            return updateActivityComponent(current, workInProgress2, renderLanes2);
          case 22:
            return updateOffscreenComponent(
              current,
              workInProgress2,
              renderLanes2,
              workInProgress2.pendingProps
            );
          case 24:
            return prepareToReadContext(workInProgress2), props = readContext(CacheContext), null === current ? ($$typeof = peekCacheFromPool(), null === $$typeof && ($$typeof = workInProgressRoot, prevState = createCache(), $$typeof.pooledCache = prevState, prevState.refCount++, null !== prevState && ($$typeof.pooledCacheLanes |= renderLanes2), $$typeof = prevState), workInProgress2.memoizedState = { parent: props, cache: $$typeof }, initializeUpdateQueue(workInProgress2), pushProvider(workInProgress2, CacheContext, $$typeof)) : (0 !== (current.lanes & renderLanes2) && (cloneUpdateQueue(current, workInProgress2), processUpdateQueue(workInProgress2, null, null, renderLanes2), suspendIfUpdateReadFromEntangledAsyncAction()), $$typeof = current.memoizedState, prevState = workInProgress2.memoizedState, $$typeof.parent !== props ? ($$typeof = { parent: props, cache: props }, workInProgress2.memoizedState = $$typeof, 0 === workInProgress2.lanes && (workInProgress2.memoizedState = workInProgress2.updateQueue.baseState = $$typeof), pushProvider(workInProgress2, CacheContext, props)) : (props = prevState.cache, pushProvider(workInProgress2, CacheContext, props), props !== $$typeof.cache && propagateContextChanges(
              workInProgress2,
              [CacheContext],
              renderLanes2,
              true
            ))), reconcileChildren(
              current,
              workInProgress2,
              workInProgress2.pendingProps.children,
              renderLanes2
            ), workInProgress2.child;
          case 29:
            throw workInProgress2.pendingProps;
        }
        throw Error(formatProdErrorMessage(156, workInProgress2.tag));
      }
      function markUpdate(workInProgress2) {
        workInProgress2.flags |= 4;
      }
      function preloadInstanceAndSuspendIfNeeded(workInProgress2, type, oldProps, newProps, renderLanes2) {
        if (type = 0 !== (workInProgress2.mode & 32))
          type = false;
        if (type) {
          if (workInProgress2.flags |= 16777216, (renderLanes2 & 335544128) === renderLanes2)
            if (workInProgress2.stateNode.complete)
              workInProgress2.flags |= 8192;
            else if (shouldRemainOnPreviousScreen())
              workInProgress2.flags |= 8192;
            else
              throw suspendedThenable = noopSuspenseyCommitThenable, SuspenseyCommitException;
        } else
          workInProgress2.flags &= -16777217;
      }
      function preloadResourceAndSuspendIfNeeded(workInProgress2, resource) {
        if ("stylesheet" !== resource.type || 0 !== (resource.state.loading & 4))
          workInProgress2.flags &= -16777217;
        else if (workInProgress2.flags |= 16777216, !preloadResource(resource))
          if (shouldRemainOnPreviousScreen())
            workInProgress2.flags |= 8192;
          else
            throw suspendedThenable = noopSuspenseyCommitThenable, SuspenseyCommitException;
      }
      function scheduleRetryEffect(workInProgress2, retryQueue) {
        null !== retryQueue && (workInProgress2.flags |= 4);
        workInProgress2.flags & 16384 && (retryQueue = 22 !== workInProgress2.tag ? claimNextRetryLane() : 536870912, workInProgress2.lanes |= retryQueue, workInProgressSuspendedRetryLanes |= retryQueue);
      }
      function cutOffTailIfNeeded(renderState, hasRenderedATailFallback) {
        if (!isHydrating)
          switch (renderState.tailMode) {
            case "hidden":
              hasRenderedATailFallback = renderState.tail;
              for (var lastTailNode = null; null !== hasRenderedATailFallback; )
                null !== hasRenderedATailFallback.alternate && (lastTailNode = hasRenderedATailFallback), hasRenderedATailFallback = hasRenderedATailFallback.sibling;
              null === lastTailNode ? renderState.tail = null : lastTailNode.sibling = null;
              break;
            case "collapsed":
              lastTailNode = renderState.tail;
              for (var lastTailNode$106 = null; null !== lastTailNode; )
                null !== lastTailNode.alternate && (lastTailNode$106 = lastTailNode), lastTailNode = lastTailNode.sibling;
              null === lastTailNode$106 ? hasRenderedATailFallback || null === renderState.tail ? renderState.tail = null : renderState.tail.sibling = null : lastTailNode$106.sibling = null;
          }
      }
      function bubbleProperties(completedWork) {
        var didBailout = null !== completedWork.alternate && completedWork.alternate.child === completedWork.child, newChildLanes = 0, subtreeFlags = 0;
        if (didBailout)
          for (var child$107 = completedWork.child; null !== child$107; )
            newChildLanes |= child$107.lanes | child$107.childLanes, subtreeFlags |= child$107.subtreeFlags & 65011712, subtreeFlags |= child$107.flags & 65011712, child$107.return = completedWork, child$107 = child$107.sibling;
        else
          for (child$107 = completedWork.child; null !== child$107; )
            newChildLanes |= child$107.lanes | child$107.childLanes, subtreeFlags |= child$107.subtreeFlags, subtreeFlags |= child$107.flags, child$107.return = completedWork, child$107 = child$107.sibling;
        completedWork.subtreeFlags |= subtreeFlags;
        completedWork.childLanes = newChildLanes;
        return didBailout;
      }
      function completeWork(current, workInProgress2, renderLanes2) {
        var newProps = workInProgress2.pendingProps;
        popTreeContext(workInProgress2);
        switch (workInProgress2.tag) {
          case 16:
          case 15:
          case 0:
          case 11:
          case 7:
          case 8:
          case 12:
          case 9:
          case 14:
            return bubbleProperties(workInProgress2), null;
          case 1:
            return bubbleProperties(workInProgress2), null;
          case 3:
            renderLanes2 = workInProgress2.stateNode;
            newProps = null;
            null !== current && (newProps = current.memoizedState.cache);
            workInProgress2.memoizedState.cache !== newProps && (workInProgress2.flags |= 2048);
            popProvider(CacheContext);
            popHostContainer();
            renderLanes2.pendingContext && (renderLanes2.context = renderLanes2.pendingContext, renderLanes2.pendingContext = null);
            if (null === current || null === current.child)
              popHydrationState(workInProgress2) ? markUpdate(workInProgress2) : null === current || current.memoizedState.isDehydrated && 0 === (workInProgress2.flags & 256) || (workInProgress2.flags |= 1024, upgradeHydrationErrorsToRecoverable());
            bubbleProperties(workInProgress2);
            return null;
          case 26:
            var type = workInProgress2.type, nextResource = workInProgress2.memoizedState;
            null === current ? (markUpdate(workInProgress2), null !== nextResource ? (bubbleProperties(workInProgress2), preloadResourceAndSuspendIfNeeded(workInProgress2, nextResource)) : (bubbleProperties(workInProgress2), preloadInstanceAndSuspendIfNeeded(
              workInProgress2,
              type,
              null,
              newProps,
              renderLanes2
            ))) : nextResource ? nextResource !== current.memoizedState ? (markUpdate(workInProgress2), bubbleProperties(workInProgress2), preloadResourceAndSuspendIfNeeded(workInProgress2, nextResource)) : (bubbleProperties(workInProgress2), workInProgress2.flags &= -16777217) : (current = current.memoizedProps, current !== newProps && markUpdate(workInProgress2), bubbleProperties(workInProgress2), preloadInstanceAndSuspendIfNeeded(
              workInProgress2,
              type,
              current,
              newProps,
              renderLanes2
            ));
            return null;
          case 27:
            popHostContext(workInProgress2);
            renderLanes2 = rootInstanceStackCursor.current;
            type = workInProgress2.type;
            if (null !== current && null != workInProgress2.stateNode)
              current.memoizedProps !== newProps && markUpdate(workInProgress2);
            else {
              if (!newProps) {
                if (null === workInProgress2.stateNode)
                  throw Error(formatProdErrorMessage(166));
                bubbleProperties(workInProgress2);
                return null;
              }
              current = contextStackCursor.current;
              popHydrationState(workInProgress2) ? prepareToHydrateHostInstance(workInProgress2, current) : (current = resolveSingletonInstance(type, newProps, renderLanes2), workInProgress2.stateNode = current, markUpdate(workInProgress2));
            }
            bubbleProperties(workInProgress2);
            return null;
          case 5:
            popHostContext(workInProgress2);
            type = workInProgress2.type;
            if (null !== current && null != workInProgress2.stateNode)
              current.memoizedProps !== newProps && markUpdate(workInProgress2);
            else {
              if (!newProps) {
                if (null === workInProgress2.stateNode)
                  throw Error(formatProdErrorMessage(166));
                bubbleProperties(workInProgress2);
                return null;
              }
              nextResource = contextStackCursor.current;
              if (popHydrationState(workInProgress2))
                prepareToHydrateHostInstance(workInProgress2, nextResource);
              else {
                var ownerDocument = getOwnerDocumentFromRootContainer(
                  rootInstanceStackCursor.current
                );
                switch (nextResource) {
                  case 1:
                    nextResource = ownerDocument.createElementNS(
                      "http://www.w3.org/2000/svg",
                      type
                    );
                    break;
                  case 2:
                    nextResource = ownerDocument.createElementNS(
                      "http://www.w3.org/1998/Math/MathML",
                      type
                    );
                    break;
                  default:
                    switch (type) {
                      case "svg":
                        nextResource = ownerDocument.createElementNS(
                          "http://www.w3.org/2000/svg",
                          type
                        );
                        break;
                      case "math":
                        nextResource = ownerDocument.createElementNS(
                          "http://www.w3.org/1998/Math/MathML",
                          type
                        );
                        break;
                      case "script":
                        nextResource = ownerDocument.createElement("div");
                        nextResource.innerHTML = "<script><\/script>";
                        nextResource = nextResource.removeChild(
                          nextResource.firstChild
                        );
                        break;
                      case "select":
                        nextResource = "string" === typeof newProps.is ? ownerDocument.createElement("select", {
                          is: newProps.is
                        }) : ownerDocument.createElement("select");
                        newProps.multiple ? nextResource.multiple = true : newProps.size && (nextResource.size = newProps.size);
                        break;
                      default:
                        nextResource = "string" === typeof newProps.is ? ownerDocument.createElement(type, { is: newProps.is }) : ownerDocument.createElement(type);
                    }
                }
                nextResource[internalInstanceKey] = workInProgress2;
                nextResource[internalPropsKey] = newProps;
                a:
                  for (ownerDocument = workInProgress2.child; null !== ownerDocument; ) {
                    if (5 === ownerDocument.tag || 6 === ownerDocument.tag)
                      nextResource.appendChild(ownerDocument.stateNode);
                    else if (4 !== ownerDocument.tag && 27 !== ownerDocument.tag && null !== ownerDocument.child) {
                      ownerDocument.child.return = ownerDocument;
                      ownerDocument = ownerDocument.child;
                      continue;
                    }
                    if (ownerDocument === workInProgress2)
                      break a;
                    for (; null === ownerDocument.sibling; ) {
                      if (null === ownerDocument.return || ownerDocument.return === workInProgress2)
                        break a;
                      ownerDocument = ownerDocument.return;
                    }
                    ownerDocument.sibling.return = ownerDocument.return;
                    ownerDocument = ownerDocument.sibling;
                  }
                workInProgress2.stateNode = nextResource;
                a:
                  switch (setInitialProperties(nextResource, type, newProps), type) {
                    case "button":
                    case "input":
                    case "select":
                    case "textarea":
                      newProps = !!newProps.autoFocus;
                      break a;
                    case "img":
                      newProps = true;
                      break a;
                    default:
                      newProps = false;
                  }
                newProps && markUpdate(workInProgress2);
              }
            }
            bubbleProperties(workInProgress2);
            preloadInstanceAndSuspendIfNeeded(
              workInProgress2,
              workInProgress2.type,
              null === current ? null : current.memoizedProps,
              workInProgress2.pendingProps,
              renderLanes2
            );
            return null;
          case 6:
            if (current && null != workInProgress2.stateNode)
              current.memoizedProps !== newProps && markUpdate(workInProgress2);
            else {
              if ("string" !== typeof newProps && null === workInProgress2.stateNode)
                throw Error(formatProdErrorMessage(166));
              current = rootInstanceStackCursor.current;
              if (popHydrationState(workInProgress2)) {
                current = workInProgress2.stateNode;
                renderLanes2 = workInProgress2.memoizedProps;
                newProps = null;
                type = hydrationParentFiber;
                if (null !== type)
                  switch (type.tag) {
                    case 27:
                    case 5:
                      newProps = type.memoizedProps;
                  }
                current[internalInstanceKey] = workInProgress2;
                current = current.nodeValue === renderLanes2 || null !== newProps && true === newProps.suppressHydrationWarning || checkForUnmatchedText(current.nodeValue, renderLanes2) ? true : false;
                current || throwOnHydrationMismatch(workInProgress2, true);
              } else
                current = getOwnerDocumentFromRootContainer(current).createTextNode(
                  newProps
                ), current[internalInstanceKey] = workInProgress2, workInProgress2.stateNode = current;
            }
            bubbleProperties(workInProgress2);
            return null;
          case 31:
            renderLanes2 = workInProgress2.memoizedState;
            if (null === current || null !== current.memoizedState) {
              newProps = popHydrationState(workInProgress2);
              if (null !== renderLanes2) {
                if (null === current) {
                  if (!newProps)
                    throw Error(formatProdErrorMessage(318));
                  current = workInProgress2.memoizedState;
                  current = null !== current ? current.dehydrated : null;
                  if (!current)
                    throw Error(formatProdErrorMessage(557));
                  current[internalInstanceKey] = workInProgress2;
                } else
                  resetHydrationState(), 0 === (workInProgress2.flags & 128) && (workInProgress2.memoizedState = null), workInProgress2.flags |= 4;
                bubbleProperties(workInProgress2);
                current = false;
              } else
                renderLanes2 = upgradeHydrationErrorsToRecoverable(), null !== current && null !== current.memoizedState && (current.memoizedState.hydrationErrors = renderLanes2), current = true;
              if (!current) {
                if (workInProgress2.flags & 256)
                  return popSuspenseHandler(workInProgress2), workInProgress2;
                popSuspenseHandler(workInProgress2);
                return null;
              }
              if (0 !== (workInProgress2.flags & 128))
                throw Error(formatProdErrorMessage(558));
            }
            bubbleProperties(workInProgress2);
            return null;
          case 13:
            newProps = workInProgress2.memoizedState;
            if (null === current || null !== current.memoizedState && null !== current.memoizedState.dehydrated) {
              type = popHydrationState(workInProgress2);
              if (null !== newProps && null !== newProps.dehydrated) {
                if (null === current) {
                  if (!type)
                    throw Error(formatProdErrorMessage(318));
                  type = workInProgress2.memoizedState;
                  type = null !== type ? type.dehydrated : null;
                  if (!type)
                    throw Error(formatProdErrorMessage(317));
                  type[internalInstanceKey] = workInProgress2;
                } else
                  resetHydrationState(), 0 === (workInProgress2.flags & 128) && (workInProgress2.memoizedState = null), workInProgress2.flags |= 4;
                bubbleProperties(workInProgress2);
                type = false;
              } else
                type = upgradeHydrationErrorsToRecoverable(), null !== current && null !== current.memoizedState && (current.memoizedState.hydrationErrors = type), type = true;
              if (!type) {
                if (workInProgress2.flags & 256)
                  return popSuspenseHandler(workInProgress2), workInProgress2;
                popSuspenseHandler(workInProgress2);
                return null;
              }
            }
            popSuspenseHandler(workInProgress2);
            if (0 !== (workInProgress2.flags & 128))
              return workInProgress2.lanes = renderLanes2, workInProgress2;
            renderLanes2 = null !== newProps;
            current = null !== current && null !== current.memoizedState;
            renderLanes2 && (newProps = workInProgress2.child, type = null, null !== newProps.alternate && null !== newProps.alternate.memoizedState && null !== newProps.alternate.memoizedState.cachePool && (type = newProps.alternate.memoizedState.cachePool.pool), nextResource = null, null !== newProps.memoizedState && null !== newProps.memoizedState.cachePool && (nextResource = newProps.memoizedState.cachePool.pool), nextResource !== type && (newProps.flags |= 2048));
            renderLanes2 !== current && renderLanes2 && (workInProgress2.child.flags |= 8192);
            scheduleRetryEffect(workInProgress2, workInProgress2.updateQueue);
            bubbleProperties(workInProgress2);
            return null;
          case 4:
            return popHostContainer(), null === current && listenToAllSupportedEvents(workInProgress2.stateNode.containerInfo), bubbleProperties(workInProgress2), null;
          case 10:
            return popProvider(workInProgress2.type), bubbleProperties(workInProgress2), null;
          case 19:
            pop(suspenseStackCursor);
            newProps = workInProgress2.memoizedState;
            if (null === newProps)
              return bubbleProperties(workInProgress2), null;
            type = 0 !== (workInProgress2.flags & 128);
            nextResource = newProps.rendering;
            if (null === nextResource)
              if (type)
                cutOffTailIfNeeded(newProps, false);
              else {
                if (0 !== workInProgressRootExitStatus || null !== current && 0 !== (current.flags & 128))
                  for (current = workInProgress2.child; null !== current; ) {
                    nextResource = findFirstSuspended(current);
                    if (null !== nextResource) {
                      workInProgress2.flags |= 128;
                      cutOffTailIfNeeded(newProps, false);
                      current = nextResource.updateQueue;
                      workInProgress2.updateQueue = current;
                      scheduleRetryEffect(workInProgress2, current);
                      workInProgress2.subtreeFlags = 0;
                      current = renderLanes2;
                      for (renderLanes2 = workInProgress2.child; null !== renderLanes2; )
                        resetWorkInProgress(renderLanes2, current), renderLanes2 = renderLanes2.sibling;
                      push(
                        suspenseStackCursor,
                        suspenseStackCursor.current & 1 | 2
                      );
                      isHydrating && pushTreeFork(workInProgress2, newProps.treeForkCount);
                      return workInProgress2.child;
                    }
                    current = current.sibling;
                  }
                null !== newProps.tail && now() > workInProgressRootRenderTargetTime && (workInProgress2.flags |= 128, type = true, cutOffTailIfNeeded(newProps, false), workInProgress2.lanes = 4194304);
              }
            else {
              if (!type)
                if (current = findFirstSuspended(nextResource), null !== current) {
                  if (workInProgress2.flags |= 128, type = true, current = current.updateQueue, workInProgress2.updateQueue = current, scheduleRetryEffect(workInProgress2, current), cutOffTailIfNeeded(newProps, true), null === newProps.tail && "hidden" === newProps.tailMode && !nextResource.alternate && !isHydrating)
                    return bubbleProperties(workInProgress2), null;
                } else
                  2 * now() - newProps.renderingStartTime > workInProgressRootRenderTargetTime && 536870912 !== renderLanes2 && (workInProgress2.flags |= 128, type = true, cutOffTailIfNeeded(newProps, false), workInProgress2.lanes = 4194304);
              newProps.isBackwards ? (nextResource.sibling = workInProgress2.child, workInProgress2.child = nextResource) : (current = newProps.last, null !== current ? current.sibling = nextResource : workInProgress2.child = nextResource, newProps.last = nextResource);
            }
            if (null !== newProps.tail)
              return current = newProps.tail, newProps.rendering = current, newProps.tail = current.sibling, newProps.renderingStartTime = now(), current.sibling = null, renderLanes2 = suspenseStackCursor.current, push(
                suspenseStackCursor,
                type ? renderLanes2 & 1 | 2 : renderLanes2 & 1
              ), isHydrating && pushTreeFork(workInProgress2, newProps.treeForkCount), current;
            bubbleProperties(workInProgress2);
            return null;
          case 22:
          case 23:
            return popSuspenseHandler(workInProgress2), popHiddenContext(), newProps = null !== workInProgress2.memoizedState, null !== current ? null !== current.memoizedState !== newProps && (workInProgress2.flags |= 8192) : newProps && (workInProgress2.flags |= 8192), newProps ? 0 !== (renderLanes2 & 536870912) && 0 === (workInProgress2.flags & 128) && (bubbleProperties(workInProgress2), workInProgress2.subtreeFlags & 6 && (workInProgress2.flags |= 8192)) : bubbleProperties(workInProgress2), renderLanes2 = workInProgress2.updateQueue, null !== renderLanes2 && scheduleRetryEffect(workInProgress2, renderLanes2.retryQueue), renderLanes2 = null, null !== current && null !== current.memoizedState && null !== current.memoizedState.cachePool && (renderLanes2 = current.memoizedState.cachePool.pool), newProps = null, null !== workInProgress2.memoizedState && null !== workInProgress2.memoizedState.cachePool && (newProps = workInProgress2.memoizedState.cachePool.pool), newProps !== renderLanes2 && (workInProgress2.flags |= 2048), null !== current && pop(resumedCache), null;
          case 24:
            return renderLanes2 = null, null !== current && (renderLanes2 = current.memoizedState.cache), workInProgress2.memoizedState.cache !== renderLanes2 && (workInProgress2.flags |= 2048), popProvider(CacheContext), bubbleProperties(workInProgress2), null;
          case 25:
            return null;
          case 30:
            return null;
        }
        throw Error(formatProdErrorMessage(156, workInProgress2.tag));
      }
      function unwindWork(current, workInProgress2) {
        popTreeContext(workInProgress2);
        switch (workInProgress2.tag) {
          case 1:
            return current = workInProgress2.flags, current & 65536 ? (workInProgress2.flags = current & -65537 | 128, workInProgress2) : null;
          case 3:
            return popProvider(CacheContext), popHostContainer(), current = workInProgress2.flags, 0 !== (current & 65536) && 0 === (current & 128) ? (workInProgress2.flags = current & -65537 | 128, workInProgress2) : null;
          case 26:
          case 27:
          case 5:
            return popHostContext(workInProgress2), null;
          case 31:
            if (null !== workInProgress2.memoizedState) {
              popSuspenseHandler(workInProgress2);
              if (null === workInProgress2.alternate)
                throw Error(formatProdErrorMessage(340));
              resetHydrationState();
            }
            current = workInProgress2.flags;
            return current & 65536 ? (workInProgress2.flags = current & -65537 | 128, workInProgress2) : null;
          case 13:
            popSuspenseHandler(workInProgress2);
            current = workInProgress2.memoizedState;
            if (null !== current && null !== current.dehydrated) {
              if (null === workInProgress2.alternate)
                throw Error(formatProdErrorMessage(340));
              resetHydrationState();
            }
            current = workInProgress2.flags;
            return current & 65536 ? (workInProgress2.flags = current & -65537 | 128, workInProgress2) : null;
          case 19:
            return pop(suspenseStackCursor), null;
          case 4:
            return popHostContainer(), null;
          case 10:
            return popProvider(workInProgress2.type), null;
          case 22:
          case 23:
            return popSuspenseHandler(workInProgress2), popHiddenContext(), null !== current && pop(resumedCache), current = workInProgress2.flags, current & 65536 ? (workInProgress2.flags = current & -65537 | 128, workInProgress2) : null;
          case 24:
            return popProvider(CacheContext), null;
          case 25:
            return null;
          default:
            return null;
        }
      }
      function unwindInterruptedWork(current, interruptedWork) {
        popTreeContext(interruptedWork);
        switch (interruptedWork.tag) {
          case 3:
            popProvider(CacheContext);
            popHostContainer();
            break;
          case 26:
          case 27:
          case 5:
            popHostContext(interruptedWork);
            break;
          case 4:
            popHostContainer();
            break;
          case 31:
            null !== interruptedWork.memoizedState && popSuspenseHandler(interruptedWork);
            break;
          case 13:
            popSuspenseHandler(interruptedWork);
            break;
          case 19:
            pop(suspenseStackCursor);
            break;
          case 10:
            popProvider(interruptedWork.type);
            break;
          case 22:
          case 23:
            popSuspenseHandler(interruptedWork);
            popHiddenContext();
            null !== current && pop(resumedCache);
            break;
          case 24:
            popProvider(CacheContext);
        }
      }
      function commitHookEffectListMount(flags, finishedWork) {
        try {
          var updateQueue = finishedWork.updateQueue, lastEffect = null !== updateQueue ? updateQueue.lastEffect : null;
          if (null !== lastEffect) {
            var firstEffect = lastEffect.next;
            updateQueue = firstEffect;
            do {
              if ((updateQueue.tag & flags) === flags) {
                lastEffect = void 0;
                var create = updateQueue.create, inst = updateQueue.inst;
                lastEffect = create();
                inst.destroy = lastEffect;
              }
              updateQueue = updateQueue.next;
            } while (updateQueue !== firstEffect);
          }
        } catch (error) {
          captureCommitPhaseError(finishedWork, finishedWork.return, error);
        }
      }
      function commitHookEffectListUnmount(flags, finishedWork, nearestMountedAncestor$jscomp$0) {
        try {
          var updateQueue = finishedWork.updateQueue, lastEffect = null !== updateQueue ? updateQueue.lastEffect : null;
          if (null !== lastEffect) {
            var firstEffect = lastEffect.next;
            updateQueue = firstEffect;
            do {
              if ((updateQueue.tag & flags) === flags) {
                var inst = updateQueue.inst, destroy = inst.destroy;
                if (void 0 !== destroy) {
                  inst.destroy = void 0;
                  lastEffect = finishedWork;
                  var nearestMountedAncestor = nearestMountedAncestor$jscomp$0, destroy_ = destroy;
                  try {
                    destroy_();
                  } catch (error) {
                    captureCommitPhaseError(
                      lastEffect,
                      nearestMountedAncestor,
                      error
                    );
                  }
                }
              }
              updateQueue = updateQueue.next;
            } while (updateQueue !== firstEffect);
          }
        } catch (error) {
          captureCommitPhaseError(finishedWork, finishedWork.return, error);
        }
      }
      function commitClassCallbacks(finishedWork) {
        var updateQueue = finishedWork.updateQueue;
        if (null !== updateQueue) {
          var instance = finishedWork.stateNode;
          try {
            commitCallbacks(updateQueue, instance);
          } catch (error) {
            captureCommitPhaseError(finishedWork, finishedWork.return, error);
          }
        }
      }
      function safelyCallComponentWillUnmount(current, nearestMountedAncestor, instance) {
        instance.props = resolveClassComponentProps(
          current.type,
          current.memoizedProps
        );
        instance.state = current.memoizedState;
        try {
          instance.componentWillUnmount();
        } catch (error) {
          captureCommitPhaseError(current, nearestMountedAncestor, error);
        }
      }
      function safelyAttachRef(current, nearestMountedAncestor) {
        try {
          var ref = current.ref;
          if (null !== ref) {
            switch (current.tag) {
              case 26:
              case 27:
              case 5:
                var instanceToUse = current.stateNode;
                break;
              case 30:
                instanceToUse = current.stateNode;
                break;
              default:
                instanceToUse = current.stateNode;
            }
            "function" === typeof ref ? current.refCleanup = ref(instanceToUse) : ref.current = instanceToUse;
          }
        } catch (error) {
          captureCommitPhaseError(current, nearestMountedAncestor, error);
        }
      }
      function safelyDetachRef(current, nearestMountedAncestor) {
        var ref = current.ref, refCleanup = current.refCleanup;
        if (null !== ref)
          if ("function" === typeof refCleanup)
            try {
              refCleanup();
            } catch (error) {
              captureCommitPhaseError(current, nearestMountedAncestor, error);
            } finally {
              current.refCleanup = null, current = current.alternate, null != current && (current.refCleanup = null);
            }
          else if ("function" === typeof ref)
            try {
              ref(null);
            } catch (error$140) {
              captureCommitPhaseError(current, nearestMountedAncestor, error$140);
            }
          else
            ref.current = null;
      }
      function commitHostMount(finishedWork) {
        var type = finishedWork.type, props = finishedWork.memoizedProps, instance = finishedWork.stateNode;
        try {
          a:
            switch (type) {
              case "button":
              case "input":
              case "select":
              case "textarea":
                props.autoFocus && instance.focus();
                break a;
              case "img":
                props.src ? instance.src = props.src : props.srcSet && (instance.srcset = props.srcSet);
            }
        } catch (error) {
          captureCommitPhaseError(finishedWork, finishedWork.return, error);
        }
      }
      function commitHostUpdate(finishedWork, newProps, oldProps) {
        try {
          var domElement = finishedWork.stateNode;
          updateProperties(domElement, finishedWork.type, oldProps, newProps);
          domElement[internalPropsKey] = newProps;
        } catch (error) {
          captureCommitPhaseError(finishedWork, finishedWork.return, error);
        }
      }
      function isHostParent(fiber) {
        return 5 === fiber.tag || 3 === fiber.tag || 26 === fiber.tag || 27 === fiber.tag && isSingletonScope(fiber.type) || 4 === fiber.tag;
      }
      function getHostSibling(fiber) {
        a:
          for (; ; ) {
            for (; null === fiber.sibling; ) {
              if (null === fiber.return || isHostParent(fiber.return))
                return null;
              fiber = fiber.return;
            }
            fiber.sibling.return = fiber.return;
            for (fiber = fiber.sibling; 5 !== fiber.tag && 6 !== fiber.tag && 18 !== fiber.tag; ) {
              if (27 === fiber.tag && isSingletonScope(fiber.type))
                continue a;
              if (fiber.flags & 2)
                continue a;
              if (null === fiber.child || 4 === fiber.tag)
                continue a;
              else
                fiber.child.return = fiber, fiber = fiber.child;
            }
            if (!(fiber.flags & 2))
              return fiber.stateNode;
          }
      }
      function insertOrAppendPlacementNodeIntoContainer(node, before, parent) {
        var tag = node.tag;
        if (5 === tag || 6 === tag)
          node = node.stateNode, before ? (9 === parent.nodeType ? parent.body : "HTML" === parent.nodeName ? parent.ownerDocument.body : parent).insertBefore(node, before) : (before = 9 === parent.nodeType ? parent.body : "HTML" === parent.nodeName ? parent.ownerDocument.body : parent, before.appendChild(node), parent = parent._reactRootContainer, null !== parent && void 0 !== parent || null !== before.onclick || (before.onclick = noop$1));
        else if (4 !== tag && (27 === tag && isSingletonScope(node.type) && (parent = node.stateNode, before = null), node = node.child, null !== node))
          for (insertOrAppendPlacementNodeIntoContainer(node, before, parent), node = node.sibling; null !== node; )
            insertOrAppendPlacementNodeIntoContainer(node, before, parent), node = node.sibling;
      }
      function insertOrAppendPlacementNode(node, before, parent) {
        var tag = node.tag;
        if (5 === tag || 6 === tag)
          node = node.stateNode, before ? parent.insertBefore(node, before) : parent.appendChild(node);
        else if (4 !== tag && (27 === tag && isSingletonScope(node.type) && (parent = node.stateNode), node = node.child, null !== node))
          for (insertOrAppendPlacementNode(node, before, parent), node = node.sibling; null !== node; )
            insertOrAppendPlacementNode(node, before, parent), node = node.sibling;
      }
      function commitHostSingletonAcquisition(finishedWork) {
        var singleton = finishedWork.stateNode, props = finishedWork.memoizedProps;
        try {
          for (var type = finishedWork.type, attributes = singleton.attributes; attributes.length; )
            singleton.removeAttributeNode(attributes[0]);
          setInitialProperties(singleton, type, props);
          singleton[internalInstanceKey] = finishedWork;
          singleton[internalPropsKey] = props;
        } catch (error) {
          captureCommitPhaseError(finishedWork, finishedWork.return, error);
        }
      }
      var offscreenSubtreeIsHidden = false;
      var offscreenSubtreeWasHidden = false;
      var needsFormReset = false;
      var PossiblyWeakSet = "function" === typeof WeakSet ? WeakSet : Set;
      var nextEffect = null;
      function commitBeforeMutationEffects(root3, firstChild) {
        root3 = root3.containerInfo;
        eventsEnabled = _enabled;
        root3 = getActiveElementDeep(root3);
        if (hasSelectionCapabilities(root3)) {
          if ("selectionStart" in root3)
            var JSCompiler_temp = {
              start: root3.selectionStart,
              end: root3.selectionEnd
            };
          else
            a: {
              JSCompiler_temp = (JSCompiler_temp = root3.ownerDocument) && JSCompiler_temp.defaultView || window;
              var selection = JSCompiler_temp.getSelection && JSCompiler_temp.getSelection();
              if (selection && 0 !== selection.rangeCount) {
                JSCompiler_temp = selection.anchorNode;
                var anchorOffset = selection.anchorOffset, focusNode = selection.focusNode;
                selection = selection.focusOffset;
                try {
                  JSCompiler_temp.nodeType, focusNode.nodeType;
                } catch (e$20) {
                  JSCompiler_temp = null;
                  break a;
                }
                var length = 0, start = -1, end = -1, indexWithinAnchor = 0, indexWithinFocus = 0, node = root3, parentNode = null;
                b:
                  for (; ; ) {
                    for (var next; ; ) {
                      node !== JSCompiler_temp || 0 !== anchorOffset && 3 !== node.nodeType || (start = length + anchorOffset);
                      node !== focusNode || 0 !== selection && 3 !== node.nodeType || (end = length + selection);
                      3 === node.nodeType && (length += node.nodeValue.length);
                      if (null === (next = node.firstChild))
                        break;
                      parentNode = node;
                      node = next;
                    }
                    for (; ; ) {
                      if (node === root3)
                        break b;
                      parentNode === JSCompiler_temp && ++indexWithinAnchor === anchorOffset && (start = length);
                      parentNode === focusNode && ++indexWithinFocus === selection && (end = length);
                      if (null !== (next = node.nextSibling))
                        break;
                      node = parentNode;
                      parentNode = node.parentNode;
                    }
                    node = next;
                  }
                JSCompiler_temp = -1 === start || -1 === end ? null : { start, end };
              } else
                JSCompiler_temp = null;
            }
          JSCompiler_temp = JSCompiler_temp || { start: 0, end: 0 };
        } else
          JSCompiler_temp = null;
        selectionInformation = { focusedElem: root3, selectionRange: JSCompiler_temp };
        _enabled = false;
        for (nextEffect = firstChild; null !== nextEffect; )
          if (firstChild = nextEffect, root3 = firstChild.child, 0 !== (firstChild.subtreeFlags & 1028) && null !== root3)
            root3.return = firstChild, nextEffect = root3;
          else
            for (; null !== nextEffect; ) {
              firstChild = nextEffect;
              focusNode = firstChild.alternate;
              root3 = firstChild.flags;
              switch (firstChild.tag) {
                case 0:
                  if (0 !== (root3 & 4) && (root3 = firstChild.updateQueue, root3 = null !== root3 ? root3.events : null, null !== root3))
                    for (JSCompiler_temp = 0; JSCompiler_temp < root3.length; JSCompiler_temp++)
                      anchorOffset = root3[JSCompiler_temp], anchorOffset.ref.impl = anchorOffset.nextImpl;
                  break;
                case 11:
                case 15:
                  break;
                case 1:
                  if (0 !== (root3 & 1024) && null !== focusNode) {
                    root3 = void 0;
                    JSCompiler_temp = firstChild;
                    anchorOffset = focusNode.memoizedProps;
                    focusNode = focusNode.memoizedState;
                    selection = JSCompiler_temp.stateNode;
                    try {
                      var resolvedPrevProps = resolveClassComponentProps(
                        JSCompiler_temp.type,
                        anchorOffset
                      );
                      root3 = selection.getSnapshotBeforeUpdate(
                        resolvedPrevProps,
                        focusNode
                      );
                      selection.__reactInternalSnapshotBeforeUpdate = root3;
                    } catch (error) {
                      captureCommitPhaseError(
                        JSCompiler_temp,
                        JSCompiler_temp.return,
                        error
                      );
                    }
                  }
                  break;
                case 3:
                  if (0 !== (root3 & 1024)) {
                    if (root3 = firstChild.stateNode.containerInfo, JSCompiler_temp = root3.nodeType, 9 === JSCompiler_temp)
                      clearContainerSparingly(root3);
                    else if (1 === JSCompiler_temp)
                      switch (root3.nodeName) {
                        case "HEAD":
                        case "HTML":
                        case "BODY":
                          clearContainerSparingly(root3);
                          break;
                        default:
                          root3.textContent = "";
                      }
                  }
                  break;
                case 5:
                case 26:
                case 27:
                case 6:
                case 4:
                case 17:
                  break;
                default:
                  if (0 !== (root3 & 1024))
                    throw Error(formatProdErrorMessage(163));
              }
              root3 = firstChild.sibling;
              if (null !== root3) {
                root3.return = firstChild.return;
                nextEffect = root3;
                break;
              }
              nextEffect = firstChild.return;
            }
      }
      function commitLayoutEffectOnFiber(finishedRoot, current, finishedWork) {
        var flags = finishedWork.flags;
        switch (finishedWork.tag) {
          case 0:
          case 11:
          case 15:
            recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
            flags & 4 && commitHookEffectListMount(5, finishedWork);
            break;
          case 1:
            recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
            if (flags & 4)
              if (finishedRoot = finishedWork.stateNode, null === current)
                try {
                  finishedRoot.componentDidMount();
                } catch (error) {
                  captureCommitPhaseError(finishedWork, finishedWork.return, error);
                }
              else {
                var prevProps = resolveClassComponentProps(
                  finishedWork.type,
                  current.memoizedProps
                );
                current = current.memoizedState;
                try {
                  finishedRoot.componentDidUpdate(
                    prevProps,
                    current,
                    finishedRoot.__reactInternalSnapshotBeforeUpdate
                  );
                } catch (error$139) {
                  captureCommitPhaseError(
                    finishedWork,
                    finishedWork.return,
                    error$139
                  );
                }
              }
            flags & 64 && commitClassCallbacks(finishedWork);
            flags & 512 && safelyAttachRef(finishedWork, finishedWork.return);
            break;
          case 3:
            recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
            if (flags & 64 && (finishedRoot = finishedWork.updateQueue, null !== finishedRoot)) {
              current = null;
              if (null !== finishedWork.child)
                switch (finishedWork.child.tag) {
                  case 27:
                  case 5:
                    current = finishedWork.child.stateNode;
                    break;
                  case 1:
                    current = finishedWork.child.stateNode;
                }
              try {
                commitCallbacks(finishedRoot, current);
              } catch (error) {
                captureCommitPhaseError(finishedWork, finishedWork.return, error);
              }
            }
            break;
          case 27:
            null === current && flags & 4 && commitHostSingletonAcquisition(finishedWork);
          case 26:
          case 5:
            recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
            null === current && flags & 4 && commitHostMount(finishedWork);
            flags & 512 && safelyAttachRef(finishedWork, finishedWork.return);
            break;
          case 12:
            recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
            break;
          case 31:
            recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
            flags & 4 && commitActivityHydrationCallbacks(finishedRoot, finishedWork);
            break;
          case 13:
            recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
            flags & 4 && commitSuspenseHydrationCallbacks(finishedRoot, finishedWork);
            flags & 64 && (finishedRoot = finishedWork.memoizedState, null !== finishedRoot && (finishedRoot = finishedRoot.dehydrated, null !== finishedRoot && (finishedWork = retryDehydratedSuspenseBoundary.bind(
              null,
              finishedWork
            ), registerSuspenseInstanceRetry(finishedRoot, finishedWork))));
            break;
          case 22:
            flags = null !== finishedWork.memoizedState || offscreenSubtreeIsHidden;
            if (!flags) {
              current = null !== current && null !== current.memoizedState || offscreenSubtreeWasHidden;
              prevProps = offscreenSubtreeIsHidden;
              var prevOffscreenSubtreeWasHidden = offscreenSubtreeWasHidden;
              offscreenSubtreeIsHidden = flags;
              (offscreenSubtreeWasHidden = current) && !prevOffscreenSubtreeWasHidden ? recursivelyTraverseReappearLayoutEffects(
                finishedRoot,
                finishedWork,
                0 !== (finishedWork.subtreeFlags & 8772)
              ) : recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
              offscreenSubtreeIsHidden = prevProps;
              offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden;
            }
            break;
          case 30:
            break;
          default:
            recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
        }
      }
      function detachFiberAfterEffects(fiber) {
        var alternate = fiber.alternate;
        null !== alternate && (fiber.alternate = null, detachFiberAfterEffects(alternate));
        fiber.child = null;
        fiber.deletions = null;
        fiber.sibling = null;
        5 === fiber.tag && (alternate = fiber.stateNode, null !== alternate && detachDeletedInstance(alternate));
        fiber.stateNode = null;
        fiber.return = null;
        fiber.dependencies = null;
        fiber.memoizedProps = null;
        fiber.memoizedState = null;
        fiber.pendingProps = null;
        fiber.stateNode = null;
        fiber.updateQueue = null;
      }
      var hostParent = null;
      var hostParentIsContainer = false;
      function recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, parent) {
        for (parent = parent.child; null !== parent; )
          commitDeletionEffectsOnFiber(finishedRoot, nearestMountedAncestor, parent), parent = parent.sibling;
      }
      function commitDeletionEffectsOnFiber(finishedRoot, nearestMountedAncestor, deletedFiber) {
        if (injectedHook && "function" === typeof injectedHook.onCommitFiberUnmount)
          try {
            injectedHook.onCommitFiberUnmount(rendererID, deletedFiber);
          } catch (err) {
          }
        switch (deletedFiber.tag) {
          case 26:
            offscreenSubtreeWasHidden || safelyDetachRef(deletedFiber, nearestMountedAncestor);
            recursivelyTraverseDeletionEffects(
              finishedRoot,
              nearestMountedAncestor,
              deletedFiber
            );
            deletedFiber.memoizedState ? deletedFiber.memoizedState.count-- : deletedFiber.stateNode && (deletedFiber = deletedFiber.stateNode, deletedFiber.parentNode.removeChild(deletedFiber));
            break;
          case 27:
            offscreenSubtreeWasHidden || safelyDetachRef(deletedFiber, nearestMountedAncestor);
            var prevHostParent = hostParent, prevHostParentIsContainer = hostParentIsContainer;
            isSingletonScope(deletedFiber.type) && (hostParent = deletedFiber.stateNode, hostParentIsContainer = false);
            recursivelyTraverseDeletionEffects(
              finishedRoot,
              nearestMountedAncestor,
              deletedFiber
            );
            releaseSingletonInstance(deletedFiber.stateNode);
            hostParent = prevHostParent;
            hostParentIsContainer = prevHostParentIsContainer;
            break;
          case 5:
            offscreenSubtreeWasHidden || safelyDetachRef(deletedFiber, nearestMountedAncestor);
          case 6:
            prevHostParent = hostParent;
            prevHostParentIsContainer = hostParentIsContainer;
            hostParent = null;
            recursivelyTraverseDeletionEffects(
              finishedRoot,
              nearestMountedAncestor,
              deletedFiber
            );
            hostParent = prevHostParent;
            hostParentIsContainer = prevHostParentIsContainer;
            if (null !== hostParent)
              if (hostParentIsContainer)
                try {
                  (9 === hostParent.nodeType ? hostParent.body : "HTML" === hostParent.nodeName ? hostParent.ownerDocument.body : hostParent).removeChild(deletedFiber.stateNode);
                } catch (error) {
                  captureCommitPhaseError(
                    deletedFiber,
                    nearestMountedAncestor,
                    error
                  );
                }
              else
                try {
                  hostParent.removeChild(deletedFiber.stateNode);
                } catch (error) {
                  captureCommitPhaseError(
                    deletedFiber,
                    nearestMountedAncestor,
                    error
                  );
                }
            break;
          case 18:
            null !== hostParent && (hostParentIsContainer ? (finishedRoot = hostParent, clearHydrationBoundary(
              9 === finishedRoot.nodeType ? finishedRoot.body : "HTML" === finishedRoot.nodeName ? finishedRoot.ownerDocument.body : finishedRoot,
              deletedFiber.stateNode
            ), retryIfBlockedOn(finishedRoot)) : clearHydrationBoundary(hostParent, deletedFiber.stateNode));
            break;
          case 4:
            prevHostParent = hostParent;
            prevHostParentIsContainer = hostParentIsContainer;
            hostParent = deletedFiber.stateNode.containerInfo;
            hostParentIsContainer = true;
            recursivelyTraverseDeletionEffects(
              finishedRoot,
              nearestMountedAncestor,
              deletedFiber
            );
            hostParent = prevHostParent;
            hostParentIsContainer = prevHostParentIsContainer;
            break;
          case 0:
          case 11:
          case 14:
          case 15:
            commitHookEffectListUnmount(2, deletedFiber, nearestMountedAncestor);
            offscreenSubtreeWasHidden || commitHookEffectListUnmount(4, deletedFiber, nearestMountedAncestor);
            recursivelyTraverseDeletionEffects(
              finishedRoot,
              nearestMountedAncestor,
              deletedFiber
            );
            break;
          case 1:
            offscreenSubtreeWasHidden || (safelyDetachRef(deletedFiber, nearestMountedAncestor), prevHostParent = deletedFiber.stateNode, "function" === typeof prevHostParent.componentWillUnmount && safelyCallComponentWillUnmount(
              deletedFiber,
              nearestMountedAncestor,
              prevHostParent
            ));
            recursivelyTraverseDeletionEffects(
              finishedRoot,
              nearestMountedAncestor,
              deletedFiber
            );
            break;
          case 21:
            recursivelyTraverseDeletionEffects(
              finishedRoot,
              nearestMountedAncestor,
              deletedFiber
            );
            break;
          case 22:
            offscreenSubtreeWasHidden = (prevHostParent = offscreenSubtreeWasHidden) || null !== deletedFiber.memoizedState;
            recursivelyTraverseDeletionEffects(
              finishedRoot,
              nearestMountedAncestor,
              deletedFiber
            );
            offscreenSubtreeWasHidden = prevHostParent;
            break;
          default:
            recursivelyTraverseDeletionEffects(
              finishedRoot,
              nearestMountedAncestor,
              deletedFiber
            );
        }
      }
      function commitActivityHydrationCallbacks(finishedRoot, finishedWork) {
        if (null === finishedWork.memoizedState && (finishedRoot = finishedWork.alternate, null !== finishedRoot && (finishedRoot = finishedRoot.memoizedState, null !== finishedRoot))) {
          finishedRoot = finishedRoot.dehydrated;
          try {
            retryIfBlockedOn(finishedRoot);
          } catch (error) {
            captureCommitPhaseError(finishedWork, finishedWork.return, error);
          }
        }
      }
      function commitSuspenseHydrationCallbacks(finishedRoot, finishedWork) {
        if (null === finishedWork.memoizedState && (finishedRoot = finishedWork.alternate, null !== finishedRoot && (finishedRoot = finishedRoot.memoizedState, null !== finishedRoot && (finishedRoot = finishedRoot.dehydrated, null !== finishedRoot))))
          try {
            retryIfBlockedOn(finishedRoot);
          } catch (error) {
            captureCommitPhaseError(finishedWork, finishedWork.return, error);
          }
      }
      function getRetryCache(finishedWork) {
        switch (finishedWork.tag) {
          case 31:
          case 13:
          case 19:
            var retryCache = finishedWork.stateNode;
            null === retryCache && (retryCache = finishedWork.stateNode = new PossiblyWeakSet());
            return retryCache;
          case 22:
            return finishedWork = finishedWork.stateNode, retryCache = finishedWork._retryCache, null === retryCache && (retryCache = finishedWork._retryCache = new PossiblyWeakSet()), retryCache;
          default:
            throw Error(formatProdErrorMessage(435, finishedWork.tag));
        }
      }
      function attachSuspenseRetryListeners(finishedWork, wakeables) {
        var retryCache = getRetryCache(finishedWork);
        wakeables.forEach(function(wakeable) {
          if (!retryCache.has(wakeable)) {
            retryCache.add(wakeable);
            var retry = resolveRetryWakeable.bind(null, finishedWork, wakeable);
            wakeable.then(retry, retry);
          }
        });
      }
      function recursivelyTraverseMutationEffects(root$jscomp$0, parentFiber) {
        var deletions = parentFiber.deletions;
        if (null !== deletions)
          for (var i = 0; i < deletions.length; i++) {
            var childToDelete = deletions[i], root3 = root$jscomp$0, returnFiber = parentFiber, parent = returnFiber;
            a:
              for (; null !== parent; ) {
                switch (parent.tag) {
                  case 27:
                    if (isSingletonScope(parent.type)) {
                      hostParent = parent.stateNode;
                      hostParentIsContainer = false;
                      break a;
                    }
                    break;
                  case 5:
                    hostParent = parent.stateNode;
                    hostParentIsContainer = false;
                    break a;
                  case 3:
                  case 4:
                    hostParent = parent.stateNode.containerInfo;
                    hostParentIsContainer = true;
                    break a;
                }
                parent = parent.return;
              }
            if (null === hostParent)
              throw Error(formatProdErrorMessage(160));
            commitDeletionEffectsOnFiber(root3, returnFiber, childToDelete);
            hostParent = null;
            hostParentIsContainer = false;
            root3 = childToDelete.alternate;
            null !== root3 && (root3.return = null);
            childToDelete.return = null;
          }
        if (parentFiber.subtreeFlags & 13886)
          for (parentFiber = parentFiber.child; null !== parentFiber; )
            commitMutationEffectsOnFiber(parentFiber, root$jscomp$0), parentFiber = parentFiber.sibling;
      }
      var currentHoistableRoot = null;
      function commitMutationEffectsOnFiber(finishedWork, root3) {
        var current = finishedWork.alternate, flags = finishedWork.flags;
        switch (finishedWork.tag) {
          case 0:
          case 11:
          case 14:
          case 15:
            recursivelyTraverseMutationEffects(root3, finishedWork);
            commitReconciliationEffects(finishedWork);
            flags & 4 && (commitHookEffectListUnmount(3, finishedWork, finishedWork.return), commitHookEffectListMount(3, finishedWork), commitHookEffectListUnmount(5, finishedWork, finishedWork.return));
            break;
          case 1:
            recursivelyTraverseMutationEffects(root3, finishedWork);
            commitReconciliationEffects(finishedWork);
            flags & 512 && (offscreenSubtreeWasHidden || null === current || safelyDetachRef(current, current.return));
            flags & 64 && offscreenSubtreeIsHidden && (finishedWork = finishedWork.updateQueue, null !== finishedWork && (flags = finishedWork.callbacks, null !== flags && (current = finishedWork.shared.hiddenCallbacks, finishedWork.shared.hiddenCallbacks = null === current ? flags : current.concat(flags))));
            break;
          case 26:
            var hoistableRoot = currentHoistableRoot;
            recursivelyTraverseMutationEffects(root3, finishedWork);
            commitReconciliationEffects(finishedWork);
            flags & 512 && (offscreenSubtreeWasHidden || null === current || safelyDetachRef(current, current.return));
            if (flags & 4) {
              var currentResource = null !== current ? current.memoizedState : null;
              flags = finishedWork.memoizedState;
              if (null === current)
                if (null === flags)
                  if (null === finishedWork.stateNode) {
                    a: {
                      flags = finishedWork.type;
                      current = finishedWork.memoizedProps;
                      hoistableRoot = hoistableRoot.ownerDocument || hoistableRoot;
                      b:
                        switch (flags) {
                          case "title":
                            currentResource = hoistableRoot.getElementsByTagName("title")[0];
                            if (!currentResource || currentResource[internalHoistableMarker] || currentResource[internalInstanceKey] || "http://www.w3.org/2000/svg" === currentResource.namespaceURI || currentResource.hasAttribute("itemprop"))
                              currentResource = hoistableRoot.createElement(flags), hoistableRoot.head.insertBefore(
                                currentResource,
                                hoistableRoot.querySelector("head > title")
                              );
                            setInitialProperties(currentResource, flags, current);
                            currentResource[internalInstanceKey] = finishedWork;
                            markNodeAsHoistable(currentResource);
                            flags = currentResource;
                            break a;
                          case "link":
                            var maybeNodes = getHydratableHoistableCache(
                              "link",
                              "href",
                              hoistableRoot
                            ).get(flags + (current.href || ""));
                            if (maybeNodes) {
                              for (var i = 0; i < maybeNodes.length; i++)
                                if (currentResource = maybeNodes[i], currentResource.getAttribute("href") === (null == current.href || "" === current.href ? null : current.href) && currentResource.getAttribute("rel") === (null == current.rel ? null : current.rel) && currentResource.getAttribute("title") === (null == current.title ? null : current.title) && currentResource.getAttribute("crossorigin") === (null == current.crossOrigin ? null : current.crossOrigin)) {
                                  maybeNodes.splice(i, 1);
                                  break b;
                                }
                            }
                            currentResource = hoistableRoot.createElement(flags);
                            setInitialProperties(currentResource, flags, current);
                            hoistableRoot.head.appendChild(currentResource);
                            break;
                          case "meta":
                            if (maybeNodes = getHydratableHoistableCache(
                              "meta",
                              "content",
                              hoistableRoot
                            ).get(flags + (current.content || ""))) {
                              for (i = 0; i < maybeNodes.length; i++)
                                if (currentResource = maybeNodes[i], currentResource.getAttribute("content") === (null == current.content ? null : "" + current.content) && currentResource.getAttribute("name") === (null == current.name ? null : current.name) && currentResource.getAttribute("property") === (null == current.property ? null : current.property) && currentResource.getAttribute("http-equiv") === (null == current.httpEquiv ? null : current.httpEquiv) && currentResource.getAttribute("charset") === (null == current.charSet ? null : current.charSet)) {
                                  maybeNodes.splice(i, 1);
                                  break b;
                                }
                            }
                            currentResource = hoistableRoot.createElement(flags);
                            setInitialProperties(currentResource, flags, current);
                            hoistableRoot.head.appendChild(currentResource);
                            break;
                          default:
                            throw Error(formatProdErrorMessage(468, flags));
                        }
                      currentResource[internalInstanceKey] = finishedWork;
                      markNodeAsHoistable(currentResource);
                      flags = currentResource;
                    }
                    finishedWork.stateNode = flags;
                  } else
                    mountHoistable(
                      hoistableRoot,
                      finishedWork.type,
                      finishedWork.stateNode
                    );
                else
                  finishedWork.stateNode = acquireResource(
                    hoistableRoot,
                    flags,
                    finishedWork.memoizedProps
                  );
              else
                currentResource !== flags ? (null === currentResource ? null !== current.stateNode && (current = current.stateNode, current.parentNode.removeChild(current)) : currentResource.count--, null === flags ? mountHoistable(
                  hoistableRoot,
                  finishedWork.type,
                  finishedWork.stateNode
                ) : acquireResource(
                  hoistableRoot,
                  flags,
                  finishedWork.memoizedProps
                )) : null === flags && null !== finishedWork.stateNode && commitHostUpdate(
                  finishedWork,
                  finishedWork.memoizedProps,
                  current.memoizedProps
                );
            }
            break;
          case 27:
            recursivelyTraverseMutationEffects(root3, finishedWork);
            commitReconciliationEffects(finishedWork);
            flags & 512 && (offscreenSubtreeWasHidden || null === current || safelyDetachRef(current, current.return));
            null !== current && flags & 4 && commitHostUpdate(
              finishedWork,
              finishedWork.memoizedProps,
              current.memoizedProps
            );
            break;
          case 5:
            recursivelyTraverseMutationEffects(root3, finishedWork);
            commitReconciliationEffects(finishedWork);
            flags & 512 && (offscreenSubtreeWasHidden || null === current || safelyDetachRef(current, current.return));
            if (finishedWork.flags & 32) {
              hoistableRoot = finishedWork.stateNode;
              try {
                setTextContent(hoistableRoot, "");
              } catch (error) {
                captureCommitPhaseError(finishedWork, finishedWork.return, error);
              }
            }
            flags & 4 && null != finishedWork.stateNode && (hoistableRoot = finishedWork.memoizedProps, commitHostUpdate(
              finishedWork,
              hoistableRoot,
              null !== current ? current.memoizedProps : hoistableRoot
            ));
            flags & 1024 && (needsFormReset = true);
            break;
          case 6:
            recursivelyTraverseMutationEffects(root3, finishedWork);
            commitReconciliationEffects(finishedWork);
            if (flags & 4) {
              if (null === finishedWork.stateNode)
                throw Error(formatProdErrorMessage(162));
              flags = finishedWork.memoizedProps;
              current = finishedWork.stateNode;
              try {
                current.nodeValue = flags;
              } catch (error) {
                captureCommitPhaseError(finishedWork, finishedWork.return, error);
              }
            }
            break;
          case 3:
            tagCaches = null;
            hoistableRoot = currentHoistableRoot;
            currentHoistableRoot = getHoistableRoot(root3.containerInfo);
            recursivelyTraverseMutationEffects(root3, finishedWork);
            currentHoistableRoot = hoistableRoot;
            commitReconciliationEffects(finishedWork);
            if (flags & 4 && null !== current && current.memoizedState.isDehydrated)
              try {
                retryIfBlockedOn(root3.containerInfo);
              } catch (error) {
                captureCommitPhaseError(finishedWork, finishedWork.return, error);
              }
            needsFormReset && (needsFormReset = false, recursivelyResetForms(finishedWork));
            break;
          case 4:
            flags = currentHoistableRoot;
            currentHoistableRoot = getHoistableRoot(
              finishedWork.stateNode.containerInfo
            );
            recursivelyTraverseMutationEffects(root3, finishedWork);
            commitReconciliationEffects(finishedWork);
            currentHoistableRoot = flags;
            break;
          case 12:
            recursivelyTraverseMutationEffects(root3, finishedWork);
            commitReconciliationEffects(finishedWork);
            break;
          case 31:
            recursivelyTraverseMutationEffects(root3, finishedWork);
            commitReconciliationEffects(finishedWork);
            flags & 4 && (flags = finishedWork.updateQueue, null !== flags && (finishedWork.updateQueue = null, attachSuspenseRetryListeners(finishedWork, flags)));
            break;
          case 13:
            recursivelyTraverseMutationEffects(root3, finishedWork);
            commitReconciliationEffects(finishedWork);
            finishedWork.child.flags & 8192 && null !== finishedWork.memoizedState !== (null !== current && null !== current.memoizedState) && (globalMostRecentFallbackTime = now());
            flags & 4 && (flags = finishedWork.updateQueue, null !== flags && (finishedWork.updateQueue = null, attachSuspenseRetryListeners(finishedWork, flags)));
            break;
          case 22:
            hoistableRoot = null !== finishedWork.memoizedState;
            var wasHidden = null !== current && null !== current.memoizedState, prevOffscreenSubtreeIsHidden = offscreenSubtreeIsHidden, prevOffscreenSubtreeWasHidden = offscreenSubtreeWasHidden;
            offscreenSubtreeIsHidden = prevOffscreenSubtreeIsHidden || hoistableRoot;
            offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden || wasHidden;
            recursivelyTraverseMutationEffects(root3, finishedWork);
            offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden;
            offscreenSubtreeIsHidden = prevOffscreenSubtreeIsHidden;
            commitReconciliationEffects(finishedWork);
            if (flags & 8192)
              a:
                for (root3 = finishedWork.stateNode, root3._visibility = hoistableRoot ? root3._visibility & -2 : root3._visibility | 1, hoistableRoot && (null === current || wasHidden || offscreenSubtreeIsHidden || offscreenSubtreeWasHidden || recursivelyTraverseDisappearLayoutEffects(finishedWork)), current = null, root3 = finishedWork; ; ) {
                  if (5 === root3.tag || 26 === root3.tag) {
                    if (null === current) {
                      wasHidden = current = root3;
                      try {
                        if (currentResource = wasHidden.stateNode, hoistableRoot)
                          maybeNodes = currentResource.style, "function" === typeof maybeNodes.setProperty ? maybeNodes.setProperty("display", "none", "important") : maybeNodes.display = "none";
                        else {
                          i = wasHidden.stateNode;
                          var styleProp = wasHidden.memoizedProps.style, display = void 0 !== styleProp && null !== styleProp && styleProp.hasOwnProperty("display") ? styleProp.display : null;
                          i.style.display = null == display || "boolean" === typeof display ? "" : ("" + display).trim();
                        }
                      } catch (error) {
                        captureCommitPhaseError(wasHidden, wasHidden.return, error);
                      }
                    }
                  } else if (6 === root3.tag) {
                    if (null === current) {
                      wasHidden = root3;
                      try {
                        wasHidden.stateNode.nodeValue = hoistableRoot ? "" : wasHidden.memoizedProps;
                      } catch (error) {
                        captureCommitPhaseError(wasHidden, wasHidden.return, error);
                      }
                    }
                  } else if (18 === root3.tag) {
                    if (null === current) {
                      wasHidden = root3;
                      try {
                        var instance = wasHidden.stateNode;
                        hoistableRoot ? hideOrUnhideDehydratedBoundary(instance, true) : hideOrUnhideDehydratedBoundary(wasHidden.stateNode, false);
                      } catch (error) {
                        captureCommitPhaseError(wasHidden, wasHidden.return, error);
                      }
                    }
                  } else if ((22 !== root3.tag && 23 !== root3.tag || null === root3.memoizedState || root3 === finishedWork) && null !== root3.child) {
                    root3.child.return = root3;
                    root3 = root3.child;
                    continue;
                  }
                  if (root3 === finishedWork)
                    break a;
                  for (; null === root3.sibling; ) {
                    if (null === root3.return || root3.return === finishedWork)
                      break a;
                    current === root3 && (current = null);
                    root3 = root3.return;
                  }
                  current === root3 && (current = null);
                  root3.sibling.return = root3.return;
                  root3 = root3.sibling;
                }
            flags & 4 && (flags = finishedWork.updateQueue, null !== flags && (current = flags.retryQueue, null !== current && (flags.retryQueue = null, attachSuspenseRetryListeners(finishedWork, current))));
            break;
          case 19:
            recursivelyTraverseMutationEffects(root3, finishedWork);
            commitReconciliationEffects(finishedWork);
            flags & 4 && (flags = finishedWork.updateQueue, null !== flags && (finishedWork.updateQueue = null, attachSuspenseRetryListeners(finishedWork, flags)));
            break;
          case 30:
            break;
          case 21:
            break;
          default:
            recursivelyTraverseMutationEffects(root3, finishedWork), commitReconciliationEffects(finishedWork);
        }
      }
      function commitReconciliationEffects(finishedWork) {
        var flags = finishedWork.flags;
        if (flags & 2) {
          try {
            for (var hostParentFiber, parentFiber = finishedWork.return; null !== parentFiber; ) {
              if (isHostParent(parentFiber)) {
                hostParentFiber = parentFiber;
                break;
              }
              parentFiber = parentFiber.return;
            }
            if (null == hostParentFiber)
              throw Error(formatProdErrorMessage(160));
            switch (hostParentFiber.tag) {
              case 27:
                var parent = hostParentFiber.stateNode, before = getHostSibling(finishedWork);
                insertOrAppendPlacementNode(finishedWork, before, parent);
                break;
              case 5:
                var parent$141 = hostParentFiber.stateNode;
                hostParentFiber.flags & 32 && (setTextContent(parent$141, ""), hostParentFiber.flags &= -33);
                var before$142 = getHostSibling(finishedWork);
                insertOrAppendPlacementNode(finishedWork, before$142, parent$141);
                break;
              case 3:
              case 4:
                var parent$143 = hostParentFiber.stateNode.containerInfo, before$144 = getHostSibling(finishedWork);
                insertOrAppendPlacementNodeIntoContainer(
                  finishedWork,
                  before$144,
                  parent$143
                );
                break;
              default:
                throw Error(formatProdErrorMessage(161));
            }
          } catch (error) {
            captureCommitPhaseError(finishedWork, finishedWork.return, error);
          }
          finishedWork.flags &= -3;
        }
        flags & 4096 && (finishedWork.flags &= -4097);
      }
      function recursivelyResetForms(parentFiber) {
        if (parentFiber.subtreeFlags & 1024)
          for (parentFiber = parentFiber.child; null !== parentFiber; ) {
            var fiber = parentFiber;
            recursivelyResetForms(fiber);
            5 === fiber.tag && fiber.flags & 1024 && fiber.stateNode.reset();
            parentFiber = parentFiber.sibling;
          }
      }
      function recursivelyTraverseLayoutEffects(root3, parentFiber) {
        if (parentFiber.subtreeFlags & 8772)
          for (parentFiber = parentFiber.child; null !== parentFiber; )
            commitLayoutEffectOnFiber(root3, parentFiber.alternate, parentFiber), parentFiber = parentFiber.sibling;
      }
      function recursivelyTraverseDisappearLayoutEffects(parentFiber) {
        for (parentFiber = parentFiber.child; null !== parentFiber; ) {
          var finishedWork = parentFiber;
          switch (finishedWork.tag) {
            case 0:
            case 11:
            case 14:
            case 15:
              commitHookEffectListUnmount(4, finishedWork, finishedWork.return);
              recursivelyTraverseDisappearLayoutEffects(finishedWork);
              break;
            case 1:
              safelyDetachRef(finishedWork, finishedWork.return);
              var instance = finishedWork.stateNode;
              "function" === typeof instance.componentWillUnmount && safelyCallComponentWillUnmount(
                finishedWork,
                finishedWork.return,
                instance
              );
              recursivelyTraverseDisappearLayoutEffects(finishedWork);
              break;
            case 27:
              releaseSingletonInstance(finishedWork.stateNode);
            case 26:
            case 5:
              safelyDetachRef(finishedWork, finishedWork.return);
              recursivelyTraverseDisappearLayoutEffects(finishedWork);
              break;
            case 22:
              null === finishedWork.memoizedState && recursivelyTraverseDisappearLayoutEffects(finishedWork);
              break;
            case 30:
              recursivelyTraverseDisappearLayoutEffects(finishedWork);
              break;
            default:
              recursivelyTraverseDisappearLayoutEffects(finishedWork);
          }
          parentFiber = parentFiber.sibling;
        }
      }
      function recursivelyTraverseReappearLayoutEffects(finishedRoot$jscomp$0, parentFiber, includeWorkInProgressEffects) {
        includeWorkInProgressEffects = includeWorkInProgressEffects && 0 !== (parentFiber.subtreeFlags & 8772);
        for (parentFiber = parentFiber.child; null !== parentFiber; ) {
          var current = parentFiber.alternate, finishedRoot = finishedRoot$jscomp$0, finishedWork = parentFiber, flags = finishedWork.flags;
          switch (finishedWork.tag) {
            case 0:
            case 11:
            case 15:
              recursivelyTraverseReappearLayoutEffects(
                finishedRoot,
                finishedWork,
                includeWorkInProgressEffects
              );
              commitHookEffectListMount(4, finishedWork);
              break;
            case 1:
              recursivelyTraverseReappearLayoutEffects(
                finishedRoot,
                finishedWork,
                includeWorkInProgressEffects
              );
              current = finishedWork;
              finishedRoot = current.stateNode;
              if ("function" === typeof finishedRoot.componentDidMount)
                try {
                  finishedRoot.componentDidMount();
                } catch (error) {
                  captureCommitPhaseError(current, current.return, error);
                }
              current = finishedWork;
              finishedRoot = current.updateQueue;
              if (null !== finishedRoot) {
                var instance = current.stateNode;
                try {
                  var hiddenCallbacks = finishedRoot.shared.hiddenCallbacks;
                  if (null !== hiddenCallbacks)
                    for (finishedRoot.shared.hiddenCallbacks = null, finishedRoot = 0; finishedRoot < hiddenCallbacks.length; finishedRoot++)
                      callCallback(hiddenCallbacks[finishedRoot], instance);
                } catch (error) {
                  captureCommitPhaseError(current, current.return, error);
                }
              }
              includeWorkInProgressEffects && flags & 64 && commitClassCallbacks(finishedWork);
              safelyAttachRef(finishedWork, finishedWork.return);
              break;
            case 27:
              commitHostSingletonAcquisition(finishedWork);
            case 26:
            case 5:
              recursivelyTraverseReappearLayoutEffects(
                finishedRoot,
                finishedWork,
                includeWorkInProgressEffects
              );
              includeWorkInProgressEffects && null === current && flags & 4 && commitHostMount(finishedWork);
              safelyAttachRef(finishedWork, finishedWork.return);
              break;
            case 12:
              recursivelyTraverseReappearLayoutEffects(
                finishedRoot,
                finishedWork,
                includeWorkInProgressEffects
              );
              break;
            case 31:
              recursivelyTraverseReappearLayoutEffects(
                finishedRoot,
                finishedWork,
                includeWorkInProgressEffects
              );
              includeWorkInProgressEffects && flags & 4 && commitActivityHydrationCallbacks(finishedRoot, finishedWork);
              break;
            case 13:
              recursivelyTraverseReappearLayoutEffects(
                finishedRoot,
                finishedWork,
                includeWorkInProgressEffects
              );
              includeWorkInProgressEffects && flags & 4 && commitSuspenseHydrationCallbacks(finishedRoot, finishedWork);
              break;
            case 22:
              null === finishedWork.memoizedState && recursivelyTraverseReappearLayoutEffects(
                finishedRoot,
                finishedWork,
                includeWorkInProgressEffects
              );
              safelyAttachRef(finishedWork, finishedWork.return);
              break;
            case 30:
              break;
            default:
              recursivelyTraverseReappearLayoutEffects(
                finishedRoot,
                finishedWork,
                includeWorkInProgressEffects
              );
          }
          parentFiber = parentFiber.sibling;
        }
      }
      function commitOffscreenPassiveMountEffects(current, finishedWork) {
        var previousCache = null;
        null !== current && null !== current.memoizedState && null !== current.memoizedState.cachePool && (previousCache = current.memoizedState.cachePool.pool);
        current = null;
        null !== finishedWork.memoizedState && null !== finishedWork.memoizedState.cachePool && (current = finishedWork.memoizedState.cachePool.pool);
        current !== previousCache && (null != current && current.refCount++, null != previousCache && releaseCache(previousCache));
      }
      function commitCachePassiveMountEffect(current, finishedWork) {
        current = null;
        null !== finishedWork.alternate && (current = finishedWork.alternate.memoizedState.cache);
        finishedWork = finishedWork.memoizedState.cache;
        finishedWork !== current && (finishedWork.refCount++, null != current && releaseCache(current));
      }
      function recursivelyTraversePassiveMountEffects(root3, parentFiber, committedLanes, committedTransitions) {
        if (parentFiber.subtreeFlags & 10256)
          for (parentFiber = parentFiber.child; null !== parentFiber; )
            commitPassiveMountOnFiber(
              root3,
              parentFiber,
              committedLanes,
              committedTransitions
            ), parentFiber = parentFiber.sibling;
      }
      function commitPassiveMountOnFiber(finishedRoot, finishedWork, committedLanes, committedTransitions) {
        var flags = finishedWork.flags;
        switch (finishedWork.tag) {
          case 0:
          case 11:
          case 15:
            recursivelyTraversePassiveMountEffects(
              finishedRoot,
              finishedWork,
              committedLanes,
              committedTransitions
            );
            flags & 2048 && commitHookEffectListMount(9, finishedWork);
            break;
          case 1:
            recursivelyTraversePassiveMountEffects(
              finishedRoot,
              finishedWork,
              committedLanes,
              committedTransitions
            );
            break;
          case 3:
            recursivelyTraversePassiveMountEffects(
              finishedRoot,
              finishedWork,
              committedLanes,
              committedTransitions
            );
            flags & 2048 && (finishedRoot = null, null !== finishedWork.alternate && (finishedRoot = finishedWork.alternate.memoizedState.cache), finishedWork = finishedWork.memoizedState.cache, finishedWork !== finishedRoot && (finishedWork.refCount++, null != finishedRoot && releaseCache(finishedRoot)));
            break;
          case 12:
            if (flags & 2048) {
              recursivelyTraversePassiveMountEffects(
                finishedRoot,
                finishedWork,
                committedLanes,
                committedTransitions
              );
              finishedRoot = finishedWork.stateNode;
              try {
                var _finishedWork$memoize2 = finishedWork.memoizedProps, id = _finishedWork$memoize2.id, onPostCommit = _finishedWork$memoize2.onPostCommit;
                "function" === typeof onPostCommit && onPostCommit(
                  id,
                  null === finishedWork.alternate ? "mount" : "update",
                  finishedRoot.passiveEffectDuration,
                  -0
                );
              } catch (error) {
                captureCommitPhaseError(finishedWork, finishedWork.return, error);
              }
            } else
              recursivelyTraversePassiveMountEffects(
                finishedRoot,
                finishedWork,
                committedLanes,
                committedTransitions
              );
            break;
          case 31:
            recursivelyTraversePassiveMountEffects(
              finishedRoot,
              finishedWork,
              committedLanes,
              committedTransitions
            );
            break;
          case 13:
            recursivelyTraversePassiveMountEffects(
              finishedRoot,
              finishedWork,
              committedLanes,
              committedTransitions
            );
            break;
          case 23:
            break;
          case 22:
            _finishedWork$memoize2 = finishedWork.stateNode;
            id = finishedWork.alternate;
            null !== finishedWork.memoizedState ? _finishedWork$memoize2._visibility & 2 ? recursivelyTraversePassiveMountEffects(
              finishedRoot,
              finishedWork,
              committedLanes,
              committedTransitions
            ) : recursivelyTraverseAtomicPassiveEffects(finishedRoot, finishedWork) : _finishedWork$memoize2._visibility & 2 ? recursivelyTraversePassiveMountEffects(
              finishedRoot,
              finishedWork,
              committedLanes,
              committedTransitions
            ) : (_finishedWork$memoize2._visibility |= 2, recursivelyTraverseReconnectPassiveEffects(
              finishedRoot,
              finishedWork,
              committedLanes,
              committedTransitions,
              0 !== (finishedWork.subtreeFlags & 10256) || false
            ));
            flags & 2048 && commitOffscreenPassiveMountEffects(id, finishedWork);
            break;
          case 24:
            recursivelyTraversePassiveMountEffects(
              finishedRoot,
              finishedWork,
              committedLanes,
              committedTransitions
            );
            flags & 2048 && commitCachePassiveMountEffect(finishedWork.alternate, finishedWork);
            break;
          default:
            recursivelyTraversePassiveMountEffects(
              finishedRoot,
              finishedWork,
              committedLanes,
              committedTransitions
            );
        }
      }
      function recursivelyTraverseReconnectPassiveEffects(finishedRoot$jscomp$0, parentFiber, committedLanes$jscomp$0, committedTransitions$jscomp$0, includeWorkInProgressEffects) {
        includeWorkInProgressEffects = includeWorkInProgressEffects && (0 !== (parentFiber.subtreeFlags & 10256) || false);
        for (parentFiber = parentFiber.child; null !== parentFiber; ) {
          var finishedRoot = finishedRoot$jscomp$0, finishedWork = parentFiber, committedLanes = committedLanes$jscomp$0, committedTransitions = committedTransitions$jscomp$0, flags = finishedWork.flags;
          switch (finishedWork.tag) {
            case 0:
            case 11:
            case 15:
              recursivelyTraverseReconnectPassiveEffects(
                finishedRoot,
                finishedWork,
                committedLanes,
                committedTransitions,
                includeWorkInProgressEffects
              );
              commitHookEffectListMount(8, finishedWork);
              break;
            case 23:
              break;
            case 22:
              var instance = finishedWork.stateNode;
              null !== finishedWork.memoizedState ? instance._visibility & 2 ? recursivelyTraverseReconnectPassiveEffects(
                finishedRoot,
                finishedWork,
                committedLanes,
                committedTransitions,
                includeWorkInProgressEffects
              ) : recursivelyTraverseAtomicPassiveEffects(
                finishedRoot,
                finishedWork
              ) : (instance._visibility |= 2, recursivelyTraverseReconnectPassiveEffects(
                finishedRoot,
                finishedWork,
                committedLanes,
                committedTransitions,
                includeWorkInProgressEffects
              ));
              includeWorkInProgressEffects && flags & 2048 && commitOffscreenPassiveMountEffects(
                finishedWork.alternate,
                finishedWork
              );
              break;
            case 24:
              recursivelyTraverseReconnectPassiveEffects(
                finishedRoot,
                finishedWork,
                committedLanes,
                committedTransitions,
                includeWorkInProgressEffects
              );
              includeWorkInProgressEffects && flags & 2048 && commitCachePassiveMountEffect(finishedWork.alternate, finishedWork);
              break;
            default:
              recursivelyTraverseReconnectPassiveEffects(
                finishedRoot,
                finishedWork,
                committedLanes,
                committedTransitions,
                includeWorkInProgressEffects
              );
          }
          parentFiber = parentFiber.sibling;
        }
      }
      function recursivelyTraverseAtomicPassiveEffects(finishedRoot$jscomp$0, parentFiber) {
        if (parentFiber.subtreeFlags & 10256)
          for (parentFiber = parentFiber.child; null !== parentFiber; ) {
            var finishedRoot = finishedRoot$jscomp$0, finishedWork = parentFiber, flags = finishedWork.flags;
            switch (finishedWork.tag) {
              case 22:
                recursivelyTraverseAtomicPassiveEffects(finishedRoot, finishedWork);
                flags & 2048 && commitOffscreenPassiveMountEffects(
                  finishedWork.alternate,
                  finishedWork
                );
                break;
              case 24:
                recursivelyTraverseAtomicPassiveEffects(finishedRoot, finishedWork);
                flags & 2048 && commitCachePassiveMountEffect(finishedWork.alternate, finishedWork);
                break;
              default:
                recursivelyTraverseAtomicPassiveEffects(finishedRoot, finishedWork);
            }
            parentFiber = parentFiber.sibling;
          }
      }
      var suspenseyCommitFlag = 8192;
      function recursivelyAccumulateSuspenseyCommit(parentFiber, committedLanes, suspendedState) {
        if (parentFiber.subtreeFlags & suspenseyCommitFlag)
          for (parentFiber = parentFiber.child; null !== parentFiber; )
            accumulateSuspenseyCommitOnFiber(
              parentFiber,
              committedLanes,
              suspendedState
            ), parentFiber = parentFiber.sibling;
      }
      function accumulateSuspenseyCommitOnFiber(fiber, committedLanes, suspendedState) {
        switch (fiber.tag) {
          case 26:
            recursivelyAccumulateSuspenseyCommit(
              fiber,
              committedLanes,
              suspendedState
            );
            fiber.flags & suspenseyCommitFlag && null !== fiber.memoizedState && suspendResource(
              suspendedState,
              currentHoistableRoot,
              fiber.memoizedState,
              fiber.memoizedProps
            );
            break;
          case 5:
            recursivelyAccumulateSuspenseyCommit(
              fiber,
              committedLanes,
              suspendedState
            );
            break;
          case 3:
          case 4:
            var previousHoistableRoot = currentHoistableRoot;
            currentHoistableRoot = getHoistableRoot(fiber.stateNode.containerInfo);
            recursivelyAccumulateSuspenseyCommit(
              fiber,
              committedLanes,
              suspendedState
            );
            currentHoistableRoot = previousHoistableRoot;
            break;
          case 22:
            null === fiber.memoizedState && (previousHoistableRoot = fiber.alternate, null !== previousHoistableRoot && null !== previousHoistableRoot.memoizedState ? (previousHoistableRoot = suspenseyCommitFlag, suspenseyCommitFlag = 16777216, recursivelyAccumulateSuspenseyCommit(
              fiber,
              committedLanes,
              suspendedState
            ), suspenseyCommitFlag = previousHoistableRoot) : recursivelyAccumulateSuspenseyCommit(
              fiber,
              committedLanes,
              suspendedState
            ));
            break;
          default:
            recursivelyAccumulateSuspenseyCommit(
              fiber,
              committedLanes,
              suspendedState
            );
        }
      }
      function detachAlternateSiblings(parentFiber) {
        var previousFiber = parentFiber.alternate;
        if (null !== previousFiber && (parentFiber = previousFiber.child, null !== parentFiber)) {
          previousFiber.child = null;
          do
            previousFiber = parentFiber.sibling, parentFiber.sibling = null, parentFiber = previousFiber;
          while (null !== parentFiber);
        }
      }
      function recursivelyTraversePassiveUnmountEffects(parentFiber) {
        var deletions = parentFiber.deletions;
        if (0 !== (parentFiber.flags & 16)) {
          if (null !== deletions)
            for (var i = 0; i < deletions.length; i++) {
              var childToDelete = deletions[i];
              nextEffect = childToDelete;
              commitPassiveUnmountEffectsInsideOfDeletedTree_begin(
                childToDelete,
                parentFiber
              );
            }
          detachAlternateSiblings(parentFiber);
        }
        if (parentFiber.subtreeFlags & 10256)
          for (parentFiber = parentFiber.child; null !== parentFiber; )
            commitPassiveUnmountOnFiber(parentFiber), parentFiber = parentFiber.sibling;
      }
      function commitPassiveUnmountOnFiber(finishedWork) {
        switch (finishedWork.tag) {
          case 0:
          case 11:
          case 15:
            recursivelyTraversePassiveUnmountEffects(finishedWork);
            finishedWork.flags & 2048 && commitHookEffectListUnmount(9, finishedWork, finishedWork.return);
            break;
          case 3:
            recursivelyTraversePassiveUnmountEffects(finishedWork);
            break;
          case 12:
            recursivelyTraversePassiveUnmountEffects(finishedWork);
            break;
          case 22:
            var instance = finishedWork.stateNode;
            null !== finishedWork.memoizedState && instance._visibility & 2 && (null === finishedWork.return || 13 !== finishedWork.return.tag) ? (instance._visibility &= -3, recursivelyTraverseDisconnectPassiveEffects(finishedWork)) : recursivelyTraversePassiveUnmountEffects(finishedWork);
            break;
          default:
            recursivelyTraversePassiveUnmountEffects(finishedWork);
        }
      }
      function recursivelyTraverseDisconnectPassiveEffects(parentFiber) {
        var deletions = parentFiber.deletions;
        if (0 !== (parentFiber.flags & 16)) {
          if (null !== deletions)
            for (var i = 0; i < deletions.length; i++) {
              var childToDelete = deletions[i];
              nextEffect = childToDelete;
              commitPassiveUnmountEffectsInsideOfDeletedTree_begin(
                childToDelete,
                parentFiber
              );
            }
          detachAlternateSiblings(parentFiber);
        }
        for (parentFiber = parentFiber.child; null !== parentFiber; ) {
          deletions = parentFiber;
          switch (deletions.tag) {
            case 0:
            case 11:
            case 15:
              commitHookEffectListUnmount(8, deletions, deletions.return);
              recursivelyTraverseDisconnectPassiveEffects(deletions);
              break;
            case 22:
              i = deletions.stateNode;
              i._visibility & 2 && (i._visibility &= -3, recursivelyTraverseDisconnectPassiveEffects(deletions));
              break;
            default:
              recursivelyTraverseDisconnectPassiveEffects(deletions);
          }
          parentFiber = parentFiber.sibling;
        }
      }
      function commitPassiveUnmountEffectsInsideOfDeletedTree_begin(deletedSubtreeRoot, nearestMountedAncestor) {
        for (; null !== nextEffect; ) {
          var fiber = nextEffect;
          switch (fiber.tag) {
            case 0:
            case 11:
            case 15:
              commitHookEffectListUnmount(8, fiber, nearestMountedAncestor);
              break;
            case 23:
            case 22:
              if (null !== fiber.memoizedState && null !== fiber.memoizedState.cachePool) {
                var cache = fiber.memoizedState.cachePool.pool;
                null != cache && cache.refCount++;
              }
              break;
            case 24:
              releaseCache(fiber.memoizedState.cache);
          }
          cache = fiber.child;
          if (null !== cache)
            cache.return = fiber, nextEffect = cache;
          else
            a:
              for (fiber = deletedSubtreeRoot; null !== nextEffect; ) {
                cache = nextEffect;
                var sibling = cache.sibling, returnFiber = cache.return;
                detachFiberAfterEffects(cache);
                if (cache === fiber) {
                  nextEffect = null;
                  break a;
                }
                if (null !== sibling) {
                  sibling.return = returnFiber;
                  nextEffect = sibling;
                  break a;
                }
                nextEffect = returnFiber;
              }
        }
      }
      var DefaultAsyncDispatcher = {
        getCacheForType: function(resourceType) {
          var cache = readContext(CacheContext), cacheForType = cache.data.get(resourceType);
          void 0 === cacheForType && (cacheForType = resourceType(), cache.data.set(resourceType, cacheForType));
          return cacheForType;
        },
        cacheSignal: function() {
          return readContext(CacheContext).controller.signal;
        }
      };
      var PossiblyWeakMap = "function" === typeof WeakMap ? WeakMap : Map;
      var executionContext = 0;
      var workInProgressRoot = null;
      var workInProgress = null;
      var workInProgressRootRenderLanes = 0;
      var workInProgressSuspendedReason = 0;
      var workInProgressThrownValue = null;
      var workInProgressRootDidSkipSuspendedSiblings = false;
      var workInProgressRootIsPrerendering = false;
      var workInProgressRootDidAttachPingListener = false;
      var entangledRenderLanes = 0;
      var workInProgressRootExitStatus = 0;
      var workInProgressRootSkippedLanes = 0;
      var workInProgressRootInterleavedUpdatedLanes = 0;
      var workInProgressRootPingedLanes = 0;
      var workInProgressDeferredLane = 0;
      var workInProgressSuspendedRetryLanes = 0;
      var workInProgressRootConcurrentErrors = null;
      var workInProgressRootRecoverableErrors = null;
      var workInProgressRootDidIncludeRecursiveRenderUpdate = false;
      var globalMostRecentFallbackTime = 0;
      var globalMostRecentTransitionTime = 0;
      var workInProgressRootRenderTargetTime = Infinity;
      var workInProgressTransitions = null;
      var legacyErrorBoundariesThatAlreadyFailed = null;
      var pendingEffectsStatus = 0;
      var pendingEffectsRoot = null;
      var pendingFinishedWork = null;
      var pendingEffectsLanes = 0;
      var pendingEffectsRemainingLanes = 0;
      var pendingPassiveTransitions = null;
      var pendingRecoverableErrors = null;
      var nestedUpdateCount = 0;
      var rootWithNestedUpdates = null;
      function requestUpdateLane() {
        return 0 !== (executionContext & 2) && 0 !== workInProgressRootRenderLanes ? workInProgressRootRenderLanes & -workInProgressRootRenderLanes : null !== ReactSharedInternals.T ? requestTransitionLane() : resolveUpdatePriority();
      }
      function requestDeferredLane() {
        if (0 === workInProgressDeferredLane)
          if (0 === (workInProgressRootRenderLanes & 536870912) || isHydrating) {
            var lane = nextTransitionDeferredLane;
            nextTransitionDeferredLane <<= 1;
            0 === (nextTransitionDeferredLane & 3932160) && (nextTransitionDeferredLane = 262144);
            workInProgressDeferredLane = lane;
          } else
            workInProgressDeferredLane = 536870912;
        lane = suspenseHandlerStackCursor.current;
        null !== lane && (lane.flags |= 32);
        return workInProgressDeferredLane;
      }
      function scheduleUpdateOnFiber(root3, fiber, lane) {
        if (root3 === workInProgressRoot && (2 === workInProgressSuspendedReason || 9 === workInProgressSuspendedReason) || null !== root3.cancelPendingCommit)
          prepareFreshStack(root3, 0), markRootSuspended(
            root3,
            workInProgressRootRenderLanes,
            workInProgressDeferredLane,
            false
          );
        markRootUpdated$1(root3, lane);
        if (0 === (executionContext & 2) || root3 !== workInProgressRoot)
          root3 === workInProgressRoot && (0 === (executionContext & 2) && (workInProgressRootInterleavedUpdatedLanes |= lane), 4 === workInProgressRootExitStatus && markRootSuspended(
            root3,
            workInProgressRootRenderLanes,
            workInProgressDeferredLane,
            false
          )), ensureRootIsScheduled(root3);
      }
      function performWorkOnRoot(root$jscomp$0, lanes, forceSync) {
        if (0 !== (executionContext & 6))
          throw Error(formatProdErrorMessage(327));
        var shouldTimeSlice = !forceSync && 0 === (lanes & 127) && 0 === (lanes & root$jscomp$0.expiredLanes) || checkIfRootIsPrerendering(root$jscomp$0, lanes), exitStatus = shouldTimeSlice ? renderRootConcurrent(root$jscomp$0, lanes) : renderRootSync(root$jscomp$0, lanes, true), renderWasConcurrent = shouldTimeSlice;
        do {
          if (0 === exitStatus) {
            workInProgressRootIsPrerendering && !shouldTimeSlice && markRootSuspended(root$jscomp$0, lanes, 0, false);
            break;
          } else {
            forceSync = root$jscomp$0.current.alternate;
            if (renderWasConcurrent && !isRenderConsistentWithExternalStores(forceSync)) {
              exitStatus = renderRootSync(root$jscomp$0, lanes, false);
              renderWasConcurrent = false;
              continue;
            }
            if (2 === exitStatus) {
              renderWasConcurrent = lanes;
              if (root$jscomp$0.errorRecoveryDisabledLanes & renderWasConcurrent)
                var JSCompiler_inline_result = 0;
              else
                JSCompiler_inline_result = root$jscomp$0.pendingLanes & -536870913, JSCompiler_inline_result = 0 !== JSCompiler_inline_result ? JSCompiler_inline_result : JSCompiler_inline_result & 536870912 ? 536870912 : 0;
              if (0 !== JSCompiler_inline_result) {
                lanes = JSCompiler_inline_result;
                a: {
                  var root3 = root$jscomp$0;
                  exitStatus = workInProgressRootConcurrentErrors;
                  var wasRootDehydrated = root3.current.memoizedState.isDehydrated;
                  wasRootDehydrated && (prepareFreshStack(root3, JSCompiler_inline_result).flags |= 256);
                  JSCompiler_inline_result = renderRootSync(
                    root3,
                    JSCompiler_inline_result,
                    false
                  );
                  if (2 !== JSCompiler_inline_result) {
                    if (workInProgressRootDidAttachPingListener && !wasRootDehydrated) {
                      root3.errorRecoveryDisabledLanes |= renderWasConcurrent;
                      workInProgressRootInterleavedUpdatedLanes |= renderWasConcurrent;
                      exitStatus = 4;
                      break a;
                    }
                    renderWasConcurrent = workInProgressRootRecoverableErrors;
                    workInProgressRootRecoverableErrors = exitStatus;
                    null !== renderWasConcurrent && (null === workInProgressRootRecoverableErrors ? workInProgressRootRecoverableErrors = renderWasConcurrent : workInProgressRootRecoverableErrors.push.apply(
                      workInProgressRootRecoverableErrors,
                      renderWasConcurrent
                    ));
                  }
                  exitStatus = JSCompiler_inline_result;
                }
                renderWasConcurrent = false;
                if (2 !== exitStatus)
                  continue;
              }
            }
            if (1 === exitStatus) {
              prepareFreshStack(root$jscomp$0, 0);
              markRootSuspended(root$jscomp$0, lanes, 0, true);
              break;
            }
            a: {
              shouldTimeSlice = root$jscomp$0;
              renderWasConcurrent = exitStatus;
              switch (renderWasConcurrent) {
                case 0:
                case 1:
                  throw Error(formatProdErrorMessage(345));
                case 4:
                  if ((lanes & 4194048) !== lanes)
                    break;
                case 6:
                  markRootSuspended(
                    shouldTimeSlice,
                    lanes,
                    workInProgressDeferredLane,
                    !workInProgressRootDidSkipSuspendedSiblings
                  );
                  break a;
                case 2:
                  workInProgressRootRecoverableErrors = null;
                  break;
                case 3:
                case 5:
                  break;
                default:
                  throw Error(formatProdErrorMessage(329));
              }
              if ((lanes & 62914560) === lanes && (exitStatus = globalMostRecentFallbackTime + 300 - now(), 10 < exitStatus)) {
                markRootSuspended(
                  shouldTimeSlice,
                  lanes,
                  workInProgressDeferredLane,
                  !workInProgressRootDidSkipSuspendedSiblings
                );
                if (0 !== getNextLanes(shouldTimeSlice, 0, true))
                  break a;
                pendingEffectsLanes = lanes;
                shouldTimeSlice.timeoutHandle = scheduleTimeout(
                  commitRootWhenReady.bind(
                    null,
                    shouldTimeSlice,
                    forceSync,
                    workInProgressRootRecoverableErrors,
                    workInProgressTransitions,
                    workInProgressRootDidIncludeRecursiveRenderUpdate,
                    lanes,
                    workInProgressDeferredLane,
                    workInProgressRootInterleavedUpdatedLanes,
                    workInProgressSuspendedRetryLanes,
                    workInProgressRootDidSkipSuspendedSiblings,
                    renderWasConcurrent,
                    "Throttled",
                    -0,
                    0
                  ),
                  exitStatus
                );
                break a;
              }
              commitRootWhenReady(
                shouldTimeSlice,
                forceSync,
                workInProgressRootRecoverableErrors,
                workInProgressTransitions,
                workInProgressRootDidIncludeRecursiveRenderUpdate,
                lanes,
                workInProgressDeferredLane,
                workInProgressRootInterleavedUpdatedLanes,
                workInProgressSuspendedRetryLanes,
                workInProgressRootDidSkipSuspendedSiblings,
                renderWasConcurrent,
                null,
                -0,
                0
              );
            }
          }
          break;
        } while (1);
        ensureRootIsScheduled(root$jscomp$0);
      }
      function commitRootWhenReady(root3, finishedWork, recoverableErrors, transitions, didIncludeRenderPhaseUpdate, lanes, spawnedLane, updatedLanes, suspendedRetryLanes, didSkipSuspendedSiblings, exitStatus, suspendedCommitReason, completedRenderStartTime, completedRenderEndTime) {
        root3.timeoutHandle = -1;
        suspendedCommitReason = finishedWork.subtreeFlags;
        if (suspendedCommitReason & 8192 || 16785408 === (suspendedCommitReason & 16785408)) {
          suspendedCommitReason = {
            stylesheets: null,
            count: 0,
            imgCount: 0,
            imgBytes: 0,
            suspenseyImages: [],
            waitingForImages: true,
            waitingForViewTransition: false,
            unsuspend: noop$1
          };
          accumulateSuspenseyCommitOnFiber(
            finishedWork,
            lanes,
            suspendedCommitReason
          );
          var timeoutOffset = (lanes & 62914560) === lanes ? globalMostRecentFallbackTime - now() : (lanes & 4194048) === lanes ? globalMostRecentTransitionTime - now() : 0;
          timeoutOffset = waitForCommitToBeReady(
            suspendedCommitReason,
            timeoutOffset
          );
          if (null !== timeoutOffset) {
            pendingEffectsLanes = lanes;
            root3.cancelPendingCommit = timeoutOffset(
              commitRoot.bind(
                null,
                root3,
                finishedWork,
                lanes,
                recoverableErrors,
                transitions,
                didIncludeRenderPhaseUpdate,
                spawnedLane,
                updatedLanes,
                suspendedRetryLanes,
                exitStatus,
                suspendedCommitReason,
                null,
                completedRenderStartTime,
                completedRenderEndTime
              )
            );
            markRootSuspended(root3, lanes, spawnedLane, !didSkipSuspendedSiblings);
            return;
          }
        }
        commitRoot(
          root3,
          finishedWork,
          lanes,
          recoverableErrors,
          transitions,
          didIncludeRenderPhaseUpdate,
          spawnedLane,
          updatedLanes,
          suspendedRetryLanes
        );
      }
      function isRenderConsistentWithExternalStores(finishedWork) {
        for (var node = finishedWork; ; ) {
          var tag = node.tag;
          if ((0 === tag || 11 === tag || 15 === tag) && node.flags & 16384 && (tag = node.updateQueue, null !== tag && (tag = tag.stores, null !== tag)))
            for (var i = 0; i < tag.length; i++) {
              var check = tag[i], getSnapshot = check.getSnapshot;
              check = check.value;
              try {
                if (!objectIs(getSnapshot(), check))
                  return false;
              } catch (error) {
                return false;
              }
            }
          tag = node.child;
          if (node.subtreeFlags & 16384 && null !== tag)
            tag.return = node, node = tag;
          else {
            if (node === finishedWork)
              break;
            for (; null === node.sibling; ) {
              if (null === node.return || node.return === finishedWork)
                return true;
              node = node.return;
            }
            node.sibling.return = node.return;
            node = node.sibling;
          }
        }
        return true;
      }
      function markRootSuspended(root3, suspendedLanes, spawnedLane, didAttemptEntireTree) {
        suspendedLanes &= ~workInProgressRootPingedLanes;
        suspendedLanes &= ~workInProgressRootInterleavedUpdatedLanes;
        root3.suspendedLanes |= suspendedLanes;
        root3.pingedLanes &= ~suspendedLanes;
        didAttemptEntireTree && (root3.warmLanes |= suspendedLanes);
        didAttemptEntireTree = root3.expirationTimes;
        for (var lanes = suspendedLanes; 0 < lanes; ) {
          var index$6 = 31 - clz32(lanes), lane = 1 << index$6;
          didAttemptEntireTree[index$6] = -1;
          lanes &= ~lane;
        }
        0 !== spawnedLane && markSpawnedDeferredLane(root3, spawnedLane, suspendedLanes);
      }
      function flushSyncWork$1() {
        return 0 === (executionContext & 6) ? (flushSyncWorkAcrossRoots_impl(0, false), false) : true;
      }
      function resetWorkInProgressStack() {
        if (null !== workInProgress) {
          if (0 === workInProgressSuspendedReason)
            var interruptedWork = workInProgress.return;
          else
            interruptedWork = workInProgress, lastContextDependency = currentlyRenderingFiber$1 = null, resetHooksOnUnwind(interruptedWork), thenableState$1 = null, thenableIndexCounter$1 = 0, interruptedWork = workInProgress;
          for (; null !== interruptedWork; )
            unwindInterruptedWork(interruptedWork.alternate, interruptedWork), interruptedWork = interruptedWork.return;
          workInProgress = null;
        }
      }
      function prepareFreshStack(root3, lanes) {
        var timeoutHandle = root3.timeoutHandle;
        -1 !== timeoutHandle && (root3.timeoutHandle = -1, cancelTimeout(timeoutHandle));
        timeoutHandle = root3.cancelPendingCommit;
        null !== timeoutHandle && (root3.cancelPendingCommit = null, timeoutHandle());
        pendingEffectsLanes = 0;
        resetWorkInProgressStack();
        workInProgressRoot = root3;
        workInProgress = timeoutHandle = createWorkInProgress(root3.current, null);
        workInProgressRootRenderLanes = lanes;
        workInProgressSuspendedReason = 0;
        workInProgressThrownValue = null;
        workInProgressRootDidSkipSuspendedSiblings = false;
        workInProgressRootIsPrerendering = checkIfRootIsPrerendering(root3, lanes);
        workInProgressRootDidAttachPingListener = false;
        workInProgressSuspendedRetryLanes = workInProgressDeferredLane = workInProgressRootPingedLanes = workInProgressRootInterleavedUpdatedLanes = workInProgressRootSkippedLanes = workInProgressRootExitStatus = 0;
        workInProgressRootRecoverableErrors = workInProgressRootConcurrentErrors = null;
        workInProgressRootDidIncludeRecursiveRenderUpdate = false;
        0 !== (lanes & 8) && (lanes |= lanes & 32);
        var allEntangledLanes = root3.entangledLanes;
        if (0 !== allEntangledLanes)
          for (root3 = root3.entanglements, allEntangledLanes &= lanes; 0 < allEntangledLanes; ) {
            var index$4 = 31 - clz32(allEntangledLanes), lane = 1 << index$4;
            lanes |= root3[index$4];
            allEntangledLanes &= ~lane;
          }
        entangledRenderLanes = lanes;
        finishQueueingConcurrentUpdates();
        return timeoutHandle;
      }
      function handleThrow(root3, thrownValue) {
        currentlyRenderingFiber = null;
        ReactSharedInternals.H = ContextOnlyDispatcher;
        thrownValue === SuspenseException || thrownValue === SuspenseActionException ? (thrownValue = getSuspendedThenable(), workInProgressSuspendedReason = 3) : thrownValue === SuspenseyCommitException ? (thrownValue = getSuspendedThenable(), workInProgressSuspendedReason = 4) : workInProgressSuspendedReason = thrownValue === SelectiveHydrationException ? 8 : null !== thrownValue && "object" === typeof thrownValue && "function" === typeof thrownValue.then ? 6 : 1;
        workInProgressThrownValue = thrownValue;
        null === workInProgress && (workInProgressRootExitStatus = 1, logUncaughtError(
          root3,
          createCapturedValueAtFiber(thrownValue, root3.current)
        ));
      }
      function shouldRemainOnPreviousScreen() {
        var handler = suspenseHandlerStackCursor.current;
        return null === handler ? true : (workInProgressRootRenderLanes & 4194048) === workInProgressRootRenderLanes ? null === shellBoundary ? true : false : (workInProgressRootRenderLanes & 62914560) === workInProgressRootRenderLanes || 0 !== (workInProgressRootRenderLanes & 536870912) ? handler === shellBoundary : false;
      }
      function pushDispatcher() {
        var prevDispatcher = ReactSharedInternals.H;
        ReactSharedInternals.H = ContextOnlyDispatcher;
        return null === prevDispatcher ? ContextOnlyDispatcher : prevDispatcher;
      }
      function pushAsyncDispatcher() {
        var prevAsyncDispatcher = ReactSharedInternals.A;
        ReactSharedInternals.A = DefaultAsyncDispatcher;
        return prevAsyncDispatcher;
      }
      function renderDidSuspendDelayIfPossible() {
        workInProgressRootExitStatus = 4;
        workInProgressRootDidSkipSuspendedSiblings || (workInProgressRootRenderLanes & 4194048) !== workInProgressRootRenderLanes && null !== suspenseHandlerStackCursor.current || (workInProgressRootIsPrerendering = true);
        0 === (workInProgressRootSkippedLanes & 134217727) && 0 === (workInProgressRootInterleavedUpdatedLanes & 134217727) || null === workInProgressRoot || markRootSuspended(
          workInProgressRoot,
          workInProgressRootRenderLanes,
          workInProgressDeferredLane,
          false
        );
      }
      function renderRootSync(root3, lanes, shouldYieldForPrerendering) {
        var prevExecutionContext = executionContext;
        executionContext |= 2;
        var prevDispatcher = pushDispatcher(), prevAsyncDispatcher = pushAsyncDispatcher();
        if (workInProgressRoot !== root3 || workInProgressRootRenderLanes !== lanes)
          workInProgressTransitions = null, prepareFreshStack(root3, lanes);
        lanes = false;
        var exitStatus = workInProgressRootExitStatus;
        a:
          do
            try {
              if (0 !== workInProgressSuspendedReason && null !== workInProgress) {
                var unitOfWork = workInProgress, thrownValue = workInProgressThrownValue;
                switch (workInProgressSuspendedReason) {
                  case 8:
                    resetWorkInProgressStack();
                    exitStatus = 6;
                    break a;
                  case 3:
                  case 2:
                  case 9:
                  case 6:
                    null === suspenseHandlerStackCursor.current && (lanes = true);
                    var reason = workInProgressSuspendedReason;
                    workInProgressSuspendedReason = 0;
                    workInProgressThrownValue = null;
                    throwAndUnwindWorkLoop(root3, unitOfWork, thrownValue, reason);
                    if (shouldYieldForPrerendering && workInProgressRootIsPrerendering) {
                      exitStatus = 0;
                      break a;
                    }
                    break;
                  default:
                    reason = workInProgressSuspendedReason, workInProgressSuspendedReason = 0, workInProgressThrownValue = null, throwAndUnwindWorkLoop(root3, unitOfWork, thrownValue, reason);
                }
              }
              workLoopSync();
              exitStatus = workInProgressRootExitStatus;
              break;
            } catch (thrownValue$165) {
              handleThrow(root3, thrownValue$165);
            }
          while (1);
        lanes && root3.shellSuspendCounter++;
        lastContextDependency = currentlyRenderingFiber$1 = null;
        executionContext = prevExecutionContext;
        ReactSharedInternals.H = prevDispatcher;
        ReactSharedInternals.A = prevAsyncDispatcher;
        null === workInProgress && (workInProgressRoot = null, workInProgressRootRenderLanes = 0, finishQueueingConcurrentUpdates());
        return exitStatus;
      }
      function workLoopSync() {
        for (; null !== workInProgress; )
          performUnitOfWork(workInProgress);
      }
      function renderRootConcurrent(root3, lanes) {
        var prevExecutionContext = executionContext;
        executionContext |= 2;
        var prevDispatcher = pushDispatcher(), prevAsyncDispatcher = pushAsyncDispatcher();
        workInProgressRoot !== root3 || workInProgressRootRenderLanes !== lanes ? (workInProgressTransitions = null, workInProgressRootRenderTargetTime = now() + 500, prepareFreshStack(root3, lanes)) : workInProgressRootIsPrerendering = checkIfRootIsPrerendering(
          root3,
          lanes
        );
        a:
          do
            try {
              if (0 !== workInProgressSuspendedReason && null !== workInProgress) {
                lanes = workInProgress;
                var thrownValue = workInProgressThrownValue;
                b:
                  switch (workInProgressSuspendedReason) {
                    case 1:
                      workInProgressSuspendedReason = 0;
                      workInProgressThrownValue = null;
                      throwAndUnwindWorkLoop(root3, lanes, thrownValue, 1);
                      break;
                    case 2:
                    case 9:
                      if (isThenableResolved(thrownValue)) {
                        workInProgressSuspendedReason = 0;
                        workInProgressThrownValue = null;
                        replaySuspendedUnitOfWork(lanes);
                        break;
                      }
                      lanes = function() {
                        2 !== workInProgressSuspendedReason && 9 !== workInProgressSuspendedReason || workInProgressRoot !== root3 || (workInProgressSuspendedReason = 7);
                        ensureRootIsScheduled(root3);
                      };
                      thrownValue.then(lanes, lanes);
                      break a;
                    case 3:
                      workInProgressSuspendedReason = 7;
                      break a;
                    case 4:
                      workInProgressSuspendedReason = 5;
                      break a;
                    case 7:
                      isThenableResolved(thrownValue) ? (workInProgressSuspendedReason = 0, workInProgressThrownValue = null, replaySuspendedUnitOfWork(lanes)) : (workInProgressSuspendedReason = 0, workInProgressThrownValue = null, throwAndUnwindWorkLoop(root3, lanes, thrownValue, 7));
                      break;
                    case 5:
                      var resource = null;
                      switch (workInProgress.tag) {
                        case 26:
                          resource = workInProgress.memoizedState;
                        case 5:
                        case 27:
                          var hostFiber = workInProgress;
                          if (resource ? preloadResource(resource) : hostFiber.stateNode.complete) {
                            workInProgressSuspendedReason = 0;
                            workInProgressThrownValue = null;
                            var sibling = hostFiber.sibling;
                            if (null !== sibling)
                              workInProgress = sibling;
                            else {
                              var returnFiber = hostFiber.return;
                              null !== returnFiber ? (workInProgress = returnFiber, completeUnitOfWork(returnFiber)) : workInProgress = null;
                            }
                            break b;
                          }
                      }
                      workInProgressSuspendedReason = 0;
                      workInProgressThrownValue = null;
                      throwAndUnwindWorkLoop(root3, lanes, thrownValue, 5);
                      break;
                    case 6:
                      workInProgressSuspendedReason = 0;
                      workInProgressThrownValue = null;
                      throwAndUnwindWorkLoop(root3, lanes, thrownValue, 6);
                      break;
                    case 8:
                      resetWorkInProgressStack();
                      workInProgressRootExitStatus = 6;
                      break a;
                    default:
                      throw Error(formatProdErrorMessage(462));
                  }
              }
              workLoopConcurrentByScheduler();
              break;
            } catch (thrownValue$167) {
              handleThrow(root3, thrownValue$167);
            }
          while (1);
        lastContextDependency = currentlyRenderingFiber$1 = null;
        ReactSharedInternals.H = prevDispatcher;
        ReactSharedInternals.A = prevAsyncDispatcher;
        executionContext = prevExecutionContext;
        if (null !== workInProgress)
          return 0;
        workInProgressRoot = null;
        workInProgressRootRenderLanes = 0;
        finishQueueingConcurrentUpdates();
        return workInProgressRootExitStatus;
      }
      function workLoopConcurrentByScheduler() {
        for (; null !== workInProgress && !shouldYield(); )
          performUnitOfWork(workInProgress);
      }
      function performUnitOfWork(unitOfWork) {
        var next = beginWork(unitOfWork.alternate, unitOfWork, entangledRenderLanes);
        unitOfWork.memoizedProps = unitOfWork.pendingProps;
        null === next ? completeUnitOfWork(unitOfWork) : workInProgress = next;
      }
      function replaySuspendedUnitOfWork(unitOfWork) {
        var next = unitOfWork;
        var current = next.alternate;
        switch (next.tag) {
          case 15:
          case 0:
            next = replayFunctionComponent(
              current,
              next,
              next.pendingProps,
              next.type,
              void 0,
              workInProgressRootRenderLanes
            );
            break;
          case 11:
            next = replayFunctionComponent(
              current,
              next,
              next.pendingProps,
              next.type.render,
              next.ref,
              workInProgressRootRenderLanes
            );
            break;
          case 5:
            resetHooksOnUnwind(next);
          default:
            unwindInterruptedWork(current, next), next = workInProgress = resetWorkInProgress(next, entangledRenderLanes), next = beginWork(current, next, entangledRenderLanes);
        }
        unitOfWork.memoizedProps = unitOfWork.pendingProps;
        null === next ? completeUnitOfWork(unitOfWork) : workInProgress = next;
      }
      function throwAndUnwindWorkLoop(root3, unitOfWork, thrownValue, suspendedReason) {
        lastContextDependency = currentlyRenderingFiber$1 = null;
        resetHooksOnUnwind(unitOfWork);
        thenableState$1 = null;
        thenableIndexCounter$1 = 0;
        var returnFiber = unitOfWork.return;
        try {
          if (throwException(
            root3,
            returnFiber,
            unitOfWork,
            thrownValue,
            workInProgressRootRenderLanes
          )) {
            workInProgressRootExitStatus = 1;
            logUncaughtError(
              root3,
              createCapturedValueAtFiber(thrownValue, root3.current)
            );
            workInProgress = null;
            return;
          }
        } catch (error) {
          if (null !== returnFiber)
            throw workInProgress = returnFiber, error;
          workInProgressRootExitStatus = 1;
          logUncaughtError(
            root3,
            createCapturedValueAtFiber(thrownValue, root3.current)
          );
          workInProgress = null;
          return;
        }
        if (unitOfWork.flags & 32768) {
          if (isHydrating || 1 === suspendedReason)
            root3 = true;
          else if (workInProgressRootIsPrerendering || 0 !== (workInProgressRootRenderLanes & 536870912))
            root3 = false;
          else if (workInProgressRootDidSkipSuspendedSiblings = root3 = true, 2 === suspendedReason || 9 === suspendedReason || 3 === suspendedReason || 6 === suspendedReason)
            suspendedReason = suspenseHandlerStackCursor.current, null !== suspendedReason && 13 === suspendedReason.tag && (suspendedReason.flags |= 16384);
          unwindUnitOfWork(unitOfWork, root3);
        } else
          completeUnitOfWork(unitOfWork);
      }
      function completeUnitOfWork(unitOfWork) {
        var completedWork = unitOfWork;
        do {
          if (0 !== (completedWork.flags & 32768)) {
            unwindUnitOfWork(
              completedWork,
              workInProgressRootDidSkipSuspendedSiblings
            );
            return;
          }
          unitOfWork = completedWork.return;
          var next = completeWork(
            completedWork.alternate,
            completedWork,
            entangledRenderLanes
          );
          if (null !== next) {
            workInProgress = next;
            return;
          }
          completedWork = completedWork.sibling;
          if (null !== completedWork) {
            workInProgress = completedWork;
            return;
          }
          workInProgress = completedWork = unitOfWork;
        } while (null !== completedWork);
        0 === workInProgressRootExitStatus && (workInProgressRootExitStatus = 5);
      }
      function unwindUnitOfWork(unitOfWork, skipSiblings) {
        do {
          var next = unwindWork(unitOfWork.alternate, unitOfWork);
          if (null !== next) {
            next.flags &= 32767;
            workInProgress = next;
            return;
          }
          next = unitOfWork.return;
          null !== next && (next.flags |= 32768, next.subtreeFlags = 0, next.deletions = null);
          if (!skipSiblings && (unitOfWork = unitOfWork.sibling, null !== unitOfWork)) {
            workInProgress = unitOfWork;
            return;
          }
          workInProgress = unitOfWork = next;
        } while (null !== unitOfWork);
        workInProgressRootExitStatus = 6;
        workInProgress = null;
      }
      function commitRoot(root3, finishedWork, lanes, recoverableErrors, transitions, didIncludeRenderPhaseUpdate, spawnedLane, updatedLanes, suspendedRetryLanes) {
        root3.cancelPendingCommit = null;
        do
          flushPendingEffects();
        while (0 !== pendingEffectsStatus);
        if (0 !== (executionContext & 6))
          throw Error(formatProdErrorMessage(327));
        if (null !== finishedWork) {
          if (finishedWork === root3.current)
            throw Error(formatProdErrorMessage(177));
          didIncludeRenderPhaseUpdate = finishedWork.lanes | finishedWork.childLanes;
          didIncludeRenderPhaseUpdate |= concurrentlyUpdatedLanes;
          markRootFinished(
            root3,
            lanes,
            didIncludeRenderPhaseUpdate,
            spawnedLane,
            updatedLanes,
            suspendedRetryLanes
          );
          root3 === workInProgressRoot && (workInProgress = workInProgressRoot = null, workInProgressRootRenderLanes = 0);
          pendingFinishedWork = finishedWork;
          pendingEffectsRoot = root3;
          pendingEffectsLanes = lanes;
          pendingEffectsRemainingLanes = didIncludeRenderPhaseUpdate;
          pendingPassiveTransitions = transitions;
          pendingRecoverableErrors = recoverableErrors;
          0 !== (finishedWork.subtreeFlags & 10256) || 0 !== (finishedWork.flags & 10256) ? (root3.callbackNode = null, root3.callbackPriority = 0, scheduleCallback$1(NormalPriority$1, function() {
            flushPassiveEffects();
            return null;
          })) : (root3.callbackNode = null, root3.callbackPriority = 0);
          recoverableErrors = 0 !== (finishedWork.flags & 13878);
          if (0 !== (finishedWork.subtreeFlags & 13878) || recoverableErrors) {
            recoverableErrors = ReactSharedInternals.T;
            ReactSharedInternals.T = null;
            transitions = ReactDOMSharedInternals.p;
            ReactDOMSharedInternals.p = 2;
            spawnedLane = executionContext;
            executionContext |= 4;
            try {
              commitBeforeMutationEffects(root3, finishedWork, lanes);
            } finally {
              executionContext = spawnedLane, ReactDOMSharedInternals.p = transitions, ReactSharedInternals.T = recoverableErrors;
            }
          }
          pendingEffectsStatus = 1;
          flushMutationEffects();
          flushLayoutEffects();
          flushSpawnedWork();
        }
      }
      function flushMutationEffects() {
        if (1 === pendingEffectsStatus) {
          pendingEffectsStatus = 0;
          var root3 = pendingEffectsRoot, finishedWork = pendingFinishedWork, rootMutationHasEffect = 0 !== (finishedWork.flags & 13878);
          if (0 !== (finishedWork.subtreeFlags & 13878) || rootMutationHasEffect) {
            rootMutationHasEffect = ReactSharedInternals.T;
            ReactSharedInternals.T = null;
            var previousPriority = ReactDOMSharedInternals.p;
            ReactDOMSharedInternals.p = 2;
            var prevExecutionContext = executionContext;
            executionContext |= 4;
            try {
              commitMutationEffectsOnFiber(finishedWork, root3);
              var priorSelectionInformation = selectionInformation, curFocusedElem = getActiveElementDeep(root3.containerInfo), priorFocusedElem = priorSelectionInformation.focusedElem, priorSelectionRange = priorSelectionInformation.selectionRange;
              if (curFocusedElem !== priorFocusedElem && priorFocusedElem && priorFocusedElem.ownerDocument && containsNode(
                priorFocusedElem.ownerDocument.documentElement,
                priorFocusedElem
              )) {
                if (null !== priorSelectionRange && hasSelectionCapabilities(priorFocusedElem)) {
                  var start = priorSelectionRange.start, end = priorSelectionRange.end;
                  void 0 === end && (end = start);
                  if ("selectionStart" in priorFocusedElem)
                    priorFocusedElem.selectionStart = start, priorFocusedElem.selectionEnd = Math.min(
                      end,
                      priorFocusedElem.value.length
                    );
                  else {
                    var doc = priorFocusedElem.ownerDocument || document, win = doc && doc.defaultView || window;
                    if (win.getSelection) {
                      var selection = win.getSelection(), length = priorFocusedElem.textContent.length, start$jscomp$0 = Math.min(priorSelectionRange.start, length), end$jscomp$0 = void 0 === priorSelectionRange.end ? start$jscomp$0 : Math.min(priorSelectionRange.end, length);
                      !selection.extend && start$jscomp$0 > end$jscomp$0 && (curFocusedElem = end$jscomp$0, end$jscomp$0 = start$jscomp$0, start$jscomp$0 = curFocusedElem);
                      var startMarker = getNodeForCharacterOffset(
                        priorFocusedElem,
                        start$jscomp$0
                      ), endMarker = getNodeForCharacterOffset(
                        priorFocusedElem,
                        end$jscomp$0
                      );
                      if (startMarker && endMarker && (1 !== selection.rangeCount || selection.anchorNode !== startMarker.node || selection.anchorOffset !== startMarker.offset || selection.focusNode !== endMarker.node || selection.focusOffset !== endMarker.offset)) {
                        var range = doc.createRange();
                        range.setStart(startMarker.node, startMarker.offset);
                        selection.removeAllRanges();
                        start$jscomp$0 > end$jscomp$0 ? (selection.addRange(range), selection.extend(endMarker.node, endMarker.offset)) : (range.setEnd(endMarker.node, endMarker.offset), selection.addRange(range));
                      }
                    }
                  }
                }
                doc = [];
                for (selection = priorFocusedElem; selection = selection.parentNode; )
                  1 === selection.nodeType && doc.push({
                    element: selection,
                    left: selection.scrollLeft,
                    top: selection.scrollTop
                  });
                "function" === typeof priorFocusedElem.focus && priorFocusedElem.focus();
                for (priorFocusedElem = 0; priorFocusedElem < doc.length; priorFocusedElem++) {
                  var info = doc[priorFocusedElem];
                  info.element.scrollLeft = info.left;
                  info.element.scrollTop = info.top;
                }
              }
              _enabled = !!eventsEnabled;
              selectionInformation = eventsEnabled = null;
            } finally {
              executionContext = prevExecutionContext, ReactDOMSharedInternals.p = previousPriority, ReactSharedInternals.T = rootMutationHasEffect;
            }
          }
          root3.current = finishedWork;
          pendingEffectsStatus = 2;
        }
      }
      function flushLayoutEffects() {
        if (2 === pendingEffectsStatus) {
          pendingEffectsStatus = 0;
          var root3 = pendingEffectsRoot, finishedWork = pendingFinishedWork, rootHasLayoutEffect = 0 !== (finishedWork.flags & 8772);
          if (0 !== (finishedWork.subtreeFlags & 8772) || rootHasLayoutEffect) {
            rootHasLayoutEffect = ReactSharedInternals.T;
            ReactSharedInternals.T = null;
            var previousPriority = ReactDOMSharedInternals.p;
            ReactDOMSharedInternals.p = 2;
            var prevExecutionContext = executionContext;
            executionContext |= 4;
            try {
              commitLayoutEffectOnFiber(root3, finishedWork.alternate, finishedWork);
            } finally {
              executionContext = prevExecutionContext, ReactDOMSharedInternals.p = previousPriority, ReactSharedInternals.T = rootHasLayoutEffect;
            }
          }
          pendingEffectsStatus = 3;
        }
      }
      function flushSpawnedWork() {
        if (4 === pendingEffectsStatus || 3 === pendingEffectsStatus) {
          pendingEffectsStatus = 0;
          requestPaint();
          var root3 = pendingEffectsRoot, finishedWork = pendingFinishedWork, lanes = pendingEffectsLanes, recoverableErrors = pendingRecoverableErrors;
          0 !== (finishedWork.subtreeFlags & 10256) || 0 !== (finishedWork.flags & 10256) ? pendingEffectsStatus = 5 : (pendingEffectsStatus = 0, pendingFinishedWork = pendingEffectsRoot = null, releaseRootPooledCache(root3, root3.pendingLanes));
          var remainingLanes = root3.pendingLanes;
          0 === remainingLanes && (legacyErrorBoundariesThatAlreadyFailed = null);
          lanesToEventPriority(lanes);
          finishedWork = finishedWork.stateNode;
          if (injectedHook && "function" === typeof injectedHook.onCommitFiberRoot)
            try {
              injectedHook.onCommitFiberRoot(
                rendererID,
                finishedWork,
                void 0,
                128 === (finishedWork.current.flags & 128)
              );
            } catch (err) {
            }
          if (null !== recoverableErrors) {
            finishedWork = ReactSharedInternals.T;
            remainingLanes = ReactDOMSharedInternals.p;
            ReactDOMSharedInternals.p = 2;
            ReactSharedInternals.T = null;
            try {
              for (var onRecoverableError = root3.onRecoverableError, i = 0; i < recoverableErrors.length; i++) {
                var recoverableError = recoverableErrors[i];
                onRecoverableError(recoverableError.value, {
                  componentStack: recoverableError.stack
                });
              }
            } finally {
              ReactSharedInternals.T = finishedWork, ReactDOMSharedInternals.p = remainingLanes;
            }
          }
          0 !== (pendingEffectsLanes & 3) && flushPendingEffects();
          ensureRootIsScheduled(root3);
          remainingLanes = root3.pendingLanes;
          0 !== (lanes & 261930) && 0 !== (remainingLanes & 42) ? root3 === rootWithNestedUpdates ? nestedUpdateCount++ : (nestedUpdateCount = 0, rootWithNestedUpdates = root3) : nestedUpdateCount = 0;
          flushSyncWorkAcrossRoots_impl(0, false);
        }
      }
      function releaseRootPooledCache(root3, remainingLanes) {
        0 === (root3.pooledCacheLanes &= remainingLanes) && (remainingLanes = root3.pooledCache, null != remainingLanes && (root3.pooledCache = null, releaseCache(remainingLanes)));
      }
      function flushPendingEffects() {
        flushMutationEffects();
        flushLayoutEffects();
        flushSpawnedWork();
        return flushPassiveEffects();
      }
      function flushPassiveEffects() {
        if (5 !== pendingEffectsStatus)
          return false;
        var root3 = pendingEffectsRoot, remainingLanes = pendingEffectsRemainingLanes;
        pendingEffectsRemainingLanes = 0;
        var renderPriority = lanesToEventPriority(pendingEffectsLanes), prevTransition = ReactSharedInternals.T, previousPriority = ReactDOMSharedInternals.p;
        try {
          ReactDOMSharedInternals.p = 32 > renderPriority ? 32 : renderPriority;
          ReactSharedInternals.T = null;
          renderPriority = pendingPassiveTransitions;
          pendingPassiveTransitions = null;
          var root$jscomp$0 = pendingEffectsRoot, lanes = pendingEffectsLanes;
          pendingEffectsStatus = 0;
          pendingFinishedWork = pendingEffectsRoot = null;
          pendingEffectsLanes = 0;
          if (0 !== (executionContext & 6))
            throw Error(formatProdErrorMessage(331));
          var prevExecutionContext = executionContext;
          executionContext |= 4;
          commitPassiveUnmountOnFiber(root$jscomp$0.current);
          commitPassiveMountOnFiber(
            root$jscomp$0,
            root$jscomp$0.current,
            lanes,
            renderPriority
          );
          executionContext = prevExecutionContext;
          flushSyncWorkAcrossRoots_impl(0, false);
          if (injectedHook && "function" === typeof injectedHook.onPostCommitFiberRoot)
            try {
              injectedHook.onPostCommitFiberRoot(rendererID, root$jscomp$0);
            } catch (err) {
            }
          return true;
        } finally {
          ReactDOMSharedInternals.p = previousPriority, ReactSharedInternals.T = prevTransition, releaseRootPooledCache(root3, remainingLanes);
        }
      }
      function captureCommitPhaseErrorOnRoot(rootFiber, sourceFiber, error) {
        sourceFiber = createCapturedValueAtFiber(error, sourceFiber);
        sourceFiber = createRootErrorUpdate(rootFiber.stateNode, sourceFiber, 2);
        rootFiber = enqueueUpdate(rootFiber, sourceFiber, 2);
        null !== rootFiber && (markRootUpdated$1(rootFiber, 2), ensureRootIsScheduled(rootFiber));
      }
      function captureCommitPhaseError(sourceFiber, nearestMountedAncestor, error) {
        if (3 === sourceFiber.tag)
          captureCommitPhaseErrorOnRoot(sourceFiber, sourceFiber, error);
        else
          for (; null !== nearestMountedAncestor; ) {
            if (3 === nearestMountedAncestor.tag) {
              captureCommitPhaseErrorOnRoot(
                nearestMountedAncestor,
                sourceFiber,
                error
              );
              break;
            } else if (1 === nearestMountedAncestor.tag) {
              var instance = nearestMountedAncestor.stateNode;
              if ("function" === typeof nearestMountedAncestor.type.getDerivedStateFromError || "function" === typeof instance.componentDidCatch && (null === legacyErrorBoundariesThatAlreadyFailed || !legacyErrorBoundariesThatAlreadyFailed.has(instance))) {
                sourceFiber = createCapturedValueAtFiber(error, sourceFiber);
                error = createClassErrorUpdate(2);
                instance = enqueueUpdate(nearestMountedAncestor, error, 2);
                null !== instance && (initializeClassErrorUpdate(
                  error,
                  instance,
                  nearestMountedAncestor,
                  sourceFiber
                ), markRootUpdated$1(instance, 2), ensureRootIsScheduled(instance));
                break;
              }
            }
            nearestMountedAncestor = nearestMountedAncestor.return;
          }
      }
      function attachPingListener(root3, wakeable, lanes) {
        var pingCache = root3.pingCache;
        if (null === pingCache) {
          pingCache = root3.pingCache = new PossiblyWeakMap();
          var threadIDs = /* @__PURE__ */ new Set();
          pingCache.set(wakeable, threadIDs);
        } else
          threadIDs = pingCache.get(wakeable), void 0 === threadIDs && (threadIDs = /* @__PURE__ */ new Set(), pingCache.set(wakeable, threadIDs));
        threadIDs.has(lanes) || (workInProgressRootDidAttachPingListener = true, threadIDs.add(lanes), root3 = pingSuspendedRoot.bind(null, root3, wakeable, lanes), wakeable.then(root3, root3));
      }
      function pingSuspendedRoot(root3, wakeable, pingedLanes) {
        var pingCache = root3.pingCache;
        null !== pingCache && pingCache.delete(wakeable);
        root3.pingedLanes |= root3.suspendedLanes & pingedLanes;
        root3.warmLanes &= ~pingedLanes;
        workInProgressRoot === root3 && (workInProgressRootRenderLanes & pingedLanes) === pingedLanes && (4 === workInProgressRootExitStatus || 3 === workInProgressRootExitStatus && (workInProgressRootRenderLanes & 62914560) === workInProgressRootRenderLanes && 300 > now() - globalMostRecentFallbackTime ? 0 === (executionContext & 2) && prepareFreshStack(root3, 0) : workInProgressRootPingedLanes |= pingedLanes, workInProgressSuspendedRetryLanes === workInProgressRootRenderLanes && (workInProgressSuspendedRetryLanes = 0));
        ensureRootIsScheduled(root3);
      }
      function retryTimedOutBoundary(boundaryFiber, retryLane) {
        0 === retryLane && (retryLane = claimNextRetryLane());
        boundaryFiber = enqueueConcurrentRenderForLane(boundaryFiber, retryLane);
        null !== boundaryFiber && (markRootUpdated$1(boundaryFiber, retryLane), ensureRootIsScheduled(boundaryFiber));
      }
      function retryDehydratedSuspenseBoundary(boundaryFiber) {
        var suspenseState = boundaryFiber.memoizedState, retryLane = 0;
        null !== suspenseState && (retryLane = suspenseState.retryLane);
        retryTimedOutBoundary(boundaryFiber, retryLane);
      }
      function resolveRetryWakeable(boundaryFiber, wakeable) {
        var retryLane = 0;
        switch (boundaryFiber.tag) {
          case 31:
          case 13:
            var retryCache = boundaryFiber.stateNode;
            var suspenseState = boundaryFiber.memoizedState;
            null !== suspenseState && (retryLane = suspenseState.retryLane);
            break;
          case 19:
            retryCache = boundaryFiber.stateNode;
            break;
          case 22:
            retryCache = boundaryFiber.stateNode._retryCache;
            break;
          default:
            throw Error(formatProdErrorMessage(314));
        }
        null !== retryCache && retryCache.delete(wakeable);
        retryTimedOutBoundary(boundaryFiber, retryLane);
      }
      function scheduleCallback$1(priorityLevel, callback) {
        return scheduleCallback$3(priorityLevel, callback);
      }
      var firstScheduledRoot = null;
      var lastScheduledRoot = null;
      var didScheduleMicrotask = false;
      var mightHavePendingSyncWork = false;
      var isFlushingWork = false;
      var currentEventTransitionLane = 0;
      function ensureRootIsScheduled(root3) {
        root3 !== lastScheduledRoot && null === root3.next && (null === lastScheduledRoot ? firstScheduledRoot = lastScheduledRoot = root3 : lastScheduledRoot = lastScheduledRoot.next = root3);
        mightHavePendingSyncWork = true;
        didScheduleMicrotask || (didScheduleMicrotask = true, scheduleImmediateRootScheduleTask());
      }
      function flushSyncWorkAcrossRoots_impl(syncTransitionLanes, onlyLegacy) {
        if (!isFlushingWork && mightHavePendingSyncWork) {
          isFlushingWork = true;
          do {
            var didPerformSomeWork = false;
            for (var root$170 = firstScheduledRoot; null !== root$170; ) {
              if (!onlyLegacy)
                if (0 !== syncTransitionLanes) {
                  var pendingLanes = root$170.pendingLanes;
                  if (0 === pendingLanes)
                    var JSCompiler_inline_result = 0;
                  else {
                    var suspendedLanes = root$170.suspendedLanes, pingedLanes = root$170.pingedLanes;
                    JSCompiler_inline_result = (1 << 31 - clz32(42 | syncTransitionLanes) + 1) - 1;
                    JSCompiler_inline_result &= pendingLanes & ~(suspendedLanes & ~pingedLanes);
                    JSCompiler_inline_result = JSCompiler_inline_result & 201326741 ? JSCompiler_inline_result & 201326741 | 1 : JSCompiler_inline_result ? JSCompiler_inline_result | 2 : 0;
                  }
                  0 !== JSCompiler_inline_result && (didPerformSomeWork = true, performSyncWorkOnRoot(root$170, JSCompiler_inline_result));
                } else
                  JSCompiler_inline_result = workInProgressRootRenderLanes, JSCompiler_inline_result = getNextLanes(
                    root$170,
                    root$170 === workInProgressRoot ? JSCompiler_inline_result : 0,
                    null !== root$170.cancelPendingCommit || -1 !== root$170.timeoutHandle
                  ), 0 === (JSCompiler_inline_result & 3) || checkIfRootIsPrerendering(root$170, JSCompiler_inline_result) || (didPerformSomeWork = true, performSyncWorkOnRoot(root$170, JSCompiler_inline_result));
              root$170 = root$170.next;
            }
          } while (didPerformSomeWork);
          isFlushingWork = false;
        }
      }
      function processRootScheduleInImmediateTask() {
        processRootScheduleInMicrotask();
      }
      function processRootScheduleInMicrotask() {
        mightHavePendingSyncWork = didScheduleMicrotask = false;
        var syncTransitionLanes = 0;
        0 !== currentEventTransitionLane && shouldAttemptEagerTransition() && (syncTransitionLanes = currentEventTransitionLane);
        for (var currentTime = now(), prev = null, root3 = firstScheduledRoot; null !== root3; ) {
          var next = root3.next, nextLanes = scheduleTaskForRootDuringMicrotask(root3, currentTime);
          if (0 === nextLanes)
            root3.next = null, null === prev ? firstScheduledRoot = next : prev.next = next, null === next && (lastScheduledRoot = prev);
          else if (prev = root3, 0 !== syncTransitionLanes || 0 !== (nextLanes & 3))
            mightHavePendingSyncWork = true;
          root3 = next;
        }
        0 !== pendingEffectsStatus && 5 !== pendingEffectsStatus || flushSyncWorkAcrossRoots_impl(syncTransitionLanes, false);
        0 !== currentEventTransitionLane && (currentEventTransitionLane = 0);
      }
      function scheduleTaskForRootDuringMicrotask(root3, currentTime) {
        for (var suspendedLanes = root3.suspendedLanes, pingedLanes = root3.pingedLanes, expirationTimes = root3.expirationTimes, lanes = root3.pendingLanes & -62914561; 0 < lanes; ) {
          var index$5 = 31 - clz32(lanes), lane = 1 << index$5, expirationTime = expirationTimes[index$5];
          if (-1 === expirationTime) {
            if (0 === (lane & suspendedLanes) || 0 !== (lane & pingedLanes))
              expirationTimes[index$5] = computeExpirationTime(lane, currentTime);
          } else
            expirationTime <= currentTime && (root3.expiredLanes |= lane);
          lanes &= ~lane;
        }
        currentTime = workInProgressRoot;
        suspendedLanes = workInProgressRootRenderLanes;
        suspendedLanes = getNextLanes(
          root3,
          root3 === currentTime ? suspendedLanes : 0,
          null !== root3.cancelPendingCommit || -1 !== root3.timeoutHandle
        );
        pingedLanes = root3.callbackNode;
        if (0 === suspendedLanes || root3 === currentTime && (2 === workInProgressSuspendedReason || 9 === workInProgressSuspendedReason) || null !== root3.cancelPendingCommit)
          return null !== pingedLanes && null !== pingedLanes && cancelCallback$1(pingedLanes), root3.callbackNode = null, root3.callbackPriority = 0;
        if (0 === (suspendedLanes & 3) || checkIfRootIsPrerendering(root3, suspendedLanes)) {
          currentTime = suspendedLanes & -suspendedLanes;
          if (currentTime === root3.callbackPriority)
            return currentTime;
          null !== pingedLanes && cancelCallback$1(pingedLanes);
          switch (lanesToEventPriority(suspendedLanes)) {
            case 2:
            case 8:
              suspendedLanes = UserBlockingPriority;
              break;
            case 32:
              suspendedLanes = NormalPriority$1;
              break;
            case 268435456:
              suspendedLanes = IdlePriority;
              break;
            default:
              suspendedLanes = NormalPriority$1;
          }
          pingedLanes = performWorkOnRootViaSchedulerTask.bind(null, root3);
          suspendedLanes = scheduleCallback$3(suspendedLanes, pingedLanes);
          root3.callbackPriority = currentTime;
          root3.callbackNode = suspendedLanes;
          return currentTime;
        }
        null !== pingedLanes && null !== pingedLanes && cancelCallback$1(pingedLanes);
        root3.callbackPriority = 2;
        root3.callbackNode = null;
        return 2;
      }
      function performWorkOnRootViaSchedulerTask(root3, didTimeout) {
        if (0 !== pendingEffectsStatus && 5 !== pendingEffectsStatus)
          return root3.callbackNode = null, root3.callbackPriority = 0, null;
        var originalCallbackNode = root3.callbackNode;
        if (flushPendingEffects() && root3.callbackNode !== originalCallbackNode)
          return null;
        var workInProgressRootRenderLanes$jscomp$0 = workInProgressRootRenderLanes;
        workInProgressRootRenderLanes$jscomp$0 = getNextLanes(
          root3,
          root3 === workInProgressRoot ? workInProgressRootRenderLanes$jscomp$0 : 0,
          null !== root3.cancelPendingCommit || -1 !== root3.timeoutHandle
        );
        if (0 === workInProgressRootRenderLanes$jscomp$0)
          return null;
        performWorkOnRoot(root3, workInProgressRootRenderLanes$jscomp$0, didTimeout);
        scheduleTaskForRootDuringMicrotask(root3, now());
        return null != root3.callbackNode && root3.callbackNode === originalCallbackNode ? performWorkOnRootViaSchedulerTask.bind(null, root3) : null;
      }
      function performSyncWorkOnRoot(root3, lanes) {
        if (flushPendingEffects())
          return null;
        performWorkOnRoot(root3, lanes, true);
      }
      function scheduleImmediateRootScheduleTask() {
        scheduleMicrotask(function() {
          0 !== (executionContext & 6) ? scheduleCallback$3(
            ImmediatePriority,
            processRootScheduleInImmediateTask
          ) : processRootScheduleInMicrotask();
        });
      }
      function requestTransitionLane() {
        if (0 === currentEventTransitionLane) {
          var actionScopeLane = currentEntangledLane;
          0 === actionScopeLane && (actionScopeLane = nextTransitionUpdateLane, nextTransitionUpdateLane <<= 1, 0 === (nextTransitionUpdateLane & 261888) && (nextTransitionUpdateLane = 256));
          currentEventTransitionLane = actionScopeLane;
        }
        return currentEventTransitionLane;
      }
      function coerceFormActionProp(actionProp) {
        return null == actionProp || "symbol" === typeof actionProp || "boolean" === typeof actionProp ? null : "function" === typeof actionProp ? actionProp : sanitizeURL("" + actionProp);
      }
      function createFormDataWithSubmitter(form, submitter) {
        var temp = submitter.ownerDocument.createElement("input");
        temp.name = submitter.name;
        temp.value = submitter.value;
        form.id && temp.setAttribute("form", form.id);
        submitter.parentNode.insertBefore(temp, submitter);
        form = new FormData(form);
        temp.parentNode.removeChild(temp);
        return form;
      }
      function extractEvents$1(dispatchQueue, domEventName, maybeTargetInst, nativeEvent, nativeEventTarget) {
        if ("submit" === domEventName && maybeTargetInst && maybeTargetInst.stateNode === nativeEventTarget) {
          var action = coerceFormActionProp(
            (nativeEventTarget[internalPropsKey] || null).action
          ), submitter = nativeEvent.submitter;
          submitter && (domEventName = (domEventName = submitter[internalPropsKey] || null) ? coerceFormActionProp(domEventName.formAction) : submitter.getAttribute("formAction"), null !== domEventName && (action = domEventName, submitter = null));
          var event = new SyntheticEvent(
            "action",
            "action",
            null,
            nativeEvent,
            nativeEventTarget
          );
          dispatchQueue.push({
            event,
            listeners: [
              {
                instance: null,
                listener: function() {
                  if (nativeEvent.defaultPrevented) {
                    if (0 !== currentEventTransitionLane) {
                      var formData = submitter ? createFormDataWithSubmitter(nativeEventTarget, submitter) : new FormData(nativeEventTarget);
                      startHostTransition(
                        maybeTargetInst,
                        {
                          pending: true,
                          data: formData,
                          method: nativeEventTarget.method,
                          action
                        },
                        null,
                        formData
                      );
                    }
                  } else
                    "function" === typeof action && (event.preventDefault(), formData = submitter ? createFormDataWithSubmitter(nativeEventTarget, submitter) : new FormData(nativeEventTarget), startHostTransition(
                      maybeTargetInst,
                      {
                        pending: true,
                        data: formData,
                        method: nativeEventTarget.method,
                        action
                      },
                      action,
                      formData
                    ));
                },
                currentTarget: nativeEventTarget
              }
            ]
          });
        }
      }
      for (i$jscomp$inline_1577 = 0; i$jscomp$inline_1577 < simpleEventPluginEvents.length; i$jscomp$inline_1577++) {
        eventName$jscomp$inline_1578 = simpleEventPluginEvents[i$jscomp$inline_1577], domEventName$jscomp$inline_1579 = eventName$jscomp$inline_1578.toLowerCase(), capitalizedEvent$jscomp$inline_1580 = eventName$jscomp$inline_1578[0].toUpperCase() + eventName$jscomp$inline_1578.slice(1);
        registerSimpleEvent(
          domEventName$jscomp$inline_1579,
          "on" + capitalizedEvent$jscomp$inline_1580
        );
      }
      var eventName$jscomp$inline_1578;
      var domEventName$jscomp$inline_1579;
      var capitalizedEvent$jscomp$inline_1580;
      var i$jscomp$inline_1577;
      registerSimpleEvent(ANIMATION_END, "onAnimationEnd");
      registerSimpleEvent(ANIMATION_ITERATION, "onAnimationIteration");
      registerSimpleEvent(ANIMATION_START, "onAnimationStart");
      registerSimpleEvent("dblclick", "onDoubleClick");
      registerSimpleEvent("focusin", "onFocus");
      registerSimpleEvent("focusout", "onBlur");
      registerSimpleEvent(TRANSITION_RUN, "onTransitionRun");
      registerSimpleEvent(TRANSITION_START, "onTransitionStart");
      registerSimpleEvent(TRANSITION_CANCEL, "onTransitionCancel");
      registerSimpleEvent(TRANSITION_END, "onTransitionEnd");
      registerDirectEvent("onMouseEnter", ["mouseout", "mouseover"]);
      registerDirectEvent("onMouseLeave", ["mouseout", "mouseover"]);
      registerDirectEvent("onPointerEnter", ["pointerout", "pointerover"]);
      registerDirectEvent("onPointerLeave", ["pointerout", "pointerover"]);
      registerTwoPhaseEvent(
        "onChange",
        "change click focusin focusout input keydown keyup selectionchange".split(" ")
      );
      registerTwoPhaseEvent(
        "onSelect",
        "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(
          " "
        )
      );
      registerTwoPhaseEvent("onBeforeInput", [
        "compositionend",
        "keypress",
        "textInput",
        "paste"
      ]);
      registerTwoPhaseEvent(
        "onCompositionEnd",
        "compositionend focusout keydown keypress keyup mousedown".split(" ")
      );
      registerTwoPhaseEvent(
        "onCompositionStart",
        "compositionstart focusout keydown keypress keyup mousedown".split(" ")
      );
      registerTwoPhaseEvent(
        "onCompositionUpdate",
        "compositionupdate focusout keydown keypress keyup mousedown".split(" ")
      );
      var mediaEventTypes = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(
        " "
      );
      var nonDelegatedEvents = new Set(
        "beforetoggle cancel close invalid load scroll scrollend toggle".split(" ").concat(mediaEventTypes)
      );
      function processDispatchQueue(dispatchQueue, eventSystemFlags) {
        eventSystemFlags = 0 !== (eventSystemFlags & 4);
        for (var i = 0; i < dispatchQueue.length; i++) {
          var _dispatchQueue$i = dispatchQueue[i], event = _dispatchQueue$i.event;
          _dispatchQueue$i = _dispatchQueue$i.listeners;
          a: {
            var previousInstance = void 0;
            if (eventSystemFlags)
              for (var i$jscomp$0 = _dispatchQueue$i.length - 1; 0 <= i$jscomp$0; i$jscomp$0--) {
                var _dispatchListeners$i = _dispatchQueue$i[i$jscomp$0], instance = _dispatchListeners$i.instance, currentTarget = _dispatchListeners$i.currentTarget;
                _dispatchListeners$i = _dispatchListeners$i.listener;
                if (instance !== previousInstance && event.isPropagationStopped())
                  break a;
                previousInstance = _dispatchListeners$i;
                event.currentTarget = currentTarget;
                try {
                  previousInstance(event);
                } catch (error) {
                  reportGlobalError(error);
                }
                event.currentTarget = null;
                previousInstance = instance;
              }
            else
              for (i$jscomp$0 = 0; i$jscomp$0 < _dispatchQueue$i.length; i$jscomp$0++) {
                _dispatchListeners$i = _dispatchQueue$i[i$jscomp$0];
                instance = _dispatchListeners$i.instance;
                currentTarget = _dispatchListeners$i.currentTarget;
                _dispatchListeners$i = _dispatchListeners$i.listener;
                if (instance !== previousInstance && event.isPropagationStopped())
                  break a;
                previousInstance = _dispatchListeners$i;
                event.currentTarget = currentTarget;
                try {
                  previousInstance(event);
                } catch (error) {
                  reportGlobalError(error);
                }
                event.currentTarget = null;
                previousInstance = instance;
              }
          }
        }
      }
      function listenToNonDelegatedEvent(domEventName, targetElement) {
        var JSCompiler_inline_result = targetElement[internalEventHandlersKey];
        void 0 === JSCompiler_inline_result && (JSCompiler_inline_result = targetElement[internalEventHandlersKey] = /* @__PURE__ */ new Set());
        var listenerSetKey = domEventName + "__bubble";
        JSCompiler_inline_result.has(listenerSetKey) || (addTrappedEventListener(targetElement, domEventName, 2, false), JSCompiler_inline_result.add(listenerSetKey));
      }
      function listenToNativeEvent(domEventName, isCapturePhaseListener, target) {
        var eventSystemFlags = 0;
        isCapturePhaseListener && (eventSystemFlags |= 4);
        addTrappedEventListener(
          target,
          domEventName,
          eventSystemFlags,
          isCapturePhaseListener
        );
      }
      var listeningMarker = "_reactListening" + Math.random().toString(36).slice(2);
      function listenToAllSupportedEvents(rootContainerElement) {
        if (!rootContainerElement[listeningMarker]) {
          rootContainerElement[listeningMarker] = true;
          allNativeEvents.forEach(function(domEventName) {
            "selectionchange" !== domEventName && (nonDelegatedEvents.has(domEventName) || listenToNativeEvent(domEventName, false, rootContainerElement), listenToNativeEvent(domEventName, true, rootContainerElement));
          });
          var ownerDocument = 9 === rootContainerElement.nodeType ? rootContainerElement : rootContainerElement.ownerDocument;
          null === ownerDocument || ownerDocument[listeningMarker] || (ownerDocument[listeningMarker] = true, listenToNativeEvent("selectionchange", false, ownerDocument));
        }
      }
      function addTrappedEventListener(targetContainer, domEventName, eventSystemFlags, isCapturePhaseListener) {
        switch (getEventPriority(domEventName)) {
          case 2:
            var listenerWrapper = dispatchDiscreteEvent;
            break;
          case 8:
            listenerWrapper = dispatchContinuousEvent;
            break;
          default:
            listenerWrapper = dispatchEvent;
        }
        eventSystemFlags = listenerWrapper.bind(
          null,
          domEventName,
          eventSystemFlags,
          targetContainer
        );
        listenerWrapper = void 0;
        !passiveBrowserEventsSupported || "touchstart" !== domEventName && "touchmove" !== domEventName && "wheel" !== domEventName || (listenerWrapper = true);
        isCapturePhaseListener ? void 0 !== listenerWrapper ? targetContainer.addEventListener(domEventName, eventSystemFlags, {
          capture: true,
          passive: listenerWrapper
        }) : targetContainer.addEventListener(domEventName, eventSystemFlags, true) : void 0 !== listenerWrapper ? targetContainer.addEventListener(domEventName, eventSystemFlags, {
          passive: listenerWrapper
        }) : targetContainer.addEventListener(domEventName, eventSystemFlags, false);
      }
      function dispatchEventForPluginEventSystem(domEventName, eventSystemFlags, nativeEvent, targetInst$jscomp$0, targetContainer) {
        var ancestorInst = targetInst$jscomp$0;
        if (0 === (eventSystemFlags & 1) && 0 === (eventSystemFlags & 2) && null !== targetInst$jscomp$0)
          a:
            for (; ; ) {
              if (null === targetInst$jscomp$0)
                return;
              var nodeTag = targetInst$jscomp$0.tag;
              if (3 === nodeTag || 4 === nodeTag) {
                var container = targetInst$jscomp$0.stateNode.containerInfo;
                if (container === targetContainer)
                  break;
                if (4 === nodeTag)
                  for (nodeTag = targetInst$jscomp$0.return; null !== nodeTag; ) {
                    var grandTag = nodeTag.tag;
                    if ((3 === grandTag || 4 === grandTag) && nodeTag.stateNode.containerInfo === targetContainer)
                      return;
                    nodeTag = nodeTag.return;
                  }
                for (; null !== container; ) {
                  nodeTag = getClosestInstanceFromNode(container);
                  if (null === nodeTag)
                    return;
                  grandTag = nodeTag.tag;
                  if (5 === grandTag || 6 === grandTag || 26 === grandTag || 27 === grandTag) {
                    targetInst$jscomp$0 = ancestorInst = nodeTag;
                    continue a;
                  }
                  container = container.parentNode;
                }
              }
              targetInst$jscomp$0 = targetInst$jscomp$0.return;
            }
        batchedUpdates$1(function() {
          var targetInst = ancestorInst, nativeEventTarget = getEventTarget(nativeEvent), dispatchQueue = [];
          a: {
            var reactName = topLevelEventsToReactNames.get(domEventName);
            if (void 0 !== reactName) {
              var SyntheticEventCtor = SyntheticEvent, reactEventType = domEventName;
              switch (domEventName) {
                case "keypress":
                  if (0 === getEventCharCode(nativeEvent))
                    break a;
                case "keydown":
                case "keyup":
                  SyntheticEventCtor = SyntheticKeyboardEvent;
                  break;
                case "focusin":
                  reactEventType = "focus";
                  SyntheticEventCtor = SyntheticFocusEvent;
                  break;
                case "focusout":
                  reactEventType = "blur";
                  SyntheticEventCtor = SyntheticFocusEvent;
                  break;
                case "beforeblur":
                case "afterblur":
                  SyntheticEventCtor = SyntheticFocusEvent;
                  break;
                case "click":
                  if (2 === nativeEvent.button)
                    break a;
                case "auxclick":
                case "dblclick":
                case "mousedown":
                case "mousemove":
                case "mouseup":
                case "mouseout":
                case "mouseover":
                case "contextmenu":
                  SyntheticEventCtor = SyntheticMouseEvent;
                  break;
                case "drag":
                case "dragend":
                case "dragenter":
                case "dragexit":
                case "dragleave":
                case "dragover":
                case "dragstart":
                case "drop":
                  SyntheticEventCtor = SyntheticDragEvent;
                  break;
                case "touchcancel":
                case "touchend":
                case "touchmove":
                case "touchstart":
                  SyntheticEventCtor = SyntheticTouchEvent;
                  break;
                case ANIMATION_END:
                case ANIMATION_ITERATION:
                case ANIMATION_START:
                  SyntheticEventCtor = SyntheticAnimationEvent;
                  break;
                case TRANSITION_END:
                  SyntheticEventCtor = SyntheticTransitionEvent;
                  break;
                case "scroll":
                case "scrollend":
                  SyntheticEventCtor = SyntheticUIEvent;
                  break;
                case "wheel":
                  SyntheticEventCtor = SyntheticWheelEvent;
                  break;
                case "copy":
                case "cut":
                case "paste":
                  SyntheticEventCtor = SyntheticClipboardEvent;
                  break;
                case "gotpointercapture":
                case "lostpointercapture":
                case "pointercancel":
                case "pointerdown":
                case "pointermove":
                case "pointerout":
                case "pointerover":
                case "pointerup":
                  SyntheticEventCtor = SyntheticPointerEvent;
                  break;
                case "toggle":
                case "beforetoggle":
                  SyntheticEventCtor = SyntheticToggleEvent;
              }
              var inCapturePhase = 0 !== (eventSystemFlags & 4), accumulateTargetOnly = !inCapturePhase && ("scroll" === domEventName || "scrollend" === domEventName), reactEventName = inCapturePhase ? null !== reactName ? reactName + "Capture" : null : reactName;
              inCapturePhase = [];
              for (var instance = targetInst, lastHostComponent; null !== instance; ) {
                var _instance = instance;
                lastHostComponent = _instance.stateNode;
                _instance = _instance.tag;
                5 !== _instance && 26 !== _instance && 27 !== _instance || null === lastHostComponent || null === reactEventName || (_instance = getListener(instance, reactEventName), null != _instance && inCapturePhase.push(
                  createDispatchListener(instance, _instance, lastHostComponent)
                ));
                if (accumulateTargetOnly)
                  break;
                instance = instance.return;
              }
              0 < inCapturePhase.length && (reactName = new SyntheticEventCtor(
                reactName,
                reactEventType,
                null,
                nativeEvent,
                nativeEventTarget
              ), dispatchQueue.push({ event: reactName, listeners: inCapturePhase }));
            }
          }
          if (0 === (eventSystemFlags & 7)) {
            a: {
              reactName = "mouseover" === domEventName || "pointerover" === domEventName;
              SyntheticEventCtor = "mouseout" === domEventName || "pointerout" === domEventName;
              if (reactName && nativeEvent !== currentReplayingEvent && (reactEventType = nativeEvent.relatedTarget || nativeEvent.fromElement) && (getClosestInstanceFromNode(reactEventType) || reactEventType[internalContainerInstanceKey]))
                break a;
              if (SyntheticEventCtor || reactName) {
                reactName = nativeEventTarget.window === nativeEventTarget ? nativeEventTarget : (reactName = nativeEventTarget.ownerDocument) ? reactName.defaultView || reactName.parentWindow : window;
                if (SyntheticEventCtor) {
                  if (reactEventType = nativeEvent.relatedTarget || nativeEvent.toElement, SyntheticEventCtor = targetInst, reactEventType = reactEventType ? getClosestInstanceFromNode(reactEventType) : null, null !== reactEventType && (accumulateTargetOnly = getNearestMountedFiber(reactEventType), inCapturePhase = reactEventType.tag, reactEventType !== accumulateTargetOnly || 5 !== inCapturePhase && 27 !== inCapturePhase && 6 !== inCapturePhase))
                    reactEventType = null;
                } else
                  SyntheticEventCtor = null, reactEventType = targetInst;
                if (SyntheticEventCtor !== reactEventType) {
                  inCapturePhase = SyntheticMouseEvent;
                  _instance = "onMouseLeave";
                  reactEventName = "onMouseEnter";
                  instance = "mouse";
                  if ("pointerout" === domEventName || "pointerover" === domEventName)
                    inCapturePhase = SyntheticPointerEvent, _instance = "onPointerLeave", reactEventName = "onPointerEnter", instance = "pointer";
                  accumulateTargetOnly = null == SyntheticEventCtor ? reactName : getNodeFromInstance(SyntheticEventCtor);
                  lastHostComponent = null == reactEventType ? reactName : getNodeFromInstance(reactEventType);
                  reactName = new inCapturePhase(
                    _instance,
                    instance + "leave",
                    SyntheticEventCtor,
                    nativeEvent,
                    nativeEventTarget
                  );
                  reactName.target = accumulateTargetOnly;
                  reactName.relatedTarget = lastHostComponent;
                  _instance = null;
                  getClosestInstanceFromNode(nativeEventTarget) === targetInst && (inCapturePhase = new inCapturePhase(
                    reactEventName,
                    instance + "enter",
                    reactEventType,
                    nativeEvent,
                    nativeEventTarget
                  ), inCapturePhase.target = lastHostComponent, inCapturePhase.relatedTarget = accumulateTargetOnly, _instance = inCapturePhase);
                  accumulateTargetOnly = _instance;
                  if (SyntheticEventCtor && reactEventType)
                    b: {
                      inCapturePhase = getParent;
                      reactEventName = SyntheticEventCtor;
                      instance = reactEventType;
                      lastHostComponent = 0;
                      for (_instance = reactEventName; _instance; _instance = inCapturePhase(_instance))
                        lastHostComponent++;
                      _instance = 0;
                      for (var tempB = instance; tempB; tempB = inCapturePhase(tempB))
                        _instance++;
                      for (; 0 < lastHostComponent - _instance; )
                        reactEventName = inCapturePhase(reactEventName), lastHostComponent--;
                      for (; 0 < _instance - lastHostComponent; )
                        instance = inCapturePhase(instance), _instance--;
                      for (; lastHostComponent--; ) {
                        if (reactEventName === instance || null !== instance && reactEventName === instance.alternate) {
                          inCapturePhase = reactEventName;
                          break b;
                        }
                        reactEventName = inCapturePhase(reactEventName);
                        instance = inCapturePhase(instance);
                      }
                      inCapturePhase = null;
                    }
                  else
                    inCapturePhase = null;
                  null !== SyntheticEventCtor && accumulateEnterLeaveListenersForEvent(
                    dispatchQueue,
                    reactName,
                    SyntheticEventCtor,
                    inCapturePhase,
                    false
                  );
                  null !== reactEventType && null !== accumulateTargetOnly && accumulateEnterLeaveListenersForEvent(
                    dispatchQueue,
                    accumulateTargetOnly,
                    reactEventType,
                    inCapturePhase,
                    true
                  );
                }
              }
            }
            a: {
              reactName = targetInst ? getNodeFromInstance(targetInst) : window;
              SyntheticEventCtor = reactName.nodeName && reactName.nodeName.toLowerCase();
              if ("select" === SyntheticEventCtor || "input" === SyntheticEventCtor && "file" === reactName.type)
                var getTargetInstFunc = getTargetInstForChangeEvent;
              else if (isTextInputElement(reactName))
                if (isInputEventSupported)
                  getTargetInstFunc = getTargetInstForInputOrChangeEvent;
                else {
                  getTargetInstFunc = getTargetInstForInputEventPolyfill;
                  var handleEventFunc = handleEventsForInputEventPolyfill;
                }
              else
                SyntheticEventCtor = reactName.nodeName, !SyntheticEventCtor || "input" !== SyntheticEventCtor.toLowerCase() || "checkbox" !== reactName.type && "radio" !== reactName.type ? targetInst && isCustomElement(targetInst.elementType) && (getTargetInstFunc = getTargetInstForChangeEvent) : getTargetInstFunc = getTargetInstForClickEvent;
              if (getTargetInstFunc && (getTargetInstFunc = getTargetInstFunc(domEventName, targetInst))) {
                createAndAccumulateChangeEvent(
                  dispatchQueue,
                  getTargetInstFunc,
                  nativeEvent,
                  nativeEventTarget
                );
                break a;
              }
              handleEventFunc && handleEventFunc(domEventName, reactName, targetInst);
              "focusout" === domEventName && targetInst && "number" === reactName.type && null != targetInst.memoizedProps.value && setDefaultValue(reactName, "number", reactName.value);
            }
            handleEventFunc = targetInst ? getNodeFromInstance(targetInst) : window;
            switch (domEventName) {
              case "focusin":
                if (isTextInputElement(handleEventFunc) || "true" === handleEventFunc.contentEditable)
                  activeElement = handleEventFunc, activeElementInst = targetInst, lastSelection = null;
                break;
              case "focusout":
                lastSelection = activeElementInst = activeElement = null;
                break;
              case "mousedown":
                mouseDown = true;
                break;
              case "contextmenu":
              case "mouseup":
              case "dragend":
                mouseDown = false;
                constructSelectEvent(dispatchQueue, nativeEvent, nativeEventTarget);
                break;
              case "selectionchange":
                if (skipSelectionChangeEvent)
                  break;
              case "keydown":
              case "keyup":
                constructSelectEvent(dispatchQueue, nativeEvent, nativeEventTarget);
            }
            var fallbackData;
            if (canUseCompositionEvent)
              b: {
                switch (domEventName) {
                  case "compositionstart":
                    var eventType = "onCompositionStart";
                    break b;
                  case "compositionend":
                    eventType = "onCompositionEnd";
                    break b;
                  case "compositionupdate":
                    eventType = "onCompositionUpdate";
                    break b;
                }
                eventType = void 0;
              }
            else
              isComposing ? isFallbackCompositionEnd(domEventName, nativeEvent) && (eventType = "onCompositionEnd") : "keydown" === domEventName && 229 === nativeEvent.keyCode && (eventType = "onCompositionStart");
            eventType && (useFallbackCompositionData && "ko" !== nativeEvent.locale && (isComposing || "onCompositionStart" !== eventType ? "onCompositionEnd" === eventType && isComposing && (fallbackData = getData()) : (root2 = nativeEventTarget, startText = "value" in root2 ? root2.value : root2.textContent, isComposing = true)), handleEventFunc = accumulateTwoPhaseListeners(targetInst, eventType), 0 < handleEventFunc.length && (eventType = new SyntheticCompositionEvent(
              eventType,
              domEventName,
              null,
              nativeEvent,
              nativeEventTarget
            ), dispatchQueue.push({ event: eventType, listeners: handleEventFunc }), fallbackData ? eventType.data = fallbackData : (fallbackData = getDataFromCustomEvent(nativeEvent), null !== fallbackData && (eventType.data = fallbackData))));
            if (fallbackData = canUseTextInputEvent ? getNativeBeforeInputChars(domEventName, nativeEvent) : getFallbackBeforeInputChars(domEventName, nativeEvent))
              eventType = accumulateTwoPhaseListeners(targetInst, "onBeforeInput"), 0 < eventType.length && (handleEventFunc = new SyntheticCompositionEvent(
                "onBeforeInput",
                "beforeinput",
                null,
                nativeEvent,
                nativeEventTarget
              ), dispatchQueue.push({
                event: handleEventFunc,
                listeners: eventType
              }), handleEventFunc.data = fallbackData);
            extractEvents$1(
              dispatchQueue,
              domEventName,
              targetInst,
              nativeEvent,
              nativeEventTarget
            );
          }
          processDispatchQueue(dispatchQueue, eventSystemFlags);
        });
      }
      function createDispatchListener(instance, listener, currentTarget) {
        return {
          instance,
          listener,
          currentTarget
        };
      }
      function accumulateTwoPhaseListeners(targetFiber, reactName) {
        for (var captureName = reactName + "Capture", listeners = []; null !== targetFiber; ) {
          var _instance2 = targetFiber, stateNode = _instance2.stateNode;
          _instance2 = _instance2.tag;
          5 !== _instance2 && 26 !== _instance2 && 27 !== _instance2 || null === stateNode || (_instance2 = getListener(targetFiber, captureName), null != _instance2 && listeners.unshift(
            createDispatchListener(targetFiber, _instance2, stateNode)
          ), _instance2 = getListener(targetFiber, reactName), null != _instance2 && listeners.push(
            createDispatchListener(targetFiber, _instance2, stateNode)
          ));
          if (3 === targetFiber.tag)
            return listeners;
          targetFiber = targetFiber.return;
        }
        return [];
      }
      function getParent(inst) {
        if (null === inst)
          return null;
        do
          inst = inst.return;
        while (inst && 5 !== inst.tag && 27 !== inst.tag);
        return inst ? inst : null;
      }
      function accumulateEnterLeaveListenersForEvent(dispatchQueue, event, target, common, inCapturePhase) {
        for (var registrationName = event._reactName, listeners = []; null !== target && target !== common; ) {
          var _instance3 = target, alternate = _instance3.alternate, stateNode = _instance3.stateNode;
          _instance3 = _instance3.tag;
          if (null !== alternate && alternate === common)
            break;
          5 !== _instance3 && 26 !== _instance3 && 27 !== _instance3 || null === stateNode || (alternate = stateNode, inCapturePhase ? (stateNode = getListener(target, registrationName), null != stateNode && listeners.unshift(
            createDispatchListener(target, stateNode, alternate)
          )) : inCapturePhase || (stateNode = getListener(target, registrationName), null != stateNode && listeners.push(
            createDispatchListener(target, stateNode, alternate)
          )));
          target = target.return;
        }
        0 !== listeners.length && dispatchQueue.push({ event, listeners });
      }
      var NORMALIZE_NEWLINES_REGEX = /\r\n?/g;
      var NORMALIZE_NULL_AND_REPLACEMENT_REGEX = /\u0000|\uFFFD/g;
      function normalizeMarkupForTextOrAttribute(markup) {
        return ("string" === typeof markup ? markup : "" + markup).replace(NORMALIZE_NEWLINES_REGEX, "\n").replace(NORMALIZE_NULL_AND_REPLACEMENT_REGEX, "");
      }
      function checkForUnmatchedText(serverText, clientText) {
        clientText = normalizeMarkupForTextOrAttribute(clientText);
        return normalizeMarkupForTextOrAttribute(serverText) === clientText ? true : false;
      }
      function setProp(domElement, tag, key, value, props, prevValue) {
        switch (key) {
          case "children":
            "string" === typeof value ? "body" === tag || "textarea" === tag && "" === value || setTextContent(domElement, value) : ("number" === typeof value || "bigint" === typeof value) && "body" !== tag && setTextContent(domElement, "" + value);
            break;
          case "className":
            setValueForKnownAttribute(domElement, "class", value);
            break;
          case "tabIndex":
            setValueForKnownAttribute(domElement, "tabindex", value);
            break;
          case "dir":
          case "role":
          case "viewBox":
          case "width":
          case "height":
            setValueForKnownAttribute(domElement, key, value);
            break;
          case "style":
            setValueForStyles(domElement, value, prevValue);
            break;
          case "data":
            if ("object" !== tag) {
              setValueForKnownAttribute(domElement, "data", value);
              break;
            }
          case "src":
          case "href":
            if ("" === value && ("a" !== tag || "href" !== key)) {
              domElement.removeAttribute(key);
              break;
            }
            if (null == value || "function" === typeof value || "symbol" === typeof value || "boolean" === typeof value) {
              domElement.removeAttribute(key);
              break;
            }
            value = sanitizeURL("" + value);
            domElement.setAttribute(key, value);
            break;
          case "action":
          case "formAction":
            if ("function" === typeof value) {
              domElement.setAttribute(
                key,
                "javascript:throw new Error('A React form was unexpectedly submitted. If you called form.submit() manually, consider using form.requestSubmit() instead. If you\\'re trying to use event.stopPropagation() in a submit event handler, consider also calling event.preventDefault().')"
              );
              break;
            } else
              "function" === typeof prevValue && ("formAction" === key ? ("input" !== tag && setProp(domElement, tag, "name", props.name, props, null), setProp(
                domElement,
                tag,
                "formEncType",
                props.formEncType,
                props,
                null
              ), setProp(
                domElement,
                tag,
                "formMethod",
                props.formMethod,
                props,
                null
              ), setProp(
                domElement,
                tag,
                "formTarget",
                props.formTarget,
                props,
                null
              )) : (setProp(domElement, tag, "encType", props.encType, props, null), setProp(domElement, tag, "method", props.method, props, null), setProp(domElement, tag, "target", props.target, props, null)));
            if (null == value || "symbol" === typeof value || "boolean" === typeof value) {
              domElement.removeAttribute(key);
              break;
            }
            value = sanitizeURL("" + value);
            domElement.setAttribute(key, value);
            break;
          case "onClick":
            null != value && (domElement.onclick = noop$1);
            break;
          case "onScroll":
            null != value && listenToNonDelegatedEvent("scroll", domElement);
            break;
          case "onScrollEnd":
            null != value && listenToNonDelegatedEvent("scrollend", domElement);
            break;
          case "dangerouslySetInnerHTML":
            if (null != value) {
              if ("object" !== typeof value || !("__html" in value))
                throw Error(formatProdErrorMessage(61));
              key = value.__html;
              if (null != key) {
                if (null != props.children)
                  throw Error(formatProdErrorMessage(60));
                domElement.innerHTML = key;
              }
            }
            break;
          case "multiple":
            domElement.multiple = value && "function" !== typeof value && "symbol" !== typeof value;
            break;
          case "muted":
            domElement.muted = value && "function" !== typeof value && "symbol" !== typeof value;
            break;
          case "suppressContentEditableWarning":
          case "suppressHydrationWarning":
          case "defaultValue":
          case "defaultChecked":
          case "innerHTML":
          case "ref":
            break;
          case "autoFocus":
            break;
          case "xlinkHref":
            if (null == value || "function" === typeof value || "boolean" === typeof value || "symbol" === typeof value) {
              domElement.removeAttribute("xlink:href");
              break;
            }
            key = sanitizeURL("" + value);
            domElement.setAttributeNS(
              "http://www.w3.org/1999/xlink",
              "xlink:href",
              key
            );
            break;
          case "contentEditable":
          case "spellCheck":
          case "draggable":
          case "value":
          case "autoReverse":
          case "externalResourcesRequired":
          case "focusable":
          case "preserveAlpha":
            null != value && "function" !== typeof value && "symbol" !== typeof value ? domElement.setAttribute(key, "" + value) : domElement.removeAttribute(key);
            break;
          case "inert":
          case "allowFullScreen":
          case "async":
          case "autoPlay":
          case "controls":
          case "default":
          case "defer":
          case "disabled":
          case "disablePictureInPicture":
          case "disableRemotePlayback":
          case "formNoValidate":
          case "hidden":
          case "loop":
          case "noModule":
          case "noValidate":
          case "open":
          case "playsInline":
          case "readOnly":
          case "required":
          case "reversed":
          case "scoped":
          case "seamless":
          case "itemScope":
            value && "function" !== typeof value && "symbol" !== typeof value ? domElement.setAttribute(key, "") : domElement.removeAttribute(key);
            break;
          case "capture":
          case "download":
            true === value ? domElement.setAttribute(key, "") : false !== value && null != value && "function" !== typeof value && "symbol" !== typeof value ? domElement.setAttribute(key, value) : domElement.removeAttribute(key);
            break;
          case "cols":
          case "rows":
          case "size":
          case "span":
            null != value && "function" !== typeof value && "symbol" !== typeof value && !isNaN(value) && 1 <= value ? domElement.setAttribute(key, value) : domElement.removeAttribute(key);
            break;
          case "rowSpan":
          case "start":
            null == value || "function" === typeof value || "symbol" === typeof value || isNaN(value) ? domElement.removeAttribute(key) : domElement.setAttribute(key, value);
            break;
          case "popover":
            listenToNonDelegatedEvent("beforetoggle", domElement);
            listenToNonDelegatedEvent("toggle", domElement);
            setValueForAttribute(domElement, "popover", value);
            break;
          case "xlinkActuate":
            setValueForNamespacedAttribute(
              domElement,
              "http://www.w3.org/1999/xlink",
              "xlink:actuate",
              value
            );
            break;
          case "xlinkArcrole":
            setValueForNamespacedAttribute(
              domElement,
              "http://www.w3.org/1999/xlink",
              "xlink:arcrole",
              value
            );
            break;
          case "xlinkRole":
            setValueForNamespacedAttribute(
              domElement,
              "http://www.w3.org/1999/xlink",
              "xlink:role",
              value
            );
            break;
          case "xlinkShow":
            setValueForNamespacedAttribute(
              domElement,
              "http://www.w3.org/1999/xlink",
              "xlink:show",
              value
            );
            break;
          case "xlinkTitle":
            setValueForNamespacedAttribute(
              domElement,
              "http://www.w3.org/1999/xlink",
              "xlink:title",
              value
            );
            break;
          case "xlinkType":
            setValueForNamespacedAttribute(
              domElement,
              "http://www.w3.org/1999/xlink",
              "xlink:type",
              value
            );
            break;
          case "xmlBase":
            setValueForNamespacedAttribute(
              domElement,
              "http://www.w3.org/XML/1998/namespace",
              "xml:base",
              value
            );
            break;
          case "xmlLang":
            setValueForNamespacedAttribute(
              domElement,
              "http://www.w3.org/XML/1998/namespace",
              "xml:lang",
              value
            );
            break;
          case "xmlSpace":
            setValueForNamespacedAttribute(
              domElement,
              "http://www.w3.org/XML/1998/namespace",
              "xml:space",
              value
            );
            break;
          case "is":
            setValueForAttribute(domElement, "is", value);
            break;
          case "innerText":
          case "textContent":
            break;
          default:
            if (!(2 < key.length) || "o" !== key[0] && "O" !== key[0] || "n" !== key[1] && "N" !== key[1])
              key = aliases.get(key) || key, setValueForAttribute(domElement, key, value);
        }
      }
      function setPropOnCustomElement(domElement, tag, key, value, props, prevValue) {
        switch (key) {
          case "style":
            setValueForStyles(domElement, value, prevValue);
            break;
          case "dangerouslySetInnerHTML":
            if (null != value) {
              if ("object" !== typeof value || !("__html" in value))
                throw Error(formatProdErrorMessage(61));
              key = value.__html;
              if (null != key) {
                if (null != props.children)
                  throw Error(formatProdErrorMessage(60));
                domElement.innerHTML = key;
              }
            }
            break;
          case "children":
            "string" === typeof value ? setTextContent(domElement, value) : ("number" === typeof value || "bigint" === typeof value) && setTextContent(domElement, "" + value);
            break;
          case "onScroll":
            null != value && listenToNonDelegatedEvent("scroll", domElement);
            break;
          case "onScrollEnd":
            null != value && listenToNonDelegatedEvent("scrollend", domElement);
            break;
          case "onClick":
            null != value && (domElement.onclick = noop$1);
            break;
          case "suppressContentEditableWarning":
          case "suppressHydrationWarning":
          case "innerHTML":
          case "ref":
            break;
          case "innerText":
          case "textContent":
            break;
          default:
            if (!registrationNameDependencies.hasOwnProperty(key))
              a: {
                if ("o" === key[0] && "n" === key[1] && (props = key.endsWith("Capture"), tag = key.slice(2, props ? key.length - 7 : void 0), prevValue = domElement[internalPropsKey] || null, prevValue = null != prevValue ? prevValue[key] : null, "function" === typeof prevValue && domElement.removeEventListener(tag, prevValue, props), "function" === typeof value)) {
                  "function" !== typeof prevValue && null !== prevValue && (key in domElement ? domElement[key] = null : domElement.hasAttribute(key) && domElement.removeAttribute(key));
                  domElement.addEventListener(tag, value, props);
                  break a;
                }
                key in domElement ? domElement[key] = value : true === value ? domElement.setAttribute(key, "") : setValueForAttribute(domElement, key, value);
              }
        }
      }
      function setInitialProperties(domElement, tag, props) {
        switch (tag) {
          case "div":
          case "span":
          case "svg":
          case "path":
          case "a":
          case "g":
          case "p":
          case "li":
            break;
          case "img":
            listenToNonDelegatedEvent("error", domElement);
            listenToNonDelegatedEvent("load", domElement);
            var hasSrc = false, hasSrcSet = false, propKey;
            for (propKey in props)
              if (props.hasOwnProperty(propKey)) {
                var propValue = props[propKey];
                if (null != propValue)
                  switch (propKey) {
                    case "src":
                      hasSrc = true;
                      break;
                    case "srcSet":
                      hasSrcSet = true;
                      break;
                    case "children":
                    case "dangerouslySetInnerHTML":
                      throw Error(formatProdErrorMessage(137, tag));
                    default:
                      setProp(domElement, tag, propKey, propValue, props, null);
                  }
              }
            hasSrcSet && setProp(domElement, tag, "srcSet", props.srcSet, props, null);
            hasSrc && setProp(domElement, tag, "src", props.src, props, null);
            return;
          case "input":
            listenToNonDelegatedEvent("invalid", domElement);
            var defaultValue = propKey = propValue = hasSrcSet = null, checked = null, defaultChecked = null;
            for (hasSrc in props)
              if (props.hasOwnProperty(hasSrc)) {
                var propValue$184 = props[hasSrc];
                if (null != propValue$184)
                  switch (hasSrc) {
                    case "name":
                      hasSrcSet = propValue$184;
                      break;
                    case "type":
                      propValue = propValue$184;
                      break;
                    case "checked":
                      checked = propValue$184;
                      break;
                    case "defaultChecked":
                      defaultChecked = propValue$184;
                      break;
                    case "value":
                      propKey = propValue$184;
                      break;
                    case "defaultValue":
                      defaultValue = propValue$184;
                      break;
                    case "children":
                    case "dangerouslySetInnerHTML":
                      if (null != propValue$184)
                        throw Error(formatProdErrorMessage(137, tag));
                      break;
                    default:
                      setProp(domElement, tag, hasSrc, propValue$184, props, null);
                  }
              }
            initInput(
              domElement,
              propKey,
              defaultValue,
              checked,
              defaultChecked,
              propValue,
              hasSrcSet,
              false
            );
            return;
          case "select":
            listenToNonDelegatedEvent("invalid", domElement);
            hasSrc = propValue = propKey = null;
            for (hasSrcSet in props)
              if (props.hasOwnProperty(hasSrcSet) && (defaultValue = props[hasSrcSet], null != defaultValue))
                switch (hasSrcSet) {
                  case "value":
                    propKey = defaultValue;
                    break;
                  case "defaultValue":
                    propValue = defaultValue;
                    break;
                  case "multiple":
                    hasSrc = defaultValue;
                  default:
                    setProp(domElement, tag, hasSrcSet, defaultValue, props, null);
                }
            tag = propKey;
            props = propValue;
            domElement.multiple = !!hasSrc;
            null != tag ? updateOptions(domElement, !!hasSrc, tag, false) : null != props && updateOptions(domElement, !!hasSrc, props, true);
            return;
          case "textarea":
            listenToNonDelegatedEvent("invalid", domElement);
            propKey = hasSrcSet = hasSrc = null;
            for (propValue in props)
              if (props.hasOwnProperty(propValue) && (defaultValue = props[propValue], null != defaultValue))
                switch (propValue) {
                  case "value":
                    hasSrc = defaultValue;
                    break;
                  case "defaultValue":
                    hasSrcSet = defaultValue;
                    break;
                  case "children":
                    propKey = defaultValue;
                    break;
                  case "dangerouslySetInnerHTML":
                    if (null != defaultValue)
                      throw Error(formatProdErrorMessage(91));
                    break;
                  default:
                    setProp(domElement, tag, propValue, defaultValue, props, null);
                }
            initTextarea(domElement, hasSrc, hasSrcSet, propKey);
            return;
          case "option":
            for (checked in props)
              if (props.hasOwnProperty(checked) && (hasSrc = props[checked], null != hasSrc))
                switch (checked) {
                  case "selected":
                    domElement.selected = hasSrc && "function" !== typeof hasSrc && "symbol" !== typeof hasSrc;
                    break;
                  default:
                    setProp(domElement, tag, checked, hasSrc, props, null);
                }
            return;
          case "dialog":
            listenToNonDelegatedEvent("beforetoggle", domElement);
            listenToNonDelegatedEvent("toggle", domElement);
            listenToNonDelegatedEvent("cancel", domElement);
            listenToNonDelegatedEvent("close", domElement);
            break;
          case "iframe":
          case "object":
            listenToNonDelegatedEvent("load", domElement);
            break;
          case "video":
          case "audio":
            for (hasSrc = 0; hasSrc < mediaEventTypes.length; hasSrc++)
              listenToNonDelegatedEvent(mediaEventTypes[hasSrc], domElement);
            break;
          case "image":
            listenToNonDelegatedEvent("error", domElement);
            listenToNonDelegatedEvent("load", domElement);
            break;
          case "details":
            listenToNonDelegatedEvent("toggle", domElement);
            break;
          case "embed":
          case "source":
          case "link":
            listenToNonDelegatedEvent("error", domElement), listenToNonDelegatedEvent("load", domElement);
          case "area":
          case "base":
          case "br":
          case "col":
          case "hr":
          case "keygen":
          case "meta":
          case "param":
          case "track":
          case "wbr":
          case "menuitem":
            for (defaultChecked in props)
              if (props.hasOwnProperty(defaultChecked) && (hasSrc = props[defaultChecked], null != hasSrc))
                switch (defaultChecked) {
                  case "children":
                  case "dangerouslySetInnerHTML":
                    throw Error(formatProdErrorMessage(137, tag));
                  default:
                    setProp(domElement, tag, defaultChecked, hasSrc, props, null);
                }
            return;
          default:
            if (isCustomElement(tag)) {
              for (propValue$184 in props)
                props.hasOwnProperty(propValue$184) && (hasSrc = props[propValue$184], void 0 !== hasSrc && setPropOnCustomElement(
                  domElement,
                  tag,
                  propValue$184,
                  hasSrc,
                  props,
                  void 0
                ));
              return;
            }
        }
        for (defaultValue in props)
          props.hasOwnProperty(defaultValue) && (hasSrc = props[defaultValue], null != hasSrc && setProp(domElement, tag, defaultValue, hasSrc, props, null));
      }
      function updateProperties(domElement, tag, lastProps, nextProps) {
        switch (tag) {
          case "div":
          case "span":
          case "svg":
          case "path":
          case "a":
          case "g":
          case "p":
          case "li":
            break;
          case "input":
            var name = null, type = null, value = null, defaultValue = null, lastDefaultValue = null, checked = null, defaultChecked = null;
            for (propKey in lastProps) {
              var lastProp = lastProps[propKey];
              if (lastProps.hasOwnProperty(propKey) && null != lastProp)
                switch (propKey) {
                  case "checked":
                    break;
                  case "value":
                    break;
                  case "defaultValue":
                    lastDefaultValue = lastProp;
                  default:
                    nextProps.hasOwnProperty(propKey) || setProp(domElement, tag, propKey, null, nextProps, lastProp);
                }
            }
            for (var propKey$201 in nextProps) {
              var propKey = nextProps[propKey$201];
              lastProp = lastProps[propKey$201];
              if (nextProps.hasOwnProperty(propKey$201) && (null != propKey || null != lastProp))
                switch (propKey$201) {
                  case "type":
                    type = propKey;
                    break;
                  case "name":
                    name = propKey;
                    break;
                  case "checked":
                    checked = propKey;
                    break;
                  case "defaultChecked":
                    defaultChecked = propKey;
                    break;
                  case "value":
                    value = propKey;
                    break;
                  case "defaultValue":
                    defaultValue = propKey;
                    break;
                  case "children":
                  case "dangerouslySetInnerHTML":
                    if (null != propKey)
                      throw Error(formatProdErrorMessage(137, tag));
                    break;
                  default:
                    propKey !== lastProp && setProp(
                      domElement,
                      tag,
                      propKey$201,
                      propKey,
                      nextProps,
                      lastProp
                    );
                }
            }
            updateInput(
              domElement,
              value,
              defaultValue,
              lastDefaultValue,
              checked,
              defaultChecked,
              type,
              name
            );
            return;
          case "select":
            propKey = value = defaultValue = propKey$201 = null;
            for (type in lastProps)
              if (lastDefaultValue = lastProps[type], lastProps.hasOwnProperty(type) && null != lastDefaultValue)
                switch (type) {
                  case "value":
                    break;
                  case "multiple":
                    propKey = lastDefaultValue;
                  default:
                    nextProps.hasOwnProperty(type) || setProp(
                      domElement,
                      tag,
                      type,
                      null,
                      nextProps,
                      lastDefaultValue
                    );
                }
            for (name in nextProps)
              if (type = nextProps[name], lastDefaultValue = lastProps[name], nextProps.hasOwnProperty(name) && (null != type || null != lastDefaultValue))
                switch (name) {
                  case "value":
                    propKey$201 = type;
                    break;
                  case "defaultValue":
                    defaultValue = type;
                    break;
                  case "multiple":
                    value = type;
                  default:
                    type !== lastDefaultValue && setProp(
                      domElement,
                      tag,
                      name,
                      type,
                      nextProps,
                      lastDefaultValue
                    );
                }
            tag = defaultValue;
            lastProps = value;
            nextProps = propKey;
            null != propKey$201 ? updateOptions(domElement, !!lastProps, propKey$201, false) : !!nextProps !== !!lastProps && (null != tag ? updateOptions(domElement, !!lastProps, tag, true) : updateOptions(domElement, !!lastProps, lastProps ? [] : "", false));
            return;
          case "textarea":
            propKey = propKey$201 = null;
            for (defaultValue in lastProps)
              if (name = lastProps[defaultValue], lastProps.hasOwnProperty(defaultValue) && null != name && !nextProps.hasOwnProperty(defaultValue))
                switch (defaultValue) {
                  case "value":
                    break;
                  case "children":
                    break;
                  default:
                    setProp(domElement, tag, defaultValue, null, nextProps, name);
                }
            for (value in nextProps)
              if (name = nextProps[value], type = lastProps[value], nextProps.hasOwnProperty(value) && (null != name || null != type))
                switch (value) {
                  case "value":
                    propKey$201 = name;
                    break;
                  case "defaultValue":
                    propKey = name;
                    break;
                  case "children":
                    break;
                  case "dangerouslySetInnerHTML":
                    if (null != name)
                      throw Error(formatProdErrorMessage(91));
                    break;
                  default:
                    name !== type && setProp(domElement, tag, value, name, nextProps, type);
                }
            updateTextarea(domElement, propKey$201, propKey);
            return;
          case "option":
            for (var propKey$217 in lastProps)
              if (propKey$201 = lastProps[propKey$217], lastProps.hasOwnProperty(propKey$217) && null != propKey$201 && !nextProps.hasOwnProperty(propKey$217))
                switch (propKey$217) {
                  case "selected":
                    domElement.selected = false;
                    break;
                  default:
                    setProp(
                      domElement,
                      tag,
                      propKey$217,
                      null,
                      nextProps,
                      propKey$201
                    );
                }
            for (lastDefaultValue in nextProps)
              if (propKey$201 = nextProps[lastDefaultValue], propKey = lastProps[lastDefaultValue], nextProps.hasOwnProperty(lastDefaultValue) && propKey$201 !== propKey && (null != propKey$201 || null != propKey))
                switch (lastDefaultValue) {
                  case "selected":
                    domElement.selected = propKey$201 && "function" !== typeof propKey$201 && "symbol" !== typeof propKey$201;
                    break;
                  default:
                    setProp(
                      domElement,
                      tag,
                      lastDefaultValue,
                      propKey$201,
                      nextProps,
                      propKey
                    );
                }
            return;
          case "img":
          case "link":
          case "area":
          case "base":
          case "br":
          case "col":
          case "embed":
          case "hr":
          case "keygen":
          case "meta":
          case "param":
          case "source":
          case "track":
          case "wbr":
          case "menuitem":
            for (var propKey$222 in lastProps)
              propKey$201 = lastProps[propKey$222], lastProps.hasOwnProperty(propKey$222) && null != propKey$201 && !nextProps.hasOwnProperty(propKey$222) && setProp(domElement, tag, propKey$222, null, nextProps, propKey$201);
            for (checked in nextProps)
              if (propKey$201 = nextProps[checked], propKey = lastProps[checked], nextProps.hasOwnProperty(checked) && propKey$201 !== propKey && (null != propKey$201 || null != propKey))
                switch (checked) {
                  case "children":
                  case "dangerouslySetInnerHTML":
                    if (null != propKey$201)
                      throw Error(formatProdErrorMessage(137, tag));
                    break;
                  default:
                    setProp(
                      domElement,
                      tag,
                      checked,
                      propKey$201,
                      nextProps,
                      propKey
                    );
                }
            return;
          default:
            if (isCustomElement(tag)) {
              for (var propKey$227 in lastProps)
                propKey$201 = lastProps[propKey$227], lastProps.hasOwnProperty(propKey$227) && void 0 !== propKey$201 && !nextProps.hasOwnProperty(propKey$227) && setPropOnCustomElement(
                  domElement,
                  tag,
                  propKey$227,
                  void 0,
                  nextProps,
                  propKey$201
                );
              for (defaultChecked in nextProps)
                propKey$201 = nextProps[defaultChecked], propKey = lastProps[defaultChecked], !nextProps.hasOwnProperty(defaultChecked) || propKey$201 === propKey || void 0 === propKey$201 && void 0 === propKey || setPropOnCustomElement(
                  domElement,
                  tag,
                  defaultChecked,
                  propKey$201,
                  nextProps,
                  propKey
                );
              return;
            }
        }
        for (var propKey$232 in lastProps)
          propKey$201 = lastProps[propKey$232], lastProps.hasOwnProperty(propKey$232) && null != propKey$201 && !nextProps.hasOwnProperty(propKey$232) && setProp(domElement, tag, propKey$232, null, nextProps, propKey$201);
        for (lastProp in nextProps)
          propKey$201 = nextProps[lastProp], propKey = lastProps[lastProp], !nextProps.hasOwnProperty(lastProp) || propKey$201 === propKey || null == propKey$201 && null == propKey || setProp(domElement, tag, lastProp, propKey$201, nextProps, propKey);
      }
      function isLikelyStaticResource(initiatorType) {
        switch (initiatorType) {
          case "css":
          case "script":
          case "font":
          case "img":
          case "image":
          case "input":
          case "link":
            return true;
          default:
            return false;
        }
      }
      function estimateBandwidth() {
        if ("function" === typeof performance.getEntriesByType) {
          for (var count = 0, bits = 0, resourceEntries = performance.getEntriesByType("resource"), i = 0; i < resourceEntries.length; i++) {
            var entry = resourceEntries[i], transferSize = entry.transferSize, initiatorType = entry.initiatorType, duration = entry.duration;
            if (transferSize && duration && isLikelyStaticResource(initiatorType)) {
              initiatorType = 0;
              duration = entry.responseEnd;
              for (i += 1; i < resourceEntries.length; i++) {
                var overlapEntry = resourceEntries[i], overlapStartTime = overlapEntry.startTime;
                if (overlapStartTime > duration)
                  break;
                var overlapTransferSize = overlapEntry.transferSize, overlapInitiatorType = overlapEntry.initiatorType;
                overlapTransferSize && isLikelyStaticResource(overlapInitiatorType) && (overlapEntry = overlapEntry.responseEnd, initiatorType += overlapTransferSize * (overlapEntry < duration ? 1 : (duration - overlapStartTime) / (overlapEntry - overlapStartTime)));
              }
              --i;
              bits += 8 * (transferSize + initiatorType) / (entry.duration / 1e3);
              count++;
              if (10 < count)
                break;
            }
          }
          if (0 < count)
            return bits / count / 1e6;
        }
        return navigator.connection && (count = navigator.connection.downlink, "number" === typeof count) ? count : 5;
      }
      var eventsEnabled = null;
      var selectionInformation = null;
      function getOwnerDocumentFromRootContainer(rootContainerElement) {
        return 9 === rootContainerElement.nodeType ? rootContainerElement : rootContainerElement.ownerDocument;
      }
      function getOwnHostContext(namespaceURI) {
        switch (namespaceURI) {
          case "http://www.w3.org/2000/svg":
            return 1;
          case "http://www.w3.org/1998/Math/MathML":
            return 2;
          default:
            return 0;
        }
      }
      function getChildHostContextProd(parentNamespace, type) {
        if (0 === parentNamespace)
          switch (type) {
            case "svg":
              return 1;
            case "math":
              return 2;
            default:
              return 0;
          }
        return 1 === parentNamespace && "foreignObject" === type ? 0 : parentNamespace;
      }
      function shouldSetTextContent(type, props) {
        return "textarea" === type || "noscript" === type || "string" === typeof props.children || "number" === typeof props.children || "bigint" === typeof props.children || "object" === typeof props.dangerouslySetInnerHTML && null !== props.dangerouslySetInnerHTML && null != props.dangerouslySetInnerHTML.__html;
      }
      var currentPopstateTransitionEvent = null;
      function shouldAttemptEagerTransition() {
        var event = window.event;
        if (event && "popstate" === event.type) {
          if (event === currentPopstateTransitionEvent)
            return false;
          currentPopstateTransitionEvent = event;
          return true;
        }
        currentPopstateTransitionEvent = null;
        return false;
      }
      var scheduleTimeout = "function" === typeof setTimeout ? setTimeout : void 0;
      var cancelTimeout = "function" === typeof clearTimeout ? clearTimeout : void 0;
      var localPromise = "function" === typeof Promise ? Promise : void 0;
      var scheduleMicrotask = "function" === typeof queueMicrotask ? queueMicrotask : "undefined" !== typeof localPromise ? function(callback) {
        return localPromise.resolve(null).then(callback).catch(handleErrorInNextTick);
      } : scheduleTimeout;
      function handleErrorInNextTick(error) {
        setTimeout(function() {
          throw error;
        });
      }
      function isSingletonScope(type) {
        return "head" === type;
      }
      function clearHydrationBoundary(parentInstance, hydrationInstance) {
        var node = hydrationInstance, depth = 0;
        do {
          var nextNode = node.nextSibling;
          parentInstance.removeChild(node);
          if (nextNode && 8 === nextNode.nodeType)
            if (node = nextNode.data, "/$" === node || "/&" === node) {
              if (0 === depth) {
                parentInstance.removeChild(nextNode);
                retryIfBlockedOn(hydrationInstance);
                return;
              }
              depth--;
            } else if ("$" === node || "$?" === node || "$~" === node || "$!" === node || "&" === node)
              depth++;
            else if ("html" === node)
              releaseSingletonInstance(parentInstance.ownerDocument.documentElement);
            else if ("head" === node) {
              node = parentInstance.ownerDocument.head;
              releaseSingletonInstance(node);
              for (var node$jscomp$0 = node.firstChild; node$jscomp$0; ) {
                var nextNode$jscomp$0 = node$jscomp$0.nextSibling, nodeName = node$jscomp$0.nodeName;
                node$jscomp$0[internalHoistableMarker] || "SCRIPT" === nodeName || "STYLE" === nodeName || "LINK" === nodeName && "stylesheet" === node$jscomp$0.rel.toLowerCase() || node.removeChild(node$jscomp$0);
                node$jscomp$0 = nextNode$jscomp$0;
              }
            } else
              "body" === node && releaseSingletonInstance(parentInstance.ownerDocument.body);
          node = nextNode;
        } while (node);
        retryIfBlockedOn(hydrationInstance);
      }
      function hideOrUnhideDehydratedBoundary(suspenseInstance, isHidden) {
        var node = suspenseInstance;
        suspenseInstance = 0;
        do {
          var nextNode = node.nextSibling;
          1 === node.nodeType ? isHidden ? (node._stashedDisplay = node.style.display, node.style.display = "none") : (node.style.display = node._stashedDisplay || "", "" === node.getAttribute("style") && node.removeAttribute("style")) : 3 === node.nodeType && (isHidden ? (node._stashedText = node.nodeValue, node.nodeValue = "") : node.nodeValue = node._stashedText || "");
          if (nextNode && 8 === nextNode.nodeType)
            if (node = nextNode.data, "/$" === node)
              if (0 === suspenseInstance)
                break;
              else
                suspenseInstance--;
            else
              "$" !== node && "$?" !== node && "$~" !== node && "$!" !== node || suspenseInstance++;
          node = nextNode;
        } while (node);
      }
      function clearContainerSparingly(container) {
        var nextNode = container.firstChild;
        nextNode && 10 === nextNode.nodeType && (nextNode = nextNode.nextSibling);
        for (; nextNode; ) {
          var node = nextNode;
          nextNode = nextNode.nextSibling;
          switch (node.nodeName) {
            case "HTML":
            case "HEAD":
            case "BODY":
              clearContainerSparingly(node);
              detachDeletedInstance(node);
              continue;
            case "SCRIPT":
            case "STYLE":
              continue;
            case "LINK":
              if ("stylesheet" === node.rel.toLowerCase())
                continue;
          }
          container.removeChild(node);
        }
      }
      function canHydrateInstance(instance, type, props, inRootOrSingleton) {
        for (; 1 === instance.nodeType; ) {
          var anyProps = props;
          if (instance.nodeName.toLowerCase() !== type.toLowerCase()) {
            if (!inRootOrSingleton && ("INPUT" !== instance.nodeName || "hidden" !== instance.type))
              break;
          } else if (!inRootOrSingleton)
            if ("input" === type && "hidden" === instance.type) {
              var name = null == anyProps.name ? null : "" + anyProps.name;
              if ("hidden" === anyProps.type && instance.getAttribute("name") === name)
                return instance;
            } else
              return instance;
          else if (!instance[internalHoistableMarker])
            switch (type) {
              case "meta":
                if (!instance.hasAttribute("itemprop"))
                  break;
                return instance;
              case "link":
                name = instance.getAttribute("rel");
                if ("stylesheet" === name && instance.hasAttribute("data-precedence"))
                  break;
                else if (name !== anyProps.rel || instance.getAttribute("href") !== (null == anyProps.href || "" === anyProps.href ? null : anyProps.href) || instance.getAttribute("crossorigin") !== (null == anyProps.crossOrigin ? null : anyProps.crossOrigin) || instance.getAttribute("title") !== (null == anyProps.title ? null : anyProps.title))
                  break;
                return instance;
              case "style":
                if (instance.hasAttribute("data-precedence"))
                  break;
                return instance;
              case "script":
                name = instance.getAttribute("src");
                if ((name !== (null == anyProps.src ? null : anyProps.src) || instance.getAttribute("type") !== (null == anyProps.type ? null : anyProps.type) || instance.getAttribute("crossorigin") !== (null == anyProps.crossOrigin ? null : anyProps.crossOrigin)) && name && instance.hasAttribute("async") && !instance.hasAttribute("itemprop"))
                  break;
                return instance;
              default:
                return instance;
            }
          instance = getNextHydratable(instance.nextSibling);
          if (null === instance)
            break;
        }
        return null;
      }
      function canHydrateTextInstance(instance, text, inRootOrSingleton) {
        if ("" === text)
          return null;
        for (; 3 !== instance.nodeType; ) {
          if ((1 !== instance.nodeType || "INPUT" !== instance.nodeName || "hidden" !== instance.type) && !inRootOrSingleton)
            return null;
          instance = getNextHydratable(instance.nextSibling);
          if (null === instance)
            return null;
        }
        return instance;
      }
      function canHydrateHydrationBoundary(instance, inRootOrSingleton) {
        for (; 8 !== instance.nodeType; ) {
          if ((1 !== instance.nodeType || "INPUT" !== instance.nodeName || "hidden" !== instance.type) && !inRootOrSingleton)
            return null;
          instance = getNextHydratable(instance.nextSibling);
          if (null === instance)
            return null;
        }
        return instance;
      }
      function isSuspenseInstancePending(instance) {
        return "$?" === instance.data || "$~" === instance.data;
      }
      function isSuspenseInstanceFallback(instance) {
        return "$!" === instance.data || "$?" === instance.data && "loading" !== instance.ownerDocument.readyState;
      }
      function registerSuspenseInstanceRetry(instance, callback) {
        var ownerDocument = instance.ownerDocument;
        if ("$~" === instance.data)
          instance._reactRetry = callback;
        else if ("$?" !== instance.data || "loading" !== ownerDocument.readyState)
          callback();
        else {
          var listener = function() {
            callback();
            ownerDocument.removeEventListener("DOMContentLoaded", listener);
          };
          ownerDocument.addEventListener("DOMContentLoaded", listener);
          instance._reactRetry = listener;
        }
      }
      function getNextHydratable(node) {
        for (; null != node; node = node.nextSibling) {
          var nodeType = node.nodeType;
          if (1 === nodeType || 3 === nodeType)
            break;
          if (8 === nodeType) {
            nodeType = node.data;
            if ("$" === nodeType || "$!" === nodeType || "$?" === nodeType || "$~" === nodeType || "&" === nodeType || "F!" === nodeType || "F" === nodeType)
              break;
            if ("/$" === nodeType || "/&" === nodeType)
              return null;
          }
        }
        return node;
      }
      var previousHydratableOnEnteringScopedSingleton = null;
      function getNextHydratableInstanceAfterHydrationBoundary(hydrationInstance) {
        hydrationInstance = hydrationInstance.nextSibling;
        for (var depth = 0; hydrationInstance; ) {
          if (8 === hydrationInstance.nodeType) {
            var data = hydrationInstance.data;
            if ("/$" === data || "/&" === data) {
              if (0 === depth)
                return getNextHydratable(hydrationInstance.nextSibling);
              depth--;
            } else
              "$" !== data && "$!" !== data && "$?" !== data && "$~" !== data && "&" !== data || depth++;
          }
          hydrationInstance = hydrationInstance.nextSibling;
        }
        return null;
      }
      function getParentHydrationBoundary(targetInstance) {
        targetInstance = targetInstance.previousSibling;
        for (var depth = 0; targetInstance; ) {
          if (8 === targetInstance.nodeType) {
            var data = targetInstance.data;
            if ("$" === data || "$!" === data || "$?" === data || "$~" === data || "&" === data) {
              if (0 === depth)
                return targetInstance;
              depth--;
            } else
              "/$" !== data && "/&" !== data || depth++;
          }
          targetInstance = targetInstance.previousSibling;
        }
        return null;
      }
      function resolveSingletonInstance(type, props, rootContainerInstance) {
        props = getOwnerDocumentFromRootContainer(rootContainerInstance);
        switch (type) {
          case "html":
            type = props.documentElement;
            if (!type)
              throw Error(formatProdErrorMessage(452));
            return type;
          case "head":
            type = props.head;
            if (!type)
              throw Error(formatProdErrorMessage(453));
            return type;
          case "body":
            type = props.body;
            if (!type)
              throw Error(formatProdErrorMessage(454));
            return type;
          default:
            throw Error(formatProdErrorMessage(451));
        }
      }
      function releaseSingletonInstance(instance) {
        for (var attributes = instance.attributes; attributes.length; )
          instance.removeAttributeNode(attributes[0]);
        detachDeletedInstance(instance);
      }
      var preloadPropsMap = /* @__PURE__ */ new Map();
      var preconnectsSet = /* @__PURE__ */ new Set();
      function getHoistableRoot(container) {
        return "function" === typeof container.getRootNode ? container.getRootNode() : 9 === container.nodeType ? container : container.ownerDocument;
      }
      var previousDispatcher = ReactDOMSharedInternals.d;
      ReactDOMSharedInternals.d = {
        f: flushSyncWork,
        r: requestFormReset,
        D: prefetchDNS,
        C: preconnect,
        L: preload,
        m: preloadModule,
        X: preinitScript,
        S: preinitStyle,
        M: preinitModuleScript
      };
      function flushSyncWork() {
        var previousWasRendering = previousDispatcher.f(), wasRendering = flushSyncWork$1();
        return previousWasRendering || wasRendering;
      }
      function requestFormReset(form) {
        var formInst = getInstanceFromNode(form);
        null !== formInst && 5 === formInst.tag && "form" === formInst.type ? requestFormReset$1(formInst) : previousDispatcher.r(form);
      }
      var globalDocument = "undefined" === typeof document ? null : document;
      function preconnectAs(rel, href, crossOrigin) {
        var ownerDocument = globalDocument;
        if (ownerDocument && "string" === typeof href && href) {
          var limitedEscapedHref = escapeSelectorAttributeValueInsideDoubleQuotes(href);
          limitedEscapedHref = 'link[rel="' + rel + '"][href="' + limitedEscapedHref + '"]';
          "string" === typeof crossOrigin && (limitedEscapedHref += '[crossorigin="' + crossOrigin + '"]');
          preconnectsSet.has(limitedEscapedHref) || (preconnectsSet.add(limitedEscapedHref), rel = { rel, crossOrigin, href }, null === ownerDocument.querySelector(limitedEscapedHref) && (href = ownerDocument.createElement("link"), setInitialProperties(href, "link", rel), markNodeAsHoistable(href), ownerDocument.head.appendChild(href)));
        }
      }
      function prefetchDNS(href) {
        previousDispatcher.D(href);
        preconnectAs("dns-prefetch", href, null);
      }
      function preconnect(href, crossOrigin) {
        previousDispatcher.C(href, crossOrigin);
        preconnectAs("preconnect", href, crossOrigin);
      }
      function preload(href, as, options2) {
        previousDispatcher.L(href, as, options2);
        var ownerDocument = globalDocument;
        if (ownerDocument && href && as) {
          var preloadSelector = 'link[rel="preload"][as="' + escapeSelectorAttributeValueInsideDoubleQuotes(as) + '"]';
          "image" === as ? options2 && options2.imageSrcSet ? (preloadSelector += '[imagesrcset="' + escapeSelectorAttributeValueInsideDoubleQuotes(
            options2.imageSrcSet
          ) + '"]', "string" === typeof options2.imageSizes && (preloadSelector += '[imagesizes="' + escapeSelectorAttributeValueInsideDoubleQuotes(
            options2.imageSizes
          ) + '"]')) : preloadSelector += '[href="' + escapeSelectorAttributeValueInsideDoubleQuotes(href) + '"]' : preloadSelector += '[href="' + escapeSelectorAttributeValueInsideDoubleQuotes(href) + '"]';
          var key = preloadSelector;
          switch (as) {
            case "style":
              key = getStyleKey(href);
              break;
            case "script":
              key = getScriptKey(href);
          }
          preloadPropsMap.has(key) || (href = assign(
            {
              rel: "preload",
              href: "image" === as && options2 && options2.imageSrcSet ? void 0 : href,
              as
            },
            options2
          ), preloadPropsMap.set(key, href), null !== ownerDocument.querySelector(preloadSelector) || "style" === as && ownerDocument.querySelector(getStylesheetSelectorFromKey(key)) || "script" === as && ownerDocument.querySelector(getScriptSelectorFromKey(key)) || (as = ownerDocument.createElement("link"), setInitialProperties(as, "link", href), markNodeAsHoistable(as), ownerDocument.head.appendChild(as)));
        }
      }
      function preloadModule(href, options2) {
        previousDispatcher.m(href, options2);
        var ownerDocument = globalDocument;
        if (ownerDocument && href) {
          var as = options2 && "string" === typeof options2.as ? options2.as : "script", preloadSelector = 'link[rel="modulepreload"][as="' + escapeSelectorAttributeValueInsideDoubleQuotes(as) + '"][href="' + escapeSelectorAttributeValueInsideDoubleQuotes(href) + '"]', key = preloadSelector;
          switch (as) {
            case "audioworklet":
            case "paintworklet":
            case "serviceworker":
            case "sharedworker":
            case "worker":
            case "script":
              key = getScriptKey(href);
          }
          if (!preloadPropsMap.has(key) && (href = assign({ rel: "modulepreload", href }, options2), preloadPropsMap.set(key, href), null === ownerDocument.querySelector(preloadSelector))) {
            switch (as) {
              case "audioworklet":
              case "paintworklet":
              case "serviceworker":
              case "sharedworker":
              case "worker":
              case "script":
                if (ownerDocument.querySelector(getScriptSelectorFromKey(key)))
                  return;
            }
            as = ownerDocument.createElement("link");
            setInitialProperties(as, "link", href);
            markNodeAsHoistable(as);
            ownerDocument.head.appendChild(as);
          }
        }
      }
      function preinitStyle(href, precedence, options2) {
        previousDispatcher.S(href, precedence, options2);
        var ownerDocument = globalDocument;
        if (ownerDocument && href) {
          var styles = getResourcesFromRoot(ownerDocument).hoistableStyles, key = getStyleKey(href);
          precedence = precedence || "default";
          var resource = styles.get(key);
          if (!resource) {
            var state = { loading: 0, preload: null };
            if (resource = ownerDocument.querySelector(
              getStylesheetSelectorFromKey(key)
            ))
              state.loading = 5;
            else {
              href = assign(
                { rel: "stylesheet", href, "data-precedence": precedence },
                options2
              );
              (options2 = preloadPropsMap.get(key)) && adoptPreloadPropsForStylesheet(href, options2);
              var link = resource = ownerDocument.createElement("link");
              markNodeAsHoistable(link);
              setInitialProperties(link, "link", href);
              link._p = new Promise(function(resolve, reject) {
                link.onload = resolve;
                link.onerror = reject;
              });
              link.addEventListener("load", function() {
                state.loading |= 1;
              });
              link.addEventListener("error", function() {
                state.loading |= 2;
              });
              state.loading |= 4;
              insertStylesheet(resource, precedence, ownerDocument);
            }
            resource = {
              type: "stylesheet",
              instance: resource,
              count: 1,
              state
            };
            styles.set(key, resource);
          }
        }
      }
      function preinitScript(src, options2) {
        previousDispatcher.X(src, options2);
        var ownerDocument = globalDocument;
        if (ownerDocument && src) {
          var scripts = getResourcesFromRoot(ownerDocument).hoistableScripts, key = getScriptKey(src), resource = scripts.get(key);
          resource || (resource = ownerDocument.querySelector(getScriptSelectorFromKey(key)), resource || (src = assign({ src, async: true }, options2), (options2 = preloadPropsMap.get(key)) && adoptPreloadPropsForScript(src, options2), resource = ownerDocument.createElement("script"), markNodeAsHoistable(resource), setInitialProperties(resource, "link", src), ownerDocument.head.appendChild(resource)), resource = {
            type: "script",
            instance: resource,
            count: 1,
            state: null
          }, scripts.set(key, resource));
        }
      }
      function preinitModuleScript(src, options2) {
        previousDispatcher.M(src, options2);
        var ownerDocument = globalDocument;
        if (ownerDocument && src) {
          var scripts = getResourcesFromRoot(ownerDocument).hoistableScripts, key = getScriptKey(src), resource = scripts.get(key);
          resource || (resource = ownerDocument.querySelector(getScriptSelectorFromKey(key)), resource || (src = assign({ src, async: true, type: "module" }, options2), (options2 = preloadPropsMap.get(key)) && adoptPreloadPropsForScript(src, options2), resource = ownerDocument.createElement("script"), markNodeAsHoistable(resource), setInitialProperties(resource, "link", src), ownerDocument.head.appendChild(resource)), resource = {
            type: "script",
            instance: resource,
            count: 1,
            state: null
          }, scripts.set(key, resource));
        }
      }
      function getResource(type, currentProps, pendingProps, currentResource) {
        var JSCompiler_inline_result = (JSCompiler_inline_result = rootInstanceStackCursor.current) ? getHoistableRoot(JSCompiler_inline_result) : null;
        if (!JSCompiler_inline_result)
          throw Error(formatProdErrorMessage(446));
        switch (type) {
          case "meta":
          case "title":
            return null;
          case "style":
            return "string" === typeof pendingProps.precedence && "string" === typeof pendingProps.href ? (currentProps = getStyleKey(pendingProps.href), pendingProps = getResourcesFromRoot(
              JSCompiler_inline_result
            ).hoistableStyles, currentResource = pendingProps.get(currentProps), currentResource || (currentResource = {
              type: "style",
              instance: null,
              count: 0,
              state: null
            }, pendingProps.set(currentProps, currentResource)), currentResource) : { type: "void", instance: null, count: 0, state: null };
          case "link":
            if ("stylesheet" === pendingProps.rel && "string" === typeof pendingProps.href && "string" === typeof pendingProps.precedence) {
              type = getStyleKey(pendingProps.href);
              var styles$243 = getResourcesFromRoot(
                JSCompiler_inline_result
              ).hoistableStyles, resource$244 = styles$243.get(type);
              resource$244 || (JSCompiler_inline_result = JSCompiler_inline_result.ownerDocument || JSCompiler_inline_result, resource$244 = {
                type: "stylesheet",
                instance: null,
                count: 0,
                state: { loading: 0, preload: null }
              }, styles$243.set(type, resource$244), (styles$243 = JSCompiler_inline_result.querySelector(
                getStylesheetSelectorFromKey(type)
              )) && !styles$243._p && (resource$244.instance = styles$243, resource$244.state.loading = 5), preloadPropsMap.has(type) || (pendingProps = {
                rel: "preload",
                as: "style",
                href: pendingProps.href,
                crossOrigin: pendingProps.crossOrigin,
                integrity: pendingProps.integrity,
                media: pendingProps.media,
                hrefLang: pendingProps.hrefLang,
                referrerPolicy: pendingProps.referrerPolicy
              }, preloadPropsMap.set(type, pendingProps), styles$243 || preloadStylesheet(
                JSCompiler_inline_result,
                type,
                pendingProps,
                resource$244.state
              )));
              if (currentProps && null === currentResource)
                throw Error(formatProdErrorMessage(528, ""));
              return resource$244;
            }
            if (currentProps && null !== currentResource)
              throw Error(formatProdErrorMessage(529, ""));
            return null;
          case "script":
            return currentProps = pendingProps.async, pendingProps = pendingProps.src, "string" === typeof pendingProps && currentProps && "function" !== typeof currentProps && "symbol" !== typeof currentProps ? (currentProps = getScriptKey(pendingProps), pendingProps = getResourcesFromRoot(
              JSCompiler_inline_result
            ).hoistableScripts, currentResource = pendingProps.get(currentProps), currentResource || (currentResource = {
              type: "script",
              instance: null,
              count: 0,
              state: null
            }, pendingProps.set(currentProps, currentResource)), currentResource) : { type: "void", instance: null, count: 0, state: null };
          default:
            throw Error(formatProdErrorMessage(444, type));
        }
      }
      function getStyleKey(href) {
        return 'href="' + escapeSelectorAttributeValueInsideDoubleQuotes(href) + '"';
      }
      function getStylesheetSelectorFromKey(key) {
        return 'link[rel="stylesheet"][' + key + "]";
      }
      function stylesheetPropsFromRawProps(rawProps) {
        return assign({}, rawProps, {
          "data-precedence": rawProps.precedence,
          precedence: null
        });
      }
      function preloadStylesheet(ownerDocument, key, preloadProps, state) {
        ownerDocument.querySelector('link[rel="preload"][as="style"][' + key + "]") ? state.loading = 1 : (key = ownerDocument.createElement("link"), state.preload = key, key.addEventListener("load", function() {
          return state.loading |= 1;
        }), key.addEventListener("error", function() {
          return state.loading |= 2;
        }), setInitialProperties(key, "link", preloadProps), markNodeAsHoistable(key), ownerDocument.head.appendChild(key));
      }
      function getScriptKey(src) {
        return '[src="' + escapeSelectorAttributeValueInsideDoubleQuotes(src) + '"]';
      }
      function getScriptSelectorFromKey(key) {
        return "script[async]" + key;
      }
      function acquireResource(hoistableRoot, resource, props) {
        resource.count++;
        if (null === resource.instance)
          switch (resource.type) {
            case "style":
              var instance = hoistableRoot.querySelector(
                'style[data-href~="' + escapeSelectorAttributeValueInsideDoubleQuotes(props.href) + '"]'
              );
              if (instance)
                return resource.instance = instance, markNodeAsHoistable(instance), instance;
              var styleProps = assign({}, props, {
                "data-href": props.href,
                "data-precedence": props.precedence,
                href: null,
                precedence: null
              });
              instance = (hoistableRoot.ownerDocument || hoistableRoot).createElement(
                "style"
              );
              markNodeAsHoistable(instance);
              setInitialProperties(instance, "style", styleProps);
              insertStylesheet(instance, props.precedence, hoistableRoot);
              return resource.instance = instance;
            case "stylesheet":
              styleProps = getStyleKey(props.href);
              var instance$249 = hoistableRoot.querySelector(
                getStylesheetSelectorFromKey(styleProps)
              );
              if (instance$249)
                return resource.state.loading |= 4, resource.instance = instance$249, markNodeAsHoistable(instance$249), instance$249;
              instance = stylesheetPropsFromRawProps(props);
              (styleProps = preloadPropsMap.get(styleProps)) && adoptPreloadPropsForStylesheet(instance, styleProps);
              instance$249 = (hoistableRoot.ownerDocument || hoistableRoot).createElement("link");
              markNodeAsHoistable(instance$249);
              var linkInstance = instance$249;
              linkInstance._p = new Promise(function(resolve, reject) {
                linkInstance.onload = resolve;
                linkInstance.onerror = reject;
              });
              setInitialProperties(instance$249, "link", instance);
              resource.state.loading |= 4;
              insertStylesheet(instance$249, props.precedence, hoistableRoot);
              return resource.instance = instance$249;
            case "script":
              instance$249 = getScriptKey(props.src);
              if (styleProps = hoistableRoot.querySelector(
                getScriptSelectorFromKey(instance$249)
              ))
                return resource.instance = styleProps, markNodeAsHoistable(styleProps), styleProps;
              instance = props;
              if (styleProps = preloadPropsMap.get(instance$249))
                instance = assign({}, props), adoptPreloadPropsForScript(instance, styleProps);
              hoistableRoot = hoistableRoot.ownerDocument || hoistableRoot;
              styleProps = hoistableRoot.createElement("script");
              markNodeAsHoistable(styleProps);
              setInitialProperties(styleProps, "link", instance);
              hoistableRoot.head.appendChild(styleProps);
              return resource.instance = styleProps;
            case "void":
              return null;
            default:
              throw Error(formatProdErrorMessage(443, resource.type));
          }
        else
          "stylesheet" === resource.type && 0 === (resource.state.loading & 4) && (instance = resource.instance, resource.state.loading |= 4, insertStylesheet(instance, props.precedence, hoistableRoot));
        return resource.instance;
      }
      function insertStylesheet(instance, precedence, root3) {
        for (var nodes = root3.querySelectorAll(
          'link[rel="stylesheet"][data-precedence],style[data-precedence]'
        ), last = nodes.length ? nodes[nodes.length - 1] : null, prior = last, i = 0; i < nodes.length; i++) {
          var node = nodes[i];
          if (node.dataset.precedence === precedence)
            prior = node;
          else if (prior !== last)
            break;
        }
        prior ? prior.parentNode.insertBefore(instance, prior.nextSibling) : (precedence = 9 === root3.nodeType ? root3.head : root3, precedence.insertBefore(instance, precedence.firstChild));
      }
      function adoptPreloadPropsForStylesheet(stylesheetProps, preloadProps) {
        null == stylesheetProps.crossOrigin && (stylesheetProps.crossOrigin = preloadProps.crossOrigin);
        null == stylesheetProps.referrerPolicy && (stylesheetProps.referrerPolicy = preloadProps.referrerPolicy);
        null == stylesheetProps.title && (stylesheetProps.title = preloadProps.title);
      }
      function adoptPreloadPropsForScript(scriptProps, preloadProps) {
        null == scriptProps.crossOrigin && (scriptProps.crossOrigin = preloadProps.crossOrigin);
        null == scriptProps.referrerPolicy && (scriptProps.referrerPolicy = preloadProps.referrerPolicy);
        null == scriptProps.integrity && (scriptProps.integrity = preloadProps.integrity);
      }
      var tagCaches = null;
      function getHydratableHoistableCache(type, keyAttribute, ownerDocument) {
        if (null === tagCaches) {
          var cache = /* @__PURE__ */ new Map();
          var caches = tagCaches = /* @__PURE__ */ new Map();
          caches.set(ownerDocument, cache);
        } else
          caches = tagCaches, cache = caches.get(ownerDocument), cache || (cache = /* @__PURE__ */ new Map(), caches.set(ownerDocument, cache));
        if (cache.has(type))
          return cache;
        cache.set(type, null);
        ownerDocument = ownerDocument.getElementsByTagName(type);
        for (caches = 0; caches < ownerDocument.length; caches++) {
          var node = ownerDocument[caches];
          if (!(node[internalHoistableMarker] || node[internalInstanceKey] || "link" === type && "stylesheet" === node.getAttribute("rel")) && "http://www.w3.org/2000/svg" !== node.namespaceURI) {
            var nodeKey = node.getAttribute(keyAttribute) || "";
            nodeKey = type + nodeKey;
            var existing = cache.get(nodeKey);
            existing ? existing.push(node) : cache.set(nodeKey, [node]);
          }
        }
        return cache;
      }
      function mountHoistable(hoistableRoot, type, instance) {
        hoistableRoot = hoistableRoot.ownerDocument || hoistableRoot;
        hoistableRoot.head.insertBefore(
          instance,
          "title" === type ? hoistableRoot.querySelector("head > title") : null
        );
      }
      function isHostHoistableType(type, props, hostContext) {
        if (1 === hostContext || null != props.itemProp)
          return false;
        switch (type) {
          case "meta":
          case "title":
            return true;
          case "style":
            if ("string" !== typeof props.precedence || "string" !== typeof props.href || "" === props.href)
              break;
            return true;
          case "link":
            if ("string" !== typeof props.rel || "string" !== typeof props.href || "" === props.href || props.onLoad || props.onError)
              break;
            switch (props.rel) {
              case "stylesheet":
                return type = props.disabled, "string" === typeof props.precedence && null == type;
              default:
                return true;
            }
          case "script":
            if (props.async && "function" !== typeof props.async && "symbol" !== typeof props.async && !props.onLoad && !props.onError && props.src && "string" === typeof props.src)
              return true;
        }
        return false;
      }
      function preloadResource(resource) {
        return "stylesheet" === resource.type && 0 === (resource.state.loading & 3) ? false : true;
      }
      function suspendResource(state, hoistableRoot, resource, props) {
        if ("stylesheet" === resource.type && ("string" !== typeof props.media || false !== matchMedia(props.media).matches) && 0 === (resource.state.loading & 4)) {
          if (null === resource.instance) {
            var key = getStyleKey(props.href), instance = hoistableRoot.querySelector(
              getStylesheetSelectorFromKey(key)
            );
            if (instance) {
              hoistableRoot = instance._p;
              null !== hoistableRoot && "object" === typeof hoistableRoot && "function" === typeof hoistableRoot.then && (state.count++, state = onUnsuspend.bind(state), hoistableRoot.then(state, state));
              resource.state.loading |= 4;
              resource.instance = instance;
              markNodeAsHoistable(instance);
              return;
            }
            instance = hoistableRoot.ownerDocument || hoistableRoot;
            props = stylesheetPropsFromRawProps(props);
            (key = preloadPropsMap.get(key)) && adoptPreloadPropsForStylesheet(props, key);
            instance = instance.createElement("link");
            markNodeAsHoistable(instance);
            var linkInstance = instance;
            linkInstance._p = new Promise(function(resolve, reject) {
              linkInstance.onload = resolve;
              linkInstance.onerror = reject;
            });
            setInitialProperties(instance, "link", props);
            resource.instance = instance;
          }
          null === state.stylesheets && (state.stylesheets = /* @__PURE__ */ new Map());
          state.stylesheets.set(resource, hoistableRoot);
          (hoistableRoot = resource.state.preload) && 0 === (resource.state.loading & 3) && (state.count++, resource = onUnsuspend.bind(state), hoistableRoot.addEventListener("load", resource), hoistableRoot.addEventListener("error", resource));
        }
      }
      var estimatedBytesWithinLimit = 0;
      function waitForCommitToBeReady(state, timeoutOffset) {
        state.stylesheets && 0 === state.count && insertSuspendedStylesheets(state, state.stylesheets);
        return 0 < state.count || 0 < state.imgCount ? function(commit) {
          var stylesheetTimer = setTimeout(function() {
            state.stylesheets && insertSuspendedStylesheets(state, state.stylesheets);
            if (state.unsuspend) {
              var unsuspend = state.unsuspend;
              state.unsuspend = null;
              unsuspend();
            }
          }, 6e4 + timeoutOffset);
          0 < state.imgBytes && 0 === estimatedBytesWithinLimit && (estimatedBytesWithinLimit = 62500 * estimateBandwidth());
          var imgTimer = setTimeout(
            function() {
              state.waitingForImages = false;
              if (0 === state.count && (state.stylesheets && insertSuspendedStylesheets(state, state.stylesheets), state.unsuspend)) {
                var unsuspend = state.unsuspend;
                state.unsuspend = null;
                unsuspend();
              }
            },
            (state.imgBytes > estimatedBytesWithinLimit ? 50 : 800) + timeoutOffset
          );
          state.unsuspend = commit;
          return function() {
            state.unsuspend = null;
            clearTimeout(stylesheetTimer);
            clearTimeout(imgTimer);
          };
        } : null;
      }
      function onUnsuspend() {
        this.count--;
        if (0 === this.count && (0 === this.imgCount || !this.waitingForImages)) {
          if (this.stylesheets)
            insertSuspendedStylesheets(this, this.stylesheets);
          else if (this.unsuspend) {
            var unsuspend = this.unsuspend;
            this.unsuspend = null;
            unsuspend();
          }
        }
      }
      var precedencesByRoot = null;
      function insertSuspendedStylesheets(state, resources) {
        state.stylesheets = null;
        null !== state.unsuspend && (state.count++, precedencesByRoot = /* @__PURE__ */ new Map(), resources.forEach(insertStylesheetIntoRoot, state), precedencesByRoot = null, onUnsuspend.call(state));
      }
      function insertStylesheetIntoRoot(root3, resource) {
        if (!(resource.state.loading & 4)) {
          var precedences = precedencesByRoot.get(root3);
          if (precedences)
            var last = precedences.get(null);
          else {
            precedences = /* @__PURE__ */ new Map();
            precedencesByRoot.set(root3, precedences);
            for (var nodes = root3.querySelectorAll(
              "link[data-precedence],style[data-precedence]"
            ), i = 0; i < nodes.length; i++) {
              var node = nodes[i];
              if ("LINK" === node.nodeName || "not all" !== node.getAttribute("media"))
                precedences.set(node.dataset.precedence, node), last = node;
            }
            last && precedences.set(null, last);
          }
          nodes = resource.instance;
          node = nodes.getAttribute("data-precedence");
          i = precedences.get(node) || last;
          i === last && precedences.set(null, nodes);
          precedences.set(node, nodes);
          this.count++;
          last = onUnsuspend.bind(this);
          nodes.addEventListener("load", last);
          nodes.addEventListener("error", last);
          i ? i.parentNode.insertBefore(nodes, i.nextSibling) : (root3 = 9 === root3.nodeType ? root3.head : root3, root3.insertBefore(nodes, root3.firstChild));
          resource.state.loading |= 4;
        }
      }
      var HostTransitionContext = {
        $$typeof: REACT_CONTEXT_TYPE,
        Provider: null,
        Consumer: null,
        _currentValue: sharedNotPendingObject,
        _currentValue2: sharedNotPendingObject,
        _threadCount: 0
      };
      function FiberRootNode(containerInfo, tag, hydrate, identifierPrefix, onUncaughtError, onCaughtError, onRecoverableError, onDefaultTransitionIndicator, formState) {
        this.tag = 1;
        this.containerInfo = containerInfo;
        this.pingCache = this.current = this.pendingChildren = null;
        this.timeoutHandle = -1;
        this.callbackNode = this.next = this.pendingContext = this.context = this.cancelPendingCommit = null;
        this.callbackPriority = 0;
        this.expirationTimes = createLaneMap(-1);
        this.entangledLanes = this.shellSuspendCounter = this.errorRecoveryDisabledLanes = this.expiredLanes = this.warmLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0;
        this.entanglements = createLaneMap(0);
        this.hiddenUpdates = createLaneMap(null);
        this.identifierPrefix = identifierPrefix;
        this.onUncaughtError = onUncaughtError;
        this.onCaughtError = onCaughtError;
        this.onRecoverableError = onRecoverableError;
        this.pooledCache = null;
        this.pooledCacheLanes = 0;
        this.formState = formState;
        this.incompleteTransitions = /* @__PURE__ */ new Map();
      }
      function createFiberRoot(containerInfo, tag, hydrate, initialChildren, hydrationCallbacks, isStrictMode, identifierPrefix, formState, onUncaughtError, onCaughtError, onRecoverableError, onDefaultTransitionIndicator) {
        containerInfo = new FiberRootNode(
          containerInfo,
          tag,
          hydrate,
          identifierPrefix,
          onUncaughtError,
          onCaughtError,
          onRecoverableError,
          onDefaultTransitionIndicator,
          formState
        );
        tag = 1;
        true === isStrictMode && (tag |= 24);
        isStrictMode = createFiberImplClass(3, null, null, tag);
        containerInfo.current = isStrictMode;
        isStrictMode.stateNode = containerInfo;
        tag = createCache();
        tag.refCount++;
        containerInfo.pooledCache = tag;
        tag.refCount++;
        isStrictMode.memoizedState = {
          element: initialChildren,
          isDehydrated: hydrate,
          cache: tag
        };
        initializeUpdateQueue(isStrictMode);
        return containerInfo;
      }
      function getContextForSubtree(parentComponent) {
        if (!parentComponent)
          return emptyContextObject;
        parentComponent = emptyContextObject;
        return parentComponent;
      }
      function updateContainerImpl(rootFiber, lane, element, container, parentComponent, callback) {
        parentComponent = getContextForSubtree(parentComponent);
        null === container.context ? container.context = parentComponent : container.pendingContext = parentComponent;
        container = createUpdate(lane);
        container.payload = { element };
        callback = void 0 === callback ? null : callback;
        null !== callback && (container.callback = callback);
        element = enqueueUpdate(rootFiber, container, lane);
        null !== element && (scheduleUpdateOnFiber(element, rootFiber, lane), entangleTransitions(element, rootFiber, lane));
      }
      function markRetryLaneImpl(fiber, retryLane) {
        fiber = fiber.memoizedState;
        if (null !== fiber && null !== fiber.dehydrated) {
          var a = fiber.retryLane;
          fiber.retryLane = 0 !== a && a < retryLane ? a : retryLane;
        }
      }
      function markRetryLaneIfNotHydrated(fiber, retryLane) {
        markRetryLaneImpl(fiber, retryLane);
        (fiber = fiber.alternate) && markRetryLaneImpl(fiber, retryLane);
      }
      function attemptContinuousHydration(fiber) {
        if (13 === fiber.tag || 31 === fiber.tag) {
          var root3 = enqueueConcurrentRenderForLane(fiber, 67108864);
          null !== root3 && scheduleUpdateOnFiber(root3, fiber, 67108864);
          markRetryLaneIfNotHydrated(fiber, 67108864);
        }
      }
      function attemptHydrationAtCurrentPriority(fiber) {
        if (13 === fiber.tag || 31 === fiber.tag) {
          var lane = requestUpdateLane();
          lane = getBumpedLaneForHydrationByLane(lane);
          var root3 = enqueueConcurrentRenderForLane(fiber, lane);
          null !== root3 && scheduleUpdateOnFiber(root3, fiber, lane);
          markRetryLaneIfNotHydrated(fiber, lane);
        }
      }
      var _enabled = true;
      function dispatchDiscreteEvent(domEventName, eventSystemFlags, container, nativeEvent) {
        var prevTransition = ReactSharedInternals.T;
        ReactSharedInternals.T = null;
        var previousPriority = ReactDOMSharedInternals.p;
        try {
          ReactDOMSharedInternals.p = 2, dispatchEvent(domEventName, eventSystemFlags, container, nativeEvent);
        } finally {
          ReactDOMSharedInternals.p = previousPriority, ReactSharedInternals.T = prevTransition;
        }
      }
      function dispatchContinuousEvent(domEventName, eventSystemFlags, container, nativeEvent) {
        var prevTransition = ReactSharedInternals.T;
        ReactSharedInternals.T = null;
        var previousPriority = ReactDOMSharedInternals.p;
        try {
          ReactDOMSharedInternals.p = 8, dispatchEvent(domEventName, eventSystemFlags, container, nativeEvent);
        } finally {
          ReactDOMSharedInternals.p = previousPriority, ReactSharedInternals.T = prevTransition;
        }
      }
      function dispatchEvent(domEventName, eventSystemFlags, targetContainer, nativeEvent) {
        if (_enabled) {
          var blockedOn = findInstanceBlockingEvent(nativeEvent);
          if (null === blockedOn)
            dispatchEventForPluginEventSystem(
              domEventName,
              eventSystemFlags,
              nativeEvent,
              return_targetInst,
              targetContainer
            ), clearIfContinuousEvent(domEventName, nativeEvent);
          else if (queueIfContinuousEvent(
            blockedOn,
            domEventName,
            eventSystemFlags,
            targetContainer,
            nativeEvent
          ))
            nativeEvent.stopPropagation();
          else if (clearIfContinuousEvent(domEventName, nativeEvent), eventSystemFlags & 4 && -1 < discreteReplayableEvents.indexOf(domEventName)) {
            for (; null !== blockedOn; ) {
              var fiber = getInstanceFromNode(blockedOn);
              if (null !== fiber)
                switch (fiber.tag) {
                  case 3:
                    fiber = fiber.stateNode;
                    if (fiber.current.memoizedState.isDehydrated) {
                      var lanes = getHighestPriorityLanes(fiber.pendingLanes);
                      if (0 !== lanes) {
                        var root3 = fiber;
                        root3.pendingLanes |= 2;
                        for (root3.entangledLanes |= 2; lanes; ) {
                          var lane = 1 << 31 - clz32(lanes);
                          root3.entanglements[1] |= lane;
                          lanes &= ~lane;
                        }
                        ensureRootIsScheduled(fiber);
                        0 === (executionContext & 6) && (workInProgressRootRenderTargetTime = now() + 500, flushSyncWorkAcrossRoots_impl(0, false));
                      }
                    }
                    break;
                  case 31:
                  case 13:
                    root3 = enqueueConcurrentRenderForLane(fiber, 2), null !== root3 && scheduleUpdateOnFiber(root3, fiber, 2), flushSyncWork$1(), markRetryLaneIfNotHydrated(fiber, 2);
                }
              fiber = findInstanceBlockingEvent(nativeEvent);
              null === fiber && dispatchEventForPluginEventSystem(
                domEventName,
                eventSystemFlags,
                nativeEvent,
                return_targetInst,
                targetContainer
              );
              if (fiber === blockedOn)
                break;
              blockedOn = fiber;
            }
            null !== blockedOn && nativeEvent.stopPropagation();
          } else
            dispatchEventForPluginEventSystem(
              domEventName,
              eventSystemFlags,
              nativeEvent,
              null,
              targetContainer
            );
        }
      }
      function findInstanceBlockingEvent(nativeEvent) {
        nativeEvent = getEventTarget(nativeEvent);
        return findInstanceBlockingTarget(nativeEvent);
      }
      var return_targetInst = null;
      function findInstanceBlockingTarget(targetNode) {
        return_targetInst = null;
        targetNode = getClosestInstanceFromNode(targetNode);
        if (null !== targetNode) {
          var nearestMounted = getNearestMountedFiber(targetNode);
          if (null === nearestMounted)
            targetNode = null;
          else {
            var tag = nearestMounted.tag;
            if (13 === tag) {
              targetNode = getSuspenseInstanceFromFiber(nearestMounted);
              if (null !== targetNode)
                return targetNode;
              targetNode = null;
            } else if (31 === tag) {
              targetNode = getActivityInstanceFromFiber(nearestMounted);
              if (null !== targetNode)
                return targetNode;
              targetNode = null;
            } else if (3 === tag) {
              if (nearestMounted.stateNode.current.memoizedState.isDehydrated)
                return 3 === nearestMounted.tag ? nearestMounted.stateNode.containerInfo : null;
              targetNode = null;
            } else
              nearestMounted !== targetNode && (targetNode = null);
          }
        }
        return_targetInst = targetNode;
        return null;
      }
      function getEventPriority(domEventName) {
        switch (domEventName) {
          case "beforetoggle":
          case "cancel":
          case "click":
          case "close":
          case "contextmenu":
          case "copy":
          case "cut":
          case "auxclick":
          case "dblclick":
          case "dragend":
          case "dragstart":
          case "drop":
          case "focusin":
          case "focusout":
          case "input":
          case "invalid":
          case "keydown":
          case "keypress":
          case "keyup":
          case "mousedown":
          case "mouseup":
          case "paste":
          case "pause":
          case "play":
          case "pointercancel":
          case "pointerdown":
          case "pointerup":
          case "ratechange":
          case "reset":
          case "resize":
          case "seeked":
          case "submit":
          case "toggle":
          case "touchcancel":
          case "touchend":
          case "touchstart":
          case "volumechange":
          case "change":
          case "selectionchange":
          case "textInput":
          case "compositionstart":
          case "compositionend":
          case "compositionupdate":
          case "beforeblur":
          case "afterblur":
          case "beforeinput":
          case "blur":
          case "fullscreenchange":
          case "focus":
          case "hashchange":
          case "popstate":
          case "select":
          case "selectstart":
            return 2;
          case "drag":
          case "dragenter":
          case "dragexit":
          case "dragleave":
          case "dragover":
          case "mousemove":
          case "mouseout":
          case "mouseover":
          case "pointermove":
          case "pointerout":
          case "pointerover":
          case "scroll":
          case "touchmove":
          case "wheel":
          case "mouseenter":
          case "mouseleave":
          case "pointerenter":
          case "pointerleave":
            return 8;
          case "message":
            switch (getCurrentPriorityLevel()) {
              case ImmediatePriority:
                return 2;
              case UserBlockingPriority:
                return 8;
              case NormalPriority$1:
              case LowPriority:
                return 32;
              case IdlePriority:
                return 268435456;
              default:
                return 32;
            }
          default:
            return 32;
        }
      }
      var hasScheduledReplayAttempt = false;
      var queuedFocus = null;
      var queuedDrag = null;
      var queuedMouse = null;
      var queuedPointers = /* @__PURE__ */ new Map();
      var queuedPointerCaptures = /* @__PURE__ */ new Map();
      var queuedExplicitHydrationTargets = [];
      var discreteReplayableEvents = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset".split(
        " "
      );
      function clearIfContinuousEvent(domEventName, nativeEvent) {
        switch (domEventName) {
          case "focusin":
          case "focusout":
            queuedFocus = null;
            break;
          case "dragenter":
          case "dragleave":
            queuedDrag = null;
            break;
          case "mouseover":
          case "mouseout":
            queuedMouse = null;
            break;
          case "pointerover":
          case "pointerout":
            queuedPointers.delete(nativeEvent.pointerId);
            break;
          case "gotpointercapture":
          case "lostpointercapture":
            queuedPointerCaptures.delete(nativeEvent.pointerId);
        }
      }
      function accumulateOrCreateContinuousQueuedReplayableEvent(existingQueuedEvent, blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent) {
        if (null === existingQueuedEvent || existingQueuedEvent.nativeEvent !== nativeEvent)
          return existingQueuedEvent = {
            blockedOn,
            domEventName,
            eventSystemFlags,
            nativeEvent,
            targetContainers: [targetContainer]
          }, null !== blockedOn && (blockedOn = getInstanceFromNode(blockedOn), null !== blockedOn && attemptContinuousHydration(blockedOn)), existingQueuedEvent;
        existingQueuedEvent.eventSystemFlags |= eventSystemFlags;
        blockedOn = existingQueuedEvent.targetContainers;
        null !== targetContainer && -1 === blockedOn.indexOf(targetContainer) && blockedOn.push(targetContainer);
        return existingQueuedEvent;
      }
      function queueIfContinuousEvent(blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent) {
        switch (domEventName) {
          case "focusin":
            return queuedFocus = accumulateOrCreateContinuousQueuedReplayableEvent(
              queuedFocus,
              blockedOn,
              domEventName,
              eventSystemFlags,
              targetContainer,
              nativeEvent
            ), true;
          case "dragenter":
            return queuedDrag = accumulateOrCreateContinuousQueuedReplayableEvent(
              queuedDrag,
              blockedOn,
              domEventName,
              eventSystemFlags,
              targetContainer,
              nativeEvent
            ), true;
          case "mouseover":
            return queuedMouse = accumulateOrCreateContinuousQueuedReplayableEvent(
              queuedMouse,
              blockedOn,
              domEventName,
              eventSystemFlags,
              targetContainer,
              nativeEvent
            ), true;
          case "pointerover":
            var pointerId = nativeEvent.pointerId;
            queuedPointers.set(
              pointerId,
              accumulateOrCreateContinuousQueuedReplayableEvent(
                queuedPointers.get(pointerId) || null,
                blockedOn,
                domEventName,
                eventSystemFlags,
                targetContainer,
                nativeEvent
              )
            );
            return true;
          case "gotpointercapture":
            return pointerId = nativeEvent.pointerId, queuedPointerCaptures.set(
              pointerId,
              accumulateOrCreateContinuousQueuedReplayableEvent(
                queuedPointerCaptures.get(pointerId) || null,
                blockedOn,
                domEventName,
                eventSystemFlags,
                targetContainer,
                nativeEvent
              )
            ), true;
        }
        return false;
      }
      function attemptExplicitHydrationTarget(queuedTarget) {
        var targetInst = getClosestInstanceFromNode(queuedTarget.target);
        if (null !== targetInst) {
          var nearestMounted = getNearestMountedFiber(targetInst);
          if (null !== nearestMounted) {
            if (targetInst = nearestMounted.tag, 13 === targetInst) {
              if (targetInst = getSuspenseInstanceFromFiber(nearestMounted), null !== targetInst) {
                queuedTarget.blockedOn = targetInst;
                runWithPriority(queuedTarget.priority, function() {
                  attemptHydrationAtCurrentPriority(nearestMounted);
                });
                return;
              }
            } else if (31 === targetInst) {
              if (targetInst = getActivityInstanceFromFiber(nearestMounted), null !== targetInst) {
                queuedTarget.blockedOn = targetInst;
                runWithPriority(queuedTarget.priority, function() {
                  attemptHydrationAtCurrentPriority(nearestMounted);
                });
                return;
              }
            } else if (3 === targetInst && nearestMounted.stateNode.current.memoizedState.isDehydrated) {
              queuedTarget.blockedOn = 3 === nearestMounted.tag ? nearestMounted.stateNode.containerInfo : null;
              return;
            }
          }
        }
        queuedTarget.blockedOn = null;
      }
      function attemptReplayContinuousQueuedEvent(queuedEvent) {
        if (null !== queuedEvent.blockedOn)
          return false;
        for (var targetContainers = queuedEvent.targetContainers; 0 < targetContainers.length; ) {
          var nextBlockedOn = findInstanceBlockingEvent(queuedEvent.nativeEvent);
          if (null === nextBlockedOn) {
            nextBlockedOn = queuedEvent.nativeEvent;
            var nativeEventClone = new nextBlockedOn.constructor(
              nextBlockedOn.type,
              nextBlockedOn
            );
            currentReplayingEvent = nativeEventClone;
            nextBlockedOn.target.dispatchEvent(nativeEventClone);
            currentReplayingEvent = null;
          } else
            return targetContainers = getInstanceFromNode(nextBlockedOn), null !== targetContainers && attemptContinuousHydration(targetContainers), queuedEvent.blockedOn = nextBlockedOn, false;
          targetContainers.shift();
        }
        return true;
      }
      function attemptReplayContinuousQueuedEventInMap(queuedEvent, key, map) {
        attemptReplayContinuousQueuedEvent(queuedEvent) && map.delete(key);
      }
      function replayUnblockedEvents() {
        hasScheduledReplayAttempt = false;
        null !== queuedFocus && attemptReplayContinuousQueuedEvent(queuedFocus) && (queuedFocus = null);
        null !== queuedDrag && attemptReplayContinuousQueuedEvent(queuedDrag) && (queuedDrag = null);
        null !== queuedMouse && attemptReplayContinuousQueuedEvent(queuedMouse) && (queuedMouse = null);
        queuedPointers.forEach(attemptReplayContinuousQueuedEventInMap);
        queuedPointerCaptures.forEach(attemptReplayContinuousQueuedEventInMap);
      }
      function scheduleCallbackIfUnblocked(queuedEvent, unblocked) {
        queuedEvent.blockedOn === unblocked && (queuedEvent.blockedOn = null, hasScheduledReplayAttempt || (hasScheduledReplayAttempt = true, Scheduler.unstable_scheduleCallback(
          Scheduler.unstable_NormalPriority,
          replayUnblockedEvents
        )));
      }
      var lastScheduledReplayQueue = null;
      function scheduleReplayQueueIfNeeded(formReplayingQueue) {
        lastScheduledReplayQueue !== formReplayingQueue && (lastScheduledReplayQueue = formReplayingQueue, Scheduler.unstable_scheduleCallback(
          Scheduler.unstable_NormalPriority,
          function() {
            lastScheduledReplayQueue === formReplayingQueue && (lastScheduledReplayQueue = null);
            for (var i = 0; i < formReplayingQueue.length; i += 3) {
              var form = formReplayingQueue[i], submitterOrAction = formReplayingQueue[i + 1], formData = formReplayingQueue[i + 2];
              if ("function" !== typeof submitterOrAction)
                if (null === findInstanceBlockingTarget(submitterOrAction || form))
                  continue;
                else
                  break;
              var formInst = getInstanceFromNode(form);
              null !== formInst && (formReplayingQueue.splice(i, 3), i -= 3, startHostTransition(
                formInst,
                {
                  pending: true,
                  data: formData,
                  method: form.method,
                  action: submitterOrAction
                },
                submitterOrAction,
                formData
              ));
            }
          }
        ));
      }
      function retryIfBlockedOn(unblocked) {
        function unblock(queuedEvent) {
          return scheduleCallbackIfUnblocked(queuedEvent, unblocked);
        }
        null !== queuedFocus && scheduleCallbackIfUnblocked(queuedFocus, unblocked);
        null !== queuedDrag && scheduleCallbackIfUnblocked(queuedDrag, unblocked);
        null !== queuedMouse && scheduleCallbackIfUnblocked(queuedMouse, unblocked);
        queuedPointers.forEach(unblock);
        queuedPointerCaptures.forEach(unblock);
        for (var i = 0; i < queuedExplicitHydrationTargets.length; i++) {
          var queuedTarget = queuedExplicitHydrationTargets[i];
          queuedTarget.blockedOn === unblocked && (queuedTarget.blockedOn = null);
        }
        for (; 0 < queuedExplicitHydrationTargets.length && (i = queuedExplicitHydrationTargets[0], null === i.blockedOn); )
          attemptExplicitHydrationTarget(i), null === i.blockedOn && queuedExplicitHydrationTargets.shift();
        i = (unblocked.ownerDocument || unblocked).$$reactFormReplay;
        if (null != i)
          for (queuedTarget = 0; queuedTarget < i.length; queuedTarget += 3) {
            var form = i[queuedTarget], submitterOrAction = i[queuedTarget + 1], formProps = form[internalPropsKey] || null;
            if ("function" === typeof submitterOrAction)
              formProps || scheduleReplayQueueIfNeeded(i);
            else if (formProps) {
              var action = null;
              if (submitterOrAction && submitterOrAction.hasAttribute("formAction"))
                if (form = submitterOrAction, formProps = submitterOrAction[internalPropsKey] || null)
                  action = formProps.formAction;
                else {
                  if (null !== findInstanceBlockingTarget(form))
                    continue;
                }
              else
                action = formProps.action;
              "function" === typeof action ? i[queuedTarget + 1] = action : (i.splice(queuedTarget, 3), queuedTarget -= 3);
              scheduleReplayQueueIfNeeded(i);
            }
          }
      }
      function defaultOnDefaultTransitionIndicator() {
        function handleNavigate(event) {
          event.canIntercept && "react-transition" === event.info && event.intercept({
            handler: function() {
              return new Promise(function(resolve) {
                return pendingResolve = resolve;
              });
            },
            focusReset: "manual",
            scroll: "manual"
          });
        }
        function handleNavigateComplete() {
          null !== pendingResolve && (pendingResolve(), pendingResolve = null);
          isCancelled || setTimeout(startFakeNavigation, 20);
        }
        function startFakeNavigation() {
          if (!isCancelled && !navigation.transition) {
            var currentEntry = navigation.currentEntry;
            currentEntry && null != currentEntry.url && navigation.navigate(currentEntry.url, {
              state: currentEntry.getState(),
              info: "react-transition",
              history: "replace"
            });
          }
        }
        if ("object" === typeof navigation) {
          var isCancelled = false, pendingResolve = null;
          navigation.addEventListener("navigate", handleNavigate);
          navigation.addEventListener("navigatesuccess", handleNavigateComplete);
          navigation.addEventListener("navigateerror", handleNavigateComplete);
          setTimeout(startFakeNavigation, 100);
          return function() {
            isCancelled = true;
            navigation.removeEventListener("navigate", handleNavigate);
            navigation.removeEventListener("navigatesuccess", handleNavigateComplete);
            navigation.removeEventListener("navigateerror", handleNavigateComplete);
            null !== pendingResolve && (pendingResolve(), pendingResolve = null);
          };
        }
      }
      function ReactDOMRoot(internalRoot) {
        this._internalRoot = internalRoot;
      }
      ReactDOMHydrationRoot.prototype.render = ReactDOMRoot.prototype.render = function(children) {
        var root3 = this._internalRoot;
        if (null === root3)
          throw Error(formatProdErrorMessage(409));
        var current = root3.current, lane = requestUpdateLane();
        updateContainerImpl(current, lane, children, root3, null, null);
      };
      ReactDOMHydrationRoot.prototype.unmount = ReactDOMRoot.prototype.unmount = function() {
        var root3 = this._internalRoot;
        if (null !== root3) {
          this._internalRoot = null;
          var container = root3.containerInfo;
          updateContainerImpl(root3.current, 2, null, root3, null, null);
          flushSyncWork$1();
          container[internalContainerInstanceKey] = null;
        }
      };
      function ReactDOMHydrationRoot(internalRoot) {
        this._internalRoot = internalRoot;
      }
      ReactDOMHydrationRoot.prototype.unstable_scheduleHydration = function(target) {
        if (target) {
          var updatePriority = resolveUpdatePriority();
          target = { blockedOn: null, target, priority: updatePriority };
          for (var i = 0; i < queuedExplicitHydrationTargets.length && 0 !== updatePriority && updatePriority < queuedExplicitHydrationTargets[i].priority; i++)
            ;
          queuedExplicitHydrationTargets.splice(i, 0, target);
          0 === i && attemptExplicitHydrationTarget(target);
        }
      };
      var isomorphicReactPackageVersion$jscomp$inline_1840 = React16.version;
      if ("19.2.0" !== isomorphicReactPackageVersion$jscomp$inline_1840)
        throw Error(
          formatProdErrorMessage(
            527,
            isomorphicReactPackageVersion$jscomp$inline_1840,
            "19.2.0"
          )
        );
      ReactDOMSharedInternals.findDOMNode = function(componentOrElement) {
        var fiber = componentOrElement._reactInternals;
        if (void 0 === fiber) {
          if ("function" === typeof componentOrElement.render)
            throw Error(formatProdErrorMessage(188));
          componentOrElement = Object.keys(componentOrElement).join(",");
          throw Error(formatProdErrorMessage(268, componentOrElement));
        }
        componentOrElement = findCurrentFiberUsingSlowPath(fiber);
        componentOrElement = null !== componentOrElement ? findCurrentHostFiberImpl(componentOrElement) : null;
        componentOrElement = null === componentOrElement ? null : componentOrElement.stateNode;
        return componentOrElement;
      };
      var internals$jscomp$inline_2347 = {
        bundleType: 0,
        version: "19.2.0",
        rendererPackageName: "react-dom",
        currentDispatcherRef: ReactSharedInternals,
        reconcilerVersion: "19.2.0"
      };
      if ("undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__) {
        hook$jscomp$inline_2348 = __REACT_DEVTOOLS_GLOBAL_HOOK__;
        if (!hook$jscomp$inline_2348.isDisabled && hook$jscomp$inline_2348.supportsFiber)
          try {
            rendererID = hook$jscomp$inline_2348.inject(
              internals$jscomp$inline_2347
            ), injectedHook = hook$jscomp$inline_2348;
          } catch (err) {
          }
      }
      var hook$jscomp$inline_2348;
      exports.createRoot = function(container, options2) {
        if (!isValidContainer(container))
          throw Error(formatProdErrorMessage(299));
        var isStrictMode = false, identifierPrefix = "", onUncaughtError = defaultOnUncaughtError, onCaughtError = defaultOnCaughtError, onRecoverableError = defaultOnRecoverableError;
        null !== options2 && void 0 !== options2 && (true === options2.unstable_strictMode && (isStrictMode = true), void 0 !== options2.identifierPrefix && (identifierPrefix = options2.identifierPrefix), void 0 !== options2.onUncaughtError && (onUncaughtError = options2.onUncaughtError), void 0 !== options2.onCaughtError && (onCaughtError = options2.onCaughtError), void 0 !== options2.onRecoverableError && (onRecoverableError = options2.onRecoverableError));
        options2 = createFiberRoot(
          container,
          1,
          false,
          null,
          null,
          isStrictMode,
          identifierPrefix,
          null,
          onUncaughtError,
          onCaughtError,
          onRecoverableError,
          defaultOnDefaultTransitionIndicator
        );
        container[internalContainerInstanceKey] = options2.current;
        listenToAllSupportedEvents(container);
        return new ReactDOMRoot(options2);
      };
      exports.hydrateRoot = function(container, initialChildren, options2) {
        if (!isValidContainer(container))
          throw Error(formatProdErrorMessage(299));
        var isStrictMode = false, identifierPrefix = "", onUncaughtError = defaultOnUncaughtError, onCaughtError = defaultOnCaughtError, onRecoverableError = defaultOnRecoverableError, formState = null;
        null !== options2 && void 0 !== options2 && (true === options2.unstable_strictMode && (isStrictMode = true), void 0 !== options2.identifierPrefix && (identifierPrefix = options2.identifierPrefix), void 0 !== options2.onUncaughtError && (onUncaughtError = options2.onUncaughtError), void 0 !== options2.onCaughtError && (onCaughtError = options2.onCaughtError), void 0 !== options2.onRecoverableError && (onRecoverableError = options2.onRecoverableError), void 0 !== options2.formState && (formState = options2.formState));
        initialChildren = createFiberRoot(
          container,
          1,
          true,
          initialChildren,
          null != options2 ? options2 : null,
          isStrictMode,
          identifierPrefix,
          formState,
          onUncaughtError,
          onCaughtError,
          onRecoverableError,
          defaultOnDefaultTransitionIndicator
        );
        initialChildren.context = getContextForSubtree(null);
        options2 = initialChildren.current;
        isStrictMode = requestUpdateLane();
        isStrictMode = getBumpedLaneForHydrationByLane(isStrictMode);
        identifierPrefix = createUpdate(isStrictMode);
        identifierPrefix.callback = null;
        enqueueUpdate(options2, identifierPrefix, isStrictMode);
        options2 = isStrictMode;
        initialChildren.current.lanes = options2;
        markRootUpdated$1(initialChildren, options2);
        ensureRootIsScheduled(initialChildren);
        container[internalContainerInstanceKey] = initialChildren.current;
        listenToAllSupportedEvents(container);
        return new ReactDOMHydrationRoot(initialChildren);
      };
      exports.version = "19.2.0";
    }
  });

  // node_modules/react-dom/client.js
  var require_client = __commonJS({
    "node_modules/react-dom/client.js"(exports, module) {
      "use strict";
      function checkDCE() {
        if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === "undefined" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE !== "function") {
          return;
        }
        if (false) {
          throw new Error("^_^");
        }
        try {
          __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE);
        } catch (err) {
          console.error(err);
        }
      }
      if (true) {
        checkDCE();
        module.exports = require_react_dom_client_production();
      } else {
        module.exports = null;
      }
    }
  });

  // node_modules/react/cjs/react-jsx-runtime.production.js
  var require_react_jsx_runtime_production = __commonJS({
    "node_modules/react/cjs/react-jsx-runtime.production.js"(exports) {
      "use strict";
      var REACT_ELEMENT_TYPE = Symbol.for("react.transitional.element");
      var REACT_FRAGMENT_TYPE = Symbol.for("react.fragment");
      function jsxProd(type, config, maybeKey) {
        var key = null;
        void 0 !== maybeKey && (key = "" + maybeKey);
        void 0 !== config.key && (key = "" + config.key);
        if ("key" in config) {
          maybeKey = {};
          for (var propName in config)
            "key" !== propName && (maybeKey[propName] = config[propName]);
        } else
          maybeKey = config;
        config = maybeKey.ref;
        return {
          $$typeof: REACT_ELEMENT_TYPE,
          type,
          key,
          ref: void 0 !== config ? config : null,
          props: maybeKey
        };
      }
      exports.Fragment = REACT_FRAGMENT_TYPE;
      exports.jsx = jsxProd;
      exports.jsxs = jsxProd;
    }
  });

  // node_modules/react/jsx-runtime.js
  var require_jsx_runtime = __commonJS({
    "node_modules/react/jsx-runtime.js"(exports, module) {
      "use strict";
      if (true) {
        module.exports = require_react_jsx_runtime_production();
      } else {
        module.exports = null;
      }
    }
  });

  // node_modules/@google/genai/dist/web/index.mjs
  var web_exports = {};
  __export(web_exports, {
    ActivityHandling: () => ActivityHandling,
    AdapterSize: () => AdapterSize,
    ApiError: () => ApiError,
    ApiSpec: () => ApiSpec,
    AuthType: () => AuthType,
    Batches: () => Batches,
    Behavior: () => Behavior,
    BlockedReason: () => BlockedReason,
    Caches: () => Caches,
    Chat: () => Chat,
    Chats: () => Chats,
    ComputeTokensResponse: () => ComputeTokensResponse,
    ContentReferenceImage: () => ContentReferenceImage,
    ControlReferenceImage: () => ControlReferenceImage,
    ControlReferenceType: () => ControlReferenceType,
    CountTokensResponse: () => CountTokensResponse,
    CreateFileResponse: () => CreateFileResponse,
    DeleteCachedContentResponse: () => DeleteCachedContentResponse,
    DeleteFileResponse: () => DeleteFileResponse,
    DeleteModelResponse: () => DeleteModelResponse,
    DocumentState: () => DocumentState,
    DynamicRetrievalConfigMode: () => DynamicRetrievalConfigMode,
    EditImageResponse: () => EditImageResponse,
    EditMode: () => EditMode,
    EmbedContentResponse: () => EmbedContentResponse,
    EndSensitivity: () => EndSensitivity,
    Environment: () => Environment,
    FeatureSelectionPreference: () => FeatureSelectionPreference,
    FileSource: () => FileSource,
    FileState: () => FileState,
    Files: () => Files,
    FinishReason: () => FinishReason,
    FunctionCallingConfigMode: () => FunctionCallingConfigMode,
    FunctionResponse: () => FunctionResponse,
    FunctionResponseBlob: () => FunctionResponseBlob,
    FunctionResponseFileData: () => FunctionResponseFileData,
    FunctionResponsePart: () => FunctionResponsePart,
    FunctionResponseScheduling: () => FunctionResponseScheduling,
    GenerateContentResponse: () => GenerateContentResponse,
    GenerateContentResponsePromptFeedback: () => GenerateContentResponsePromptFeedback,
    GenerateContentResponseUsageMetadata: () => GenerateContentResponseUsageMetadata,
    GenerateImagesResponse: () => GenerateImagesResponse,
    GenerateVideosOperation: () => GenerateVideosOperation,
    GenerateVideosResponse: () => GenerateVideosResponse,
    GoogleGenAI: () => GoogleGenAI,
    HarmBlockMethod: () => HarmBlockMethod,
    HarmBlockThreshold: () => HarmBlockThreshold,
    HarmCategory: () => HarmCategory,
    HarmProbability: () => HarmProbability,
    HarmSeverity: () => HarmSeverity,
    HttpElementLocation: () => HttpElementLocation,
    HttpResponse: () => HttpResponse,
    ImagePromptLanguage: () => ImagePromptLanguage,
    ImportFileOperation: () => ImportFileOperation,
    ImportFileResponse: () => ImportFileResponse,
    InlinedEmbedContentResponse: () => InlinedEmbedContentResponse,
    InlinedResponse: () => InlinedResponse,
    JobState: () => JobState,
    Language: () => Language,
    ListBatchJobsResponse: () => ListBatchJobsResponse,
    ListCachedContentsResponse: () => ListCachedContentsResponse,
    ListDocumentsResponse: () => ListDocumentsResponse,
    ListFileSearchStoresResponse: () => ListFileSearchStoresResponse,
    ListFilesResponse: () => ListFilesResponse,
    ListModelsResponse: () => ListModelsResponse,
    ListTuningJobsResponse: () => ListTuningJobsResponse,
    Live: () => Live,
    LiveClientToolResponse: () => LiveClientToolResponse,
    LiveMusicPlaybackControl: () => LiveMusicPlaybackControl,
    LiveMusicServerMessage: () => LiveMusicServerMessage,
    LiveSendToolResponseParameters: () => LiveSendToolResponseParameters,
    LiveServerMessage: () => LiveServerMessage,
    MaskReferenceImage: () => MaskReferenceImage,
    MaskReferenceMode: () => MaskReferenceMode,
    MediaModality: () => MediaModality,
    MediaResolution: () => MediaResolution,
    Modality: () => Modality,
    Mode: () => Mode,
    Models: () => Models,
    MusicGenerationMode: () => MusicGenerationMode,
    Operations: () => Operations,
    Outcome: () => Outcome,
    PagedItem: () => PagedItem,
    Pager: () => Pager,
    PartMediaResolutionLevel: () => PartMediaResolutionLevel,
    PersonGeneration: () => PersonGeneration,
    PhishBlockThreshold: () => PhishBlockThreshold,
    RawReferenceImage: () => RawReferenceImage,
    RecontextImageResponse: () => RecontextImageResponse,
    ReplayResponse: () => ReplayResponse,
    SafetyFilterLevel: () => SafetyFilterLevel,
    Scale: () => Scale,
    SegmentImageResponse: () => SegmentImageResponse,
    SegmentMode: () => SegmentMode,
    Session: () => Session,
    SingleEmbedContentResponse: () => SingleEmbedContentResponse,
    StartSensitivity: () => StartSensitivity,
    StyleReferenceImage: () => StyleReferenceImage,
    SubjectReferenceImage: () => SubjectReferenceImage,
    SubjectReferenceType: () => SubjectReferenceType,
    ThinkingLevel: () => ThinkingLevel,
    Tokens: () => Tokens,
    TrafficType: () => TrafficType,
    TuningMethod: () => TuningMethod,
    TuningMode: () => TuningMode,
    TuningTask: () => TuningTask,
    TurnCompleteReason: () => TurnCompleteReason,
    TurnCoverage: () => TurnCoverage,
    Type: () => Type,
    UploadToFileSearchStoreOperation: () => UploadToFileSearchStoreOperation,
    UploadToFileSearchStoreResponse: () => UploadToFileSearchStoreResponse,
    UploadToFileSearchStoreResumableResponse: () => UploadToFileSearchStoreResumableResponse,
    UpscaleImageResponse: () => UpscaleImageResponse,
    UrlRetrievalStatus: () => UrlRetrievalStatus,
    VideoCompressionQuality: () => VideoCompressionQuality,
    VideoGenerationMaskMode: () => VideoGenerationMaskMode,
    VideoGenerationReferenceType: () => VideoGenerationReferenceType,
    createFunctionResponsePartFromBase64: () => createFunctionResponsePartFromBase64,
    createFunctionResponsePartFromUri: () => createFunctionResponsePartFromUri,
    createModelContent: () => createModelContent,
    createPartFromBase64: () => createPartFromBase64,
    createPartFromCodeExecutionResult: () => createPartFromCodeExecutionResult,
    createPartFromExecutableCode: () => createPartFromExecutableCode,
    createPartFromFunctionCall: () => createPartFromFunctionCall,
    createPartFromFunctionResponse: () => createPartFromFunctionResponse,
    createPartFromText: () => createPartFromText,
    createPartFromUri: () => createPartFromUri,
    createUserContent: () => createUserContent,
    mcpToTool: () => mcpToTool,
    setDefaultBaseUrls: () => setDefaultBaseUrls
  });
  function setDefaultBaseUrls(baseUrlParams) {
    _defaultBaseGeminiUrl = baseUrlParams.geminiUrl;
    _defaultBaseVertexUrl = baseUrlParams.vertexUrl;
  }
  function getDefaultBaseUrls() {
    return {
      geminiUrl: _defaultBaseGeminiUrl,
      vertexUrl: _defaultBaseVertexUrl
    };
  }
  function getBaseUrl(httpOptions, vertexai, vertexBaseUrlFromEnv, geminiBaseUrlFromEnv) {
    var _a, _b;
    if (!(httpOptions === null || httpOptions === void 0 ? void 0 : httpOptions.baseUrl)) {
      const defaultBaseUrls = getDefaultBaseUrls();
      if (vertexai) {
        return (_a = defaultBaseUrls.vertexUrl) !== null && _a !== void 0 ? _a : vertexBaseUrlFromEnv;
      } else {
        return (_b = defaultBaseUrls.geminiUrl) !== null && _b !== void 0 ? _b : geminiBaseUrlFromEnv;
      }
    }
    return httpOptions.baseUrl;
  }
  function formatMap(templateString, valueMap) {
    const regex = /\{([^}]+)\}/g;
    return templateString.replace(regex, (match, key) => {
      if (Object.prototype.hasOwnProperty.call(valueMap, key)) {
        const value = valueMap[key];
        return value !== void 0 && value !== null ? String(value) : "";
      } else {
        throw new Error(`Key '${key}' not found in valueMap.`);
      }
    });
  }
  function setValueByPath(data, keys, value) {
    for (let i = 0; i < keys.length - 1; i++) {
      const key = keys[i];
      if (key.endsWith("[]")) {
        const keyName = key.slice(0, -2);
        if (!(keyName in data)) {
          if (Array.isArray(value)) {
            data[keyName] = Array.from({ length: value.length }, () => ({}));
          } else {
            throw new Error(`Value must be a list given an array path ${key}`);
          }
        }
        if (Array.isArray(data[keyName])) {
          const arrayData = data[keyName];
          if (Array.isArray(value)) {
            for (let j = 0; j < arrayData.length; j++) {
              const entry = arrayData[j];
              setValueByPath(entry, keys.slice(i + 1), value[j]);
            }
          } else {
            for (const d of arrayData) {
              setValueByPath(d, keys.slice(i + 1), value);
            }
          }
        }
        return;
      } else if (key.endsWith("[0]")) {
        const keyName = key.slice(0, -3);
        if (!(keyName in data)) {
          data[keyName] = [{}];
        }
        const arrayData = data[keyName];
        setValueByPath(arrayData[0], keys.slice(i + 1), value);
        return;
      }
      if (!data[key] || typeof data[key] !== "object") {
        data[key] = {};
      }
      data = data[key];
    }
    const keyToSet = keys[keys.length - 1];
    const existingData = data[keyToSet];
    if (existingData !== void 0) {
      if (!value || typeof value === "object" && Object.keys(value).length === 0) {
        return;
      }
      if (value === existingData) {
        return;
      }
      if (typeof existingData === "object" && typeof value === "object" && existingData !== null && value !== null) {
        Object.assign(existingData, value);
      } else {
        throw new Error(`Cannot set value for an existing key. Key: ${keyToSet}`);
      }
    } else {
      if (keyToSet === "_self" && typeof value === "object" && value !== null && !Array.isArray(value)) {
        const valueAsRecord = value;
        Object.assign(data, valueAsRecord);
      } else {
        data[keyToSet] = value;
      }
    }
  }
  function getValueByPath(data, keys, defaultValue = void 0) {
    try {
      if (keys.length === 1 && keys[0] === "_self") {
        return data;
      }
      for (let i = 0; i < keys.length; i++) {
        if (typeof data !== "object" || data === null) {
          return defaultValue;
        }
        const key = keys[i];
        if (key.endsWith("[]")) {
          const keyName = key.slice(0, -2);
          if (keyName in data) {
            const arrayData = data[keyName];
            if (!Array.isArray(arrayData)) {
              return defaultValue;
            }
            return arrayData.map((d) => getValueByPath(d, keys.slice(i + 1), defaultValue));
          } else {
            return defaultValue;
          }
        } else {
          data = data[key];
        }
      }
      return data;
    } catch (error) {
      if (error instanceof TypeError) {
        return defaultValue;
      }
      throw error;
    }
  }
  function moveValueByPath(data, paths) {
    for (const [sourcePath, destPath] of Object.entries(paths)) {
      const sourceKeys = sourcePath.split(".");
      const destKeys = destPath.split(".");
      const excludeKeys = /* @__PURE__ */ new Set();
      let wildcardIdx = -1;
      for (let i = 0; i < sourceKeys.length; i++) {
        if (sourceKeys[i] === "*") {
          wildcardIdx = i;
          break;
        }
      }
      if (wildcardIdx !== -1 && destKeys.length > wildcardIdx) {
        for (let i = wildcardIdx; i < destKeys.length; i++) {
          const key = destKeys[i];
          if (key !== "*" && !key.endsWith("[]") && !key.endsWith("[0]")) {
            excludeKeys.add(key);
          }
        }
      }
      _moveValueRecursive(data, sourceKeys, destKeys, 0, excludeKeys);
    }
  }
  function _moveValueRecursive(data, sourceKeys, destKeys, keyIdx, excludeKeys) {
    if (keyIdx >= sourceKeys.length) {
      return;
    }
    if (typeof data !== "object" || data === null) {
      return;
    }
    const key = sourceKeys[keyIdx];
    if (key.endsWith("[]")) {
      const keyName = key.slice(0, -2);
      const dataRecord = data;
      if (keyName in dataRecord && Array.isArray(dataRecord[keyName])) {
        for (const item of dataRecord[keyName]) {
          _moveValueRecursive(item, sourceKeys, destKeys, keyIdx + 1, excludeKeys);
        }
      }
    } else if (key === "*") {
      if (typeof data === "object" && data !== null && !Array.isArray(data)) {
        const dataRecord = data;
        const keysToMove = Object.keys(dataRecord).filter((k) => !k.startsWith("_") && !excludeKeys.has(k));
        const valuesToMove = {};
        for (const k of keysToMove) {
          valuesToMove[k] = dataRecord[k];
        }
        for (const [k, v] of Object.entries(valuesToMove)) {
          const newDestKeys = [];
          for (const dk of destKeys.slice(keyIdx)) {
            if (dk === "*") {
              newDestKeys.push(k);
            } else {
              newDestKeys.push(dk);
            }
          }
          setValueByPath(dataRecord, newDestKeys, v);
        }
        for (const k of keysToMove) {
          delete dataRecord[k];
        }
      }
    } else {
      const dataRecord = data;
      if (key in dataRecord) {
        _moveValueRecursive(dataRecord[key], sourceKeys, destKeys, keyIdx + 1, excludeKeys);
      }
    }
  }
  function tBytes$1(fromBytes) {
    if (typeof fromBytes !== "string") {
      throw new Error("fromImageBytes must be a string");
    }
    return fromBytes;
  }
  function fetchPredictOperationParametersToVertex(fromObject) {
    const toObject = {};
    const fromOperationName = getValueByPath(fromObject, [
      "operationName"
    ]);
    if (fromOperationName != null) {
      setValueByPath(toObject, ["operationName"], fromOperationName);
    }
    const fromResourceName = getValueByPath(fromObject, ["resourceName"]);
    if (fromResourceName != null) {
      setValueByPath(toObject, ["_url", "resourceName"], fromResourceName);
    }
    return toObject;
  }
  function generateVideosOperationFromMldev$1(fromObject) {
    const toObject = {};
    const fromName = getValueByPath(fromObject, ["name"]);
    if (fromName != null) {
      setValueByPath(toObject, ["name"], fromName);
    }
    const fromMetadata = getValueByPath(fromObject, ["metadata"]);
    if (fromMetadata != null) {
      setValueByPath(toObject, ["metadata"], fromMetadata);
    }
    const fromDone = getValueByPath(fromObject, ["done"]);
    if (fromDone != null) {
      setValueByPath(toObject, ["done"], fromDone);
    }
    const fromError = getValueByPath(fromObject, ["error"]);
    if (fromError != null) {
      setValueByPath(toObject, ["error"], fromError);
    }
    const fromResponse = getValueByPath(fromObject, [
      "response",
      "generateVideoResponse"
    ]);
    if (fromResponse != null) {
      setValueByPath(toObject, ["response"], generateVideosResponseFromMldev$1(fromResponse));
    }
    return toObject;
  }
  function generateVideosOperationFromVertex$1(fromObject) {
    const toObject = {};
    const fromName = getValueByPath(fromObject, ["name"]);
    if (fromName != null) {
      setValueByPath(toObject, ["name"], fromName);
    }
    const fromMetadata = getValueByPath(fromObject, ["metadata"]);
    if (fromMetadata != null) {
      setValueByPath(toObject, ["metadata"], fromMetadata);
    }
    const fromDone = getValueByPath(fromObject, ["done"]);
    if (fromDone != null) {
      setValueByPath(toObject, ["done"], fromDone);
    }
    const fromError = getValueByPath(fromObject, ["error"]);
    if (fromError != null) {
      setValueByPath(toObject, ["error"], fromError);
    }
    const fromResponse = getValueByPath(fromObject, ["response"]);
    if (fromResponse != null) {
      setValueByPath(toObject, ["response"], generateVideosResponseFromVertex$1(fromResponse));
    }
    return toObject;
  }
  function generateVideosResponseFromMldev$1(fromObject) {
    const toObject = {};
    const fromGeneratedVideos = getValueByPath(fromObject, [
      "generatedSamples"
    ]);
    if (fromGeneratedVideos != null) {
      let transformedList = fromGeneratedVideos;
      if (Array.isArray(transformedList)) {
        transformedList = transformedList.map((item) => {
          return generatedVideoFromMldev$1(item);
        });
      }
      setValueByPath(toObject, ["generatedVideos"], transformedList);
    }
    const fromRaiMediaFilteredCount = getValueByPath(fromObject, [
      "raiMediaFilteredCount"
    ]);
    if (fromRaiMediaFilteredCount != null) {
      setValueByPath(toObject, ["raiMediaFilteredCount"], fromRaiMediaFilteredCount);
    }
    const fromRaiMediaFilteredReasons = getValueByPath(fromObject, [
      "raiMediaFilteredReasons"
    ]);
    if (fromRaiMediaFilteredReasons != null) {
      setValueByPath(toObject, ["raiMediaFilteredReasons"], fromRaiMediaFilteredReasons);
    }
    return toObject;
  }
  function generateVideosResponseFromVertex$1(fromObject) {
    const toObject = {};
    const fromGeneratedVideos = getValueByPath(fromObject, ["videos"]);
    if (fromGeneratedVideos != null) {
      let transformedList = fromGeneratedVideos;
      if (Array.isArray(transformedList)) {
        transformedList = transformedList.map((item) => {
          return generatedVideoFromVertex$1(item);
        });
      }
      setValueByPath(toObject, ["generatedVideos"], transformedList);
    }
    const fromRaiMediaFilteredCount = getValueByPath(fromObject, [
      "raiMediaFilteredCount"
    ]);
    if (fromRaiMediaFilteredCount != null) {
      setValueByPath(toObject, ["raiMediaFilteredCount"], fromRaiMediaFilteredCount);
    }
    const fromRaiMediaFilteredReasons = getValueByPath(fromObject, [
      "raiMediaFilteredReasons"
    ]);
    if (fromRaiMediaFilteredReasons != null) {
      setValueByPath(toObject, ["raiMediaFilteredReasons"], fromRaiMediaFilteredReasons);
    }
    return toObject;
  }
  function generatedVideoFromMldev$1(fromObject) {
    const toObject = {};
    const fromVideo = getValueByPath(fromObject, ["video"]);
    if (fromVideo != null) {
      setValueByPath(toObject, ["video"], videoFromMldev$1(fromVideo));
    }
    return toObject;
  }
  function generatedVideoFromVertex$1(fromObject) {
    const toObject = {};
    const fromVideo = getValueByPath(fromObject, ["_self"]);
    if (fromVideo != null) {
      setValueByPath(toObject, ["video"], videoFromVertex$1(fromVideo));
    }
    return toObject;
  }
  function getOperationParametersToMldev(fromObject) {
    const toObject = {};
    const fromOperationName = getValueByPath(fromObject, [
      "operationName"
    ]);
    if (fromOperationName != null) {
      setValueByPath(toObject, ["_url", "operationName"], fromOperationName);
    }
    return toObject;
  }
  function getOperationParametersToVertex(fromObject) {
    const toObject = {};
    const fromOperationName = getValueByPath(fromObject, [
      "operationName"
    ]);
    if (fromOperationName != null) {
      setValueByPath(toObject, ["_url", "operationName"], fromOperationName);
    }
    return toObject;
  }
  function importFileOperationFromMldev$1(fromObject) {
    const toObject = {};
    const fromName = getValueByPath(fromObject, ["name"]);
    if (fromName != null) {
      setValueByPath(toObject, ["name"], fromName);
    }
    const fromMetadata = getValueByPath(fromObject, ["metadata"]);
    if (fromMetadata != null) {
      setValueByPath(toObject, ["metadata"], fromMetadata);
    }
    const fromDone = getValueByPath(fromObject, ["done"]);
    if (fromDone != null) {
      setValueByPath(toObject, ["done"], fromDone);
    }
    const fromError = getValueByPath(fromObject, ["error"]);
    if (fromError != null) {
      setValueByPath(toObject, ["error"], fromError);
    }
    const fromResponse = getValueByPath(fromObject, ["response"]);
    if (fromResponse != null) {
      setValueByPath(toObject, ["response"], importFileResponseFromMldev$1(fromResponse));
    }
    return toObject;
  }
  function importFileResponseFromMldev$1(fromObject) {
    const toObject = {};
    const fromSdkHttpResponse = getValueByPath(fromObject, [
      "sdkHttpResponse"
    ]);
    if (fromSdkHttpResponse != null) {
      setValueByPath(toObject, ["sdkHttpResponse"], fromSdkHttpResponse);
    }
    const fromParent = getValueByPath(fromObject, ["parent"]);
    if (fromParent != null) {
      setValueByPath(toObject, ["parent"], fromParent);
    }
    const fromDocumentName = getValueByPath(fromObject, ["documentName"]);
    if (fromDocumentName != null) {
      setValueByPath(toObject, ["documentName"], fromDocumentName);
    }
    return toObject;
  }
  function uploadToFileSearchStoreOperationFromMldev(fromObject) {
    const toObject = {};
    const fromName = getValueByPath(fromObject, ["name"]);
    if (fromName != null) {
      setValueByPath(toObject, ["name"], fromName);
    }
    const fromMetadata = getValueByPath(fromObject, ["metadata"]);
    if (fromMetadata != null) {
      setValueByPath(toObject, ["metadata"], fromMetadata);
    }
    const fromDone = getValueByPath(fromObject, ["done"]);
    if (fromDone != null) {
      setValueByPath(toObject, ["done"], fromDone);
    }
    const fromError = getValueByPath(fromObject, ["error"]);
    if (fromError != null) {
      setValueByPath(toObject, ["error"], fromError);
    }
    const fromResponse = getValueByPath(fromObject, ["response"]);
    if (fromResponse != null) {
      setValueByPath(toObject, ["response"], uploadToFileSearchStoreResponseFromMldev(fromResponse));
    }
    return toObject;
  }
  function uploadToFileSearchStoreResponseFromMldev(fromObject) {
    const toObject = {};
    const fromSdkHttpResponse = getValueByPath(fromObject, [
      "sdkHttpResponse"
    ]);
    if (fromSdkHttpResponse != null) {
      setValueByPath(toObject, ["sdkHttpResponse"], fromSdkHttpResponse);
    }
    const fromParent = getValueByPath(fromObject, ["parent"]);
    if (fromParent != null) {
      setValueByPath(toObject, ["parent"], fromParent);
    }
    const fromDocumentName = getValueByPath(fromObject, ["documentName"]);
    if (fromDocumentName != null) {
      setValueByPath(toObject, ["documentName"], fromDocumentName);
    }
    return toObject;
  }
  function videoFromMldev$1(fromObject) {
    const toObject = {};
    const fromUri = getValueByPath(fromObject, ["uri"]);
    if (fromUri != null) {
      setValueByPath(toObject, ["uri"], fromUri);
    }
    const fromVideoBytes = getValueByPath(fromObject, ["encodedVideo"]);
    if (fromVideoBytes != null) {
      setValueByPath(toObject, ["videoBytes"], tBytes$1(fromVideoBytes));
    }
    const fromMimeType = getValueByPath(fromObject, ["encoding"]);
    if (fromMimeType != null) {
      setValueByPath(toObject, ["mimeType"], fromMimeType);
    }
    return toObject;
  }
  function videoFromVertex$1(fromObject) {
    const toObject = {};
    const fromUri = getValueByPath(fromObject, ["gcsUri"]);
    if (fromUri != null) {
      setValueByPath(toObject, ["uri"], fromUri);
    }
    const fromVideoBytes = getValueByPath(fromObject, [
      "bytesBase64Encoded"
    ]);
    if (fromVideoBytes != null) {
      setValueByPath(toObject, ["videoBytes"], tBytes$1(fromVideoBytes));
    }
    const fromMimeType = getValueByPath(fromObject, ["mimeType"]);
    if (fromMimeType != null) {
      setValueByPath(toObject, ["mimeType"], fromMimeType);
    }
    return toObject;
  }
  function createFunctionResponsePartFromBase64(data, mimeType) {
    return {
      inlineData: {
        data,
        mimeType
      }
    };
  }
  function createFunctionResponsePartFromUri(uri, mimeType) {
    return {
      fileData: {
        fileUri: uri,
        mimeType
      }
    };
  }
  function createPartFromUri(uri, mimeType, mediaResolution) {
    return Object.assign({ fileData: {
      fileUri: uri,
      mimeType
    } }, mediaResolution && { mediaResolution: { level: mediaResolution } });
  }
  function createPartFromText(text) {
    return {
      text
    };
  }
  function createPartFromFunctionCall(name, args) {
    return {
      functionCall: {
        name,
        args
      }
    };
  }
  function createPartFromFunctionResponse(id, name, response, parts = []) {
    return {
      functionResponse: Object.assign({ id, name, response }, parts.length > 0 && { parts })
    };
  }
  function createPartFromBase64(data, mimeType, mediaResolution) {
    return Object.assign({ inlineData: {
      data,
      mimeType
    } }, mediaResolution && { mediaResolution: { level: mediaResolution } });
  }
  function createPartFromCodeExecutionResult(outcome, output) {
    return {
      codeExecutionResult: {
        outcome,
        output
      }
    };
  }
  function createPartFromExecutableCode(code, language) {
    return {
      executableCode: {
        code,
        language
      }
    };
  }
  function _isPart(obj) {
    if (typeof obj === "object" && obj !== null) {
      return "fileData" in obj || "text" in obj || "functionCall" in obj || "functionResponse" in obj || "inlineData" in obj || "videoMetadata" in obj || "codeExecutionResult" in obj || "executableCode" in obj;
    }
    return false;
  }
  function _toParts(partOrString) {
    const parts = [];
    if (typeof partOrString === "string") {
      parts.push(createPartFromText(partOrString));
    } else if (_isPart(partOrString)) {
      parts.push(partOrString);
    } else if (Array.isArray(partOrString)) {
      if (partOrString.length === 0) {
        throw new Error("partOrString cannot be an empty array");
      }
      for (const part of partOrString) {
        if (typeof part === "string") {
          parts.push(createPartFromText(part));
        } else if (_isPart(part)) {
          parts.push(part);
        } else {
          throw new Error("element in PartUnion must be a Part object or string");
        }
      }
    } else {
      throw new Error("partOrString must be a Part object, string, or array");
    }
    return parts;
  }
  function createUserContent(partOrString) {
    return {
      role: "user",
      parts: _toParts(partOrString)
    };
  }
  function createModelContent(partOrString) {
    return {
      role: "model",
      parts: _toParts(partOrString)
    };
  }
  function tModel(apiClient, model) {
    if (!model || typeof model !== "string") {
      throw new Error("model is required and must be a string");
    }
    if (model.includes("..") || model.includes("?") || model.includes("&")) {
      throw new Error("invalid model parameter");
    }
    if (apiClient.isVertexAI()) {
      if (model.startsWith("publishers/") || model.startsWith("projects/") || model.startsWith("models/")) {
        return model;
      } else if (model.indexOf("/") >= 0) {
        const parts = model.split("/", 2);
        return `publishers/${parts[0]}/models/${parts[1]}`;
      } else {
        return `publishers/google/models/${model}`;
      }
    } else {
      if (model.startsWith("models/") || model.startsWith("tunedModels/")) {
        return model;
      } else {
        return `models/${model}`;
      }
    }
  }
  function tCachesModel(apiClient, model) {
    const transformedModel = tModel(apiClient, model);
    if (!transformedModel) {
      return "";
    }
    if (transformedModel.startsWith("publishers/") && apiClient.isVertexAI()) {
      return `projects/${apiClient.getProject()}/locations/${apiClient.getLocation()}/${transformedModel}`;
    } else if (transformedModel.startsWith("models/") && apiClient.isVertexAI()) {
      return `projects/${apiClient.getProject()}/locations/${apiClient.getLocation()}/publishers/google/${transformedModel}`;
    } else {
      return transformedModel;
    }
  }
  function tBlobs(blobs) {
    if (Array.isArray(blobs)) {
      return blobs.map((blob) => tBlob(blob));
    } else {
      return [tBlob(blobs)];
    }
  }
  function tBlob(blob) {
    if (typeof blob === "object" && blob !== null) {
      return blob;
    }
    throw new Error(`Could not parse input as Blob. Unsupported blob type: ${typeof blob}`);
  }
  function tImageBlob(blob) {
    const transformedBlob = tBlob(blob);
    if (transformedBlob.mimeType && transformedBlob.mimeType.startsWith("image/")) {
      return transformedBlob;
    }
    throw new Error(`Unsupported mime type: ${transformedBlob.mimeType}`);
  }
  function tAudioBlob(blob) {
    const transformedBlob = tBlob(blob);
    if (transformedBlob.mimeType && transformedBlob.mimeType.startsWith("audio/")) {
      return transformedBlob;
    }
    throw new Error(`Unsupported mime type: ${transformedBlob.mimeType}`);
  }
  function tPart(origin) {
    if (origin === null || origin === void 0) {
      throw new Error("PartUnion is required");
    }
    if (typeof origin === "object") {
      return origin;
    }
    if (typeof origin === "string") {
      return { text: origin };
    }
    throw new Error(`Unsupported part type: ${typeof origin}`);
  }
  function tParts(origin) {
    if (origin === null || origin === void 0 || Array.isArray(origin) && origin.length === 0) {
      throw new Error("PartListUnion is required");
    }
    if (Array.isArray(origin)) {
      return origin.map((item) => tPart(item));
    }
    return [tPart(origin)];
  }
  function _isContent(origin) {
    return origin !== null && origin !== void 0 && typeof origin === "object" && "parts" in origin && Array.isArray(origin.parts);
  }
  function _isFunctionCallPart(origin) {
    return origin !== null && origin !== void 0 && typeof origin === "object" && "functionCall" in origin;
  }
  function _isFunctionResponsePart(origin) {
    return origin !== null && origin !== void 0 && typeof origin === "object" && "functionResponse" in origin;
  }
  function tContent(origin) {
    if (origin === null || origin === void 0) {
      throw new Error("ContentUnion is required");
    }
    if (_isContent(origin)) {
      return origin;
    }
    return {
      role: "user",
      parts: tParts(origin)
    };
  }
  function tContentsForEmbed(apiClient, origin) {
    if (!origin) {
      return [];
    }
    if (apiClient.isVertexAI() && Array.isArray(origin)) {
      return origin.flatMap((item) => {
        const content = tContent(item);
        if (content.parts && content.parts.length > 0 && content.parts[0].text !== void 0) {
          return [content.parts[0].text];
        }
        return [];
      });
    } else if (apiClient.isVertexAI()) {
      const content = tContent(origin);
      if (content.parts && content.parts.length > 0 && content.parts[0].text !== void 0) {
        return [content.parts[0].text];
      }
      return [];
    }
    if (Array.isArray(origin)) {
      return origin.map((item) => tContent(item));
    }
    return [tContent(origin)];
  }
  function tContents(origin) {
    if (origin === null || origin === void 0 || Array.isArray(origin) && origin.length === 0) {
      throw new Error("contents are required");
    }
    if (!Array.isArray(origin)) {
      if (_isFunctionCallPart(origin) || _isFunctionResponsePart(origin)) {
        throw new Error("To specify functionCall or functionResponse parts, please wrap them in a Content object, specifying the role for them");
      }
      return [tContent(origin)];
    }
    const result = [];
    const accumulatedParts = [];
    const isContentArray = _isContent(origin[0]);
    for (const item of origin) {
      const isContent = _isContent(item);
      if (isContent != isContentArray) {
        throw new Error("Mixing Content and Parts is not supported, please group the parts into a the appropriate Content objects and specify the roles for them");
      }
      if (isContent) {
        result.push(item);
      } else if (_isFunctionCallPart(item) || _isFunctionResponsePart(item)) {
        throw new Error("To specify functionCall or functionResponse parts, please wrap them, and any other parts, in Content objects as appropriate, specifying the role for them");
      } else {
        accumulatedParts.push(item);
      }
    }
    if (!isContentArray) {
      result.push({ role: "user", parts: tParts(accumulatedParts) });
    }
    return result;
  }
  function flattenTypeArrayToAnyOf(typeList, resultingSchema) {
    if (typeList.includes("null")) {
      resultingSchema["nullable"] = true;
    }
    const listWithoutNull = typeList.filter((type) => type !== "null");
    if (listWithoutNull.length === 1) {
      resultingSchema["type"] = Object.values(Type).includes(listWithoutNull[0].toUpperCase()) ? listWithoutNull[0].toUpperCase() : Type.TYPE_UNSPECIFIED;
    } else {
      resultingSchema["anyOf"] = [];
      for (const i of listWithoutNull) {
        resultingSchema["anyOf"].push({
          "type": Object.values(Type).includes(i.toUpperCase()) ? i.toUpperCase() : Type.TYPE_UNSPECIFIED
        });
      }
    }
  }
  function processJsonSchema(_jsonSchema) {
    const genAISchema = {};
    const schemaFieldNames = ["items"];
    const listSchemaFieldNames = ["anyOf"];
    const dictSchemaFieldNames = ["properties"];
    if (_jsonSchema["type"] && _jsonSchema["anyOf"]) {
      throw new Error("type and anyOf cannot be both populated.");
    }
    const incomingAnyOf = _jsonSchema["anyOf"];
    if (incomingAnyOf != null && incomingAnyOf.length == 2) {
      if (incomingAnyOf[0]["type"] === "null") {
        genAISchema["nullable"] = true;
        _jsonSchema = incomingAnyOf[1];
      } else if (incomingAnyOf[1]["type"] === "null") {
        genAISchema["nullable"] = true;
        _jsonSchema = incomingAnyOf[0];
      }
    }
    if (_jsonSchema["type"] instanceof Array) {
      flattenTypeArrayToAnyOf(_jsonSchema["type"], genAISchema);
    }
    for (const [fieldName, fieldValue] of Object.entries(_jsonSchema)) {
      if (fieldValue == null) {
        continue;
      }
      if (fieldName == "type") {
        if (fieldValue === "null") {
          throw new Error("type: null can not be the only possible type for the field.");
        }
        if (fieldValue instanceof Array) {
          continue;
        }
        genAISchema["type"] = Object.values(Type).includes(fieldValue.toUpperCase()) ? fieldValue.toUpperCase() : Type.TYPE_UNSPECIFIED;
      } else if (schemaFieldNames.includes(fieldName)) {
        genAISchema[fieldName] = processJsonSchema(fieldValue);
      } else if (listSchemaFieldNames.includes(fieldName)) {
        const listSchemaFieldValue = [];
        for (const item of fieldValue) {
          if (item["type"] == "null") {
            genAISchema["nullable"] = true;
            continue;
          }
          listSchemaFieldValue.push(processJsonSchema(item));
        }
        genAISchema[fieldName] = listSchemaFieldValue;
      } else if (dictSchemaFieldNames.includes(fieldName)) {
        const dictSchemaFieldValue = {};
        for (const [key, value] of Object.entries(fieldValue)) {
          dictSchemaFieldValue[key] = processJsonSchema(value);
        }
        genAISchema[fieldName] = dictSchemaFieldValue;
      } else {
        if (fieldName === "additionalProperties") {
          continue;
        }
        genAISchema[fieldName] = fieldValue;
      }
    }
    return genAISchema;
  }
  function tSchema(schema) {
    return processJsonSchema(schema);
  }
  function tSpeechConfig(speechConfig) {
    if (typeof speechConfig === "object") {
      return speechConfig;
    } else if (typeof speechConfig === "string") {
      return {
        voiceConfig: {
          prebuiltVoiceConfig: {
            voiceName: speechConfig
          }
        }
      };
    } else {
      throw new Error(`Unsupported speechConfig type: ${typeof speechConfig}`);
    }
  }
  function tLiveSpeechConfig(speechConfig) {
    if ("multiSpeakerVoiceConfig" in speechConfig) {
      throw new Error("multiSpeakerVoiceConfig is not supported in the live API.");
    }
    return speechConfig;
  }
  function tTool(tool) {
    if (tool.functionDeclarations) {
      for (const functionDeclaration of tool.functionDeclarations) {
        if (functionDeclaration.parameters) {
          if (!Object.keys(functionDeclaration.parameters).includes("$schema")) {
            functionDeclaration.parameters = processJsonSchema(functionDeclaration.parameters);
          } else {
            if (!functionDeclaration.parametersJsonSchema) {
              functionDeclaration.parametersJsonSchema = functionDeclaration.parameters;
              delete functionDeclaration.parameters;
            }
          }
        }
        if (functionDeclaration.response) {
          if (!Object.keys(functionDeclaration.response).includes("$schema")) {
            functionDeclaration.response = processJsonSchema(functionDeclaration.response);
          } else {
            if (!functionDeclaration.responseJsonSchema) {
              functionDeclaration.responseJsonSchema = functionDeclaration.response;
              delete functionDeclaration.response;
            }
          }
        }
      }
    }
    return tool;
  }
  function tTools(tools) {
    if (tools === void 0 || tools === null) {
      throw new Error("tools is required");
    }
    if (!Array.isArray(tools)) {
      throw new Error("tools is required and must be an array of Tools");
    }
    const result = [];
    for (const tool of tools) {
      result.push(tool);
    }
    return result;
  }
  function resourceName(client, resourceName2, resourcePrefix, splitsAfterPrefix = 1) {
    const shouldAppendPrefix = !resourceName2.startsWith(`${resourcePrefix}/`) && resourceName2.split("/").length === splitsAfterPrefix;
    if (client.isVertexAI()) {
      if (resourceName2.startsWith("projects/")) {
        return resourceName2;
      } else if (resourceName2.startsWith("locations/")) {
        return `projects/${client.getProject()}/${resourceName2}`;
      } else if (resourceName2.startsWith(`${resourcePrefix}/`)) {
        return `projects/${client.getProject()}/locations/${client.getLocation()}/${resourceName2}`;
      } else if (shouldAppendPrefix) {
        return `projects/${client.getProject()}/locations/${client.getLocation()}/${resourcePrefix}/${resourceName2}`;
      } else {
        return resourceName2;
      }
    }
    if (shouldAppendPrefix) {
      return `${resourcePrefix}/${resourceName2}`;
    }
    return resourceName2;
  }
  function tCachedContentName(apiClient, name) {
    if (typeof name !== "string") {
      throw new Error("name must be a string");
    }
    return resourceName(apiClient, name, "cachedContents");
  }
  function tTuningJobStatus(status) {
    switch (status) {
      case "STATE_UNSPECIFIED":
        return "JOB_STATE_UNSPECIFIED";
      case "CREATING":
        return "JOB_STATE_RUNNING";
      case "ACTIVE":
        return "JOB_STATE_SUCCEEDED";
      case "FAILED":
        return "JOB_STATE_FAILED";
      default:
        return status;
    }
  }
  function tBytes(fromImageBytes) {
    return tBytes$1(fromImageBytes);
  }
  function _isFile(origin) {
    return origin !== null && origin !== void 0 && typeof origin === "object" && "name" in origin;
  }
  function isGeneratedVideo(origin) {
    return origin !== null && origin !== void 0 && typeof origin === "object" && "video" in origin;
  }
  function isVideo(origin) {
    return origin !== null && origin !== void 0 && typeof origin === "object" && "uri" in origin;
  }
  function tFileName(fromName) {
    var _a;
    let name;
    if (_isFile(fromName)) {
      name = fromName.name;
    }
    if (isVideo(fromName)) {
      name = fromName.uri;
      if (name === void 0) {
        return void 0;
      }
    }
    if (isGeneratedVideo(fromName)) {
      name = (_a = fromName.video) === null || _a === void 0 ? void 0 : _a.uri;
      if (name === void 0) {
        return void 0;
      }
    }
    if (typeof fromName === "string") {
      name = fromName;
    }
    if (name === void 0) {
      throw new Error("Could not extract file name from the provided input.");
    }
    if (name.startsWith("https://")) {
      const suffix = name.split("files/")[1];
      const match = suffix.match(/[a-z0-9]+/);
      if (match === null) {
        throw new Error(`Could not extract file name from URI ${name}`);
      }
      name = match[0];
    } else if (name.startsWith("files/")) {
      name = name.split("files/")[1];
    }
    return name;
  }
  function tModelsUrl(apiClient, baseModels) {
    let res;
    if (apiClient.isVertexAI()) {
      res = baseModels ? "publishers/google/models" : "models";
    } else {
      res = baseModels ? "models" : "tunedModels";
    }
    return res;
  }
  function tExtractModels(response) {
    for (const key of ["models", "tunedModels", "publisherModels"]) {
      if (hasField(response, key)) {
        return response[key];
      }
    }
    return [];
  }
  function hasField(data, fieldName) {
    return data !== null && typeof data === "object" && fieldName in data;
  }
  function mcpToGeminiTool(mcpTool, config = {}) {
    const mcpToolSchema = mcpTool;
    const functionDeclaration = {
      name: mcpToolSchema["name"],
      description: mcpToolSchema["description"],
      parametersJsonSchema: mcpToolSchema["inputSchema"]
    };
    if (mcpToolSchema["outputSchema"]) {
      functionDeclaration["responseJsonSchema"] = mcpToolSchema["outputSchema"];
    }
    if (config.behavior) {
      functionDeclaration["behavior"] = config.behavior;
    }
    const geminiTool = {
      functionDeclarations: [
        functionDeclaration
      ]
    };
    return geminiTool;
  }
  function mcpToolsToGeminiTool(mcpTools, config = {}) {
    const functionDeclarations = [];
    const toolNames = /* @__PURE__ */ new Set();
    for (const mcpTool of mcpTools) {
      const mcpToolName = mcpTool.name;
      if (toolNames.has(mcpToolName)) {
        throw new Error(`Duplicate function name ${mcpToolName} found in MCP tools. Please ensure function names are unique.`);
      }
      toolNames.add(mcpToolName);
      const geminiTool = mcpToGeminiTool(mcpTool, config);
      if (geminiTool.functionDeclarations) {
        functionDeclarations.push(...geminiTool.functionDeclarations);
      }
    }
    return { functionDeclarations };
  }
  function tBatchJobSource(client, src) {
    let sourceObj;
    if (typeof src === "string") {
      if (client.isVertexAI()) {
        if (src.startsWith("gs://")) {
          sourceObj = { format: "jsonl", gcsUri: [src] };
        } else if (src.startsWith("bq://")) {
          sourceObj = { format: "bigquery", bigqueryUri: src };
        } else {
          throw new Error(`Unsupported string source for Vertex AI: ${src}`);
        }
      } else {
        if (src.startsWith("files/")) {
          sourceObj = { fileName: src };
        } else {
          throw new Error(`Unsupported string source for Gemini API: ${src}`);
        }
      }
    } else if (Array.isArray(src)) {
      if (client.isVertexAI()) {
        throw new Error("InlinedRequest[] is not supported in Vertex AI.");
      }
      sourceObj = { inlinedRequests: src };
    } else {
      sourceObj = src;
    }
    const vertexSourcesCount = [sourceObj.gcsUri, sourceObj.bigqueryUri].filter(Boolean).length;
    const mldevSourcesCount = [
      sourceObj.inlinedRequests,
      sourceObj.fileName
    ].filter(Boolean).length;
    if (client.isVertexAI()) {
      if (mldevSourcesCount > 0 || vertexSourcesCount !== 1) {
        throw new Error("Exactly one of `gcsUri` or `bigqueryUri` must be set for Vertex AI.");
      }
    } else {
      if (vertexSourcesCount > 0 || mldevSourcesCount !== 1) {
        throw new Error("Exactly one of `inlinedRequests`, `fileName`, must be set for Gemini API.");
      }
    }
    return sourceObj;
  }
  function tBatchJobDestination(dest) {
    if (typeof dest !== "string") {
      return dest;
    }
    const destString = dest;
    if (destString.startsWith("gs://")) {
      return {
        format: "jsonl",
        gcsUri: destString
      };
    } else if (destString.startsWith("bq://")) {
      return {
        format: "bigquery",
        bigqueryUri: destString
      };
    } else {
      throw new Error(`Unsupported destination: ${destString}`);
    }
  }
  function tRecvBatchJobDestination(dest) {
    if (typeof dest !== "object" || dest === null) {
      return {};
    }
    const obj = dest;
    const inlineResponsesVal = obj["inlinedResponses"];
    if (typeof inlineResponsesVal !== "object" || inlineResponsesVal === null) {
      return dest;
    }
    const inlineResponsesObj = inlineResponsesVal;
    const responsesArray = inlineResponsesObj["inlinedResponses"];
    if (!Array.isArray(responsesArray) || responsesArray.length === 0) {
      return dest;
    }
    let hasEmbedding = false;
    for (const responseItem of responsesArray) {
      if (typeof responseItem !== "object" || responseItem === null) {
        continue;
      }
      const responseItemObj = responseItem;
      const responseVal = responseItemObj["response"];
      if (typeof responseVal !== "object" || responseVal === null) {
        continue;
      }
      const responseObj = responseVal;
      if (responseObj["embedding"] !== void 0) {
        hasEmbedding = true;
        break;
      }
    }
    if (hasEmbedding) {
      obj["inlinedEmbedContentResponses"] = obj["inlinedResponses"];
      delete obj["inlinedResponses"];
    }
    return dest;
  }
  function tBatchJobName(apiClient, name) {
    const nameString = name;
    if (!apiClient.isVertexAI()) {
      const mldevPattern = /batches\/[^/]+$/;
      if (mldevPattern.test(nameString)) {
        return nameString.split("/").pop();
      } else {
        throw new Error(`Invalid batch job name: ${nameString}.`);
      }
    }
    const vertexPattern = /^projects\/[^/]+\/locations\/[^/]+\/batchPredictionJobs\/[^/]+$/;
    if (vertexPattern.test(nameString)) {
      return nameString.split("/").pop();
    } else if (/^\d+$/.test(nameString)) {
      return nameString;
    } else {
      throw new Error(`Invalid batch job name: ${nameString}.`);
    }
  }
  function tJobState(state) {
    const stateString = state;
    if (stateString === "BATCH_STATE_UNSPECIFIED") {
      return "JOB_STATE_UNSPECIFIED";
    } else if (stateString === "BATCH_STATE_PENDING") {
      return "JOB_STATE_PENDING";
    } else if (stateString === "BATCH_STATE_RUNNING") {
      return "JOB_STATE_RUNNING";
    } else if (stateString === "BATCH_STATE_SUCCEEDED") {
      return "JOB_STATE_SUCCEEDED";
    } else if (stateString === "BATCH_STATE_FAILED") {
      return "JOB_STATE_FAILED";
    } else if (stateString === "BATCH_STATE_CANCELLED") {
      return "JOB_STATE_CANCELLED";
    } else if (stateString === "BATCH_STATE_EXPIRED") {
      return "JOB_STATE_EXPIRED";
    } else {
      return stateString;
    }
  }
  function batchJobDestinationFromMldev(fromObject) {
    const toObject = {};
    const fromFileName = getValueByPath(fromObject, ["responsesFile"]);
    if (fromFileName != null) {
      setValueByPath(toObject, ["fileName"], fromFileName);
    }
    const fromInlinedResponses = getValueByPath(fromObject, [
      "inlinedResponses",
      "inlinedResponses"
    ]);
    if (fromInlinedResponses != null) {
      let transformedList = fromInlinedResponses;
      if (Array.isArray(transformedList)) {
        transformedList = transformedList.map((item) => {
          return inlinedResponseFromMldev(item);
        });
      }
      setValueByPath(toObject, ["inlinedResponses"], transformedList);
    }
    const fromInlinedEmbedContentResponses = getValueByPath(fromObject, [
      "inlinedEmbedContentResponses",
      "inlinedResponses"
    ]);
    if (fromInlinedEmbedContentResponses != null) {
      let transformedList = fromInlinedEmbedContentResponses;
      if (Array.isArray(transformedList)) {
        transformedList = transformedList.map((item) => {
          return item;
        });
      }
      setValueByPath(toObject, ["inlinedEmbedContentResponses"], transformedList);
    }
    return toObject;
  }
  function batchJobDestinationFromVertex(fromObject) {
    const toObject = {};
    const fromFormat = getValueByPath(fromObject, ["predictionsFormat"]);
    if (fromFormat != null) {
      setValueByPath(toObject, ["format"], fromFormat);
    }
    const fromGcsUri = getValueByPath(fromObject, [
      "gcsDestination",
      "outputUriPrefix"
    ]);
    if (fromGcsUri != null) {
      setValueByPath(toObject, ["gcsUri"], fromGcsUri);
    }
    const fromBigqueryUri = getValueByPath(fromObject, [
      "bigqueryDestination",
      "outputUri"
    ]);
    if (fromBigqueryUri != null) {
      setValueByPath(toObject, ["bigqueryUri"], fromBigqueryUri);
    }
    return toObject;
  }
  function batchJobDestinationToVertex(fromObject) {
    const toObject = {};
    const fromFormat = getValueByPath(fromObject, ["format"]);
    if (fromFormat != null) {
      setValueByPath(toObject, ["predictionsFormat"], fromFormat);
    }
    const fromGcsUri = getValueByPath(fromObject, ["gcsUri"]);
    if (fromGcsUri != null) {
      setValueByPath(toObject, ["gcsDestination", "outputUriPrefix"], fromGcsUri);
    }
    const fromBigqueryUri = getValueByPath(fromObject, ["bigqueryUri"]);
    if (fromBigqueryUri != null) {
      setValueByPath(toObject, ["bigqueryDestination", "outputUri"], fromBigqueryUri);
    }
    if (getValueByPath(fromObject, ["fileName"]) !== void 0) {
      throw new Error("fileName parameter is not supported in Vertex AI.");
    }
    if (getValueByPath(fromObject, ["inlinedResponses"]) !== void 0) {
      throw new Error("inlinedResponses parameter is not supported in Vertex AI.");
    }
    if (getValueByPath(fromObject, ["inlinedEmbedContentResponses"]) !== void 0) {
      throw new Error("inlinedEmbedContentResponses parameter is not supported in Vertex AI.");
    }
    return toObject;
  }
  function batchJobFromMldev(fromObject) {
    const toObject = {};
    const fromName = getValueByPath(fromObject, ["name"]);
    if (fromName != null) {
      setValueByPath(toObject, ["name"], fromName);
    }
    const fromDisplayName = getValueByPath(fromObject, [
      "metadata",
      "displayName"
    ]);
    if (fromDisplayName != null) {
      setValueByPath(toObject, ["displayName"], fromDisplayName);
    }
    const fromState = getValueByPath(fromObject, ["metadata", "state"]);
    if (fromState != null) {
      setValueByPath(toObject, ["state"], tJobState(fromState));
    }
    const fromCreateTime = getValueByPath(fromObject, [
      "metadata",
      "createTime"
    ]);
    if (fromCreateTime != null) {
      setValueByPath(toObject, ["createTime"], fromCreateTime);
    }
    const fromEndTime = getValueByPath(fromObject, [
      "metadata",
      "endTime"
    ]);
    if (fromEndTime != null) {
      setValueByPath(toObject, ["endTime"], fromEndTime);
    }
    const fromUpdateTime = getValueByPath(fromObject, [
      "metadata",
      "updateTime"
    ]);
    if (fromUpdateTime != null) {
      setValueByPath(toObject, ["updateTime"], fromUpdateTime);
    }
    const fromModel = getValueByPath(fromObject, ["metadata", "model"]);
    if (fromModel != null) {
      setValueByPath(toObject, ["model"], fromModel);
    }
    const fromDest = getValueByPath(fromObject, ["metadata", "output"]);
    if (fromDest != null) {
      setValueByPath(toObject, ["dest"], batchJobDestinationFromMldev(tRecvBatchJobDestination(fromDest)));
    }
    return toObject;
  }
  function batchJobFromVertex(fromObject) {
    const toObject = {};
    const fromName = getValueByPath(fromObject, ["name"]);
    if (fromName != null) {
      setValueByPath(toObject, ["name"], fromName);
    }
    const fromDisplayName = getValueByPath(fromObject, ["displayName"]);
    if (fromDisplayName != null) {
      setValueByPath(toObject, ["displayName"], fromDisplayName);
    }
    const fromState = getValueByPath(fromObject, ["state"]);
    if (fromState != null) {
      setValueByPath(toObject, ["state"], tJobState(fromState));
    }
    const fromError = getValueByPath(fromObject, ["error"]);
    if (fromError != null) {
      setValueByPath(toObject, ["error"], fromError);
    }
    const fromCreateTime = getValueByPath(fromObject, ["createTime"]);
    if (fromCreateTime != null) {
      setValueByPath(toObject, ["createTime"], fromCreateTime);
    }
    const fromStartTime = getValueByPath(fromObject, ["startTime"]);
    if (fromStartTime != null) {
      setValueByPath(toObject, ["startTime"], fromStartTime);
    }
    const fromEndTime = getValueByPath(fromObject, ["endTime"]);
    if (fromEndTime != null) {
      setValueByPath(toObject, ["endTime"], fromEndTime);
    }
    const fromUpdateTime = getValueByPath(fromObject, ["updateTime"]);
    if (fromUpdateTime != null) {
      setValueByPath(toObject, ["updateTime"], fromUpdateTime);
    }
    const fromModel = getValueByPath(fromObject, ["model"]);
    if (fromModel != null) {
      setValueByPath(toObject, ["model"], fromModel);
    }
    const fromSrc = getValueByPath(fromObject, ["inputConfig"]);
    if (fromSrc != null) {
      setValueByPath(toObject, ["src"], batchJobSourceFromVertex(fromSrc));
    }
    const fromDest = getValueByPath(fromObject, ["outputConfig"]);
    if (fromDest != null) {
      setValueByPath(toObject, ["dest"], batchJobDestinationFromVertex(tRecvBatchJobDestination(fromDest)));
    }
    const fromCompletionStats = getValueByPath(fromObject, [
      "completionStats"
    ]);
    if (fromCompletionStats != null) {
      setValueByPath(toObject, ["completionStats"], fromCompletionStats);
    }
    return toObject;
  }
  function batchJobSourceFromVertex(fromObject) {
    const toObject = {};
    const fromFormat = getValueByPath(fromObject, ["instancesFormat"]);
    if (fromFormat != null) {
      setValueByPath(toObject, ["format"], fromFormat);
    }
    const fromGcsUri = getValueByPath(fromObject, ["gcsSource", "uris"]);
    if (fromGcsUri != null) {
      setValueByPath(toObject, ["gcsUri"], fromGcsUri);
    }
    const fromBigqueryUri = getValueByPath(fromObject, [
      "bigquerySource",
      "inputUri"
    ]);
    if (fromBigqueryUri != null) {
      setValueByPath(toObject, ["bigqueryUri"], fromBigqueryUri);
    }
    return toObject;
  }
  function batchJobSourceToMldev(apiClient, fromObject) {
    const toObject = {};
    if (getValueByPath(fromObject, ["format"]) !== void 0) {
      throw new Error("format parameter is not supported in Gemini API.");
    }
    if (getValueByPath(fromObject, ["gcsUri"]) !== void 0) {
      throw new Error("gcsUri parameter is not supported in Gemini API.");
    }
    if (getValueByPath(fromObject, ["bigqueryUri"]) !== void 0) {
      throw new Error("bigqueryUri parameter is not supported in Gemini API.");
    }
    const fromFileName = getValueByPath(fromObject, ["fileName"]);
    if (fromFileName != null) {
      setValueByPath(toObject, ["fileName"], fromFileName);
    }
    const fromInlinedRequests = getValueByPath(fromObject, [
      "inlinedRequests"
    ]);
    if (fromInlinedRequests != null) {
      let transformedList = fromInlinedRequests;
      if (Array.isArray(transformedList)) {
        transformedList = transformedList.map((item) => {
          return inlinedRequestToMldev(apiClient, item);
        });
      }
      setValueByPath(toObject, ["requests", "requests"], transformedList);
    }
    return toObject;
  }
  function batchJobSourceToVertex(fromObject) {
    const toObject = {};
    const fromFormat = getValueByPath(fromObject, ["format"]);
    if (fromFormat != null) {
      setValueByPath(toObject, ["instancesFormat"], fromFormat);
    }
    const fromGcsUri = getValueByPath(fromObject, ["gcsUri"]);
    if (fromGcsUri != null) {
      setValueByPath(toObject, ["gcsSource", "uris"], fromGcsUri);
    }
    const fromBigqueryUri = getValueByPath(fromObject, ["bigqueryUri"]);
    if (fromBigqueryUri != null) {
      setValueByPath(toObject, ["bigquerySource", "inputUri"], fromBigqueryUri);
    }
    if (getValueByPath(fromObject, ["fileName"]) !== void 0) {
      throw new Error("fileName parameter is not supported in Vertex AI.");
    }
    if (getValueByPath(fromObject, ["inlinedRequests"]) !== void 0) {
      throw new Error("inlinedRequests parameter is not supported in Vertex AI.");
    }
    return toObject;
  }
  function blobToMldev$4(fromObject) {
    const toObject = {};
    const fromData = getValueByPath(fromObject, ["data"]);
    if (fromData != null) {
      setValueByPath(toObject, ["data"], fromData);
    }
    if (getValueByPath(fromObject, ["displayName"]) !== void 0) {
      throw new Error("displayName parameter is not supported in Gemini API.");
    }
    const fromMimeType = getValueByPath(fromObject, ["mimeType"]);
    if (fromMimeType != null) {
      setValueByPath(toObject, ["mimeType"], fromMimeType);
    }
    return toObject;
  }
  function cancelBatchJobParametersToMldev(apiClient, fromObject) {
    const toObject = {};
    const fromName = getValueByPath(fromObject, ["name"]);
    if (fromName != null) {
      setValueByPath(toObject, ["_url", "name"], tBatchJobName(apiClient, fromName));
    }
    return toObject;
  }
  function cancelBatchJobParametersToVertex(apiClient, fromObject) {
    const toObject = {};
    const fromName = getValueByPath(fromObject, ["name"]);
    if (fromName != null) {
      setValueByPath(toObject, ["_url", "name"], tBatchJobName(apiClient, fromName));
    }
    return toObject;
  }
  function candidateFromMldev$1(fromObject) {
    const toObject = {};
    const fromContent = getValueByPath(fromObject, ["content"]);
    if (fromContent != null) {
      setValueByPath(toObject, ["content"], fromContent);
    }
    const fromCitationMetadata = getValueByPath(fromObject, [
      "citationMetadata"
    ]);
    if (fromCitationMetadata != null) {
      setValueByPath(toObject, ["citationMetadata"], citationMetadataFromMldev$1(fromCitationMetadata));
    }
    const fromTokenCount = getValueByPath(fromObject, ["tokenCount"]);
    if (fromTokenCount != null) {
      setValueByPath(toObject, ["tokenCount"], fromTokenCount);
    }
    const fromFinishReason = getValueByPath(fromObject, ["finishReason"]);
    if (fromFinishReason != null) {
      setValueByPath(toObject, ["finishReason"], fromFinishReason);
    }
    const fromAvgLogprobs = getValueByPath(fromObject, ["avgLogprobs"]);
    if (fromAvgLogprobs != null) {
      setValueByPath(toObject, ["avgLogprobs"], fromAvgLogprobs);
    }
    const fromGroundingMetadata = getValueByPath(fromObject, [
      "groundingMetadata"
    ]);
    if (fromGroundingMetadata != null) {
      setValueByPath(toObject, ["groundingMetadata"], fromGroundingMetadata);
    }
    const fromIndex = getValueByPath(fromObject, ["index"]);
    if (fromIndex != null) {
      setValueByPath(toObject, ["index"], fromIndex);
    }
    const fromLogprobsResult = getValueByPath(fromObject, [
      "logprobsResult"
    ]);
    if (fromLogprobsResult != null) {
      setValueByPath(toObject, ["logprobsResult"], fromLogprobsResult);
    }
    const fromSafetyRatings = getValueByPath(fromObject, [
      "safetyRatings"
    ]);
    if (fromSafetyRatings != null) {
      let transformedList = fromSafetyRatings;
      if (Array.isArray(transformedList)) {
        transformedList = transformedList.map((item) => {
          return item;
        });
      }
      setValueByPath(toObject, ["safetyRatings"], transformedList);
    }
    const fromUrlContextMetadata = getValueByPath(fromObject, [
      "urlContextMetadata"
    ]);
    if (fromUrlContextMetadata != null) {
      setValueByPath(toObject, ["urlContextMetadata"], fromUrlContextMetadata);
    }
    return toObject;
  }
  function citationMetadataFromMldev$1(fromObject) {
    const toObject = {};
    const fromCitations = getValueByPath(fromObject, ["citationSources"]);
    if (fromCitations != null) {
      let transformedList = fromCitations;
      if (Array.isArray(transformedList)) {
        transformedList = transformedList.map((item) => {
          return item;
        });
      }
      setValueByPath(toObject, ["citations"], transformedList);
    }
    return toObject;
  }
  function contentToMldev$4(fromObject) {
    const toObject = {};
    const fromParts = getValueByPath(fromObject, ["parts"]);
    if (fromParts != null) {
      let transformedList = fromParts;
      if (Array.isArray(transformedList)) {
        transformedList = transformedList.map((item) => {
          return partToMldev$4(item);
        });
      }
      setValueByPath(toObject, ["parts"], transformedList);
    }
    const fromRole = getValueByPath(fromObject, ["role"]);
    if (fromRole != null) {
      setValueByPath(toObject, ["role"], fromRole);
    }
    return toObject;
  }
  function createBatchJobConfigToMldev(fromObject, parentObject) {
    const toObject = {};
    const fromDisplayName = getValueByPath(fromObject, ["displayName"]);
    if (parentObject !== void 0 && fromDisplayName != null) {
      setValueByPath(parentObject, ["batch", "displayName"], fromDisplayName);
    }
    if (getValueByPath(fromObject, ["dest"]) !== void 0) {
      throw new Error("dest parameter is not supported in Gemini API.");
    }
    return toObject;
  }
  function createBatchJobConfigToVertex(fromObject, parentObject) {
    const toObject = {};
    const fromDisplayName = getValueByPath(fromObject, ["displayName"]);
    if (parentObject !== void 0 && fromDisplayName != null) {
      setValueByPath(parentObject, ["displayName"], fromDisplayName);
    }
    const fromDest = getValueByPath(fromObject, ["dest"]);
    if (parentObject !== void 0 && fromDest != null) {
      setValueByPath(parentObject, ["outputConfig"], batchJobDestinationToVertex(tBatchJobDestination(fromDest)));
    }
    return toObject;
  }
  function createBatchJobParametersToMldev(apiClient, fromObject) {
    const toObject = {};
    const fromModel = getValueByPath(fromObject, ["model"]);
    if (fromModel != null) {
      setValueByPath(toObject, ["_url", "model"], tModel(apiClient, fromModel));
    }
    const fromSrc = getValueByPath(fromObject, ["src"]);
    if (fromSrc != null) {
      setValueByPath(toObject, ["batch", "inputConfig"], batchJobSourceToMldev(apiClient, tBatchJobSource(apiClient, fromSrc)));
    }
    const fromConfig = getValueByPath(fromObject, ["config"]);
    if (fromConfig != null) {
      createBatchJobConfigToMldev(fromConfig, toObject);
    }
    return toObject;
  }
  function createBatchJobParametersToVertex(apiClient, fromObject) {
    const toObject = {};
    const fromModel = getValueByPath(fromObject, ["model"]);
    if (fromModel != null) {
      setValueByPath(toObject, ["model"], tModel(apiClient, fromModel));
    }
    const fromSrc = getValueByPath(fromObject, ["src"]);
    if (fromSrc != null) {
      setValueByPath(toObject, ["inputConfig"], batchJobSourceToVertex(tBatchJobSource(apiClient, fromSrc)));
    }
    const fromConfig = getValueByPath(fromObject, ["config"]);
    if (fromConfig != null) {
      createBatchJobConfigToVertex(fromConfig, toObject);
    }
    return toObject;
  }
  function createEmbeddingsBatchJobConfigToMldev(fromObject, parentObject) {
    const toObject = {};
    const fromDisplayName = getValueByPath(fromObject, ["displayName"]);
    if (parentObject !== void 0 && fromDisplayName != null) {
      setValueByPath(parentObject, ["batch", "displayName"], fromDisplayName);
    }
    return toObject;
  }
  function createEmbeddingsBatchJobParametersToMldev(apiClient, fromObject) {
    const toObject = {};
    const fromModel = getValueByPath(fromObject, ["model"]);
    if (fromModel != null) {
      setValueByPath(toObject, ["_url", "model"], tModel(apiClient, fromModel));
    }
    const fromSrc = getValueByPath(fromObject, ["src"]);
    if (fromSrc != null) {
      setValueByPath(toObject, ["batch", "inputConfig"], embeddingsBatchJobSourceToMldev(apiClient, fromSrc));
    }
    const fromConfig = getValueByPath(fromObject, ["config"]);
    if (fromConfig != null) {
      createEmbeddingsBatchJobConfigToMldev(fromConfig, toObject);
    }
    return toObject;
  }
  function deleteBatchJobParametersToMldev(apiClient, fromObject) {
    const toObject = {};
    const fromName = getValueByPath(fromObject, ["name"]);
    if (fromName != null) {
      setValueByPath(toObject, ["_url", "name"], tBatchJobName(apiClient, fromName));
    }
    return toObject;
  }
  function deleteBatchJobParametersToVertex(apiClient, fromObject) {
    const toObject = {};
    const fromName = getValueByPath(fromObject, ["name"]);
    if (fromName != null) {
      setValueByPath(toObject, ["_url", "name"], tBatchJobName(apiClient, fromName));
    }
    return toObject;
  }
  function deleteResourceJobFromMldev(fromObject) {
    const toObject = {};
    const fromSdkHttpResponse = getValueByPath(fromObject, [
      "sdkHttpResponse"
    ]);
    if (fromSdkHttpResponse != null) {
      setValueByPath(toObject, ["sdkHttpResponse"], fromSdkHttpResponse);
    }
    const fromName = getValueByPath(fromObject, ["name"]);
    if (fromName != null) {
      setValueByPath(toObject, ["name"], fromName);
    }
    const fromDone = getValueByPath(fromObject, ["done"]);
    if (fromDone != null) {
      setValueByPath(toObject, ["done"], fromDone);
    }
    const fromError = getValueByPath(fromObject, ["error"]);
    if (fromError != null) {
      setValueByPath(toObject, ["error"], fromError);
    }
    return toObject;
  }
  function deleteResourceJobFromVertex(fromObject) {
    const toObject = {};
    const fromSdkHttpResponse = getValueByPath(fromObject, [
      "sdkHttpResponse"
    ]);
    if (fromSdkHttpResponse != null) {
      setValueByPath(toObject, ["sdkHttpResponse"], fromSdkHttpResponse);
    }
    const fromName = getValueByPath(fromObject, ["name"]);
    if (fromName != null) {
      setValueByPath(toObject, ["name"], fromName);
    }
    const fromDone = getValueByPath(fromObject, ["done"]);
    if (fromDone != null) {
      setValueByPath(toObject, ["done"], fromDone);
    }
    const fromError = getValueByPath(fromObject, ["error"]);
    if (fromError != null) {
      setValueByPath(toObject, ["error"], fromError);
    }
    return toObject;
  }
  function embedContentBatchToMldev(apiClient, fromObject) {
    const toObject = {};
    const fromContents = getValueByPath(fromObject, ["contents"]);
    if (fromContents != null) {
      let transformedList = tContentsForEmbed(apiClient, fromContents);
      if (Array.isArray(transformedList)) {
        transformedList = transformedList.map((item) => {
          return item;
        });
      }
      setValueByPath(toObject, ["requests[]", "request", "content"], transformedList);
    }
    const fromConfig = getValueByPath(fromObject, ["config"]);
    if (fromConfig != null) {
      setValueByPath(toObject, ["_self"], embedContentConfigToMldev$1(fromConfig, toObject));
      moveValueByPath(toObject, { "requests[].*": "requests[].request.*" });
    }
    return toObject;
  }
  function embedContentConfigToMldev$1(fromObject, parentObject) {
    const toObject = {};
    const fromTaskType = getValueByPath(fromObject, ["taskType"]);
    if (parentObject !== void 0 && fromTaskType != null) {
      setValueByPath(parentObject, ["requests[]", "taskType"], fromTaskType);
    }
    const fromTitle = getValueByPath(fromObject, ["title"]);
    if (parentObject !== void 0 && fromTitle != null) {
      setValueByPath(parentObject, ["requests[]", "title"], fromTitle);
    }
    const fromOutputDimensionality = getValueByPath(fromObject, [
      "outputDimensionality"
    ]);
    if (parentObject !== void 0 && fromOutputDimensionality != null) {
      setValueByPath(parentObject, ["requests[]", "outputDimensionality"], fromOutputDimensionality);
    }
    if (getValueByPath(fromObject, ["mimeType"]) !== void 0) {
      throw new Error("mimeType parameter is not supported in Gemini API.");
    }
    if (getValueByPath(fromObject, ["autoTruncate"]) !== void 0) {
      throw new Error("autoTruncate parameter is not supported in Gemini API.");
    }
    return toObject;
  }
  function embeddingsBatchJobSourceToMldev(apiClient, fromObject) {
    const toObject = {};
    const fromFileName = getValueByPath(fromObject, ["fileName"]);
    if (fromFileName != null) {
      setValueByPath(toObject, ["file_name"], fromFileName);
    }
    const fromInlinedRequests = getValueByPath(fromObject, [
      "inlinedRequests"
    ]);
    if (fromInlinedRequests != null) {
      setValueByPath(toObject, ["requests"], embedContentBatchToMldev(apiClient, fromInlinedRequests));
    }
    return toObject;
  }
  function fileDataToMldev$4(fromObject) {
    const toObject = {};
    if (getValueByPath(fromObject, ["displayName"]) !== void 0) {
      throw new Error("displayName parameter is not supported in Gemini API.");
    }
    const fromFileUri = getValueByPath(fromObject, ["fileUri"]);
    if (fromFileUri != null) {
      setValueByPath(toObject, ["fileUri"], fromFileUri);
    }
    const fromMimeType = getValueByPath(fromObject, ["mimeType"]);
    if (fromMimeType != null) {
      setValueByPath(toObject, ["mimeType"], fromMimeType);
    }
    return toObject;
  }
  function functionCallToMldev$4(fromObject) {
    const toObject = {};
    const fromId = getValueByPath(fromObject, ["id"]);
    if (fromId != null) {
      setValueByPath(toObject, ["id"], fromId);
    }
    const fromArgs = getValueByPath(fromObject, ["args"]);
    if (fromArgs != null) {
      setValueByPath(toObject, ["args"], fromArgs);
    }
    const fromName = getValueByPath(fromObject, ["name"]);
    if (fromName != null) {
      setValueByPath(toObject, ["name"], fromName);
    }
    if (getValueByPath(fromObject, ["partialArgs"]) !== void 0) {
      throw new Error("partialArgs parameter is not supported in Gemini API.");
    }
    if (getValueByPath(fromObject, ["willContinue"]) !== void 0) {
      throw new Error("willContinue parameter is not supported in Gemini API.");
    }
    return toObject;
  }
  function functionCallingConfigToMldev$2(fromObject) {
    const toObject = {};
    const fromMode = getValueByPath(fromObject, ["mode"]);
    if (fromMode != null) {
      setValueByPath(toObject, ["mode"], fromMode);
    }
    const fromAllowedFunctionNames = getValueByPath(fromObject, [
      "allowedFunctionNames"
    ]);
    if (fromAllowedFunctionNames != null) {
      setValueByPath(toObject, ["allowedFunctionNames"], fromAllowedFunctionNames);
    }
    if (getValueByPath(fromObject, ["streamFunctionCallArguments"]) !== void 0) {
      throw new Error("streamFunctionCallArguments parameter is not supported in Gemini API.");
    }
    return toObject;
  }
  function generateContentConfigToMldev$1(apiClient, fromObject, parentObject) {
    const toObject = {};
    const fromSystemInstruction = getValueByPath(fromObject, [
      "systemInstruction"
    ]);
    if (parentObject !== void 0 && fromSystemInstruction != null) {
      setValueByPath(parentObject, ["systemInstruction"], contentToMldev$4(tContent(fromSystemInstruction)));
    }
    const fromTemperature = getValueByPath(fromObject, ["temperature"]);
    if (fromTemperature != null) {
      setValueByPath(toObject, ["temperature"], fromTemperature);
    }
    const fromTopP = getValueByPath(fromObject, ["topP"]);
    if (fromTopP != null) {
      setValueByPath(toObject, ["topP"], fromTopP);
    }
    const fromTopK = getValueByPath(fromObject, ["topK"]);
    if (fromTopK != null) {
      setValueByPath(toObject, ["topK"], fromTopK);
    }
    const fromCandidateCount = getValueByPath(fromObject, [
      "candidateCount"
    ]);
    if (fromCandidateCount != null) {
      setValueByPath(toObject, ["candidateCount"], fromCandidateCount);
    }
    const fromMaxOutputTokens = getValueByPath(fromObject, [
      "maxOutputTokens"
    ]);
    if (fromMaxOutputTokens != null) {
      setValueByPath(toObject, ["maxOutputTokens"], fromMaxOutputTokens);
    }
    const fromStopSequences = getValueByPath(fromObject, [
      "stopSequences"
    ]);
    if (fromStopSequences != null) {
      setValueByPath(toObject, ["stopSequences"], fromStopSequences);
    }
    const fromResponseLogprobs = getValueByPath(fromObject, [
      "responseLogprobs"
    ]);
    if (fromResponseLogprobs != null) {
      setValueByPath(toObject, ["responseLogprobs"], fromResponseLogprobs);
    }
    const fromLogprobs = getValueByPath(fromObject, ["logprobs"]);
    if (fromLogprobs != null) {
      setValueByPath(toObject, ["logprobs"], fromLogprobs);
    }
    const fromPresencePenalty = getValueByPath(fromObject, [
      "presencePenalty"
    ]);
    if (fromPresencePenalty != null) {
      setValueByPath(toObject, ["presencePenalty"], fromPresencePenalty);
    }
    const fromFrequencyPenalty = getValueByPath(fromObject, [
      "frequencyPenalty"
    ]);
    if (fromFrequencyPenalty != null) {
      setValueByPath(toObject, ["frequencyPenalty"], fromFrequencyPenalty);
    }
    const fromSeed = getValueByPath(fromObject, ["seed"]);
    if (fromSeed != null) {
      setValueByPath(toObject, ["seed"], fromSeed);
    }
    const fromResponseMimeType = getValueByPath(fromObject, [
      "responseMimeType"
    ]);
    if (fromResponseMimeType != null) {
      setValueByPath(toObject, ["responseMimeType"], fromResponseMimeType);
    }
    const fromResponseSchema = getValueByPath(fromObject, [
      "responseSchema"
    ]);
    if (fromResponseSchema != null) {
      setValueByPath(toObject, ["responseSchema"], tSchema(fromResponseSchema));
    }
    const fromResponseJsonSchema = getValueByPath(fromObject, [
      "responseJsonSchema"
    ]);
    if (fromResponseJsonSchema != null) {
      setValueByPath(toObject, ["responseJsonSchema"], fromResponseJsonSchema);
    }
    if (getValueByPath(fromObject, ["routingConfig"]) !== void 0) {
      throw new Error("routingConfig parameter is not supported in Gemini API.");
    }
    if (getValueByPath(fromObject, ["modelSelectionConfig"]) !== void 0) {
      throw new Error("modelSelectionConfig parameter is not supported in Gemini API.");
    }
    const fromSafetySettings = getValueByPath(fromObject, [
      "safetySettings"
    ]);
    if (parentObject !== void 0 && fromSafetySettings != null) {
      let transformedList = fromSafetySettings;
      if (Array.isArray(transformedList)) {
        transformedList = transformedList.map((item) => {
          return safetySettingToMldev$1(item);
        });
      }
      setValueByPath(parentObject, ["safetySettings"], transformedList);
    }
    const fromTools = getValueByPath(fromObject, ["tools"]);
    if (parentObject !== void 0 && fromTools != null) {
      let transformedList = tTools(fromTools);
      if (Array.isArray(transformedList)) {
        transformedList = transformedList.map((item) => {
          return toolToMldev$4(tTool(item));
        });
      }
      setValueByPath(parentObject, ["tools"], transformedList);
    }
    const fromToolConfig = getValueByPath(fromObject, ["toolConfig"]);
    if (parentObject !== void 0 && fromToolConfig != null) {
      setValueByPath(parentObject, ["toolConfig"], toolConfigToMldev$2(fromToolConfig));
    }
    if (getValueByPath(fromObject, ["labels"]) !== void 0) {
      throw new Error("labels parameter is not supported in Gemini API.");
    }
    const fromCachedContent = getValueByPath(fromObject, [
      "cachedContent"
    ]);
    if (parentObject !== void 0 && fromCachedContent != null) {
      setValueByPath(parentObject, ["cachedContent"], tCachedContentName(apiClient, fromCachedContent));
    }
    const fromResponseModalities = getValueByPath(fromObject, [
      "responseModalities"
    ]);
    if (fromResponseModalities != null) {
      setValueByPath(toObject, ["responseModalities"], fromResponseModalities);
    }
    const fromMediaResolution = getValueByPath(fromObject, [
      "mediaResolution"
    ]);
    if (fromMediaResolution != null) {
      setValueByPath(toObject, ["mediaResolution"], fromMediaResolution);
    }
    const fromSpeechConfig = getValueByPath(fromObject, ["speechConfig"]);
    if (fromSpeechConfig != null) {
      setValueByPath(toObject, ["speechConfig"], tSpeechConfig(fromSpeechConfig));
    }
    if (getValueByPath(fromObject, ["audioTimestamp"]) !== void 0) {
      throw new Error("audioTimestamp parameter is not supported in Gemini API.");
    }
    const fromThinkingConfig = getValueByPath(fromObject, [
      "thinkingConfig"
    ]);
    if (fromThinkingConfig != null) {
      setValueByPath(toObject, ["thinkingConfig"], fromThinkingConfig);
    }
    const fromImageConfig = getValueByPath(fromObject, ["imageConfig"]);
    if (fromImageConfig != null) {
      setValueByPath(toObject, ["imageConfig"], imageConfigToMldev$1(fromImageConfig));
    }
    return toObject;
  }
  function generateContentResponseFromMldev$1(fromObject) {
    const toObject = {};
    const fromSdkHttpResponse = getValueByPath(fromObject, [
      "sdkHttpResponse"
    ]);
    if (fromSdkHttpResponse != null) {
      setValueByPath(toObject, ["sdkHttpResponse"], fromSdkHttpResponse);
    }
    const fromCandidates = getValueByPath(fromObject, ["candidates"]);
    if (fromCandidates != null) {
      let transformedList = fromCandidates;
      if (Array.isArray(transformedList)) {
        transformedList = transformedList.map((item) => {
          return candidateFromMldev$1(item);
        });
      }
      setValueByPath(toObject, ["candidates"], transformedList);
    }
    const fromModelVersion = getValueByPath(fromObject, ["modelVersion"]);
    if (fromModelVersion != null) {
      setValueByPath(toObject, ["modelVersion"], fromModelVersion);
    }
    const fromPromptFeedback = getValueByPath(fromObject, [
      "promptFeedback"
    ]);
    if (fromPromptFeedback != null) {
      setValueByPath(toObject, ["promptFeedback"], fromPromptFeedback);
    }
    const fromResponseId = getValueByPath(fromObject, ["responseId"]);
    if (fromResponseId != null) {
      setValueByPath(toObject, ["responseId"], fromResponseId);
    }
    const fromUsageMetadata = getValueByPath(fromObject, [
      "usageMetadata"
    ]);
    if (fromUsageMetadata != null) {
      setValueByPath(toObject, ["usageMetadata"], fromUsageMetadata);
    }
    return toObject;
  }
  function getBatchJobParametersToMldev(apiClient, fromObject) {
    const toObject = {};
    const fromName = getValueByPath(fromObject, ["name"]);
    if (fromName != null) {
      setValueByPath(toObject, ["_url", "name"], tBatchJobName(apiClient, fromName));
    }
    return toObject;
  }
  function getBatchJobParametersToVertex(apiClient, fromObject) {
    const toObject = {};
    const fromName = getValueByPath(fromObject, ["name"]);
    if (fromName != null) {
      setValueByPath(toObject, ["_url", "name"], tBatchJobName(apiClient, fromName));
    }
    return toObject;
  }
  function googleMapsToMldev$4(fromObject) {
    const toObject = {};
    if (getValueByPath(fromObject, ["authConfig"]) !== void 0) {
      throw new Error("authConfig parameter is not supported in Gemini API.");
    }
    const fromEnableWidget = getValueByPath(fromObject, ["enableWidget"]);
    if (fromEnableWidget != null) {
      setValueByPath(toObject, ["enableWidget"], fromEnableWidget);
    }
    return toObject;
  }
  function googleSearchToMldev$4(fromObject) {
    const toObject = {};
    if (getValueByPath(fromObject, ["excludeDomains"]) !== void 0) {
      throw new Error("excludeDomains parameter is not supported in Gemini API.");
    }
    if (getValueByPath(fromObject, ["blockingConfidence"]) !== void 0) {
      throw new Error("blockingConfidence parameter is not supported in Gemini API.");
    }
    const fromTimeRangeFilter = getValueByPath(fromObject, [
      "timeRangeFilter"
    ]);
    if (fromTimeRangeFilter != null) {
      setValueByPath(toObject, ["timeRangeFilter"], fromTimeRangeFilter);
    }
    return toObject;
  }
  function imageConfigToMldev$1(fromObject) {
    const toObject = {};
    const fromAspectRatio = getValueByPath(fromObject, ["aspectRatio"]);
    if (fromAspectRatio != null) {
      setValueByPath(toObject, ["aspectRatio"], fromAspectRatio);
    }
    const fromImageSize = getValueByPath(fromObject, ["imageSize"]);
    if (fromImageSize != null) {
      setValueByPath(toObject, ["imageSize"], fromImageSize);
    }
    if (getValueByPath(fromObject, ["outputMimeType"]) !== void 0) {
      throw new Error("outputMimeType parameter is not supported in Gemini API.");
    }
    if (getValueByPath(fromObject, ["outputCompressionQuality"]) !== void 0) {
      throw new Error("outputCompressionQuality parameter is not supported in Gemini API.");
    }
    return toObject;
  }
  function inlinedRequestToMldev(apiClient, fromObject) {
    const toObject = {};
    const fromModel = getValueByPath(fromObject, ["model"]);
    if (fromModel != null) {
      setValueByPath(toObject, ["request", "model"], tModel(apiClient, fromModel));
    }
    const fromContents = getValueByPath(fromObject, ["contents"]);
    if (fromContents != null) {
      let transformedList = tContents(fromContents);
      if (Array.isArray(transformedList)) {
        transformedList = transformedList.map((item) => {
          return contentToMldev$4(item);
        });
      }
      setValueByPath(toObject, ["request", "contents"], transformedList);
    }
    const fromMetadata = getValueByPath(fromObject, ["metadata"]);
    if (fromMetadata != null) {
      setValueByPath(toObject, ["metadata"], fromMetadata);
    }
    const fromConfig = getValueByPath(fromObject, ["config"]);
    if (fromConfig != null) {
      setValueByPath(toObject, ["request", "generationConfig"], generateContentConfigToMldev$1(apiClient, fromConfig, getValueByPath(toObject, ["request"], {})));
    }
    return toObject;
  }
  function inlinedResponseFromMldev(fromObject) {
    const toObject = {};
    const fromResponse = getValueByPath(fromObject, ["response"]);
    if (fromResponse != null) {
      setValueByPath(toObject, ["response"], generateContentResponseFromMldev$1(fromResponse));
    }
    const fromError = getValueByPath(fromObject, ["error"]);
    if (fromError != null) {
      setValueByPath(toObject, ["error"], fromError);
    }
    return toObject;
  }
  function listBatchJobsConfigToMldev(fromObject, parentObject) {
    const toObject = {};
    const fromPageSize = getValueByPath(fromObject, ["pageSize"]);
    if (parentObject !== void 0 && fromPageSize != null) {
      setValueByPath(parentObject, ["_query", "pageSize"], fromPageSize);
    }
    const fromPageToken = getValueByPath(fromObject, ["pageToken"]);
    if (parentObject !== void 0 && fromPageToken != null) {
      setValueByPath(parentObject, ["_query", "pageToken"], fromPageToken);
    }
    if (getValueByPath(fromObject, ["filter"]) !== void 0) {
      throw new Error("filter parameter is not supported in Gemini API.");
    }
    return toObject;
  }
  function listBatchJobsConfigToVertex(fromObject, parentObject) {
    const toObject = {};
    const fromPageSize = getValueByPath(fromObject, ["pageSize"]);
    if (parentObject !== void 0 && fromPageSize != null) {
      setValueByPath(parentObject, ["_query", "pageSize"], fromPageSize);
    }
    const fromPageToken = getValueByPath(fromObject, ["pageToken"]);
    if (parentObject !== void 0 && fromPageToken != null) {
      setValueByPath(parentObject, ["_query", "pageToken"], fromPageToken);
    }
    const fromFilter = getValueByPath(fromObject, ["filter"]);
    if (parentObject !== void 0 && fromFilter != null) {
      setValueByPath(parentObject, ["_query", "filter"], fromFilter);
    }
    return toObject;
  }
  function listBatchJobsParametersToMldev(fromObject) {
    const toObject = {};
    const fromConfig = getValueByPath(fromObject, ["config"]);
    if (fromConfig != null) {
      listBatchJobsConfigToMldev(fromConfig, toObject);
    }
    return toObject;
  }
  function listBatchJobsParametersToVertex(fromObject) {
    const toObject = {};
    const fromConfig = getValueByPath(fromObject, ["config"]);
    if (fromConfig != null) {
      listBatchJobsConfigToVertex(fromConfig, toObject);
    }
    return toObject;
  }
  function listBatchJobsResponseFromMldev(fromObject) {
    const toObject = {};
    const fromSdkHttpResponse = getValueByPath(fromObject, [
      "sdkHttpResponse"
    ]);
    if (fromSdkHttpResponse != null) {
      setValueByPath(toObject, ["sdkHttpResponse"], fromSdkHttpResponse);
    }
    const fromNextPageToken = getValueByPath(fromObject, [
      "nextPageToken"
    ]);
    if (fromNextPageToken != null) {
      setValueByPath(toObject, ["nextPageToken"], fromNextPageToken);
    }
    const fromBatchJobs = getValueByPath(fromObject, ["operations"]);
    if (fromBatchJobs != null) {
      let transformedList = fromBatchJobs;
      if (Array.isArray(transformedList)) {
        transformedList = transformedList.map((item) => {
          return batchJobFromMldev(item);
        });
      }
      setValueByPath(toObject, ["batchJobs"], transformedList);
    }
    return toObject;
  }
  function listBatchJobsResponseFromVertex(fromObject) {
    const toObject = {};
    const fromSdkHttpResponse = getValueByPath(fromObject, [
      "sdkHttpResponse"
    ]);
    if (fromSdkHttpResponse != null) {
      setValueByPath(toObject, ["sdkHttpResponse"], fromSdkHttpResponse);
    }
    const fromNextPageToken = getValueByPath(fromObject, [
      "nextPageToken"
    ]);
    if (fromNextPageToken != null) {
      setValueByPath(toObject, ["nextPageToken"], fromNextPageToken);
    }
    const fromBatchJobs = getValueByPath(fromObject, [
      "batchPredictionJobs"
    ]);
    if (fromBatchJobs != null) {
      let transformedList = fromBatchJobs;
      if (Array.isArray(transformedList)) {
        transformedList = transformedList.map((item) => {
          return batchJobFromVertex(item);
        });
      }
      setValueByPath(toObject, ["batchJobs"], transformedList);
    }
    return toObject;
  }
  function partToMldev$4(fromObject) {
    const toObject = {};
    const fromMediaResolution = getValueByPath(fromObject, [
      "mediaResolution"
    ]);
    if (fromMediaResolution != null) {
      setValueByPath(toObject, ["mediaResolution"], fromMediaResolution);
    }
    const fromCodeExecutionResult = getValueByPath(fromObject, [
      "codeExecutionResult"
    ]);
    if (fromCodeExecutionResult != null) {
      setValueByPath(toObject, ["codeExecutionResult"], fromCodeExecutionResult);
    }
    const fromExecutableCode = getValueByPath(fromObject, [
      "executableCode"
    ]);
    if (fromExecutableCode != null) {
      setValueByPath(toObject, ["executableCode"], fromExecutableCode);
    }
    const fromFileData = getValueByPath(fromObject, ["fileData"]);
    if (fromFileData != null) {
      setValueByPath(toObject, ["fileData"], fileDataToMldev$4(fromFileData));
    }
    const fromFunctionCall = getValueByPath(fromObject, ["functionCall"]);
    if (fromFunctionCall != null) {
      setValueByPath(toObject, ["functionCall"], functionCallToMldev$4(fromFunctionCall));
    }
    const fromFunctionResponse = getValueByPath(fromObject, [
      "functionResponse"
    ]);
    if (fromFunctionResponse != null) {
      setValueByPath(toObject, ["functionResponse"], fromFunctionResponse);
    }
    const fromInlineData = getValueByPath(fromObject, ["inlineData"]);
    if (fromInlineData != null) {
      setValueByPath(toObject, ["inlineData"], blobToMldev$4(fromInlineData));
    }
    const fromText = getValueByPath(fromObject, ["text"]);
    if (fromText != null) {
      setValueByPath(toObject, ["text"], fromText);
    }
    const fromThought = getValueByPath(fromObject, ["thought"]);
    if (fromThought != null) {
      setValueByPath(toObject, ["thought"], fromThought);
    }
    const fromThoughtSignature = getValueByPath(fromObject, [
      "thoughtSignature"
    ]);
    if (fromThoughtSignature != null) {
      setValueByPath(toObject, ["thoughtSignature"], fromThoughtSignature);
    }
    const fromVideoMetadata = getValueByPath(fromObject, [
      "videoMetadata"
    ]);
    if (fromVideoMetadata != null) {
      setValueByPath(toObject, ["videoMetadata"], fromVideoMetadata);
    }
    return toObject;
  }
  function safetySettingToMldev$1(fromObject) {
    const toObject = {};
    const fromCategory = getValueByPath(fromObject, ["category"]);
    if (fromCategory != null) {
      setValueByPath(toObject, ["category"], fromCategory);
    }
    if (getValueByPath(fromObject, ["method"]) !== void 0) {
      throw new Error("method parameter is not supported in Gemini API.");
    }
    const fromThreshold = getValueByPath(fromObject, ["threshold"]);
    if (fromThreshold != null) {
      setValueByPath(toObject, ["threshold"], fromThreshold);
    }
    return toObject;
  }
  function toolConfigToMldev$2(fromObject) {
    const toObject = {};
    const fromFunctionCallingConfig = getValueByPath(fromObject, [
      "functionCallingConfig"
    ]);
    if (fromFunctionCallingConfig != null) {
      setValueByPath(toObject, ["functionCallingConfig"], functionCallingConfigToMldev$2(fromFunctionCallingConfig));
    }
    const fromRetrievalConfig = getValueByPath(fromObject, [
      "retrievalConfig"
    ]);
    if (fromRetrievalConfig != null) {
      setValueByPath(toObject, ["retrievalConfig"], fromRetrievalConfig);
    }
    return toObject;
  }
  function toolToMldev$4(fromObject) {
    const toObject = {};
    const fromFunctionDeclarations = getValueByPath(fromObject, [
      "functionDeclarations"
    ]);
    if (fromFunctionDeclarations != null) {
      let transformedList = fromFunctionDeclarations;
      if (Array.isArray(transformedList)) {
        transformedList = transformedList.map((item) => {
          return item;
        });
      }
      setValueByPath(toObject, ["functionDeclarations"], transformedList);
    }
    if (getValueByPath(fromObject, ["retrieval"]) !== void 0) {
      throw new Error("retrieval parameter is not supported in Gemini API.");
    }
    const fromGoogleSearchRetrieval = getValueByPath(fromObject, [
      "googleSearchRetrieval"
    ]);
    if (fromGoogleSearchRetrieval != null) {
      setValueByPath(toObject, ["googleSearchRetrieval"], fromGoogleSearchRetrieval);
    }
    const fromComputerUse = getValueByPath(fromObject, ["computerUse"]);
    if (fromComputerUse != null) {
      setValueByPath(toObject, ["computerUse"], fromComputerUse);
    }
    const fromFileSearch = getValueByPath(fromObject, ["fileSearch"]);
    if (fromFileSearch != null) {
      setValueByPath(toObject, ["fileSearch"], fromFileSearch);
    }
    const fromCodeExecution = getValueByPath(fromObject, [
      "codeExecution"
    ]);
    if (fromCodeExecution != null) {
      setValueByPath(toObject, ["codeExecution"], fromCodeExecution);
    }
    if (getValueByPath(fromObject, ["enterpriseWebSearch"]) !== void 0) {
      throw new Error("enterpriseWebSearch parameter is not supported in Gemini API.");
    }
    const fromGoogleMaps = getValueByPath(fromObject, ["googleMaps"]);
    if (fromGoogleMaps != null) {
      setValueByPath(toObject, ["googleMaps"], googleMapsToMldev$4(fromGoogleMaps));
    }
    const fromGoogleSearch = getValueByPath(fromObject, ["googleSearch"]);
    if (fromGoogleSearch != null) {
      setValueByPath(toObject, ["googleSearch"], googleSearchToMldev$4(fromGoogleSearch));
    }
    const fromUrlContext = getValueByPath(fromObject, ["urlContext"]);
    if (fromUrlContext != null) {
      setValueByPath(toObject, ["urlContext"], fromUrlContext);
    }
    return toObject;
  }
  function blobToMldev$3(fromObject) {
    const toObject = {};
    const fromData = getValueByPath(fromObject, ["data"]);
    if (fromData != null) {
      setValueByPath(toObject, ["data"], fromData);
    }
    if (getValueByPath(fromObject, ["displayName"]) !== void 0) {
      throw new Error("displayName parameter is not supported in Gemini API.");
    }
    const fromMimeType = getValueByPath(fromObject, ["mimeType"]);
    if (fromMimeType != null) {
      setValueByPath(toObject, ["mimeType"], fromMimeType);
    }
    return toObject;
  }
  function contentToMldev$3(fromObject) {
    const toObject = {};
    const fromParts = getValueByPath(fromObject, ["parts"]);
    if (fromParts != null) {
      let transformedList = fromParts;
      if (Array.isArray(transformedList)) {
        transformedList = transformedList.map((item) => {
          return partToMldev$3(item);
        });
      }
      setValueByPath(toObject, ["parts"], transformedList);
    }
    const fromRole = getValueByPath(fromObject, ["role"]);
    if (fromRole != null) {
      setValueByPath(toObject, ["role"], fromRole);
    }
    return toObject;
  }
  function createCachedContentConfigToMldev(fromObject, parentObject) {
    const toObject = {};
    const fromTtl = getValueByPath(fromObject, ["ttl"]);
    if (parentObject !== void 0 && fromTtl != null) {
      setValueByPath(parentObject, ["ttl"], fromTtl);
    }
    const fromExpireTime = getValueByPath(fromObject, ["expireTime"]);
    if (parentObject !== void 0 && fromExpireTime != null) {
      setValueByPath(parentObject, ["expireTime"], fromExpireTime);
    }
    const fromDisplayName = getValueByPath(fromObject, ["displayName"]);
    if (parentObject !== void 0 && fromDisplayName != null) {
      setValueByPath(parentObject, ["displayName"], fromDisplayName);
    }
    const fromContents = getValueByPath(fromObject, ["contents"]);
    if (parentObject !== void 0 && fromContents != null) {
      let transformedList = tContents(fromContents);
      if (Array.isArray(transformedList)) {
        transformedList = transformedList.map((item) => {
          return contentToMldev$3(item);
        });
      }
      setValueByPath(parentObject, ["contents"], transformedList);
    }
    const fromSystemInstruction = getValueByPath(fromObject, [
      "systemInstruction"
    ]);
    if (parentObject !== void 0 && fromSystemInstruction != null) {
      setValueByPath(parentObject, ["systemInstruction"], contentToMldev$3(tContent(fromSystemInstruction)));
    }
    const fromTools = getValueByPath(fromObject, ["tools"]);
    if (parentObject !== void 0 && fromTools != null) {
      let transformedList = fromTools;
      if (Array.isArray(transformedList)) {
        transformedList = transformedList.map((item) => {
          return toolToMldev$3(item);
        });
      }
      setValueByPath(parentObject, ["tools"], transformedList);
    }
    const fromToolConfig = getValueByPath(fromObject, ["toolConfig"]);
    if (parentObject !== void 0 && fromToolConfig != null) {
      setValueByPath(parentObject, ["toolConfig"], toolConfigToMldev$1(fromToolConfig));
    }
    if (getValueByPath(fromObject, ["kmsKeyName"]) !== void 0) {
      throw new Error("kmsKeyName parameter is not supported in Gemini API.");
    }
    return toObject;
  }
  function createCachedContentConfigToVertex(fromObject, parentObject) {
    const toObject = {};
    const fromTtl = getValueByPath(fromObject, ["ttl"]);
    if (parentObject !== void 0 && fromTtl != null) {
      setValueByPath(parentObject, ["ttl"], fromTtl);
    }
    const fromExpireTime = getValueByPath(fromObject, ["expireTime"]);
    if (parentObject !== void 0 && fromExpireTime != null) {
      setValueByPath(parentObject, ["expireTime"], fromExpireTime);
    }
    const fromDisplayName = getValueByPath(fromObject, ["displayName"]);
    if (parentObject !== void 0 && fromDisplayName != null) {
      setValueByPath(parentObject, ["displayName"], fromDisplayName);
    }
    const fromContents = getValueByPath(fromObject, ["contents"]);
    if (parentObject !== void 0 && fromContents != null) {
      let transformedList = tContents(fromContents);
      if (Array.isArray(transformedList)) {
        transformedList = transformedList.map((item) => {
          return item;
        });
      }
      setValueByPath(parentObject, ["contents"], transformedList);
    }
    const fromSystemInstruction = getValueByPath(fromObject, [
      "systemInstruction"
    ]);
    if (parentObject !== void 0 && fromSystemInstruction != null) {
      setValueByPath(parentObject, ["systemInstruction"], tContent(fromSystemInstruction));
    }
    const fromTools = getValueByPath(fromObject, ["tools"]);
    if (parentObject !== void 0 && fromTools != null) {
      let transformedList = fromTools;
      if (Array.isArray(transformedList)) {
        transformedList = transformedList.map((item) => {
          return toolToVertex$2(item);
        });
      }
      setValueByPath(parentObject, ["tools"], transformedList);
    }
    const fromToolConfig = getValueByPath(fromObject, ["toolConfig"]);
    if (parentObject !== void 0 && fromToolConfig != null) {
      setValueByPath(parentObject, ["toolConfig"], fromToolConfig);
    }
    const fromKmsKeyName = getValueByPath(fromObject, ["kmsKeyName"]);
    if (parentObject !== void 0 && fromKmsKeyName != null) {
      setValueByPath(parentObject, ["encryption_spec", "kmsKeyName"], fromKmsKeyName);
    }
    return toObject;
  }
  function createCachedContentParametersToMldev(apiClient, fromObject) {
    const toObject = {};
    const fromModel = getValueByPath(fromObject, ["model"]);
    if (fromModel != null) {
      setValueByPath(toObject, ["model"], tCachesModel(apiClient, fromModel));
    }
    const fromConfig = getValueByPath(fromObject, ["config"]);
    if (fromConfig != null) {
      createCachedContentConfigToMldev(fromConfig, toObject);
    }
    return toObject;
  }
  function createCachedContentParametersToVertex(apiClient, fromObject) {
    const toObject = {};
    const fromModel = getValueByPath(fromObject, ["model"]);
    if (fromModel != null) {
      setValueByPath(toObject, ["model"], tCachesModel(apiClient, fromModel));
    }
    const fromConfig = getValueByPath(fromObject, ["config"]);
    if (fromConfig != null) {
      createCachedContentConfigToVertex(fromConfig, toObject);
    }
    return toObject;
  }
  function deleteCachedContentParametersToMldev(apiClient, fromObject) {
    const toObject = {};
    const fromName = getValueByPath(fromObject, ["name"]);
    if (fromName != null) {
      setValueByPath(toObject, ["_url", "name"], tCachedContentName(apiClient, fromName));
    }
    return toObject;
  }
  function deleteCachedContentParametersToVertex(apiClient, fromObject) {
    const toObject = {};
    const fromName = getValueByPath(fromObject, ["name"]);
    if (fromName != null) {
      setValueByPath(toObject, ["_url", "name"], tCachedContentName(apiClient, fromName));
    }
    return toObject;
  }
  function deleteCachedContentResponseFromMldev(fromObject) {
    const toObject = {};
    const fromSdkHttpResponse = getValueByPath(fromObject, [
      "sdkHttpResponse"
    ]);
    if (fromSdkHttpResponse != null) {
      setValueByPath(toObject, ["sdkHttpResponse"], fromSdkHttpResponse);
    }
    return toObject;
  }
  function deleteCachedContentResponseFromVertex(fromObject) {
    const toObject = {};
    const fromSdkHttpResponse = getValueByPath(fromObject, [
      "sdkHttpResponse"
    ]);
    if (fromSdkHttpResponse != null) {
      setValueByPath(toObject, ["sdkHttpResponse"], fromSdkHttpResponse);
    }
    return toObject;
  }
  function fileDataToMldev$3(fromObject) {
    const toObject = {};
    if (getValueByPath(fromObject, ["displayName"]) !== void 0) {
      throw new Error("displayName parameter is not supported in Gemini API.");
    }
    const fromFileUri = getValueByPath(fromObject, ["fileUri"]);
    if (fromFileUri != null) {
      setValueByPath(toObject, ["fileUri"], fromFileUri);
    }
    const fromMimeType = getValueByPath(fromObject, ["mimeType"]);
    if (fromMimeType != null) {
      setValueByPath(toObject, ["mimeType"], fromMimeType);
    }
    return toObject;
  }
  function functionCallToMldev$3(fromObject) {
    const toObject = {};
    const fromId = getValueByPath(fromObject, ["id"]);
    if (fromId != null) {
      setValueByPath(toObject, ["id"], fromId);
    }
    const fromArgs = getValueByPath(fromObject, ["args"]);
    if (fromArgs != null) {
      setValueByPath(toObject, ["args"], fromArgs);
    }
    const fromName = getValueByPath(fromObject, ["name"]);
    if (fromName != null) {
      setValueByPath(toObject, ["name"], fromName);
    }
    if (getValueByPath(fromObject, ["partialArgs"]) !== void 0) {
      throw new Error("partialArgs parameter is not supported in Gemini API.");
    }
    if (getValueByPath(fromObject, ["willContinue"]) !== void 0) {
      throw new Error("willContinue parameter is not supported in Gemini API.");
    }
    return toObject;
  }
  function functionCallingConfigToMldev$1(fromObject) {
    const toObject = {};
    const fromMode = getValueByPath(fromObject, ["mode"]);
    if (fromMode != null) {
      setValueByPath(toObject, ["mode"], fromMode);
    }
    const fromAllowedFunctionNames = getValueByPath(fromObject, [
      "allowedFunctionNames"
    ]);
    if (fromAllowedFunctionNames != null) {
      setValueByPath(toObject, ["allowedFunctionNames"], fromAllowedFunctionNames);
    }
    if (getValueByPath(fromObject, ["streamFunctionCallArguments"]) !== void 0) {
      throw new Error("streamFunctionCallArguments parameter is not supported in Gemini API.");
    }
    return toObject;
  }
  function functionDeclarationToVertex$2(fromObject) {
    const toObject = {};
    if (getValueByPath(fromObject, ["behavior"]) !== void 0) {
      throw new Error("behavior parameter is not supported in Vertex AI.");
    }
    const fromDescription = getValueByPath(fromObject, ["description"]);
    if (fromDescription != null) {
      setValueByPath(toObject, ["description"], fromDescription);
    }
    const fromName = getValueByPath(fromObject, ["name"]);
    if (fromName != null) {
      setValueByPath(toObject, ["name"], fromName);
    }
    const fromParameters = getValueByPath(fromObject, ["parameters"]);
    if (fromParameters != null) {
      setValueByPath(toObject, ["parameters"], fromParameters);
    }
    const fromParametersJsonSchema = getValueByPath(fromObject, [
      "parametersJsonSchema"
    ]);
    if (fromParametersJsonSchema != null) {
      setValueByPath(toObject, ["parametersJsonSchema"], fromParametersJsonSchema);
    }
    const fromResponse = getValueByPath(fromObject, ["response"]);
    if (fromResponse != null) {
      setValueByPath(toObject, ["response"], fromResponse);
    }
    const fromResponseJsonSchema = getValueByPath(fromObject, [
      "responseJsonSchema"
    ]);
    if (fromResponseJsonSchema != null) {
      setValueByPath(toObject, ["responseJsonSchema"], fromResponseJsonSchema);
    }
    return toObject;
  }
  function getCachedContentParametersToMldev(apiClient, fromObject) {
    const toObject = {};
    const fromName = getValueByPath(fromObject, ["name"]);
    if (fromName != null) {
      setValueByPath(toObject, ["_url", "name"], tCachedContentName(apiClient, fromName));
    }
    return toObject;
  }
  function getCachedContentParametersToVertex(apiClient, fromObject) {
    const toObject = {};
    const fromName = getValueByPath(fromObject, ["name"]);
    if (fromName != null) {
      setValueByPath(toObject, ["_url", "name"], tCachedContentName(apiClient, fromName));
    }
    return toObject;
  }
  function googleMapsToMldev$3(fromObject) {
    const toObject = {};
    if (getValueByPath(fromObject, ["authConfig"]) !== void 0) {
      throw new Error("authConfig parameter is not supported in Gemini API.");
    }
    const fromEnableWidget = getValueByPath(fromObject, ["enableWidget"]);
    if (fromEnableWidget != null) {
      setValueByPath(toObject, ["enableWidget"], fromEnableWidget);
    }
    return toObject;
  }
  function googleSearchToMldev$3(fromObject) {
    const toObject = {};
    if (getValueByPath(fromObject, ["excludeDomains"]) !== void 0) {
      throw new Error("excludeDomains parameter is not supported in Gemini API.");
    }
    if (getValueByPath(fromObject, ["blockingConfidence"]) !== void 0) {
      throw new Error("blockingConfidence parameter is not supported in Gemini API.");
    }
    const fromTimeRangeFilter = getValueByPath(fromObject, [
      "timeRangeFilter"
    ]);
    if (fromTimeRangeFilter != null) {
      setValueByPath(toObject, ["timeRangeFilter"], fromTimeRangeFilter);
    }
    return toObject;
  }
  function listCachedContentsConfigToMldev(fromObject, parentObject) {
    const toObject = {};
    const fromPageSize = getValueByPath(fromObject, ["pageSize"]);
    if (parentObject !== void 0 && fromPageSize != null) {
      setValueByPath(parentObject, ["_query", "pageSize"], fromPageSize);
    }
    const fromPageToken = getValueByPath(fromObject, ["pageToken"]);
    if (parentObject !== void 0 && fromPageToken != null) {
      setValueByPath(parentObject, ["_query", "pageToken"], fromPageToken);
    }
    return toObject;
  }
  function listCachedContentsConfigToVertex(fromObject, parentObject) {
    const toObject = {};
    const fromPageSize = getValueByPath(fromObject, ["pageSize"]);
    if (parentObject !== void 0 && fromPageSize != null) {
      setValueByPath(parentObject, ["_query", "pageSize"], fromPageSize);
    }
    const fromPageToken = getValueByPath(fromObject, ["pageToken"]);
    if (parentObject !== void 0 && fromPageToken != null) {
      setValueByPath(parentObject, ["_query", "pageToken"], fromPageToken);
    }
    return toObject;
  }
  function listCachedContentsParametersToMldev(fromObject) {
    const toObject = {};
    const fromConfig = getValueByPath(fromObject, ["config"]);
    if (fromConfig != null) {
      listCachedContentsConfigToMldev(fromConfig, toObject);
    }
    return toObject;
  }
  function listCachedContentsParametersToVertex(fromObject) {
    const toObject = {};
    const fromConfig = getValueByPath(fromObject, ["config"]);
    if (fromConfig != null) {
      listCachedContentsConfigToVertex(fromConfig, toObject);
    }
    return toObject;
  }
  function listCachedContentsResponseFromMldev(fromObject) {
    const toObject = {};
    const fromSdkHttpResponse = getValueByPath(fromObject, [
      "sdkHttpResponse"
    ]);
    if (fromSdkHttpResponse != null) {
      setValueByPath(toObject, ["sdkHttpResponse"], fromSdkHttpResponse);
    }
    const fromNextPageToken = getValueByPath(fromObject, [
      "nextPageToken"
    ]);
    if (fromNextPageToken != null) {
      setValueByPath(toObject, ["nextPageToken"], fromNextPageToken);
    }
    const fromCachedContents = getValueByPath(fromObject, [
      "cachedContents"
    ]);
    if (fromCachedContents != null) {
      let transformedList = fromCachedContents;
      if (Array.isArray(transformedList)) {
        transformedList = transformedList.map((item) => {
          return item;
        });
      }
      setValueByPath(toObject, ["cachedContents"], transformedList);
    }
    return toObject;
  }
  function listCachedContentsResponseFromVertex(fromObject) {
    const toObject = {};
    const fromSdkHttpResponse = getValueByPath(fromObject, [
      "sdkHttpResponse"
    ]);
    if (fromSdkHttpResponse != null) {
      setValueByPath(toObject, ["sdkHttpResponse"], fromSdkHttpResponse);
    }
    const fromNextPageToken = getValueByPath(fromObject, [
      "nextPageToken"
    ]);
    if (fromNextPageToken != null) {
      setValueByPath(toObject, ["nextPageToken"], fromNextPageToken);
    }
    const fromCachedContents = getValueByPath(fromObject, [
      "cachedContents"
    ]);
    if (fromCachedContents != null) {
      let transformedList = fromCachedContents;
      if (Array.isArray(transformedList)) {
        transformedList = transformedList.map((item) => {
          return item;
        });
      }
      setValueByPath(toObject, ["cachedContents"], transformedList);
    }
    return toObject;
  }
  function partToMldev$3(fromObject) {
    const toObject = {};
    const fromMediaResolution = getValueByPath(fromObject, [
      "mediaResolution"
    ]);
    if (fromMediaResolution != null) {
      setValueByPath(toObject, ["mediaResolution"], fromMediaResolution);
    }
    const fromCodeExecutionResult = getValueByPath(fromObject, [
      "codeExecutionResult"
    ]);
    if (fromCodeExecutionResult != null) {
      setValueByPath(toObject, ["codeExecutionResult"], fromCodeExecutionResult);
    }
    const fromExecutableCode = getValueByPath(fromObject, [
      "executableCode"
    ]);
    if (fromExecutableCode != null) {
      setValueByPath(toObject, ["executableCode"], fromExecutableCode);
    }
    const fromFileData = getValueByPath(fromObject, ["fileData"]);
    if (fromFileData != null) {
      setValueByPath(toObject, ["fileData"], fileDataToMldev$3(fromFileData));
    }
    const fromFunctionCall = getValueByPath(fromObject, ["functionCall"]);
    if (fromFunctionCall != null) {
      setValueByPath(toObject, ["functionCall"], functionCallToMldev$3(fromFunctionCall));
    }
    const fromFunctionResponse = getValueByPath(fromObject, [
      "functionResponse"
    ]);
    if (fromFunctionResponse != null) {
      setValueByPath(toObject, ["functionResponse"], fromFunctionResponse);
    }
    const fromInlineData = getValueByPath(fromObject, ["inlineData"]);
    if (fromInlineData != null) {
      setValueByPath(toObject, ["inlineData"], blobToMldev$3(fromInlineData));
    }
    const fromText = getValueByPath(fromObject, ["text"]);
    if (fromText != null) {
      setValueByPath(toObject, ["text"], fromText);
    }
    const fromThought = getValueByPath(fromObject, ["thought"]);
    if (fromThought != null) {
      setValueByPath(toObject, ["thought"], fromThought);
    }
    const fromThoughtSignature = getValueByPath(fromObject, [
      "thoughtSignature"
    ]);
    if (fromThoughtSignature != null) {
      setValueByPath(toObject, ["thoughtSignature"], fromThoughtSignature);
    }
    const fromVideoMetadata = getValueByPath(fromObject, [
      "videoMetadata"
    ]);
    if (fromVideoMetadata != null) {
      setValueByPath(toObject, ["videoMetadata"], fromVideoMetadata);
    }
    return toObject;
  }
  function toolConfigToMldev$1(fromObject) {
    const toObject = {};
    const fromFunctionCallingConfig = getValueByPath(fromObject, [
      "functionCallingConfig"
    ]);
    if (fromFunctionCallingConfig != null) {
      setValueByPath(toObject, ["functionCallingConfig"], functionCallingConfigToMldev$1(fromFunctionCallingConfig));
    }
    const fromRetrievalConfig = getValueByPath(fromObject, [
      "retrievalConfig"
    ]);
    if (fromRetrievalConfig != null) {
      setValueByPath(toObject, ["retrievalConfig"], fromRetrievalConfig);
    }
    return toObject;
  }
  function toolToMldev$3(fromObject) {
    const toObject = {};
    const fromFunctionDeclarations = getValueByPath(fromObject, [
      "functionDeclarations"
    ]);
    if (fromFunctionDeclarations != null) {
      let transformedList = fromFunctionDeclarations;
      if (Array.isArray(transformedList)) {
        transformedList = transformedList.map((item) => {
          return item;
        });
      }
      setValueByPath(toObject, ["functionDeclarations"], transformedList);
    }
    if (getValueByPath(fromObject, ["retrieval"]) !== void 0) {
      throw new Error("retrieval parameter is not supported in Gemini API.");
    }
    const fromGoogleSearchRetrieval = getValueByPath(fromObject, [
      "googleSearchRetrieval"
    ]);
    if (fromGoogleSearchRetrieval != null) {
      setValueByPath(toObject, ["googleSearchRetrieval"], fromGoogleSearchRetrieval);
    }
    const fromComputerUse = getValueByPath(fromObject, ["computerUse"]);
    if (fromComputerUse != null) {
      setValueByPath(toObject, ["computerUse"], fromComputerUse);
    }
    const fromFileSearch = getValueByPath(fromObject, ["fileSearch"]);
    if (fromFileSearch != null) {
      setValueByPath(toObject, ["fileSearch"], fromFileSearch);
    }
    const fromCodeExecution = getValueByPath(fromObject, [
      "codeExecution"
    ]);
    if (fromCodeExecution != null) {
      setValueByPath(toObject, ["codeExecution"], fromCodeExecution);
    }
    if (getValueByPath(fromObject, ["enterpriseWebSearch"]) !== void 0) {
      throw new Error("enterpriseWebSearch parameter is not supported in Gemini API.");
    }
    const fromGoogleMaps = getValueByPath(fromObject, ["googleMaps"]);
    if (fromGoogleMaps != null) {
      setValueByPath(toObject, ["googleMaps"], googleMapsToMldev$3(fromGoogleMaps));
    }
    const fromGoogleSearch = getValueByPath(fromObject, ["googleSearch"]);
    if (fromGoogleSearch != null) {
      setValueByPath(toObject, ["googleSearch"], googleSearchToMldev$3(fromGoogleSearch));
    }
    const fromUrlContext = getValueByPath(fromObject, ["urlContext"]);
    if (fromUrlContext != null) {
      setValueByPath(toObject, ["urlContext"], fromUrlContext);
    }
    return toObject;
  }
  function toolToVertex$2(fromObject) {
    const toObject = {};
    const fromFunctionDeclarations = getValueByPath(fromObject, [
      "functionDeclarations"
    ]);
    if (fromFunctionDeclarations != null) {
      let transformedList = fromFunctionDeclarations;
      if (Array.isArray(transformedList)) {
        transformedList = transformedList.map((item) => {
          return functionDeclarationToVertex$2(item);
        });
      }
      setValueByPath(toObject, ["functionDeclarations"], transformedList);
    }
    const fromRetrieval = getValueByPath(fromObject, ["retrieval"]);
    if (fromRetrieval != null) {
      setValueByPath(toObject, ["retrieval"], fromRetrieval);
    }
    const fromGoogleSearchRetrieval = getValueByPath(fromObject, [
      "googleSearchRetrieval"
    ]);
    if (fromGoogleSearchRetrieval != null) {
      setValueByPath(toObject, ["googleSearchRetrieval"], fromGoogleSearchRetrieval);
    }
    const fromComputerUse = getValueByPath(fromObject, ["computerUse"]);
    if (fromComputerUse != null) {
      setValueByPath(toObject, ["computerUse"], fromComputerUse);
    }
    if (getValueByPath(fromObject, ["fileSearch"]) !== void 0) {
      throw new Error("fileSearch parameter is not supported in Vertex AI.");
    }
    const fromCodeExecution = getValueByPath(fromObject, [
      "codeExecution"
    ]);
    if (fromCodeExecution != null) {
      setValueByPath(toObject, ["codeExecution"], fromCodeExecution);
    }
    const fromEnterpriseWebSearch = getValueByPath(fromObject, [
      "enterpriseWebSearch"
    ]);
    if (fromEnterpriseWebSearch != null) {
      setValueByPath(toObject, ["enterpriseWebSearch"], fromEnterpriseWebSearch);
    }
    const fromGoogleMaps = getValueByPath(fromObject, ["googleMaps"]);
    if (fromGoogleMaps != null) {
      setValueByPath(toObject, ["googleMaps"], fromGoogleMaps);
    }
    const fromGoogleSearch = getValueByPath(fromObject, ["googleSearch"]);
    if (fromGoogleSearch != null) {
      setValueByPath(toObject, ["googleSearch"], fromGoogleSearch);
    }
    const fromUrlContext = getValueByPath(fromObject, ["urlContext"]);
    if (fromUrlContext != null) {
      setValueByPath(toObject, ["urlContext"], fromUrlContext);
    }
    return toObject;
  }
  function updateCachedContentConfigToMldev(fromObject, parentObject) {
    const toObject = {};
    const fromTtl = getValueByPath(fromObject, ["ttl"]);
    if (parentObject !== void 0 && fromTtl != null) {
      setValueByPath(parentObject, ["ttl"], fromTtl);
    }
    const fromExpireTime = getValueByPath(fromObject, ["expireTime"]);
    if (parentObject !== void 0 && fromExpireTime != null) {
      setValueByPath(parentObject, ["expireTime"], fromExpireTime);
    }
    return toObject;
  }
  function updateCachedContentConfigToVertex(fromObject, parentObject) {
    const toObject = {};
    const fromTtl = getValueByPath(fromObject, ["ttl"]);
    if (parentObject !== void 0 && fromTtl != null) {
      setValueByPath(parentObject, ["ttl"], fromTtl);
    }
    const fromExpireTime = getValueByPath(fromObject, ["expireTime"]);
    if (parentObject !== void 0 && fromExpireTime != null) {
      setValueByPath(parentObject, ["expireTime"], fromExpireTime);
    }
    return toObject;
  }
  function updateCachedContentParametersToMldev(apiClient, fromObject) {
    const toObject = {};
    const fromName = getValueByPath(fromObject, ["name"]);
    if (fromName != null) {
      setValueByPath(toObject, ["_url", "name"], tCachedContentName(apiClient, fromName));
    }
    const fromConfig = getValueByPath(fromObject, ["config"]);
    if (fromConfig != null) {
      updateCachedContentConfigToMldev(fromConfig, toObject);
    }
    return toObject;
  }
  function updateCachedContentParametersToVertex(apiClient, fromObject) {
    const toObject = {};
    const fromName = getValueByPath(fromObject, ["name"]);
    if (fromName != null) {
      setValueByPath(toObject, ["_url", "name"], tCachedContentName(apiClient, fromName));
    }
    const fromConfig = getValueByPath(fromObject, ["config"]);
    if (fromConfig != null) {
      updateCachedContentConfigToVertex(fromConfig, toObject);
    }
    return toObject;
  }
  function __values(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m)
      return m.call(o);
    if (o && typeof o.length === "number")
      return {
        next: function() {
          if (o && i >= o.length)
            o = void 0;
          return { value: o && o[i++], done: !o };
        }
      };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
  }
  function __await(v) {
    return this instanceof __await ? (this.v = v, this) : new __await(v);
  }
  function __asyncGenerator(thisArg, _arguments, generator) {
    if (!Symbol.asyncIterator)
      throw new TypeError("Symbol.asyncIterator is not defined.");
    var g = generator.apply(thisArg, _arguments || []), i, q = [];
    return i = Object.create((typeof AsyncIterator === "function" ? AsyncIterator : Object).prototype), verb("next"), verb("throw"), verb("return", awaitReturn), i[Symbol.asyncIterator] = function() {
      return this;
    }, i;
    function awaitReturn(f) {
      return function(v) {
        return Promise.resolve(v).then(f, reject);
      };
    }
    function verb(n, f) {
      if (g[n]) {
        i[n] = function(v) {
          return new Promise(function(a, b) {
            q.push([n, v, a, b]) > 1 || resume(n, v);
          });
        };
        if (f)
          i[n] = f(i[n]);
      }
    }
    function resume(n, v) {
      try {
        step(g[n](v));
      } catch (e) {
        settle(q[0][3], e);
      }
    }
    function step(r) {
      r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
    }
    function fulfill(value) {
      resume("next", value);
    }
    function reject(value) {
      resume("throw", value);
    }
    function settle(f, v) {
      if (f(v), q.shift(), q.length)
        resume(q[0][0], q[0][1]);
    }
  }
  function __asyncValues(o) {
    if (!Symbol.asyncIterator)
      throw new TypeError("Symbol.asyncIterator is not defined.");
    var m = o[Symbol.asyncIterator], i;
    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
      return this;
    }, i);
    function verb(n) {
      i[n] = o[n] && function(v) {
        return new Promise(function(resolve, reject) {
          v = o[n](v), settle(resolve, reject, v.done, v.value);
        });
      };
    }
    function settle(resolve, reject, d, v) {
      Promise.resolve(v).then(function(v2) {
        resolve({ value: v2, done: d });
      }, reject);
    }
  }
  function isValidResponse(response) {
    var _a;
    if (response.candidates == void 0 || response.candidates.length === 0) {
      return false;
    }
    const content = (_a = response.candidates[0]) === null || _a === void 0 ? void 0 : _a.content;
    if (content === void 0) {
      return false;
    }
    return isValidContent(content);
  }
  function isValidContent(content) {
    if (content.parts === void 0 || content.parts.length === 0) {
      return false;
    }
    for (const part of content.parts) {
      if (part === void 0 || Object.keys(part).length === 0) {
        return false;
      }
    }
    return true;
  }
  function validateHistory(history) {
    if (history.length === 0) {
      return;
    }
    for (const content of history) {
      if (content.role !== "user" && content.role !== "model") {
        throw new Error(`Role must be user or model, but got ${content.role}.`);
      }
    }
  }
  function extractCuratedHistory(comprehensiveHistory) {
    if (comprehensiveHistory === void 0 || comprehensiveHistory.length === 0) {
      return [];
    }
    const curatedHistory = [];
    const length = comprehensiveHistory.length;
    let i = 0;
    while (i < length) {
      if (comprehensiveHistory[i].role === "user") {
        curatedHistory.push(comprehensiveHistory[i]);
        i++;
      } else {
        const modelOutput = [];
        let isValid = true;
        while (i < length && comprehensiveHistory[i].role === "model") {
          modelOutput.push(comprehensiveHistory[i]);
          if (isValid && !isValidContent(comprehensiveHistory[i])) {
            isValid = false;
          }
          i++;
        }
        if (isValid) {
          curatedHistory.push(...modelOutput);
        } else {
          curatedHistory.pop();
        }
      }
    }
    return curatedHistory;
  }
  function createFileParametersToMldev(fromObject) {
    const toObject = {};
    const fromFile = getValueByPath(fromObject, ["file"]);
    if (fromFile != null) {
      setValueByPath(toObject, ["file"], fromFile);
    }
    return toObject;
  }
  function createFileResponseFromMldev(fromObject) {
    const toObject = {};
    const fromSdkHttpResponse = getValueByPath(fromObject, [
      "sdkHttpResponse"
    ]);
    if (fromSdkHttpResponse != null) {
      setValueByPath(toObject, ["sdkHttpResponse"], fromSdkHttpResponse);
    }
    return toObject;
  }
  function deleteFileParametersToMldev(fromObject) {
    const toObject = {};
    const fromName = getValueByPath(fromObject, ["name"]);
    if (fromName != null) {
      setValueByPath(toObject, ["_url", "file"], tFileName(fromName));
    }
    return toObject;
  }
  function deleteFileResponseFromMldev(fromObject) {
    const toObject = {};
    const fromSdkHttpResponse = getValueByPath(fromObject, [
      "sdkHttpResponse"
    ]);
    if (fromSdkHttpResponse != null) {
      setValueByPath(toObject, ["sdkHttpResponse"], fromSdkHttpResponse);
    }
    return toObject;
  }
  function getFileParametersToMldev(fromObject) {
    const toObject = {};
    const fromName = getValueByPath(fromObject, ["name"]);
    if (fromName != null) {
      setValueByPath(toObject, ["_url", "file"], tFileName(fromName));
    }
    return toObject;
  }
  function listFilesConfigToMldev(fromObject, parentObject) {
    const toObject = {};
    const fromPageSize = getValueByPath(fromObject, ["pageSize"]);
    if (parentObject !== void 0 && fromPageSize != null) {
      setValueByPath(parentObject, ["_query", "pageSize"], fromPageSize);
    }
    const fromPageToken = getValueByPath(fromObject, ["pageToken"]);
    if (parentObject !== void 0 && fromPageToken != null) {
      setValueByPath(parentObject, ["_query", "pageToken"], fromPageToken);
    }
    return toObject;
  }
  function listFilesParametersToMldev(fromObject) {
    const toObject = {};
    const fromConfig = getValueByPath(fromObject, ["config"]);
    if (fromConfig != null) {
      listFilesConfigToMldev(fromConfig, toObject);
    }
    return toObject;
  }
  function listFilesResponseFromMldev(fromObject) {
    const toObject = {};
    const fromSdkHttpResponse = getValueByPath(fromObject, [
      "sdkHttpResponse"
    ]);
    if (fromSdkHttpResponse != null) {
      setValueByPath(toObject, ["sdkHttpResponse"], fromSdkHttpResponse);
    }
    const fromNextPageToken = getValueByPath(fromObject, [
      "nextPageToken"
    ]);
    if (fromNextPageToken != null) {
      setValueByPath(toObject, ["nextPageToken"], fromNextPageToken);
    }
    const fromFiles = getValueByPath(fromObject, ["files"]);
    if (fromFiles != null) {
      let transformedList = fromFiles;
      if (Array.isArray(transformedList)) {
        transformedList = transformedList.map((item) => {
          return item;
        });
      }
      setValueByPath(toObject, ["files"], transformedList);
    }
    return toObject;
  }
  function blobToMldev$2(fromObject) {
    const toObject = {};
    const fromData = getValueByPath(fromObject, ["data"]);
    if (fromData != null) {
      setValueByPath(toObject, ["data"], fromData);
    }
    if (getValueByPath(fromObject, ["displayName"]) !== void 0) {
      throw new Error("displayName parameter is not supported in Gemini API.");
    }
    const fromMimeType = getValueByPath(fromObject, ["mimeType"]);
    if (fromMimeType != null) {
      setValueByPath(toObject, ["mimeType"], fromMimeType);
    }
    return toObject;
  }
  function contentToMldev$2(fromObject) {
    const toObject = {};
    const fromParts = getValueByPath(fromObject, ["parts"]);
    if (fromParts != null) {
      let transformedList = fromParts;
      if (Array.isArray(transformedList)) {
        transformedList = transformedList.map((item) => {
          return partToMldev$2(item);
        });
      }
      setValueByPath(toObject, ["parts"], transformedList);
    }
    const fromRole = getValueByPath(fromObject, ["role"]);
    if (fromRole != null) {
      setValueByPath(toObject, ["role"], fromRole);
    }
    return toObject;
  }
  function fileDataToMldev$2(fromObject) {
    const toObject = {};
    if (getValueByPath(fromObject, ["displayName"]) !== void 0) {
      throw new Error("displayName parameter is not supported in Gemini API.");
    }
    const fromFileUri = getValueByPath(fromObject, ["fileUri"]);
    if (fromFileUri != null) {
      setValueByPath(toObject, ["fileUri"], fromFileUri);
    }
    const fromMimeType = getValueByPath(fromObject, ["mimeType"]);
    if (fromMimeType != null) {
      setValueByPath(toObject, ["mimeType"], fromMimeType);
    }
    return toObject;
  }
  function functionCallToMldev$2(fromObject) {
    const toObject = {};
    const fromId = getValueByPath(fromObject, ["id"]);
    if (fromId != null) {
      setValueByPath(toObject, ["id"], fromId);
    }
    const fromArgs = getValueByPath(fromObject, ["args"]);
    if (fromArgs != null) {
      setValueByPath(toObject, ["args"], fromArgs);
    }
    const fromName = getValueByPath(fromObject, ["name"]);
    if (fromName != null) {
      setValueByPath(toObject, ["name"], fromName);
    }
    if (getValueByPath(fromObject, ["partialArgs"]) !== void 0) {
      throw new Error("partialArgs parameter is not supported in Gemini API.");
    }
    if (getValueByPath(fromObject, ["willContinue"]) !== void 0) {
      throw new Error("willContinue parameter is not supported in Gemini API.");
    }
    return toObject;
  }
  function functionDeclarationToVertex$1(fromObject) {
    const toObject = {};
    if (getValueByPath(fromObject, ["behavior"]) !== void 0) {
      throw new Error("behavior parameter is not supported in Vertex AI.");
    }
    const fromDescription = getValueByPath(fromObject, ["description"]);
    if (fromDescription != null) {
      setValueByPath(toObject, ["description"], fromDescription);
    }
    const fromName = getValueByPath(fromObject, ["name"]);
    if (fromName != null) {
      setValueByPath(toObject, ["name"], fromName);
    }
    const fromParameters = getValueByPath(fromObject, ["parameters"]);
    if (fromParameters != null) {
      setValueByPath(toObject, ["parameters"], fromParameters);
    }
    const fromParametersJsonSchema = getValueByPath(fromObject, [
      "parametersJsonSchema"
    ]);
    if (fromParametersJsonSchema != null) {
      setValueByPath(toObject, ["parametersJsonSchema"], fromParametersJsonSchema);
    }
    const fromResponse = getValueByPath(fromObject, ["response"]);
    if (fromResponse != null) {
      setValueByPath(toObject, ["response"], fromResponse);
    }
    const fromResponseJsonSchema = getValueByPath(fromObject, [
      "responseJsonSchema"
    ]);
    if (fromResponseJsonSchema != null) {
      setValueByPath(toObject, ["responseJsonSchema"], fromResponseJsonSchema);
    }
    return toObject;
  }
  function generationConfigToVertex$1(fromObject) {
    const toObject = {};
    const fromModelSelectionConfig = getValueByPath(fromObject, [
      "modelSelectionConfig"
    ]);
    if (fromModelSelectionConfig != null) {
      setValueByPath(toObject, ["modelConfig"], fromModelSelectionConfig);
    }
    const fromResponseJsonSchema = getValueByPath(fromObject, [
      "responseJsonSchema"
    ]);
    if (fromResponseJsonSchema != null) {
      setValueByPath(toObject, ["responseJsonSchema"], fromResponseJsonSchema);
    }
    const fromAudioTimestamp = getValueByPath(fromObject, [
      "audioTimestamp"
    ]);
    if (fromAudioTimestamp != null) {
      setValueByPath(toObject, ["audioTimestamp"], fromAudioTimestamp);
    }
    const fromCandidateCount = getValueByPath(fromObject, [
      "candidateCount"
    ]);
    if (fromCandidateCount != null) {
      setValueByPath(toObject, ["candidateCount"], fromCandidateCount);
    }
    const fromEnableAffectiveDialog = getValueByPath(fromObject, [
      "enableAffectiveDialog"
    ]);
    if (fromEnableAffectiveDialog != null) {
      setValueByPath(toObject, ["enableAffectiveDialog"], fromEnableAffectiveDialog);
    }
    const fromFrequencyPenalty = getValueByPath(fromObject, [
      "frequencyPenalty"
    ]);
    if (fromFrequencyPenalty != null) {
      setValueByPath(toObject, ["frequencyPenalty"], fromFrequencyPenalty);
    }
    const fromLogprobs = getValueByPath(fromObject, ["logprobs"]);
    if (fromLogprobs != null) {
      setValueByPath(toObject, ["logprobs"], fromLogprobs);
    }
    const fromMaxOutputTokens = getValueByPath(fromObject, [
      "maxOutputTokens"
    ]);
    if (fromMaxOutputTokens != null) {
      setValueByPath(toObject, ["maxOutputTokens"], fromMaxOutputTokens);
    }
    const fromMediaResolution = getValueByPath(fromObject, [
      "mediaResolution"
    ]);
    if (fromMediaResolution != null) {
      setValueByPath(toObject, ["mediaResolution"], fromMediaResolution);
    }
    const fromPresencePenalty = getValueByPath(fromObject, [
      "presencePenalty"
    ]);
    if (fromPresencePenalty != null) {
      setValueByPath(toObject, ["presencePenalty"], fromPresencePenalty);
    }
    const fromResponseLogprobs = getValueByPath(fromObject, [
      "responseLogprobs"
    ]);
    if (fromResponseLogprobs != null) {
      setValueByPath(toObject, ["responseLogprobs"], fromResponseLogprobs);
    }
    const fromResponseMimeType = getValueByPath(fromObject, [
      "responseMimeType"
    ]);
    if (fromResponseMimeType != null) {
      setValueByPath(toObject, ["responseMimeType"], fromResponseMimeType);
    }
    const fromResponseModalities = getValueByPath(fromObject, [
      "responseModalities"
    ]);
    if (fromResponseModalities != null) {
      setValueByPath(toObject, ["responseModalities"], fromResponseModalities);
    }
    const fromResponseSchema = getValueByPath(fromObject, [
      "responseSchema"
    ]);
    if (fromResponseSchema != null) {
      setValueByPath(toObject, ["responseSchema"], fromResponseSchema);
    }
    const fromRoutingConfig = getValueByPath(fromObject, [
      "routingConfig"
    ]);
    if (fromRoutingConfig != null) {
      setValueByPath(toObject, ["routingConfig"], fromRoutingConfig);
    }
    const fromSeed = getValueByPath(fromObject, ["seed"]);
    if (fromSeed != null) {
      setValueByPath(toObject, ["seed"], fromSeed);
    }
    const fromSpeechConfig = getValueByPath(fromObject, ["speechConfig"]);
    if (fromSpeechConfig != null) {
      setValueByPath(toObject, ["speechConfig"], speechConfigToVertex$1(fromSpeechConfig));
    }
    const fromStopSequences = getValueByPath(fromObject, [
      "stopSequences"
    ]);
    if (fromStopSequences != null) {
      setValueByPath(toObject, ["stopSequences"], fromStopSequences);
    }
    const fromTemperature = getValueByPath(fromObject, ["temperature"]);
    if (fromTemperature != null) {
      setValueByPath(toObject, ["temperature"], fromTemperature);
    }
    const fromThinkingConfig = getValueByPath(fromObject, [
      "thinkingConfig"
    ]);
    if (fromThinkingConfig != null) {
      setValueByPath(toObject, ["thinkingConfig"], fromThinkingConfig);
    }
    const fromTopK = getValueByPath(fromObject, ["topK"]);
    if (fromTopK != null) {
      setValueByPath(toObject, ["topK"], fromTopK);
    }
    const fromTopP = getValueByPath(fromObject, ["topP"]);
    if (fromTopP != null) {
      setValueByPath(toObject, ["topP"], fromTopP);
    }
    if (getValueByPath(fromObject, ["enableEnhancedCivicAnswers"]) !== void 0) {
      throw new Error("enableEnhancedCivicAnswers parameter is not supported in Vertex AI.");
    }
    return toObject;
  }
  function googleMapsToMldev$2(fromObject) {
    const toObject = {};
    if (getValueByPath(fromObject, ["authConfig"]) !== void 0) {
      throw new Error("authConfig parameter is not supported in Gemini API.");
    }
    const fromEnableWidget = getValueByPath(fromObject, ["enableWidget"]);
    if (fromEnableWidget != null) {
      setValueByPath(toObject, ["enableWidget"], fromEnableWidget);
    }
    return toObject;
  }
  function googleSearchToMldev$2(fromObject) {
    const toObject = {};
    if (getValueByPath(fromObject, ["excludeDomains"]) !== void 0) {
      throw new Error("excludeDomains parameter is not supported in Gemini API.");
    }
    if (getValueByPath(fromObject, ["blockingConfidence"]) !== void 0) {
      throw new Error("blockingConfidence parameter is not supported in Gemini API.");
    }
    const fromTimeRangeFilter = getValueByPath(fromObject, [
      "timeRangeFilter"
    ]);
    if (fromTimeRangeFilter != null) {
      setValueByPath(toObject, ["timeRangeFilter"], fromTimeRangeFilter);
    }
    return toObject;
  }
  function liveConnectConfigToMldev$1(fromObject, parentObject) {
    const toObject = {};
    const fromGenerationConfig = getValueByPath(fromObject, [
      "generationConfig"
    ]);
    if (parentObject !== void 0 && fromGenerationConfig != null) {
      setValueByPath(parentObject, ["setup", "generationConfig"], fromGenerationConfig);
    }
    const fromResponseModalities = getValueByPath(fromObject, [
      "responseModalities"
    ]);
    if (parentObject !== void 0 && fromResponseModalities != null) {
      setValueByPath(parentObject, ["setup", "generationConfig", "responseModalities"], fromResponseModalities);
    }
    const fromTemperature = getValueByPath(fromObject, ["temperature"]);
    if (parentObject !== void 0 && fromTemperature != null) {
      setValueByPath(parentObject, ["setup", "generationConfig", "temperature"], fromTemperature);
    }
    const fromTopP = getValueByPath(fromObject, ["topP"]);
    if (parentObject !== void 0 && fromTopP != null) {
      setValueByPath(parentObject, ["setup", "generationConfig", "topP"], fromTopP);
    }
    const fromTopK = getValueByPath(fromObject, ["topK"]);
    if (parentObject !== void 0 && fromTopK != null) {
      setValueByPath(parentObject, ["setup", "generationConfig", "topK"], fromTopK);
    }
    const fromMaxOutputTokens = getValueByPath(fromObject, [
      "maxOutputTokens"
    ]);
    if (parentObject !== void 0 && fromMaxOutputTokens != null) {
      setValueByPath(parentObject, ["setup", "generationConfig", "maxOutputTokens"], fromMaxOutputTokens);
    }
    const fromMediaResolution = getValueByPath(fromObject, [
      "mediaResolution"
    ]);
    if (parentObject !== void 0 && fromMediaResolution != null) {
      setValueByPath(parentObject, ["setup", "generationConfig", "mediaResolution"], fromMediaResolution);
    }
    const fromSeed = getValueByPath(fromObject, ["seed"]);
    if (parentObject !== void 0 && fromSeed != null) {
      setValueByPath(parentObject, ["setup", "generationConfig", "seed"], fromSeed);
    }
    const fromSpeechConfig = getValueByPath(fromObject, ["speechConfig"]);
    if (parentObject !== void 0 && fromSpeechConfig != null) {
      setValueByPath(parentObject, ["setup", "generationConfig", "speechConfig"], tLiveSpeechConfig(fromSpeechConfig));
    }
    const fromThinkingConfig = getValueByPath(fromObject, [
      "thinkingConfig"
    ]);
    if (parentObject !== void 0 && fromThinkingConfig != null) {
      setValueByPath(parentObject, ["setup", "generationConfig", "thinkingConfig"], fromThinkingConfig);
    }
    const fromEnableAffectiveDialog = getValueByPath(fromObject, [
      "enableAffectiveDialog"
    ]);
    if (parentObject !== void 0 && fromEnableAffectiveDialog != null) {
      setValueByPath(parentObject, ["setup", "generationConfig", "enableAffectiveDialog"], fromEnableAffectiveDialog);
    }
    const fromSystemInstruction = getValueByPath(fromObject, [
      "systemInstruction"
    ]);
    if (parentObject !== void 0 && fromSystemInstruction != null) {
      setValueByPath(parentObject, ["setup", "systemInstruction"], contentToMldev$2(tContent(fromSystemInstruction)));
    }
    const fromTools = getValueByPath(fromObject, ["tools"]);
    if (parentObject !== void 0 && fromTools != null) {
      let transformedList = tTools(fromTools);
      if (Array.isArray(transformedList)) {
        transformedList = transformedList.map((item) => {
          return toolToMldev$2(tTool(item));
        });
      }
      setValueByPath(parentObject, ["setup", "tools"], transformedList);
    }
    const fromSessionResumption = getValueByPath(fromObject, [
      "sessionResumption"
    ]);
    if (parentObject !== void 0 && fromSessionResumption != null) {
      setValueByPath(parentObject, ["setup", "sessionResumption"], sessionResumptionConfigToMldev$1(fromSessionResumption));
    }
    const fromInputAudioTranscription = getValueByPath(fromObject, [
      "inputAudioTranscription"
    ]);
    if (parentObject !== void 0 && fromInputAudioTranscription != null) {
      setValueByPath(parentObject, ["setup", "inputAudioTranscription"], fromInputAudioTranscription);
    }
    const fromOutputAudioTranscription = getValueByPath(fromObject, [
      "outputAudioTranscription"
    ]);
    if (parentObject !== void 0 && fromOutputAudioTranscription != null) {
      setValueByPath(parentObject, ["setup", "outputAudioTranscription"], fromOutputAudioTranscription);
    }
    const fromRealtimeInputConfig = getValueByPath(fromObject, [
      "realtimeInputConfig"
    ]);
    if (parentObject !== void 0 && fromRealtimeInputConfig != null) {
      setValueByPath(parentObject, ["setup", "realtimeInputConfig"], fromRealtimeInputConfig);
    }
    const fromContextWindowCompression = getValueByPath(fromObject, [
      "contextWindowCompression"
    ]);
    if (parentObject !== void 0 && fromContextWindowCompression != null) {
      setValueByPath(parentObject, ["setup", "contextWindowCompression"], fromContextWindowCompression);
    }
    const fromProactivity = getValueByPath(fromObject, ["proactivity"]);
    if (parentObject !== void 0 && fromProactivity != null) {
      setValueByPath(parentObject, ["setup", "proactivity"], fromProactivity);
    }
    return toObject;
  }
  function liveConnectConfigToVertex(fromObject, parentObject) {
    const toObject = {};
    const fromGenerationConfig = getValueByPath(fromObject, [
      "generationConfig"
    ]);
    if (parentObject !== void 0 && fromGenerationConfig != null) {
      setValueByPath(parentObject, ["setup", "generationConfig"], generationConfigToVertex$1(fromGenerationConfig));
    }
    const fromResponseModalities = getValueByPath(fromObject, [
      "responseModalities"
    ]);
    if (parentObject !== void 0 && fromResponseModalities != null) {
      setValueByPath(parentObject, ["setup", "generationConfig", "responseModalities"], fromResponseModalities);
    }
    const fromTemperature = getValueByPath(fromObject, ["temperature"]);
    if (parentObject !== void 0 && fromTemperature != null) {
      setValueByPath(parentObject, ["setup", "generationConfig", "temperature"], fromTemperature);
    }
    const fromTopP = getValueByPath(fromObject, ["topP"]);
    if (parentObject !== void 0 && fromTopP != null) {
      setValueByPath(parentObject, ["setup", "generationConfig", "topP"], fromTopP);
    }
    const fromTopK = getValueByPath(fromObject, ["topK"]);
    if (parentObject !== void 0 && fromTopK != null) {
      setValueByPath(parentObject, ["setup", "generationConfig", "topK"], fromTopK);
    }
    const fromMaxOutputTokens = getValueByPath(fromObject, [
      "maxOutputTokens"
    ]);
    if (parentObject !== void 0 && fromMaxOutputTokens != null) {
      setValueByPath(parentObject, ["setup", "generationConfig", "maxOutputTokens"], fromMaxOutputTokens);
    }
    const fromMediaResolution = getValueByPath(fromObject, [
      "mediaResolution"
    ]);
    if (parentObject !== void 0 && fromMediaResolution != null) {
      setValueByPath(parentObject, ["setup", "generationConfig", "mediaResolution"], fromMediaResolution);
    }
    const fromSeed = getValueByPath(fromObject, ["seed"]);
    if (parentObject !== void 0 && fromSeed != null) {
      setValueByPath(parentObject, ["setup", "generationConfig", "seed"], fromSeed);
    }
    const fromSpeechConfig = getValueByPath(fromObject, ["speechConfig"]);
    if (parentObject !== void 0 && fromSpeechConfig != null) {
      setValueByPath(parentObject, ["setup", "generationConfig", "speechConfig"], speechConfigToVertex$1(tLiveSpeechConfig(fromSpeechConfig)));
    }
    const fromThinkingConfig = getValueByPath(fromObject, [
      "thinkingConfig"
    ]);
    if (parentObject !== void 0 && fromThinkingConfig != null) {
      setValueByPath(parentObject, ["setup", "generationConfig", "thinkingConfig"], fromThinkingConfig);
    }
    const fromEnableAffectiveDialog = getValueByPath(fromObject, [
      "enableAffectiveDialog"
    ]);
    if (parentObject !== void 0 && fromEnableAffectiveDialog != null) {
      setValueByPath(parentObject, ["setup", "generationConfig", "enableAffectiveDialog"], fromEnableAffectiveDialog);
    }
    const fromSystemInstruction = getValueByPath(fromObject, [
      "systemInstruction"
    ]);
    if (parentObject !== void 0 && fromSystemInstruction != null) {
      setValueByPath(parentObject, ["setup", "systemInstruction"], tContent(fromSystemInstruction));
    }
    const fromTools = getValueByPath(fromObject, ["tools"]);
    if (parentObject !== void 0 && fromTools != null) {
      let transformedList = tTools(fromTools);
      if (Array.isArray(transformedList)) {
        transformedList = transformedList.map((item) => {
          return toolToVertex$1(tTool(item));
        });
      }
      setValueByPath(parentObject, ["setup", "tools"], transformedList);
    }
    const fromSessionResumption = getValueByPath(fromObject, [
      "sessionResumption"
    ]);
    if (parentObject !== void 0 && fromSessionResumption != null) {
      setValueByPath(parentObject, ["setup", "sessionResumption"], fromSessionResumption);
    }
    const fromInputAudioTranscription = getValueByPath(fromObject, [
      "inputAudioTranscription"
    ]);
    if (parentObject !== void 0 && fromInputAudioTranscription != null) {
      setValueByPath(parentObject, ["setup", "inputAudioTranscription"], fromInputAudioTranscription);
    }
    const fromOutputAudioTranscription = getValueByPath(fromObject, [
      "outputAudioTranscription"
    ]);
    if (parentObject !== void 0 && fromOutputAudioTranscription != null) {
      setValueByPath(parentObject, ["setup", "outputAudioTranscription"], fromOutputAudioTranscription);
    }
    const fromRealtimeInputConfig = getValueByPath(fromObject, [
      "realtimeInputConfig"
    ]);
    if (parentObject !== void 0 && fromRealtimeInputConfig != null) {
      setValueByPath(parentObject, ["setup", "realtimeInputConfig"], fromRealtimeInputConfig);
    }
    const fromContextWindowCompression = getValueByPath(fromObject, [
      "contextWindowCompression"
    ]);
    if (parentObject !== void 0 && fromContextWindowCompression != null) {
      setValueByPath(parentObject, ["setup", "contextWindowCompression"], fromContextWindowCompression);
    }
    const fromProactivity = getValueByPath(fromObject, ["proactivity"]);
    if (parentObject !== void 0 && fromProactivity != null) {
      setValueByPath(parentObject, ["setup", "proactivity"], fromProactivity);
    }
    return toObject;
  }
  function liveConnectParametersToMldev(apiClient, fromObject) {
    const toObject = {};
    const fromModel = getValueByPath(fromObject, ["model"]);
    if (fromModel != null) {
      setValueByPath(toObject, ["setup", "model"], tModel(apiClient, fromModel));
    }
    const fromConfig = getValueByPath(fromObject, ["config"]);
    if (fromConfig != null) {
      setValueByPath(toObject, ["config"], liveConnectConfigToMldev$1(fromConfig, toObject));
    }
    return toObject;
  }
  function liveConnectParametersToVertex(apiClient, fromObject) {
    const toObject = {};
    const fromModel = getValueByPath(fromObject, ["model"]);
    if (fromModel != null) {
      setValueByPath(toObject, ["setup", "model"], tModel(apiClient, fromModel));
    }
    const fromConfig = getValueByPath(fromObject, ["config"]);
    if (fromConfig != null) {
      setValueByPath(toObject, ["config"], liveConnectConfigToVertex(fromConfig, toObject));
    }
    return toObject;
  }
  function liveMusicSetConfigParametersToMldev(fromObject) {
    const toObject = {};
    const fromMusicGenerationConfig = getValueByPath(fromObject, [
      "musicGenerationConfig"
    ]);
    if (fromMusicGenerationConfig != null) {
      setValueByPath(toObject, ["musicGenerationConfig"], fromMusicGenerationConfig);
    }
    return toObject;
  }
  function liveMusicSetWeightedPromptsParametersToMldev(fromObject) {
    const toObject = {};
    const fromWeightedPrompts = getValueByPath(fromObject, [
      "weightedPrompts"
    ]);
    if (fromWeightedPrompts != null) {
      let transformedList = fromWeightedPrompts;
      if (Array.isArray(transformedList)) {
        transformedList = transformedList.map((item) => {
          return item;
        });
      }
      setValueByPath(toObject, ["weightedPrompts"], transformedList);
    }
    return toObject;
  }
  function liveSendRealtimeInputParametersToMldev(fromObject) {
    const toObject = {};
    const fromMedia = getValueByPath(fromObject, ["media"]);
    if (fromMedia != null) {
      let transformedList = tBlobs(fromMedia);
      if (Array.isArray(transformedList)) {
        transformedList = transformedList.map((item) => {
          return blobToMldev$2(item);
        });
      }
      setValueByPath(toObject, ["mediaChunks"], transformedList);
    }
    const fromAudio = getValueByPath(fromObject, ["audio"]);
    if (fromAudio != null) {
      setValueByPath(toObject, ["audio"], blobToMldev$2(tAudioBlob(fromAudio)));
    }
    const fromAudioStreamEnd = getValueByPath(fromObject, [
      "audioStreamEnd"
    ]);
    if (fromAudioStreamEnd != null) {
      setValueByPath(toObject, ["audioStreamEnd"], fromAudioStreamEnd);
    }
    const fromVideo = getValueByPath(fromObject, ["video"]);
    if (fromVideo != null) {
      setValueByPath(toObject, ["video"], blobToMldev$2(tImageBlob(fromVideo)));
    }
    const fromText = getValueByPath(fromObject, ["text"]);
    if (fromText != null) {
      setValueByPath(toObject, ["text"], fromText);
    }
    const fromActivityStart = getValueByPath(fromObject, [
      "activityStart"
    ]);
    if (fromActivityStart != null) {
      setValueByPath(toObject, ["activityStart"], fromActivityStart);
    }
    const fromActivityEnd = getValueByPath(fromObject, ["activityEnd"]);
    if (fromActivityEnd != null) {
      setValueByPath(toObject, ["activityEnd"], fromActivityEnd);
    }
    return toObject;
  }
  function liveSendRealtimeInputParametersToVertex(fromObject) {
    const toObject = {};
    const fromMedia = getValueByPath(fromObject, ["media"]);
    if (fromMedia != null) {
      let transformedList = tBlobs(fromMedia);
      if (Array.isArray(transformedList)) {
        transformedList = transformedList.map((item) => {
          return item;
        });
      }
      setValueByPath(toObject, ["mediaChunks"], transformedList);
    }
    const fromAudio = getValueByPath(fromObject, ["audio"]);
    if (fromAudio != null) {
      setValueByPath(toObject, ["audio"], tAudioBlob(fromAudio));
    }
    const fromAudioStreamEnd = getValueByPath(fromObject, [
      "audioStreamEnd"
    ]);
    if (fromAudioStreamEnd != null) {
      setValueByPath(toObject, ["audioStreamEnd"], fromAudioStreamEnd);
    }
    const fromVideo = getValueByPath(fromObject, ["video"]);
    if (fromVideo != null) {
      setValueByPath(toObject, ["video"], tImageBlob(fromVideo));
    }
    const fromText = getValueByPath(fromObject, ["text"]);
    if (fromText != null) {
      setValueByPath(toObject, ["text"], fromText);
    }
    const fromActivityStart = getValueByPath(fromObject, [
      "activityStart"
    ]);
    if (fromActivityStart != null) {
      setValueByPath(toObject, ["activityStart"], fromActivityStart);
    }
    const fromActivityEnd = getValueByPath(fromObject, ["activityEnd"]);
    if (fromActivityEnd != null) {
      setValueByPath(toObject, ["activityEnd"], fromActivityEnd);
    }
    return toObject;
  }
  function liveServerMessageFromVertex(fromObject) {
    const toObject = {};
    const fromSetupComplete = getValueByPath(fromObject, [
      "setupComplete"
    ]);
    if (fromSetupComplete != null) {
      setValueByPath(toObject, ["setupComplete"], fromSetupComplete);
    }
    const fromServerContent = getValueByPath(fromObject, [
      "serverContent"
    ]);
    if (fromServerContent != null) {
      setValueByPath(toObject, ["serverContent"], fromServerContent);
    }
    const fromToolCall = getValueByPath(fromObject, ["toolCall"]);
    if (fromToolCall != null) {
      setValueByPath(toObject, ["toolCall"], fromToolCall);
    }
    const fromToolCallCancellation = getValueByPath(fromObject, [
      "toolCallCancellation"
    ]);
    if (fromToolCallCancellation != null) {
      setValueByPath(toObject, ["toolCallCancellation"], fromToolCallCancellation);
    }
    const fromUsageMetadata = getValueByPath(fromObject, [
      "usageMetadata"
    ]);
    if (fromUsageMetadata != null) {
      setValueByPath(toObject, ["usageMetadata"], usageMetadataFromVertex(fromUsageMetadata));
    }
    const fromGoAway = getValueByPath(fromObject, ["goAway"]);
    if (fromGoAway != null) {
      setValueByPath(toObject, ["goAway"], fromGoAway);
    }
    const fromSessionResumptionUpdate = getValueByPath(fromObject, [
      "sessionResumptionUpdate"
    ]);
    if (fromSessionResumptionUpdate != null) {
      setValueByPath(toObject, ["sessionResumptionUpdate"], fromSessionResumptionUpdate);
    }
    return toObject;
  }
  function partToMldev$2(fromObject) {
    const toObject = {};
    const fromMediaResolution = getValueByPath(fromObject, [
      "mediaResolution"
    ]);
    if (fromMediaResolution != null) {
      setValueByPath(toObject, ["mediaResolution"], fromMediaResolution);
    }
    const fromCodeExecutionResult = getValueByPath(fromObject, [
      "codeExecutionResult"
    ]);
    if (fromCodeExecutionResult != null) {
      setValueByPath(toObject, ["codeExecutionResult"], fromCodeExecutionResult);
    }
    const fromExecutableCode = getValueByPath(fromObject, [
      "executableCode"
    ]);
    if (fromExecutableCode != null) {
      setValueByPath(toObject, ["executableCode"], fromExecutableCode);
    }
    const fromFileData = getValueByPath(fromObject, ["fileData"]);
    if (fromFileData != null) {
      setValueByPath(toObject, ["fileData"], fileDataToMldev$2(fromFileData));
    }
    const fromFunctionCall = getValueByPath(fromObject, ["functionCall"]);
    if (fromFunctionCall != null) {
      setValueByPath(toObject, ["functionCall"], functionCallToMldev$2(fromFunctionCall));
    }
    const fromFunctionResponse = getValueByPath(fromObject, [
      "functionResponse"
    ]);
    if (fromFunctionResponse != null) {
      setValueByPath(toObject, ["functionResponse"], fromFunctionResponse);
    }
    const fromInlineData = getValueByPath(fromObject, ["inlineData"]);
    if (fromInlineData != null) {
      setValueByPath(toObject, ["inlineData"], blobToMldev$2(fromInlineData));
    }
    const fromText = getValueByPath(fromObject, ["text"]);
    if (fromText != null) {
      setValueByPath(toObject, ["text"], fromText);
    }
    const fromThought = getValueByPath(fromObject, ["thought"]);
    if (fromThought != null) {
      setValueByPath(toObject, ["thought"], fromThought);
    }
    const fromThoughtSignature = getValueByPath(fromObject, [
      "thoughtSignature"
    ]);
    if (fromThoughtSignature != null) {
      setValueByPath(toObject, ["thoughtSignature"], fromThoughtSignature);
    }
    const fromVideoMetadata = getValueByPath(fromObject, [
      "videoMetadata"
    ]);
    if (fromVideoMetadata != null) {
      setValueByPath(toObject, ["videoMetadata"], fromVideoMetadata);
    }
    return toObject;
  }
  function sessionResumptionConfigToMldev$1(fromObject) {
    const toObject = {};
    const fromHandle = getValueByPath(fromObject, ["handle"]);
    if (fromHandle != null) {
      setValueByPath(toObject, ["handle"], fromHandle);
    }
    if (getValueByPath(fromObject, ["transparent"]) !== void 0) {
      throw new Error("transparent parameter is not supported in Gemini API.");
    }
    return toObject;
  }
  function speechConfigToVertex$1(fromObject) {
    const toObject = {};
    const fromLanguageCode = getValueByPath(fromObject, ["languageCode"]);
    if (fromLanguageCode != null) {
      setValueByPath(toObject, ["languageCode"], fromLanguageCode);
    }
    const fromVoiceConfig = getValueByPath(fromObject, ["voiceConfig"]);
    if (fromVoiceConfig != null) {
      setValueByPath(toObject, ["voiceConfig"], fromVoiceConfig);
    }
    if (getValueByPath(fromObject, ["multiSpeakerVoiceConfig"]) !== void 0) {
      throw new Error("multiSpeakerVoiceConfig parameter is not supported in Vertex AI.");
    }
    return toObject;
  }
  function toolToMldev$2(fromObject) {
    const toObject = {};
    const fromFunctionDeclarations = getValueByPath(fromObject, [
      "functionDeclarations"
    ]);
    if (fromFunctionDeclarations != null) {
      let transformedList = fromFunctionDeclarations;
      if (Array.isArray(transformedList)) {
        transformedList = transformedList.map((item) => {
          return item;
        });
      }
      setValueByPath(toObject, ["functionDeclarations"], transformedList);
    }
    if (getValueByPath(fromObject, ["retrieval"]) !== void 0) {
      throw new Error("retrieval parameter is not supported in Gemini API.");
    }
    const fromGoogleSearchRetrieval = getValueByPath(fromObject, [
      "googleSearchRetrieval"
    ]);
    if (fromGoogleSearchRetrieval != null) {
      setValueByPath(toObject, ["googleSearchRetrieval"], fromGoogleSearchRetrieval);
    }
    const fromComputerUse = getValueByPath(fromObject, ["computerUse"]);
    if (fromComputerUse != null) {
      setValueByPath(toObject, ["computerUse"], fromComputerUse);
    }
    const fromFileSearch = getValueByPath(fromObject, ["fileSearch"]);
    if (fromFileSearch != null) {
      setValueByPath(toObject, ["fileSearch"], fromFileSearch);
    }
    const fromCodeExecution = getValueByPath(fromObject, [
      "codeExecution"
    ]);
    if (fromCodeExecution != null) {
      setValueByPath(toObject, ["codeExecution"], fromCodeExecution);
    }
    if (getValueByPath(fromObject, ["enterpriseWebSearch"]) !== void 0) {
      throw new Error("enterpriseWebSearch parameter is not supported in Gemini API.");
    }
    const fromGoogleMaps = getValueByPath(fromObject, ["googleMaps"]);
    if (fromGoogleMaps != null) {
      setValueByPath(toObject, ["googleMaps"], googleMapsToMldev$2(fromGoogleMaps));
    }
    const fromGoogleSearch = getValueByPath(fromObject, ["googleSearch"]);
    if (fromGoogleSearch != null) {
      setValueByPath(toObject, ["googleSearch"], googleSearchToMldev$2(fromGoogleSearch));
    }
    const fromUrlContext = getValueByPath(fromObject, ["urlContext"]);
    if (fromUrlContext != null) {
      setValueByPath(toObject, ["urlContext"], fromUrlContext);
    }
    return toObject;
  }
  function toolToVertex$1(fromObject) {
    const toObject = {};
    const fromFunctionDeclarations = getValueByPath(fromObject, [
      "functionDeclarations"
    ]);
    if (fromFunctionDeclarations != null) {
      let transformedList = fromFunctionDeclarations;
      if (Array.isArray(transformedList)) {
        transformedList = transformedList.map((item) => {
          return functionDeclarationToVertex$1(item);
        });
      }
      setValueByPath(toObject, ["functionDeclarations"], transformedList);
    }
    const fromRetrieval = getValueByPath(fromObject, ["retrieval"]);
    if (fromRetrieval != null) {
      setValueByPath(toObject, ["retrieval"], fromRetrieval);
    }
    const fromGoogleSearchRetrieval = getValueByPath(fromObject, [
      "googleSearchRetrieval"
    ]);
    if (fromGoogleSearchRetrieval != null) {
      setValueByPath(toObject, ["googleSearchRetrieval"], fromGoogleSearchRetrieval);
    }
    const fromComputerUse = getValueByPath(fromObject, ["computerUse"]);
    if (fromComputerUse != null) {
      setValueByPath(toObject, ["computerUse"], fromComputerUse);
    }
    if (getValueByPath(fromObject, ["fileSearch"]) !== void 0) {
      throw new Error("fileSearch parameter is not supported in Vertex AI.");
    }
    const fromCodeExecution = getValueByPath(fromObject, [
      "codeExecution"
    ]);
    if (fromCodeExecution != null) {
      setValueByPath(toObject, ["codeExecution"], fromCodeExecution);
    }
    const fromEnterpriseWebSearch = getValueByPath(fromObject, [
      "enterpriseWebSearch"
    ]);
    if (fromEnterpriseWebSearch != null) {
      setValueByPath(toObject, ["enterpriseWebSearch"], fromEnterpriseWebSearch);
    }
    const fromGoogleMaps = getValueByPath(fromObject, ["googleMaps"]);
    if (fromGoogleMaps != null) {
      setValueByPath(toObject, ["googleMaps"], fromGoogleMaps);
    }
    const fromGoogleSearch = getValueByPath(fromObject, ["googleSearch"]);
    if (fromGoogleSearch != null) {
      setValueByPath(toObject, ["googleSearch"], fromGoogleSearch);
    }
    const fromUrlContext = getValueByPath(fromObject, ["urlContext"]);
    if (fromUrlContext != null) {
      setValueByPath(toObject, ["urlContext"], fromUrlContext);
    }
    return toObject;
  }
  function usageMetadataFromVertex(fromObject) {
    const toObject = {};
    const fromPromptTokenCount = getValueByPath(fromObject, [
      "promptTokenCount"
    ]);
    if (fromPromptTokenCount != null) {
      setValueByPath(toObject, ["promptTokenCount"], fromPromptTokenCount);
    }
    const fromCachedContentTokenCount = getValueByPath(fromObject, [
      "cachedContentTokenCount"
    ]);
    if (fromCachedContentTokenCount != null) {
      setValueByPath(toObject, ["cachedContentTokenCount"], fromCachedContentTokenCount);
    }
    const fromResponseTokenCount = getValueByPath(fromObject, [
      "candidatesTokenCount"
    ]);
    if (fromResponseTokenCount != null) {
      setValueByPath(toObject, ["responseTokenCount"], fromResponseTokenCount);
    }
    const fromToolUsePromptTokenCount = getValueByPath(fromObject, [
      "toolUsePromptTokenCount"
    ]);
    if (fromToolUsePromptTokenCount != null) {
      setValueByPath(toObject, ["toolUsePromptTokenCount"], fromToolUsePromptTokenCount);
    }
    const fromThoughtsTokenCount = getValueByPath(fromObject, [
      "thoughtsTokenCount"
    ]);
    if (fromThoughtsTokenCount != null) {
      setValueByPath(toObject, ["thoughtsTokenCount"], fromThoughtsTokenCount);
    }
    const fromTotalTokenCount = getValueByPath(fromObject, [
      "totalTokenCount"
    ]);
    if (fromTotalTokenCount != null) {
      setValueByPath(toObject, ["totalTokenCount"], fromTotalTokenCount);
    }
    const fromPromptTokensDetails = getValueByPath(fromObject, [
      "promptTokensDetails"
    ]);
    if (fromPromptTokensDetails != null) {
      let transformedList = fromPromptTokensDetails;
      if (Array.isArray(transformedList)) {
        transformedList = transformedList.map((item) => {
          return item;
        });
      }
      setValueByPath(toObject, ["promptTokensDetails"], transformedList);
    }
    const fromCacheTokensDetails = getValueByPath(fromObject, [
      "cacheTokensDetails"
    ]);
    if (fromCacheTokensDetails != null) {
      let transformedList = fromCacheTokensDetails;
      if (Array.isArray(transformedList)) {
        transformedList = transformedList.map((item) => {
          return item;
        });
      }
      setValueByPath(toObject, ["cacheTokensDetails"], transformedList);
    }
    const fromResponseTokensDetails = getValueByPath(fromObject, [
      "candidatesTokensDetails"
    ]);
    if (fromResponseTokensDetails != null) {
      let transformedList = fromResponseTokensDetails;
      if (Array.isArray(transformedList)) {
        transformedList = transformedList.map((item) => {
          return item;
        });
      }
      setValueByPath(toObject, ["responseTokensDetails"], transformedList);
    }
    const fromToolUsePromptTokensDetails = getValueByPath(fromObject, [
      "toolUsePromptTokensDetails"
    ]);
    if (fromToolUsePromptTokensDetails != null) {
      let transformedList = fromToolUsePromptTokensDetails;
      if (Array.isArray(transformedList)) {
        transformedList = transformedList.map((item) => {
          return item;
        });
      }
      setValueByPath(toObject, ["toolUsePromptTokensDetails"], transformedList);
    }
    const fromTrafficType = getValueByPath(fromObject, ["trafficType"]);
    if (fromTrafficType != null) {
      setValueByPath(toObject, ["trafficType"], fromTrafficType);
    }
    return toObject;
  }
  function blobToMldev$1(fromObject) {
    const toObject = {};
    const fromData = getValueByPath(fromObject, ["data"]);
    if (fromData != null) {
      setValueByPath(toObject, ["data"], fromData);
    }
    if (getValueByPath(fromObject, ["displayName"]) !== void 0) {
      throw new Error("displayName parameter is not supported in Gemini API.");
    }
    const fromMimeType = getValueByPath(fromObject, ["mimeType"]);
    if (fromMimeType != null) {
      setValueByPath(toObject, ["mimeType"], fromMimeType);
    }
    return toObject;
  }
  function candidateFromMldev(fromObject) {
    const toObject = {};
    const fromContent = getValueByPath(fromObject, ["content"]);
    if (fromContent != null) {
      setValueByPath(toObject, ["content"], fromContent);
    }
    const fromCitationMetadata = getValueByPath(fromObject, [
      "citationMetadata"
    ]);
    if (fromCitationMetadata != null) {
      setValueByPath(toObject, ["citationMetadata"], citationMetadataFromMldev(fromCitationMetadata));
    }
    const fromTokenCount = getValueByPath(fromObject, ["tokenCount"]);
    if (fromTokenCount != null) {
      setValueByPath(toObject, ["tokenCount"], fromTokenCount);
    }
    const fromFinishReason = getValueByPath(fromObject, ["finishReason"]);
    if (fromFinishReason != null) {
      setValueByPath(toObject, ["finishReason"], fromFinishReason);
    }
    const fromAvgLogprobs = getValueByPath(fromObject, ["avgLogprobs"]);
    if (fromAvgLogprobs != null) {
      setValueByPath(toObject, ["avgLogprobs"], fromAvgLogprobs);
    }
    const fromGroundingMetadata = getValueByPath(fromObject, [
      "groundingMetadata"
    ]);
    if (fromGroundingMetadata != null) {
      setValueByPath(toObject, ["groundingMetadata"], fromGroundingMetadata);
    }
    const fromIndex = getValueByPath(fromObject, ["index"]);
    if (fromIndex != null) {
      setValueByPath(toObject, ["index"], fromIndex);
    }
    const fromLogprobsResult = getValueByPath(fromObject, [
      "logprobsResult"
    ]);
    if (fromLogprobsResult != null) {
      setValueByPath(toObject, ["logprobsResult"], fromLogprobsResult);
    }
    const fromSafetyRatings = getValueByPath(fromObject, [
      "safetyRatings"
    ]);
    if (fromSafetyRatings != null) {
      let transformedList = fromSafetyRatings;
      if (Array.isArray(transformedList)) {
        transformedList = transformedList.map((item) => {
          return item;
        });
      }
      setValueByPath(toObject, ["safetyRatings"], transformedList);
    }
    const fromUrlContextMetadata = getValueByPath(fromObject, [
      "urlContextMetadata"
    ]);
    if (fromUrlContextMetadata != null) {
      setValueByPath(toObject, ["urlContextMetadata"], fromUrlContextMetadata);
    }
    return toObject;
  }
  function citationMetadataFromMldev(fromObject) {
    const toObject = {};
    const fromCitations = getValueByPath(fromObject, ["citationSources"]);
    if (fromCitations != null) {
      let transformedList = fromCitations;
      if (Array.isArray(transformedList)) {
        transformedList = transformedList.map((item) => {
          return item;
        });
      }
      setValueByPath(toObject, ["citations"], transformedList);
    }
    return toObject;
  }
  function computeTokensParametersToVertex(apiClient, fromObject) {
    const toObject = {};
    const fromModel = getValueByPath(fromObject, ["model"]);
    if (fromModel != null) {
      setValueByPath(toObject, ["_url", "model"], tModel(apiClient, fromModel));
    }
    const fromContents = getValueByPath(fromObject, ["contents"]);
    if (fromContents != null) {
      let transformedList = tContents(fromContents);
      if (Array.isArray(transformedList)) {
        transformedList = transformedList.map((item) => {
          return item;
        });
      }
      setValueByPath(toObject, ["contents"], transformedList);
    }
    return toObject;
  }
  function computeTokensResponseFromVertex(fromObject) {
    const toObject = {};
    const fromSdkHttpResponse = getValueByPath(fromObject, [
      "sdkHttpResponse"
    ]);
    if (fromSdkHttpResponse != null) {
      setValueByPath(toObject, ["sdkHttpResponse"], fromSdkHttpResponse);
    }
    const fromTokensInfo = getValueByPath(fromObject, ["tokensInfo"]);
    if (fromTokensInfo != null) {
      let transformedList = fromTokensInfo;
      if (Array.isArray(transformedList)) {
        transformedList = transformedList.map((item) => {
          return item;
        });
      }
      setValueByPath(toObject, ["tokensInfo"], transformedList);
    }
    return toObject;
  }
  function contentEmbeddingFromVertex(fromObject) {
    const toObject = {};
    const fromValues = getValueByPath(fromObject, ["values"]);
    if (fromValues != null) {
      setValueByPath(toObject, ["values"], fromValues);
    }
    const fromStatistics = getValueByPath(fromObject, ["statistics"]);
    if (fromStatistics != null) {
      setValueByPath(toObject, ["statistics"], contentEmbeddingStatisticsFromVertex(fromStatistics));
    }
    return toObject;
  }
  function contentEmbeddingStatisticsFromVertex(fromObject) {
    const toObject = {};
    const fromTruncated = getValueByPath(fromObject, ["truncated"]);
    if (fromTruncated != null) {
      setValueByPath(toObject, ["truncated"], fromTruncated);
    }
    const fromTokenCount = getValueByPath(fromObject, ["token_count"]);
    if (fromTokenCount != null) {
      setValueByPath(toObject, ["tokenCount"], fromTokenCount);
    }
    return toObject;
  }
  function contentToMldev$1(fromObject) {
    const toObject = {};
    const fromParts = getValueByPath(fromObject, ["parts"]);
    if (fromParts != null) {
      let transformedList = fromParts;
      if (Array.isArray(transformedList)) {
        transformedList = transformedList.map((item) => {
          return partToMldev$1(item);
        });
      }
      setValueByPath(toObject, ["parts"], transformedList);
    }
    const fromRole = getValueByPath(fromObject, ["role"]);
    if (fromRole != null) {
      setValueByPath(toObject, ["role"], fromRole);
    }
    return toObject;
  }
  function controlReferenceConfigToVertex(fromObject) {
    const toObject = {};
    const fromControlType = getValueByPath(fromObject, ["controlType"]);
    if (fromControlType != null) {
      setValueByPath(toObject, ["controlType"], fromControlType);
    }
    const fromEnableControlImageComputation = getValueByPath(fromObject, [
      "enableControlImageComputation"
    ]);
    if (fromEnableControlImageComputation != null) {
      setValueByPath(toObject, ["computeControl"], fromEnableControlImageComputation);
    }
    return toObject;
  }
  function countTokensConfigToMldev(fromObject) {
    const toObject = {};
    if (getValueByPath(fromObject, ["systemInstruction"]) !== void 0) {
      throw new Error("systemInstruction parameter is not supported in Gemini API.");
    }
    if (getValueByPath(fromObject, ["tools"]) !== void 0) {
      throw new Error("tools parameter is not supported in Gemini API.");
    }
    if (getValueByPath(fromObject, ["generationConfig"]) !== void 0) {
      throw new Error("generationConfig parameter is not supported in Gemini API.");
    }
    return toObject;
  }
  function countTokensConfigToVertex(fromObject, parentObject) {
    const toObject = {};
    const fromSystemInstruction = getValueByPath(fromObject, [
      "systemInstruction"
    ]);
    if (parentObject !== void 0 && fromSystemInstruction != null) {
      setValueByPath(parentObject, ["systemInstruction"], tContent(fromSystemInstruction));
    }
    const fromTools = getValueByPath(fromObject, ["tools"]);
    if (parentObject !== void 0 && fromTools != null) {
      let transformedList = fromTools;
      if (Array.isArray(transformedList)) {
        transformedList = transformedList.map((item) => {
          return toolToVertex(item);
        });
      }
      setValueByPath(parentObject, ["tools"], transformedList);
    }
    const fromGenerationConfig = getValueByPath(fromObject, [
      "generationConfig"
    ]);
    if (parentObject !== void 0 && fromGenerationConfig != null) {
      setValueByPath(parentObject, ["generationConfig"], generationConfigToVertex(fromGenerationConfig));
    }
    return toObject;
  }
  function countTokensParametersToMldev(apiClient, fromObject) {
    const toObject = {};
    const fromModel = getValueByPath(fromObject, ["model"]);
    if (fromModel != null) {
      setValueByPath(toObject, ["_url", "model"], tModel(apiClient, fromModel));
    }
    const fromContents = getValueByPath(fromObject, ["contents"]);
    if (fromContents != null) {
      let transformedList = tContents(fromContents);
      if (Array.isArray(transformedList)) {
        transformedList = transformedList.map((item) => {
          return contentToMldev$1(item);
        });
      }
      setValueByPath(toObject, ["contents"], transformedList);
    }
    const fromConfig = getValueByPath(fromObject, ["config"]);
    if (fromConfig != null) {
      countTokensConfigToMldev(fromConfig);
    }
    return toObject;
  }
  function countTokensParametersToVertex(apiClient, fromObject) {
    const toObject = {};
    const fromModel = getValueByPath(fromObject, ["model"]);
    if (fromModel != null) {
      setValueByPath(toObject, ["_url", "model"], tModel(apiClient, fromModel));
    }
    const fromContents = getValueByPath(fromObject, ["contents"]);
    if (fromContents != null) {
      let transformedList = tContents(fromContents);
      if (Array.isArray(transformedList)) {
        transformedList = transformedList.map((item) => {
          return item;
        });
      }
      setValueByPath(toObject, ["contents"], transformedList);
    }
    const fromConfig = getValueByPath(fromObject, ["config"]);
    if (fromConfig != null) {
      countTokensConfigToVertex(fromConfig, toObject);
    }
    return toObject;
  }
  function countTokensResponseFromMldev(fromObject) {
    const toObject = {};
    const fromSdkHttpResponse = getValueByPath(fromObject, [
      "sdkHttpResponse"
    ]);
    if (fromSdkHttpResponse != null) {
      setValueByPath(toObject, ["sdkHttpResponse"], fromSdkHttpResponse);
    }
    const fromTotalTokens = getValueByPath(fromObject, ["totalTokens"]);
    if (fromTotalTokens != null) {
      setValueByPath(toObject, ["totalTokens"], fromTotalTokens);
    }
    const fromCachedContentTokenCount = getValueByPath(fromObject, [
      "cachedContentTokenCount"
    ]);
    if (fromCachedContentTokenCount != null) {
      setValueByPath(toObject, ["cachedContentTokenCount"], fromCachedContentTokenCount);
    }
    return toObject;
  }
  function countTokensResponseFromVertex(fromObject) {
    const toObject = {};
    const fromSdkHttpResponse = getValueByPath(fromObject, [
      "sdkHttpResponse"
    ]);
    if (fromSdkHttpResponse != null) {
      setValueByPath(toObject, ["sdkHttpResponse"], fromSdkHttpResponse);
    }
    const fromTotalTokens = getValueByPath(fromObject, ["totalTokens"]);
    if (fromTotalTokens != null) {
      setValueByPath(toObject, ["totalTokens"], fromTotalTokens);
    }
    return toObject;
  }
  function deleteModelParametersToMldev(apiClient, fromObject) {
    const toObject = {};
    const fromModel = getValueByPath(fromObject, ["model"]);
    if (fromModel != null) {
      setValueByPath(toObject, ["_url", "name"], tModel(apiClient, fromModel));
    }
    return toObject;
  }
  function deleteModelParametersToVertex(apiClient, fromObject) {
    const toObject = {};
    const fromModel = getValueByPath(fromObject, ["model"]);
    if (fromModel != null) {
      setValueByPath(toObject, ["_url", "name"], tModel(apiClient, fromModel));
    }
    return toObject;
  }
  function deleteModelResponseFromMldev(fromObject) {
    const toObject = {};
    const fromSdkHttpResponse = getValueByPath(fromObject, [
      "sdkHttpResponse"
    ]);
    if (fromSdkHttpResponse != null) {
      setValueByPath(toObject, ["sdkHttpResponse"], fromSdkHttpResponse);
    }
    return toObject;
  }
  function deleteModelResponseFromVertex(fromObject) {
    const toObject = {};
    const fromSdkHttpResponse = getValueByPath(fromObject, [
      "sdkHttpResponse"
    ]);
    if (fromSdkHttpResponse != null) {
      setValueByPath(toObject, ["sdkHttpResponse"], fromSdkHttpResponse);
    }
    return toObject;
  }
  function editImageConfigToVertex(fromObject, parentObject) {
    const toObject = {};
    const fromOutputGcsUri = getValueByPath(fromObject, ["outputGcsUri"]);
    if (parentObject !== void 0 && fromOutputGcsUri != null) {
      setValueByPath(parentObject, ["parameters", "storageUri"], fromOutputGcsUri);
    }
    const fromNegativePrompt = getValueByPath(fromObject, [
      "negativePrompt"
    ]);
    if (parentObject !== void 0 && fromNegativePrompt != null) {
      setValueByPath(parentObject, ["parameters", "negativePrompt"], fromNegativePrompt);
    }
    const fromNumberOfImages = getValueByPath(fromObject, [
      "numberOfImages"
    ]);
    if (parentObject !== void 0 && fromNumberOfImages != null) {
      setValueByPath(parentObject, ["parameters", "sampleCount"], fromNumberOfImages);
    }
    const fromAspectRatio = getValueByPath(fromObject, ["aspectRatio"]);
    if (parentObject !== void 0 && fromAspectRatio != null) {
      setValueByPath(parentObject, ["parameters", "aspectRatio"], fromAspectRatio);
    }
    const fromGuidanceScale = getValueByPath(fromObject, [
      "guidanceScale"
    ]);
    if (parentObject !== void 0 && fromGuidanceScale != null) {
      setValueByPath(parentObject, ["parameters", "guidanceScale"], fromGuidanceScale);
    }
    const fromSeed = getValueByPath(fromObject, ["seed"]);
    if (parentObject !== void 0 && fromSeed != null) {
      setValueByPath(parentObject, ["parameters", "seed"], fromSeed);
    }
    const fromSafetyFilterLevel = getValueByPath(fromObject, [
      "safetyFilterLevel"
    ]);
    if (parentObject !== void 0 && fromSafetyFilterLevel != null) {
      setValueByPath(parentObject, ["parameters", "safetySetting"], fromSafetyFilterLevel);
    }
    const fromPersonGeneration = getValueByPath(fromObject, [
      "personGeneration"
    ]);
    if (parentObject !== void 0 && fromPersonGeneration != null) {
      setValueByPath(parentObject, ["parameters", "personGeneration"], fromPersonGeneration);
    }
    const fromIncludeSafetyAttributes = getValueByPath(fromObject, [
      "includeSafetyAttributes"
    ]);
    if (parentObject !== void 0 && fromIncludeSafetyAttributes != null) {
      setValueByPath(parentObject, ["parameters", "includeSafetyAttributes"], fromIncludeSafetyAttributes);
    }
    const fromIncludeRaiReason = getValueByPath(fromObject, [
      "includeRaiReason"
    ]);
    if (parentObject !== void 0 && fromIncludeRaiReason != null) {
      setValueByPath(parentObject, ["parameters", "includeRaiReason"], fromIncludeRaiReason);
    }
    const fromLanguage = getValueByPath(fromObject, ["language"]);
    if (parentObject !== void 0 && fromLanguage != null) {
      setValueByPath(parentObject, ["parameters", "language"], fromLanguage);
    }
    const fromOutputMimeType = getValueByPath(fromObject, [
      "outputMimeType"
    ]);
    if (parentObject !== void 0 && fromOutputMimeType != null) {
      setValueByPath(parentObject, ["parameters", "outputOptions", "mimeType"], fromOutputMimeType);
    }
    const fromOutputCompressionQuality = getValueByPath(fromObject, [
      "outputCompressionQuality"
    ]);
    if (parentObject !== void 0 && fromOutputCompressionQuality != null) {
      setValueByPath(parentObject, ["parameters", "outputOptions", "compressionQuality"], fromOutputCompressionQuality);
    }
    const fromAddWatermark = getValueByPath(fromObject, ["addWatermark"]);
    if (parentObject !== void 0 && fromAddWatermark != null) {
      setValueByPath(parentObject, ["parameters", "addWatermark"], fromAddWatermark);
    }
    const fromLabels = getValueByPath(fromObject, ["labels"]);
    if (parentObject !== void 0 && fromLabels != null) {
      setValueByPath(parentObject, ["labels"], fromLabels);
    }
    const fromEditMode = getValueByPath(fromObject, ["editMode"]);
    if (parentObject !== void 0 && fromEditMode != null) {
      setValueByPath(parentObject, ["parameters", "editMode"], fromEditMode);
    }
    const fromBaseSteps = getValueByPath(fromObject, ["baseSteps"]);
    if (parentObject !== void 0 && fromBaseSteps != null) {
      setValueByPath(parentObject, ["parameters", "editConfig", "baseSteps"], fromBaseSteps);
    }
    return toObject;
  }
  function editImageParametersInternalToVertex(apiClient, fromObject) {
    const toObject = {};
    const fromModel = getValueByPath(fromObject, ["model"]);
    if (fromModel != null) {
      setValueByPath(toObject, ["_url", "model"], tModel(apiClient, fromModel));
    }
    const fromPrompt = getValueByPath(fromObject, ["prompt"]);
    if (fromPrompt != null) {
      setValueByPath(toObject, ["instances[0]", "prompt"], fromPrompt);
    }
    const fromReferenceImages = getValueByPath(fromObject, [
      "referenceImages"
    ]);
    if (fromReferenceImages != null) {
      let transformedList = fromReferenceImages;
      if (Array.isArray(transformedList)) {
        transformedList = transformedList.map((item) => {
          return referenceImageAPIInternalToVertex(item);
        });
      }
      setValueByPath(toObject, ["instances[0]", "referenceImages"], transformedList);
    }
    const fromConfig = getValueByPath(fromObject, ["config"]);
    if (fromConfig != null) {
      editImageConfigToVertex(fromConfig, toObject);
    }
    return toObject;
  }
  function editImageResponseFromVertex(fromObject) {
    const toObject = {};
    const fromSdkHttpResponse = getValueByPath(fromObject, [
      "sdkHttpResponse"
    ]);
    if (fromSdkHttpResponse != null) {
      setValueByPath(toObject, ["sdkHttpResponse"], fromSdkHttpResponse);
    }
    const fromGeneratedImages = getValueByPath(fromObject, [
      "predictions"
    ]);
    if (fromGeneratedImages != null) {
      let transformedList = fromGeneratedImages;
      if (Array.isArray(transformedList)) {
        transformedList = transformedList.map((item) => {
          return generatedImageFromVertex(item);
        });
      }
      setValueByPath(toObject, ["generatedImages"], transformedList);
    }
    return toObject;
  }
  function embedContentConfigToMldev(fromObject, parentObject) {
    const toObject = {};
    const fromTaskType = getValueByPath(fromObject, ["taskType"]);
    if (parentObject !== void 0 && fromTaskType != null) {
      setValueByPath(parentObject, ["requests[]", "taskType"], fromTaskType);
    }
    const fromTitle = getValueByPath(fromObject, ["title"]);
    if (parentObject !== void 0 && fromTitle != null) {
      setValueByPath(parentObject, ["requests[]", "title"], fromTitle);
    }
    const fromOutputDimensionality = getValueByPath(fromObject, [
      "outputDimensionality"
    ]);
    if (parentObject !== void 0 && fromOutputDimensionality != null) {
      setValueByPath(parentObject, ["requests[]", "outputDimensionality"], fromOutputDimensionality);
    }
    if (getValueByPath(fromObject, ["mimeType"]) !== void 0) {
      throw new Error("mimeType parameter is not supported in Gemini API.");
    }
    if (getValueByPath(fromObject, ["autoTruncate"]) !== void 0) {
      throw new Error("autoTruncate parameter is not supported in Gemini API.");
    }
    return toObject;
  }
  function embedContentConfigToVertex(fromObject, parentObject) {
    const toObject = {};
    const fromTaskType = getValueByPath(fromObject, ["taskType"]);
    if (parentObject !== void 0 && fromTaskType != null) {
      setValueByPath(parentObject, ["instances[]", "task_type"], fromTaskType);
    }
    const fromTitle = getValueByPath(fromObject, ["title"]);
    if (parentObject !== void 0 && fromTitle != null) {
      setValueByPath(parentObject, ["instances[]", "title"], fromTitle);
    }
    const fromOutputDimensionality = getValueByPath(fromObject, [
      "outputDimensionality"
    ]);
    if (parentObject !== void 0 && fromOutputDimensionality != null) {
      setValueByPath(parentObject, ["parameters", "outputDimensionality"], fromOutputDimensionality);
    }
    const fromMimeType = getValueByPath(fromObject, ["mimeType"]);
    if (parentObject !== void 0 && fromMimeType != null) {
      setValueByPath(parentObject, ["instances[]", "mimeType"], fromMimeType);
    }
    const fromAutoTruncate = getValueByPath(fromObject, ["autoTruncate"]);
    if (parentObject !== void 0 && fromAutoTruncate != null) {
      setValueByPath(parentObject, ["parameters", "autoTruncate"], fromAutoTruncate);
    }
    return toObject;
  }
  function embedContentParametersToMldev(apiClient, fromObject) {
    const toObject = {};
    const fromModel = getValueByPath(fromObject, ["model"]);
    if (fromModel != null) {
      setValueByPath(toObject, ["_url", "model"], tModel(apiClient, fromModel));
    }
    const fromContents = getValueByPath(fromObject, ["contents"]);
    if (fromContents != null) {
      let transformedList = tContentsForEmbed(apiClient, fromContents);
      if (Array.isArray(transformedList)) {
        transformedList = transformedList.map((item) => {
          return item;
        });
      }
      setValueByPath(toObject, ["requests[]", "content"], transformedList);
    }
    const fromConfig = getValueByPath(fromObject, ["config"]);
    if (fromConfig != null) {
      embedContentConfigToMldev(fromConfig, toObject);
    }
    const fromModelForEmbedContent = getValueByPath(fromObject, ["model"]);
    if (fromModelForEmbedContent !== void 0) {
      setValueByPath(toObject, ["requests[]", "model"], tModel(apiClient, fromModelForEmbedContent));
    }
    return toObject;
  }
  function embedContentParametersToVertex(apiClient, fromObject) {
    const toObject = {};
    const fromModel = getValueByPath(fromObject, ["model"]);
    if (fromModel != null) {
      setValueByPath(toObject, ["_url", "model"], tModel(apiClient, fromModel));
    }
    const fromContents = getValueByPath(fromObject, ["contents"]);
    if (fromContents != null) {
      let transformedList = tContentsForEmbed(apiClient, fromContents);
      if (Array.isArray(transformedList)) {
        transformedList = transformedList.map((item) => {
          return item;
        });
      }
      setValueByPath(toObject, ["instances[]", "content"], transformedList);
    }
    const fromConfig = getValueByPath(fromObject, ["config"]);
    if (fromConfig != null) {
      embedContentConfigToVertex(fromConfig, toObject);
    }
    return toObject;
  }
  function embedContentResponseFromMldev(fromObject) {
    const toObject = {};
    const fromSdkHttpResponse = getValueByPath(fromObject, [
      "sdkHttpResponse"
    ]);
    if (fromSdkHttpResponse != null) {
      setValueByPath(toObject, ["sdkHttpResponse"], fromSdkHttpResponse);
    }
    const fromEmbeddings = getValueByPath(fromObject, ["embeddings"]);
    if (fromEmbeddings != null) {
      let transformedList = fromEmbeddings;
      if (Array.isArray(transformedList)) {
        transformedList = transformedList.map((item) => {
          return item;
        });
      }
      setValueByPath(toObject, ["embeddings"], transformedList);
    }
    const fromMetadata = getValueByPath(fromObject, ["metadata"]);
    if (fromMetadata != null) {
      setValueByPath(toObject, ["metadata"], fromMetadata);
    }
    return toObject;
  }
  function embedContentResponseFromVertex(fromObject) {
    const toObject = {};
    const fromSdkHttpResponse = getValueByPath(fromObject, [
      "sdkHttpResponse"
    ]);
    if (fromSdkHttpResponse != null) {
      setValueByPath(toObject, ["sdkHttpResponse"], fromSdkHttpResponse);
    }
    const fromEmbeddings = getValueByPath(fromObject, [
      "predictions[]",
      "embeddings"
    ]);
    if (fromEmbeddings != null) {
      let transformedList = fromEmbeddings;
      if (Array.isArray(transformedList)) {
        transformedList = transformedList.map((item) => {
          return contentEmbeddingFromVertex(item);
        });
      }
      setValueByPath(toObject, ["embeddings"], transformedList);
    }
    const fromMetadata = getValueByPath(fromObject, ["metadata"]);
    if (fromMetadata != null) {
      setValueByPath(toObject, ["metadata"], fromMetadata);
    }
    return toObject;
  }
  function endpointFromVertex(fromObject) {
    const toObject = {};
    const fromName = getValueByPath(fromObject, ["endpoint"]);
    if (fromName != null) {
      setValueByPath(toObject, ["name"], fromName);
    }
    const fromDeployedModelId = getValueByPath(fromObject, [
      "deployedModelId"
    ]);
    if (fromDeployedModelId != null) {
      setValueByPath(toObject, ["deployedModelId"], fromDeployedModelId);
    }
    return toObject;
  }
  function fileDataToMldev$1(fromObject) {
    const toObject = {};
    if (getValueByPath(fromObject, ["displayName"]) !== void 0) {
      throw new Error("displayName parameter is not supported in Gemini API.");
    }
    const fromFileUri = getValueByPath(fromObject, ["fileUri"]);
    if (fromFileUri != null) {
      setValueByPath(toObject, ["fileUri"], fromFileUri);
    }
    const fromMimeType = getValueByPath(fromObject, ["mimeType"]);
    if (fromMimeType != null) {
      setValueByPath(toObject, ["mimeType"], fromMimeType);
    }
    return toObject;
  }
  function functionCallToMldev$1(fromObject) {
    const toObject = {};
    const fromId = getValueByPath(fromObject, ["id"]);
    if (fromId != null) {
      setValueByPath(toObject, ["id"], fromId);
    }
    const fromArgs = getValueByPath(fromObject, ["args"]);
    if (fromArgs != null) {
      setValueByPath(toObject, ["args"], fromArgs);
    }
    const fromName = getValueByPath(fromObject, ["name"]);
    if (fromName != null) {
      setValueByPath(toObject, ["name"], fromName);
    }
    if (getValueByPath(fromObject, ["partialArgs"]) !== void 0) {
      throw new Error("partialArgs parameter is not supported in Gemini API.");
    }
    if (getValueByPath(fromObject, ["willContinue"]) !== void 0) {
      throw new Error("willContinue parameter is not supported in Gemini API.");
    }
    return toObject;
  }
  function functionCallingConfigToMldev(fromObject) {
    const toObject = {};
    const fromMode = getValueByPath(fromObject, ["mode"]);
    if (fromMode != null) {
      setValueByPath(toObject, ["mode"], fromMode);
    }
    const fromAllowedFunctionNames = getValueByPath(fromObject, [
      "allowedFunctionNames"
    ]);
    if (fromAllowedFunctionNames != null) {
      setValueByPath(toObject, ["allowedFunctionNames"], fromAllowedFunctionNames);
    }
    if (getValueByPath(fromObject, ["streamFunctionCallArguments"]) !== void 0) {
      throw new Error("streamFunctionCallArguments parameter is not supported in Gemini API.");
    }
    return toObject;
  }
  function functionDeclarationToVertex(fromObject) {
    const toObject = {};
    if (getValueByPath(fromObject, ["behavior"]) !== void 0) {
      throw new Error("behavior parameter is not supported in Vertex AI.");
    }
    const fromDescription = getValueByPath(fromObject, ["description"]);
    if (fromDescription != null) {
      setValueByPath(toObject, ["description"], fromDescription);
    }
    const fromName = getValueByPath(fromObject, ["name"]);
    if (fromName != null) {
      setValueByPath(toObject, ["name"], fromName);
    }
    const fromParameters = getValueByPath(fromObject, ["parameters"]);
    if (fromParameters != null) {
      setValueByPath(toObject, ["parameters"], fromParameters);
    }
    const fromParametersJsonSchema = getValueByPath(fromObject, [
      "parametersJsonSchema"
    ]);
    if (fromParametersJsonSchema != null) {
      setValueByPath(toObject, ["parametersJsonSchema"], fromParametersJsonSchema);
    }
    const fromResponse = getValueByPath(fromObject, ["response"]);
    if (fromResponse != null) {
      setValueByPath(toObject, ["response"], fromResponse);
    }
    const fromResponseJsonSchema = getValueByPath(fromObject, [
      "responseJsonSchema"
    ]);
    if (fromResponseJsonSchema != null) {
      setValueByPath(toObject, ["responseJsonSchema"], fromResponseJsonSchema);
    }
    return toObject;
  }
  function generateContentConfigToMldev(apiClient, fromObject, parentObject) {
    const toObject = {};
    const fromSystemInstruction = getValueByPath(fromObject, [
      "systemInstruction"
    ]);
    if (parentObject !== void 0 && fromSystemInstruction != null) {
      setValueByPath(parentObject, ["systemInstruction"], contentToMldev$1(tContent(fromSystemInstruction)));
    }
    const fromTemperature = getValueByPath(fromObject, ["temperature"]);
    if (fromTemperature != null) {
      setValueByPath(toObject, ["temperature"], fromTemperature);
    }
    const fromTopP = getValueByPath(fromObject, ["topP"]);
    if (fromTopP != null) {
      setValueByPath(toObject, ["topP"], fromTopP);
    }
    const fromTopK = getValueByPath(fromObject, ["topK"]);
    if (fromTopK != null) {
      setValueByPath(toObject, ["topK"], fromTopK);
    }
    const fromCandidateCount = getValueByPath(fromObject, [
      "candidateCount"
    ]);
    if (fromCandidateCount != null) {
      setValueByPath(toObject, ["candidateCount"], fromCandidateCount);
    }
    const fromMaxOutputTokens = getValueByPath(fromObject, [
      "maxOutputTokens"
    ]);
    if (fromMaxOutputTokens != null) {
      setValueByPath(toObject, ["maxOutputTokens"], fromMaxOutputTokens);
    }
    const fromStopSequences = getValueByPath(fromObject, [
      "stopSequences"
    ]);
    if (fromStopSequences != null) {
      setValueByPath(toObject, ["stopSequences"], fromStopSequences);
    }
    const fromResponseLogprobs = getValueByPath(fromObject, [
      "responseLogprobs"
    ]);
    if (fromResponseLogprobs != null) {
      setValueByPath(toObject, ["responseLogprobs"], fromResponseLogprobs);
    }
    const fromLogprobs = getValueByPath(fromObject, ["logprobs"]);
    if (fromLogprobs != null) {
      setValueByPath(toObject, ["logprobs"], fromLogprobs);
    }
    const fromPresencePenalty = getValueByPath(fromObject, [
      "presencePenalty"
    ]);
    if (fromPresencePenalty != null) {
      setValueByPath(toObject, ["presencePenalty"], fromPresencePenalty);
    }
    const fromFrequencyPenalty = getValueByPath(fromObject, [
      "frequencyPenalty"
    ]);
    if (fromFrequencyPenalty != null) {
      setValueByPath(toObject, ["frequencyPenalty"], fromFrequencyPenalty);
    }
    const fromSeed = getValueByPath(fromObject, ["seed"]);
    if (fromSeed != null) {
      setValueByPath(toObject, ["seed"], fromSeed);
    }
    const fromResponseMimeType = getValueByPath(fromObject, [
      "responseMimeType"
    ]);
    if (fromResponseMimeType != null) {
      setValueByPath(toObject, ["responseMimeType"], fromResponseMimeType);
    }
    const fromResponseSchema = getValueByPath(fromObject, [
      "responseSchema"
    ]);
    if (fromResponseSchema != null) {
      setValueByPath(toObject, ["responseSchema"], tSchema(fromResponseSchema));
    }
    const fromResponseJsonSchema = getValueByPath(fromObject, [
      "responseJsonSchema"
    ]);
    if (fromResponseJsonSchema != null) {
      setValueByPath(toObject, ["responseJsonSchema"], fromResponseJsonSchema);
    }
    if (getValueByPath(fromObject, ["routingConfig"]) !== void 0) {
      throw new Error("routingConfig parameter is not supported in Gemini API.");
    }
    if (getValueByPath(fromObject, ["modelSelectionConfig"]) !== void 0) {
      throw new Error("modelSelectionConfig parameter is not supported in Gemini API.");
    }
    const fromSafetySettings = getValueByPath(fromObject, [
      "safetySettings"
    ]);
    if (parentObject !== void 0 && fromSafetySettings != null) {
      let transformedList = fromSafetySettings;
      if (Array.isArray(transformedList)) {
        transformedList = transformedList.map((item) => {
          return safetySettingToMldev(item);
        });
      }
      setValueByPath(parentObject, ["safetySettings"], transformedList);
    }
    const fromTools = getValueByPath(fromObject, ["tools"]);
    if (parentObject !== void 0 && fromTools != null) {
      let transformedList = tTools(fromTools);
      if (Array.isArray(transformedList)) {
        transformedList = transformedList.map((item) => {
          return toolToMldev$1(tTool(item));
        });
      }
      setValueByPath(parentObject, ["tools"], transformedList);
    }
    const fromToolConfig = getValueByPath(fromObject, ["toolConfig"]);
    if (parentObject !== void 0 && fromToolConfig != null) {
      setValueByPath(parentObject, ["toolConfig"], toolConfigToMldev(fromToolConfig));
    }
    if (getValueByPath(fromObject, ["labels"]) !== void 0) {
      throw new Error("labels parameter is not supported in Gemini API.");
    }
    const fromCachedContent = getValueByPath(fromObject, [
      "cachedContent"
    ]);
    if (parentObject !== void 0 && fromCachedContent != null) {
      setValueByPath(parentObject, ["cachedContent"], tCachedContentName(apiClient, fromCachedContent));
    }
    const fromResponseModalities = getValueByPath(fromObject, [
      "responseModalities"
    ]);
    if (fromResponseModalities != null) {
      setValueByPath(toObject, ["responseModalities"], fromResponseModalities);
    }
    const fromMediaResolution = getValueByPath(fromObject, [
      "mediaResolution"
    ]);
    if (fromMediaResolution != null) {
      setValueByPath(toObject, ["mediaResolution"], fromMediaResolution);
    }
    const fromSpeechConfig = getValueByPath(fromObject, ["speechConfig"]);
    if (fromSpeechConfig != null) {
      setValueByPath(toObject, ["speechConfig"], tSpeechConfig(fromSpeechConfig));
    }
    if (getValueByPath(fromObject, ["audioTimestamp"]) !== void 0) {
      throw new Error("audioTimestamp parameter is not supported in Gemini API.");
    }
    const fromThinkingConfig = getValueByPath(fromObject, [
      "thinkingConfig"
    ]);
    if (fromThinkingConfig != null) {
      setValueByPath(toObject, ["thinkingConfig"], fromThinkingConfig);
    }
    const fromImageConfig = getValueByPath(fromObject, ["imageConfig"]);
    if (fromImageConfig != null) {
      setValueByPath(toObject, ["imageConfig"], imageConfigToMldev(fromImageConfig));
    }
    return toObject;
  }
  function generateContentConfigToVertex(apiClient, fromObject, parentObject) {
    const toObject = {};
    const fromSystemInstruction = getValueByPath(fromObject, [
      "systemInstruction"
    ]);
    if (parentObject !== void 0 && fromSystemInstruction != null) {
      setValueByPath(parentObject, ["systemInstruction"], tContent(fromSystemInstruction));
    }
    const fromTemperature = getValueByPath(fromObject, ["temperature"]);
    if (fromTemperature != null) {
      setValueByPath(toObject, ["temperature"], fromTemperature);
    }
    const fromTopP = getValueByPath(fromObject, ["topP"]);
    if (fromTopP != null) {
      setValueByPath(toObject, ["topP"], fromTopP);
    }
    const fromTopK = getValueByPath(fromObject, ["topK"]);
    if (fromTopK != null) {
      setValueByPath(toObject, ["topK"], fromTopK);
    }
    const fromCandidateCount = getValueByPath(fromObject, [
      "candidateCount"
    ]);
    if (fromCandidateCount != null) {
      setValueByPath(toObject, ["candidateCount"], fromCandidateCount);
    }
    const fromMaxOutputTokens = getValueByPath(fromObject, [
      "maxOutputTokens"
    ]);
    if (fromMaxOutputTokens != null) {
      setValueByPath(toObject, ["maxOutputTokens"], fromMaxOutputTokens);
    }
    const fromStopSequences = getValueByPath(fromObject, [
      "stopSequences"
    ]);
    if (fromStopSequences != null) {
      setValueByPath(toObject, ["stopSequences"], fromStopSequences);
    }
    const fromResponseLogprobs = getValueByPath(fromObject, [
      "responseLogprobs"
    ]);
    if (fromResponseLogprobs != null) {
      setValueByPath(toObject, ["responseLogprobs"], fromResponseLogprobs);
    }
    const fromLogprobs = getValueByPath(fromObject, ["logprobs"]);
    if (fromLogprobs != null) {
      setValueByPath(toObject, ["logprobs"], fromLogprobs);
    }
    const fromPresencePenalty = getValueByPath(fromObject, [
      "presencePenalty"
    ]);
    if (fromPresencePenalty != null) {
      setValueByPath(toObject, ["presencePenalty"], fromPresencePenalty);
    }
    const fromFrequencyPenalty = getValueByPath(fromObject, [
      "frequencyPenalty"
    ]);
    if (fromFrequencyPenalty != null) {
      setValueByPath(toObject, ["frequencyPenalty"], fromFrequencyPenalty);
    }
    const fromSeed = getValueByPath(fromObject, ["seed"]);
    if (fromSeed != null) {
      setValueByPath(toObject, ["seed"], fromSeed);
    }
    const fromResponseMimeType = getValueByPath(fromObject, [
      "responseMimeType"
    ]);
    if (fromResponseMimeType != null) {
      setValueByPath(toObject, ["responseMimeType"], fromResponseMimeType);
    }
    const fromResponseSchema = getValueByPath(fromObject, [
      "responseSchema"
    ]);
    if (fromResponseSchema != null) {
      setValueByPath(toObject, ["responseSchema"], tSchema(fromResponseSchema));
    }
    const fromResponseJsonSchema = getValueByPath(fromObject, [
      "responseJsonSchema"
    ]);
    if (fromResponseJsonSchema != null) {
      setValueByPath(toObject, ["responseJsonSchema"], fromResponseJsonSchema);
    }
    const fromRoutingConfig = getValueByPath(fromObject, [
      "routingConfig"
    ]);
    if (fromRoutingConfig != null) {
      setValueByPath(toObject, ["routingConfig"], fromRoutingConfig);
    }
    const fromModelSelectionConfig = getValueByPath(fromObject, [
      "modelSelectionConfig"
    ]);
    if (fromModelSelectionConfig != null) {
      setValueByPath(toObject, ["modelConfig"], fromModelSelectionConfig);
    }
    const fromSafetySettings = getValueByPath(fromObject, [
      "safetySettings"
    ]);
    if (parentObject !== void 0 && fromSafetySettings != null) {
      let transformedList = fromSafetySettings;
      if (Array.isArray(transformedList)) {
        transformedList = transformedList.map((item) => {
          return item;
        });
      }
      setValueByPath(parentObject, ["safetySettings"], transformedList);
    }
    const fromTools = getValueByPath(fromObject, ["tools"]);
    if (parentObject !== void 0 && fromTools != null) {
      let transformedList = tTools(fromTools);
      if (Array.isArray(transformedList)) {
        transformedList = transformedList.map((item) => {
          return toolToVertex(tTool(item));
        });
      }
      setValueByPath(parentObject, ["tools"], transformedList);
    }
    const fromToolConfig = getValueByPath(fromObject, ["toolConfig"]);
    if (parentObject !== void 0 && fromToolConfig != null) {
      setValueByPath(parentObject, ["toolConfig"], fromToolConfig);
    }
    const fromLabels = getValueByPath(fromObject, ["labels"]);
    if (parentObject !== void 0 && fromLabels != null) {
      setValueByPath(parentObject, ["labels"], fromLabels);
    }
    const fromCachedContent = getValueByPath(fromObject, [
      "cachedContent"
    ]);
    if (parentObject !== void 0 && fromCachedContent != null) {
      setValueByPath(parentObject, ["cachedContent"], tCachedContentName(apiClient, fromCachedContent));
    }
    const fromResponseModalities = getValueByPath(fromObject, [
      "responseModalities"
    ]);
    if (fromResponseModalities != null) {
      setValueByPath(toObject, ["responseModalities"], fromResponseModalities);
    }
    const fromMediaResolution = getValueByPath(fromObject, [
      "mediaResolution"
    ]);
    if (fromMediaResolution != null) {
      setValueByPath(toObject, ["mediaResolution"], fromMediaResolution);
    }
    const fromSpeechConfig = getValueByPath(fromObject, ["speechConfig"]);
    if (fromSpeechConfig != null) {
      setValueByPath(toObject, ["speechConfig"], speechConfigToVertex(tSpeechConfig(fromSpeechConfig)));
    }
    const fromAudioTimestamp = getValueByPath(fromObject, [
      "audioTimestamp"
    ]);
    if (fromAudioTimestamp != null) {
      setValueByPath(toObject, ["audioTimestamp"], fromAudioTimestamp);
    }
    const fromThinkingConfig = getValueByPath(fromObject, [
      "thinkingConfig"
    ]);
    if (fromThinkingConfig != null) {
      setValueByPath(toObject, ["thinkingConfig"], fromThinkingConfig);
    }
    const fromImageConfig = getValueByPath(fromObject, ["imageConfig"]);
    if (fromImageConfig != null) {
      setValueByPath(toObject, ["imageConfig"], imageConfigToVertex(fromImageConfig));
    }
    return toObject;
  }
  function generateContentParametersToMldev(apiClient, fromObject) {
    const toObject = {};
    const fromModel = getValueByPath(fromObject, ["model"]);
    if (fromModel != null) {
      setValueByPath(toObject, ["_url", "model"], tModel(apiClient, fromModel));
    }
    const fromContents = getValueByPath(fromObject, ["contents"]);
    if (fromContents != null) {
      let transformedList = tContents(fromContents);
      if (Array.isArray(transformedList)) {
        transformedList = transformedList.map((item) => {
          return contentToMldev$1(item);
        });
      }
      setValueByPath(toObject, ["contents"], transformedList);
    }
    const fromConfig = getValueByPath(fromObject, ["config"]);
    if (fromConfig != null) {
      setValueByPath(toObject, ["generationConfig"], generateContentConfigToMldev(apiClient, fromConfig, toObject));
    }
    return toObject;
  }
  function generateContentParametersToVertex(apiClient, fromObject) {
    const toObject = {};
    const fromModel = getValueByPath(fromObject, ["model"]);
    if (fromModel != null) {
      setValueByPath(toObject, ["_url", "model"], tModel(apiClient, fromModel));
    }
    const fromContents = getValueByPath(fromObject, ["contents"]);
    if (fromContents != null) {
      let transformedList = tContents(fromContents);
      if (Array.isArray(transformedList)) {
        transformedList = transformedList.map((item) => {
          return item;
        });
      }
      setValueByPath(toObject, ["contents"], transformedList);
    }
    const fromConfig = getValueByPath(fromObject, ["config"]);
    if (fromConfig != null) {
      setValueByPath(toObject, ["generationConfig"], generateContentConfigToVertex(apiClient, fromConfig, toObject));
    }
    return toObject;
  }
  function generateContentResponseFromMldev(fromObject) {
    const toObject = {};
    const fromSdkHttpResponse = getValueByPath(fromObject, [
      "sdkHttpResponse"
    ]);
    if (fromSdkHttpResponse != null) {
      setValueByPath(toObject, ["sdkHttpResponse"], fromSdkHttpResponse);
    }
    const fromCandidates = getValueByPath(fromObject, ["candidates"]);
    if (fromCandidates != null) {
      let transformedList = fromCandidates;
      if (Array.isArray(transformedList)) {
        transformedList = transformedList.map((item) => {
          return candidateFromMldev(item);
        });
      }
      setValueByPath(toObject, ["candidates"], transformedList);
    }
    const fromModelVersion = getValueByPath(fromObject, ["modelVersion"]);
    if (fromModelVersion != null) {
      setValueByPath(toObject, ["modelVersion"], fromModelVersion);
    }
    const fromPromptFeedback = getValueByPath(fromObject, [
      "promptFeedback"
    ]);
    if (fromPromptFeedback != null) {
      setValueByPath(toObject, ["promptFeedback"], fromPromptFeedback);
    }
    const fromResponseId = getValueByPath(fromObject, ["responseId"]);
    if (fromResponseId != null) {
      setValueByPath(toObject, ["responseId"], fromResponseId);
    }
    const fromUsageMetadata = getValueByPath(fromObject, [
      "usageMetadata"
    ]);
    if (fromUsageMetadata != null) {
      setValueByPath(toObject, ["usageMetadata"], fromUsageMetadata);
    }
    return toObject;
  }
  function generateContentResponseFromVertex(fromObject) {
    const toObject = {};
    const fromSdkHttpResponse = getValueByPath(fromObject, [
      "sdkHttpResponse"
    ]);
    if (fromSdkHttpResponse != null) {
      setValueByPath(toObject, ["sdkHttpResponse"], fromSdkHttpResponse);
    }
    const fromCandidates = getValueByPath(fromObject, ["candidates"]);
    if (fromCandidates != null) {
      let transformedList = fromCandidates;
      if (Array.isArray(transformedList)) {
        transformedList = transformedList.map((item) => {
          return item;
        });
      }
      setValueByPath(toObject, ["candidates"], transformedList);
    }
    const fromCreateTime = getValueByPath(fromObject, ["createTime"]);
    if (fromCreateTime != null) {
      setValueByPath(toObject, ["createTime"], fromCreateTime);
    }
    const fromModelVersion = getValueByPath(fromObject, ["modelVersion"]);
    if (fromModelVersion != null) {
      setValueByPath(toObject, ["modelVersion"], fromModelVersion);
    }
    const fromPromptFeedback = getValueByPath(fromObject, [
      "promptFeedback"
    ]);
    if (fromPromptFeedback != null) {
      setValueByPath(toObject, ["promptFeedback"], fromPromptFeedback);
    }
    const fromResponseId = getValueByPath(fromObject, ["responseId"]);
    if (fromResponseId != null) {
      setValueByPath(toObject, ["responseId"], fromResponseId);
    }
    const fromUsageMetadata = getValueByPath(fromObject, [
      "usageMetadata"
    ]);
    if (fromUsageMetadata != null) {
      setValueByPath(toObject, ["usageMetadata"], fromUsageMetadata);
    }
    return toObject;
  }
  function generateImagesConfigToMldev(fromObject, parentObject) {
    const toObject = {};
    if (getValueByPath(fromObject, ["outputGcsUri"]) !== void 0) {
      throw new Error("outputGcsUri parameter is not supported in Gemini API.");
    }
    if (getValueByPath(fromObject, ["negativePrompt"]) !== void 0) {
      throw new Error("negativePrompt parameter is not supported in Gemini API.");
    }
    const fromNumberOfImages = getValueByPath(fromObject, [
      "numberOfImages"
    ]);
    if (parentObject !== void 0 && fromNumberOfImages != null) {
      setValueByPath(parentObject, ["parameters", "sampleCount"], fromNumberOfImages);
    }
    const fromAspectRatio = getValueByPath(fromObject, ["aspectRatio"]);
    if (parentObject !== void 0 && fromAspectRatio != null) {
      setValueByPath(parentObject, ["parameters", "aspectRatio"], fromAspectRatio);
    }
    const fromGuidanceScale = getValueByPath(fromObject, [
      "guidanceScale"
    ]);
    if (parentObject !== void 0 && fromGuidanceScale != null) {
      setValueByPath(parentObject, ["parameters", "guidanceScale"], fromGuidanceScale);
    }
    if (getValueByPath(fromObject, ["seed"]) !== void 0) {
      throw new Error("seed parameter is not supported in Gemini API.");
    }
    const fromSafetyFilterLevel = getValueByPath(fromObject, [
      "safetyFilterLevel"
    ]);
    if (parentObject !== void 0 && fromSafetyFilterLevel != null) {
      setValueByPath(parentObject, ["parameters", "safetySetting"], fromSafetyFilterLevel);
    }
    const fromPersonGeneration = getValueByPath(fromObject, [
      "personGeneration"
    ]);
    if (parentObject !== void 0 && fromPersonGeneration != null) {
      setValueByPath(parentObject, ["parameters", "personGeneration"], fromPersonGeneration);
    }
    const fromIncludeSafetyAttributes = getValueByPath(fromObject, [
      "includeSafetyAttributes"
    ]);
    if (parentObject !== void 0 && fromIncludeSafetyAttributes != null) {
      setValueByPath(parentObject, ["parameters", "includeSafetyAttributes"], fromIncludeSafetyAttributes);
    }
    const fromIncludeRaiReason = getValueByPath(fromObject, [
      "includeRaiReason"
    ]);
    if (parentObject !== void 0 && fromIncludeRaiReason != null) {
      setValueByPath(parentObject, ["parameters", "includeRaiReason"], fromIncludeRaiReason);
    }
    const fromLanguage = getValueByPath(fromObject, ["language"]);
    if (parentObject !== void 0 && fromLanguage != null) {
      setValueByPath(parentObject, ["parameters", "language"], fromLanguage);
    }
    const fromOutputMimeType = getValueByPath(fromObject, [
      "outputMimeType"
    ]);
    if (parentObject !== void 0 && fromOutputMimeType != null) {
      setValueByPath(parentObject, ["parameters", "outputOptions", "mimeType"], fromOutputMimeType);
    }
    const fromOutputCompressionQuality = getValueByPath(fromObject, [
      "outputCompressionQuality"
    ]);
    if (parentObject !== void 0 && fromOutputCompressionQuality != null) {
      setValueByPath(parentObject, ["parameters", "outputOptions", "compressionQuality"], fromOutputCompressionQuality);
    }
    if (getValueByPath(fromObject, ["addWatermark"]) !== void 0) {
      throw new Error("addWatermark parameter is not supported in Gemini API.");
    }
    if (getValueByPath(fromObject, ["labels"]) !== void 0) {
      throw new Error("labels parameter is not supported in Gemini API.");
    }
    const fromImageSize = getValueByPath(fromObject, ["imageSize"]);
    if (parentObject !== void 0 && fromImageSize != null) {
      setValueByPath(parentObject, ["parameters", "sampleImageSize"], fromImageSize);
    }
    if (getValueByPath(fromObject, ["enhancePrompt"]) !== void 0) {
      throw new Error("enhancePrompt parameter is not supported in Gemini API.");
    }
    return toObject;
  }
  function generateImagesConfigToVertex(fromObject, parentObject) {
    const toObject = {};
    const fromOutputGcsUri = getValueByPath(fromObject, ["outputGcsUri"]);
    if (parentObject !== void 0 && fromOutputGcsUri != null) {
      setValueByPath(parentObject, ["parameters", "storageUri"], fromOutputGcsUri);
    }
    const fromNegativePrompt = getValueByPath(fromObject, [
      "negativePrompt"
    ]);
    if (parentObject !== void 0 && fromNegativePrompt != null) {
      setValueByPath(parentObject, ["parameters", "negativePrompt"], fromNegativePrompt);
    }
    const fromNumberOfImages = getValueByPath(fromObject, [
      "numberOfImages"
    ]);
    if (parentObject !== void 0 && fromNumberOfImages != null) {
      setValueByPath(parentObject, ["parameters", "sampleCount"], fromNumberOfImages);
    }
    const fromAspectRatio = getValueByPath(fromObject, ["aspectRatio"]);
    if (parentObject !== void 0 && fromAspectRatio != null) {
      setValueByPath(parentObject, ["parameters", "aspectRatio"], fromAspectRatio);
    }
    const fromGuidanceScale = getValueByPath(fromObject, [
      "guidanceScale"
    ]);
    if (parentObject !== void 0 && fromGuidanceScale != null) {
      setValueByPath(parentObject, ["parameters", "guidanceScale"], fromGuidanceScale);
    }
    const fromSeed = getValueByPath(fromObject, ["seed"]);
    if (parentObject !== void 0 && fromSeed != null) {
      setValueByPath(parentObject, ["parameters", "seed"], fromSeed);
    }
    const fromSafetyFilterLevel = getValueByPath(fromObject, [
      "safetyFilterLevel"
    ]);
    if (parentObject !== void 0 && fromSafetyFilterLevel != null) {
      setValueByPath(parentObject, ["parameters", "safetySetting"], fromSafetyFilterLevel);
    }
    const fromPersonGeneration = getValueByPath(fromObject, [
      "personGeneration"
    ]);
    if (parentObject !== void 0 && fromPersonGeneration != null) {
      setValueByPath(parentObject, ["parameters", "personGeneration"], fromPersonGeneration);
    }
    const fromIncludeSafetyAttributes = getValueByPath(fromObject, [
      "includeSafetyAttributes"
    ]);
    if (parentObject !== void 0 && fromIncludeSafetyAttributes != null) {
      setValueByPath(parentObject, ["parameters", "includeSafetyAttributes"], fromIncludeSafetyAttributes);
    }
    const fromIncludeRaiReason = getValueByPath(fromObject, [
      "includeRaiReason"
    ]);
    if (parentObject !== void 0 && fromIncludeRaiReason != null) {
      setValueByPath(parentObject, ["parameters", "includeRaiReason"], fromIncludeRaiReason);
    }
    const fromLanguage = getValueByPath(fromObject, ["language"]);
    if (parentObject !== void 0 && fromLanguage != null) {
      setValueByPath(parentObject, ["parameters", "language"], fromLanguage);
    }
    const fromOutputMimeType = getValueByPath(fromObject, [
      "outputMimeType"
    ]);
    if (parentObject !== void 0 && fromOutputMimeType != null) {
      setValueByPath(parentObject, ["parameters", "outputOptions", "mimeType"], fromOutputMimeType);
    }
    const fromOutputCompressionQuality = getValueByPath(fromObject, [
      "outputCompressionQuality"
    ]);
    if (parentObject !== void 0 && fromOutputCompressionQuality != null) {
      setValueByPath(parentObject, ["parameters", "outputOptions", "compressionQuality"], fromOutputCompressionQuality);
    }
    const fromAddWatermark = getValueByPath(fromObject, ["addWatermark"]);
    if (parentObject !== void 0 && fromAddWatermark != null) {
      setValueByPath(parentObject, ["parameters", "addWatermark"], fromAddWatermark);
    }
    const fromLabels = getValueByPath(fromObject, ["labels"]);
    if (parentObject !== void 0 && fromLabels != null) {
      setValueByPath(parentObject, ["labels"], fromLabels);
    }
    const fromImageSize = getValueByPath(fromObject, ["imageSize"]);
    if (parentObject !== void 0 && fromImageSize != null) {
      setValueByPath(parentObject, ["parameters", "sampleImageSize"], fromImageSize);
    }
    const fromEnhancePrompt = getValueByPath(fromObject, [
      "enhancePrompt"
    ]);
    if (parentObject !== void 0 && fromEnhancePrompt != null) {
      setValueByPath(parentObject, ["parameters", "enhancePrompt"], fromEnhancePrompt);
    }
    return toObject;
  }
  function generateImagesParametersToMldev(apiClient, fromObject) {
    const toObject = {};
    const fromModel = getValueByPath(fromObject, ["model"]);
    if (fromModel != null) {
      setValueByPath(toObject, ["_url", "model"], tModel(apiClient, fromModel));
    }
    const fromPrompt = getValueByPath(fromObject, ["prompt"]);
    if (fromPrompt != null) {
      setValueByPath(toObject, ["instances[0]", "prompt"], fromPrompt);
    }
    const fromConfig = getValueByPath(fromObject, ["config"]);
    if (fromConfig != null) {
      generateImagesConfigToMldev(fromConfig, toObject);
    }
    return toObject;
  }
  function generateImagesParametersToVertex(apiClient, fromObject) {
    const toObject = {};
    const fromModel = getValueByPath(fromObject, ["model"]);
    if (fromModel != null) {
      setValueByPath(toObject, ["_url", "model"], tModel(apiClient, fromModel));
    }
    const fromPrompt = getValueByPath(fromObject, ["prompt"]);
    if (fromPrompt != null) {
      setValueByPath(toObject, ["instances[0]", "prompt"], fromPrompt);
    }
    const fromConfig = getValueByPath(fromObject, ["config"]);
    if (fromConfig != null) {
      generateImagesConfigToVertex(fromConfig, toObject);
    }
    return toObject;
  }
  function generateImagesResponseFromMldev(fromObject) {
    const toObject = {};
    const fromSdkHttpResponse = getValueByPath(fromObject, [
      "sdkHttpResponse"
    ]);
    if (fromSdkHttpResponse != null) {
      setValueByPath(toObject, ["sdkHttpResponse"], fromSdkHttpResponse);
    }
    const fromGeneratedImages = getValueByPath(fromObject, [
      "predictions"
    ]);
    if (fromGeneratedImages != null) {
      let transformedList = fromGeneratedImages;
      if (Array.isArray(transformedList)) {
        transformedList = transformedList.map((item) => {
          return generatedImageFromMldev(item);
        });
      }
      setValueByPath(toObject, ["generatedImages"], transformedList);
    }
    const fromPositivePromptSafetyAttributes = getValueByPath(fromObject, [
      "positivePromptSafetyAttributes"
    ]);
    if (fromPositivePromptSafetyAttributes != null) {
      setValueByPath(toObject, ["positivePromptSafetyAttributes"], safetyAttributesFromMldev(fromPositivePromptSafetyAttributes));
    }
    return toObject;
  }
  function generateImagesResponseFromVertex(fromObject) {
    const toObject = {};
    const fromSdkHttpResponse = getValueByPath(fromObject, [
      "sdkHttpResponse"
    ]);
    if (fromSdkHttpResponse != null) {
      setValueByPath(toObject, ["sdkHttpResponse"], fromSdkHttpResponse);
    }
    const fromGeneratedImages = getValueByPath(fromObject, [
      "predictions"
    ]);
    if (fromGeneratedImages != null) {
      let transformedList = fromGeneratedImages;
      if (Array.isArray(transformedList)) {
        transformedList = transformedList.map((item) => {
          return generatedImageFromVertex(item);
        });
      }
      setValueByPath(toObject, ["generatedImages"], transformedList);
    }
    const fromPositivePromptSafetyAttributes = getValueByPath(fromObject, [
      "positivePromptSafetyAttributes"
    ]);
    if (fromPositivePromptSafetyAttributes != null) {
      setValueByPath(toObject, ["positivePromptSafetyAttributes"], safetyAttributesFromVertex(fromPositivePromptSafetyAttributes));
    }
    return toObject;
  }
  function generateVideosConfigToMldev(fromObject, parentObject) {
    const toObject = {};
    const fromNumberOfVideos = getValueByPath(fromObject, [
      "numberOfVideos"
    ]);
    if (parentObject !== void 0 && fromNumberOfVideos != null) {
      setValueByPath(parentObject, ["parameters", "sampleCount"], fromNumberOfVideos);
    }
    if (getValueByPath(fromObject, ["outputGcsUri"]) !== void 0) {
      throw new Error("outputGcsUri parameter is not supported in Gemini API.");
    }
    if (getValueByPath(fromObject, ["fps"]) !== void 0) {
      throw new Error("fps parameter is not supported in Gemini API.");
    }
    const fromDurationSeconds = getValueByPath(fromObject, [
      "durationSeconds"
    ]);
    if (parentObject !== void 0 && fromDurationSeconds != null) {
      setValueByPath(parentObject, ["parameters", "durationSeconds"], fromDurationSeconds);
    }
    if (getValueByPath(fromObject, ["seed"]) !== void 0) {
      throw new Error("seed parameter is not supported in Gemini API.");
    }
    const fromAspectRatio = getValueByPath(fromObject, ["aspectRatio"]);
    if (parentObject !== void 0 && fromAspectRatio != null) {
      setValueByPath(parentObject, ["parameters", "aspectRatio"], fromAspectRatio);
    }
    const fromResolution = getValueByPath(fromObject, ["resolution"]);
    if (parentObject !== void 0 && fromResolution != null) {
      setValueByPath(parentObject, ["parameters", "resolution"], fromResolution);
    }
    const fromPersonGeneration = getValueByPath(fromObject, [
      "personGeneration"
    ]);
    if (parentObject !== void 0 && fromPersonGeneration != null) {
      setValueByPath(parentObject, ["parameters", "personGeneration"], fromPersonGeneration);
    }
    if (getValueByPath(fromObject, ["pubsubTopic"]) !== void 0) {
      throw new Error("pubsubTopic parameter is not supported in Gemini API.");
    }
    const fromNegativePrompt = getValueByPath(fromObject, [
      "negativePrompt"
    ]);
    if (parentObject !== void 0 && fromNegativePrompt != null) {
      setValueByPath(parentObject, ["parameters", "negativePrompt"], fromNegativePrompt);
    }
    const fromEnhancePrompt = getValueByPath(fromObject, [
      "enhancePrompt"
    ]);
    if (parentObject !== void 0 && fromEnhancePrompt != null) {
      setValueByPath(parentObject, ["parameters", "enhancePrompt"], fromEnhancePrompt);
    }
    if (getValueByPath(fromObject, ["generateAudio"]) !== void 0) {
      throw new Error("generateAudio parameter is not supported in Gemini API.");
    }
    const fromLastFrame = getValueByPath(fromObject, ["lastFrame"]);
    if (parentObject !== void 0 && fromLastFrame != null) {
      setValueByPath(parentObject, ["instances[0]", "lastFrame"], imageToMldev(fromLastFrame));
    }
    const fromReferenceImages = getValueByPath(fromObject, [
      "referenceImages"
    ]);
    if (parentObject !== void 0 && fromReferenceImages != null) {
      let transformedList = fromReferenceImages;
      if (Array.isArray(transformedList)) {
        transformedList = transformedList.map((item) => {
          return videoGenerationReferenceImageToMldev(item);
        });
      }
      setValueByPath(parentObject, ["instances[0]", "referenceImages"], transformedList);
    }
    if (getValueByPath(fromObject, ["mask"]) !== void 0) {
      throw new Error("mask parameter is not supported in Gemini API.");
    }
    if (getValueByPath(fromObject, ["compressionQuality"]) !== void 0) {
      throw new Error("compressionQuality parameter is not supported in Gemini API.");
    }
    return toObject;
  }
  function generateVideosConfigToVertex(fromObject, parentObject) {
    const toObject = {};
    const fromNumberOfVideos = getValueByPath(fromObject, [
      "numberOfVideos"
    ]);
    if (parentObject !== void 0 && fromNumberOfVideos != null) {
      setValueByPath(parentObject, ["parameters", "sampleCount"], fromNumberOfVideos);
    }
    const fromOutputGcsUri = getValueByPath(fromObject, ["outputGcsUri"]);
    if (parentObject !== void 0 && fromOutputGcsUri != null) {
      setValueByPath(parentObject, ["parameters", "storageUri"], fromOutputGcsUri);
    }
    const fromFps = getValueByPath(fromObject, ["fps"]);
    if (parentObject !== void 0 && fromFps != null) {
      setValueByPath(parentObject, ["parameters", "fps"], fromFps);
    }
    const fromDurationSeconds = getValueByPath(fromObject, [
      "durationSeconds"
    ]);
    if (parentObject !== void 0 && fromDurationSeconds != null) {
      setValueByPath(parentObject, ["parameters", "durationSeconds"], fromDurationSeconds);
    }
    const fromSeed = getValueByPath(fromObject, ["seed"]);
    if (parentObject !== void 0 && fromSeed != null) {
      setValueByPath(parentObject, ["parameters", "seed"], fromSeed);
    }
    const fromAspectRatio = getValueByPath(fromObject, ["aspectRatio"]);
    if (parentObject !== void 0 && fromAspectRatio != null) {
      setValueByPath(parentObject, ["parameters", "aspectRatio"], fromAspectRatio);
    }
    const fromResolution = getValueByPath(fromObject, ["resolution"]);
    if (parentObject !== void 0 && fromResolution != null) {
      setValueByPath(parentObject, ["parameters", "resolution"], fromResolution);
    }
    const fromPersonGeneration = getValueByPath(fromObject, [
      "personGeneration"
    ]);
    if (parentObject !== void 0 && fromPersonGeneration != null) {
      setValueByPath(parentObject, ["parameters", "personGeneration"], fromPersonGeneration);
    }
    const fromPubsubTopic = getValueByPath(fromObject, ["pubsubTopic"]);
    if (parentObject !== void 0 && fromPubsubTopic != null) {
      setValueByPath(parentObject, ["parameters", "pubsubTopic"], fromPubsubTopic);
    }
    const fromNegativePrompt = getValueByPath(fromObject, [
      "negativePrompt"
    ]);
    if (parentObject !== void 0 && fromNegativePrompt != null) {
      setValueByPath(parentObject, ["parameters", "negativePrompt"], fromNegativePrompt);
    }
    const fromEnhancePrompt = getValueByPath(fromObject, [
      "enhancePrompt"
    ]);
    if (parentObject !== void 0 && fromEnhancePrompt != null) {
      setValueByPath(parentObject, ["parameters", "enhancePrompt"], fromEnhancePrompt);
    }
    const fromGenerateAudio = getValueByPath(fromObject, [
      "generateAudio"
    ]);
    if (parentObject !== void 0 && fromGenerateAudio != null) {
      setValueByPath(parentObject, ["parameters", "generateAudio"], fromGenerateAudio);
    }
    const fromLastFrame = getValueByPath(fromObject, ["lastFrame"]);
    if (parentObject !== void 0 && fromLastFrame != null) {
      setValueByPath(parentObject, ["instances[0]", "lastFrame"], imageToVertex(fromLastFrame));
    }
    const fromReferenceImages = getValueByPath(fromObject, [
      "referenceImages"
    ]);
    if (parentObject !== void 0 && fromReferenceImages != null) {
      let transformedList = fromReferenceImages;
      if (Array.isArray(transformedList)) {
        transformedList = transformedList.map((item) => {
          return videoGenerationReferenceImageToVertex(item);
        });
      }
      setValueByPath(parentObject, ["instances[0]", "referenceImages"], transformedList);
    }
    const fromMask = getValueByPath(fromObject, ["mask"]);
    if (parentObject !== void 0 && fromMask != null) {
      setValueByPath(parentObject, ["instances[0]", "mask"], videoGenerationMaskToVertex(fromMask));
    }
    const fromCompressionQuality = getValueByPath(fromObject, [
      "compressionQuality"
    ]);
    if (parentObject !== void 0 && fromCompressionQuality != null) {
      setValueByPath(parentObject, ["parameters", "compressionQuality"], fromCompressionQuality);
    }
    return toObject;
  }
  function generateVideosOperationFromMldev(fromObject) {
    const toObject = {};
    const fromName = getValueByPath(fromObject, ["name"]);
    if (fromName != null) {
      setValueByPath(toObject, ["name"], fromName);
    }
    const fromMetadata = getValueByPath(fromObject, ["metadata"]);
    if (fromMetadata != null) {
      setValueByPath(toObject, ["metadata"], fromMetadata);
    }
    const fromDone = getValueByPath(fromObject, ["done"]);
    if (fromDone != null) {
      setValueByPath(toObject, ["done"], fromDone);
    }
    const fromError = getValueByPath(fromObject, ["error"]);
    if (fromError != null) {
      setValueByPath(toObject, ["error"], fromError);
    }
    const fromResponse = getValueByPath(fromObject, [
      "response",
      "generateVideoResponse"
    ]);
    if (fromResponse != null) {
      setValueByPath(toObject, ["response"], generateVideosResponseFromMldev(fromResponse));
    }
    return toObject;
  }
  function generateVideosOperationFromVertex(fromObject) {
    const toObject = {};
    const fromName = getValueByPath(fromObject, ["name"]);
    if (fromName != null) {
      setValueByPath(toObject, ["name"], fromName);
    }
    const fromMetadata = getValueByPath(fromObject, ["metadata"]);
    if (fromMetadata != null) {
      setValueByPath(toObject, ["metadata"], fromMetadata);
    }
    const fromDone = getValueByPath(fromObject, ["done"]);
    if (fromDone != null) {
      setValueByPath(toObject, ["done"], fromDone);
    }
    const fromError = getValueByPath(fromObject, ["error"]);
    if (fromError != null) {
      setValueByPath(toObject, ["error"], fromError);
    }
    const fromResponse = getValueByPath(fromObject, ["response"]);
    if (fromResponse != null) {
      setValueByPath(toObject, ["response"], generateVideosResponseFromVertex(fromResponse));
    }
    return toObject;
  }
  function generateVideosParametersToMldev(apiClient, fromObject) {
    const toObject = {};
    const fromModel = getValueByPath(fromObject, ["model"]);
    if (fromModel != null) {
      setValueByPath(toObject, ["_url", "model"], tModel(apiClient, fromModel));
    }
    const fromPrompt = getValueByPath(fromObject, ["prompt"]);
    if (fromPrompt != null) {
      setValueByPath(toObject, ["instances[0]", "prompt"], fromPrompt);
    }
    const fromImage = getValueByPath(fromObject, ["image"]);
    if (fromImage != null) {
      setValueByPath(toObject, ["instances[0]", "image"], imageToMldev(fromImage));
    }
    const fromVideo = getValueByPath(fromObject, ["video"]);
    if (fromVideo != null) {
      setValueByPath(toObject, ["instances[0]", "video"], videoToMldev(fromVideo));
    }
    const fromSource = getValueByPath(fromObject, ["source"]);
    if (fromSource != null) {
      generateVideosSourceToMldev(fromSource, toObject);
    }
    const fromConfig = getValueByPath(fromObject, ["config"]);
    if (fromConfig != null) {
      generateVideosConfigToMldev(fromConfig, toObject);
    }
    return toObject;
  }
  function generateVideosParametersToVertex(apiClient, fromObject) {
    const toObject = {};
    const fromModel = getValueByPath(fromObject, ["model"]);
    if (fromModel != null) {
      setValueByPath(toObject, ["_url", "model"], tModel(apiClient, fromModel));
    }
    const fromPrompt = getValueByPath(fromObject, ["prompt"]);
    if (fromPrompt != null) {
      setValueByPath(toObject, ["instances[0]", "prompt"], fromPrompt);
    }
    const fromImage = getValueByPath(fromObject, ["image"]);
    if (fromImage != null) {
      setValueByPath(toObject, ["instances[0]", "image"], imageToVertex(fromImage));
    }
    const fromVideo = getValueByPath(fromObject, ["video"]);
    if (fromVideo != null) {
      setValueByPath(toObject, ["instances[0]", "video"], videoToVertex(fromVideo));
    }
    const fromSource = getValueByPath(fromObject, ["source"]);
    if (fromSource != null) {
      generateVideosSourceToVertex(fromSource, toObject);
    }
    const fromConfig = getValueByPath(fromObject, ["config"]);
    if (fromConfig != null) {
      generateVideosConfigToVertex(fromConfig, toObject);
    }
    return toObject;
  }
  function generateVideosResponseFromMldev(fromObject) {
    const toObject = {};
    const fromGeneratedVideos = getValueByPath(fromObject, [
      "generatedSamples"
    ]);
    if (fromGeneratedVideos != null) {
      let transformedList = fromGeneratedVideos;
      if (Array.isArray(transformedList)) {
        transformedList = transformedList.map((item) => {
          return generatedVideoFromMldev(item);
        });
      }
      setValueByPath(toObject, ["generatedVideos"], transformedList);
    }
    const fromRaiMediaFilteredCount = getValueByPath(fromObject, [
      "raiMediaFilteredCount"
    ]);
    if (fromRaiMediaFilteredCount != null) {
      setValueByPath(toObject, ["raiMediaFilteredCount"], fromRaiMediaFilteredCount);
    }
    const fromRaiMediaFilteredReasons = getValueByPath(fromObject, [
      "raiMediaFilteredReasons"
    ]);
    if (fromRaiMediaFilteredReasons != null) {
      setValueByPath(toObject, ["raiMediaFilteredReasons"], fromRaiMediaFilteredReasons);
    }
    return toObject;
  }
  function generateVideosResponseFromVertex(fromObject) {
    const toObject = {};
    const fromGeneratedVideos = getValueByPath(fromObject, ["videos"]);
    if (fromGeneratedVideos != null) {
      let transformedList = fromGeneratedVideos;
      if (Array.isArray(transformedList)) {
        transformedList = transformedList.map((item) => {
          return generatedVideoFromVertex(item);
        });
      }
      setValueByPath(toObject, ["generatedVideos"], transformedList);
    }
    const fromRaiMediaFilteredCount = getValueByPath(fromObject, [
      "raiMediaFilteredCount"
    ]);
    if (fromRaiMediaFilteredCount != null) {
      setValueByPath(toObject, ["raiMediaFilteredCount"], fromRaiMediaFilteredCount);
    }
    const fromRaiMediaFilteredReasons = getValueByPath(fromObject, [
      "raiMediaFilteredReasons"
    ]);
    if (fromRaiMediaFilteredReasons != null) {
      setValueByPath(toObject, ["raiMediaFilteredReasons"], fromRaiMediaFilteredReasons);
    }
    return toObject;
  }
  function generateVideosSourceToMldev(fromObject, parentObject) {
    const toObject = {};
    const fromPrompt = getValueByPath(fromObject, ["prompt"]);
    if (parentObject !== void 0 && fromPrompt != null) {
      setValueByPath(parentObject, ["instances[0]", "prompt"], fromPrompt);
    }
    const fromImage = getValueByPath(fromObject, ["image"]);
    if (parentObject !== void 0 && fromImage != null) {
      setValueByPath(parentObject, ["instances[0]", "image"], imageToMldev(fromImage));
    }
    const fromVideo = getValueByPath(fromObject, ["video"]);
    if (parentObject !== void 0 && fromVideo != null) {
      setValueByPath(parentObject, ["instances[0]", "video"], videoToMldev(fromVideo));
    }
    return toObject;
  }
  function generateVideosSourceToVertex(fromObject, parentObject) {
    const toObject = {};
    const fromPrompt = getValueByPath(fromObject, ["prompt"]);
    if (parentObject !== void 0 && fromPrompt != null) {
      setValueByPath(parentObject, ["instances[0]", "prompt"], fromPrompt);
    }
    const fromImage = getValueByPath(fromObject, ["image"]);
    if (parentObject !== void 0 && fromImage != null) {
      setValueByPath(parentObject, ["instances[0]", "image"], imageToVertex(fromImage));
    }
    const fromVideo = getValueByPath(fromObject, ["video"]);
    if (parentObject !== void 0 && fromVideo != null) {
      setValueByPath(parentObject, ["instances[0]", "video"], videoToVertex(fromVideo));
    }
    return toObject;
  }
  function generatedImageFromMldev(fromObject) {
    const toObject = {};
    const fromImage = getValueByPath(fromObject, ["_self"]);
    if (fromImage != null) {
      setValueByPath(toObject, ["image"], imageFromMldev(fromImage));
    }
    const fromRaiFilteredReason = getValueByPath(fromObject, [
      "raiFilteredReason"
    ]);
    if (fromRaiFilteredReason != null) {
      setValueByPath(toObject, ["raiFilteredReason"], fromRaiFilteredReason);
    }
    const fromSafetyAttributes = getValueByPath(fromObject, ["_self"]);
    if (fromSafetyAttributes != null) {
      setValueByPath(toObject, ["safetyAttributes"], safetyAttributesFromMldev(fromSafetyAttributes));
    }
    return toObject;
  }
  function generatedImageFromVertex(fromObject) {
    const toObject = {};
    const fromImage = getValueByPath(fromObject, ["_self"]);
    if (fromImage != null) {
      setValueByPath(toObject, ["image"], imageFromVertex(fromImage));
    }
    const fromRaiFilteredReason = getValueByPath(fromObject, [
      "raiFilteredReason"
    ]);
    if (fromRaiFilteredReason != null) {
      setValueByPath(toObject, ["raiFilteredReason"], fromRaiFilteredReason);
    }
    const fromSafetyAttributes = getValueByPath(fromObject, ["_self"]);
    if (fromSafetyAttributes != null) {
      setValueByPath(toObject, ["safetyAttributes"], safetyAttributesFromVertex(fromSafetyAttributes));
    }
    const fromEnhancedPrompt = getValueByPath(fromObject, ["prompt"]);
    if (fromEnhancedPrompt != null) {
      setValueByPath(toObject, ["enhancedPrompt"], fromEnhancedPrompt);
    }
    return toObject;
  }
  function generatedImageMaskFromVertex(fromObject) {
    const toObject = {};
    const fromMask = getValueByPath(fromObject, ["_self"]);
    if (fromMask != null) {
      setValueByPath(toObject, ["mask"], imageFromVertex(fromMask));
    }
    const fromLabels = getValueByPath(fromObject, ["labels"]);
    if (fromLabels != null) {
      let transformedList = fromLabels;
      if (Array.isArray(transformedList)) {
        transformedList = transformedList.map((item) => {
          return item;
        });
      }
      setValueByPath(toObject, ["labels"], transformedList);
    }
    return toObject;
  }
  function generatedVideoFromMldev(fromObject) {
    const toObject = {};
    const fromVideo = getValueByPath(fromObject, ["video"]);
    if (fromVideo != null) {
      setValueByPath(toObject, ["video"], videoFromMldev(fromVideo));
    }
    return toObject;
  }
  function generatedVideoFromVertex(fromObject) {
    const toObject = {};
    const fromVideo = getValueByPath(fromObject, ["_self"]);
    if (fromVideo != null) {
      setValueByPath(toObject, ["video"], videoFromVertex(fromVideo));
    }
    return toObject;
  }
  function generationConfigToVertex(fromObject) {
    const toObject = {};
    const fromModelSelectionConfig = getValueByPath(fromObject, [
      "modelSelectionConfig"
    ]);
    if (fromModelSelectionConfig != null) {
      setValueByPath(toObject, ["modelConfig"], fromModelSelectionConfig);
    }
    const fromResponseJsonSchema = getValueByPath(fromObject, [
      "responseJsonSchema"
    ]);
    if (fromResponseJsonSchema != null) {
      setValueByPath(toObject, ["responseJsonSchema"], fromResponseJsonSchema);
    }
    const fromAudioTimestamp = getValueByPath(fromObject, [
      "audioTimestamp"
    ]);
    if (fromAudioTimestamp != null) {
      setValueByPath(toObject, ["audioTimestamp"], fromAudioTimestamp);
    }
    const fromCandidateCount = getValueByPath(fromObject, [
      "candidateCount"
    ]);
    if (fromCandidateCount != null) {
      setValueByPath(toObject, ["candidateCount"], fromCandidateCount);
    }
    const fromEnableAffectiveDialog = getValueByPath(fromObject, [
      "enableAffectiveDialog"
    ]);
    if (fromEnableAffectiveDialog != null) {
      setValueByPath(toObject, ["enableAffectiveDialog"], fromEnableAffectiveDialog);
    }
    const fromFrequencyPenalty = getValueByPath(fromObject, [
      "frequencyPenalty"
    ]);
    if (fromFrequencyPenalty != null) {
      setValueByPath(toObject, ["frequencyPenalty"], fromFrequencyPenalty);
    }
    const fromLogprobs = getValueByPath(fromObject, ["logprobs"]);
    if (fromLogprobs != null) {
      setValueByPath(toObject, ["logprobs"], fromLogprobs);
    }
    const fromMaxOutputTokens = getValueByPath(fromObject, [
      "maxOutputTokens"
    ]);
    if (fromMaxOutputTokens != null) {
      setValueByPath(toObject, ["maxOutputTokens"], fromMaxOutputTokens);
    }
    const fromMediaResolution = getValueByPath(fromObject, [
      "mediaResolution"
    ]);
    if (fromMediaResolution != null) {
      setValueByPath(toObject, ["mediaResolution"], fromMediaResolution);
    }
    const fromPresencePenalty = getValueByPath(fromObject, [
      "presencePenalty"
    ]);
    if (fromPresencePenalty != null) {
      setValueByPath(toObject, ["presencePenalty"], fromPresencePenalty);
    }
    const fromResponseLogprobs = getValueByPath(fromObject, [
      "responseLogprobs"
    ]);
    if (fromResponseLogprobs != null) {
      setValueByPath(toObject, ["responseLogprobs"], fromResponseLogprobs);
    }
    const fromResponseMimeType = getValueByPath(fromObject, [
      "responseMimeType"
    ]);
    if (fromResponseMimeType != null) {
      setValueByPath(toObject, ["responseMimeType"], fromResponseMimeType);
    }
    const fromResponseModalities = getValueByPath(fromObject, [
      "responseModalities"
    ]);
    if (fromResponseModalities != null) {
      setValueByPath(toObject, ["responseModalities"], fromResponseModalities);
    }
    const fromResponseSchema = getValueByPath(fromObject, [
      "responseSchema"
    ]);
    if (fromResponseSchema != null) {
      setValueByPath(toObject, ["responseSchema"], fromResponseSchema);
    }
    const fromRoutingConfig = getValueByPath(fromObject, [
      "routingConfig"
    ]);
    if (fromRoutingConfig != null) {
      setValueByPath(toObject, ["routingConfig"], fromRoutingConfig);
    }
    const fromSeed = getValueByPath(fromObject, ["seed"]);
    if (fromSeed != null) {
      setValueByPath(toObject, ["seed"], fromSeed);
    }
    const fromSpeechConfig = getValueByPath(fromObject, ["speechConfig"]);
    if (fromSpeechConfig != null) {
      setValueByPath(toObject, ["speechConfig"], speechConfigToVertex(fromSpeechConfig));
    }
    const fromStopSequences = getValueByPath(fromObject, [
      "stopSequences"
    ]);
    if (fromStopSequences != null) {
      setValueByPath(toObject, ["stopSequences"], fromStopSequences);
    }
    const fromTemperature = getValueByPath(fromObject, ["temperature"]);
    if (fromTemperature != null) {
      setValueByPath(toObject, ["temperature"], fromTemperature);
    }
    const fromThinkingConfig = getValueByPath(fromObject, [
      "thinkingConfig"
    ]);
    if (fromThinkingConfig != null) {
      setValueByPath(toObject, ["thinkingConfig"], fromThinkingConfig);
    }
    const fromTopK = getValueByPath(fromObject, ["topK"]);
    if (fromTopK != null) {
      setValueByPath(toObject, ["topK"], fromTopK);
    }
    const fromTopP = getValueByPath(fromObject, ["topP"]);
    if (fromTopP != null) {
      setValueByPath(toObject, ["topP"], fromTopP);
    }
    if (getValueByPath(fromObject, ["enableEnhancedCivicAnswers"]) !== void 0) {
      throw new Error("enableEnhancedCivicAnswers parameter is not supported in Vertex AI.");
    }
    return toObject;
  }
  function getModelParametersToMldev(apiClient, fromObject) {
    const toObject = {};
    const fromModel = getValueByPath(fromObject, ["model"]);
    if (fromModel != null) {
      setValueByPath(toObject, ["_url", "name"], tModel(apiClient, fromModel));
    }
    return toObject;
  }
  function getModelParametersToVertex(apiClient, fromObject) {
    const toObject = {};
    const fromModel = getValueByPath(fromObject, ["model"]);
    if (fromModel != null) {
      setValueByPath(toObject, ["_url", "name"], tModel(apiClient, fromModel));
    }
    return toObject;
  }
  function googleMapsToMldev$1(fromObject) {
    const toObject = {};
    if (getValueByPath(fromObject, ["authConfig"]) !== void 0) {
      throw new Error("authConfig parameter is not supported in Gemini API.");
    }
    const fromEnableWidget = getValueByPath(fromObject, ["enableWidget"]);
    if (fromEnableWidget != null) {
      setValueByPath(toObject, ["enableWidget"], fromEnableWidget);
    }
    return toObject;
  }
  function googleSearchToMldev$1(fromObject) {
    const toObject = {};
    if (getValueByPath(fromObject, ["excludeDomains"]) !== void 0) {
      throw new Error("excludeDomains parameter is not supported in Gemini API.");
    }
    if (getValueByPath(fromObject, ["blockingConfidence"]) !== void 0) {
      throw new Error("blockingConfidence parameter is not supported in Gemini API.");
    }
    const fromTimeRangeFilter = getValueByPath(fromObject, [
      "timeRangeFilter"
    ]);
    if (fromTimeRangeFilter != null) {
      setValueByPath(toObject, ["timeRangeFilter"], fromTimeRangeFilter);
    }
    return toObject;
  }
  function imageConfigToMldev(fromObject) {
    const toObject = {};
    const fromAspectRatio = getValueByPath(fromObject, ["aspectRatio"]);
    if (fromAspectRatio != null) {
      setValueByPath(toObject, ["aspectRatio"], fromAspectRatio);
    }
    const fromImageSize = getValueByPath(fromObject, ["imageSize"]);
    if (fromImageSize != null) {
      setValueByPath(toObject, ["imageSize"], fromImageSize);
    }
    if (getValueByPath(fromObject, ["outputMimeType"]) !== void 0) {
      throw new Error("outputMimeType parameter is not supported in Gemini API.");
    }
    if (getValueByPath(fromObject, ["outputCompressionQuality"]) !== void 0) {
      throw new Error("outputCompressionQuality parameter is not supported in Gemini API.");
    }
    return toObject;
  }
  function imageConfigToVertex(fromObject) {
    const toObject = {};
    const fromAspectRatio = getValueByPath(fromObject, ["aspectRatio"]);
    if (fromAspectRatio != null) {
      setValueByPath(toObject, ["aspectRatio"], fromAspectRatio);
    }
    const fromImageSize = getValueByPath(fromObject, ["imageSize"]);
    if (fromImageSize != null) {
      setValueByPath(toObject, ["imageSize"], fromImageSize);
    }
    const fromOutputMimeType = getValueByPath(fromObject, [
      "outputMimeType"
    ]);
    if (fromOutputMimeType != null) {
      setValueByPath(toObject, ["imageOutputOptions", "mimeType"], fromOutputMimeType);
    }
    const fromOutputCompressionQuality = getValueByPath(fromObject, [
      "outputCompressionQuality"
    ]);
    if (fromOutputCompressionQuality != null) {
      setValueByPath(toObject, ["imageOutputOptions", "compressionQuality"], fromOutputCompressionQuality);
    }
    return toObject;
  }
  function imageFromMldev(fromObject) {
    const toObject = {};
    const fromImageBytes = getValueByPath(fromObject, [
      "bytesBase64Encoded"
    ]);
    if (fromImageBytes != null) {
      setValueByPath(toObject, ["imageBytes"], tBytes(fromImageBytes));
    }
    const fromMimeType = getValueByPath(fromObject, ["mimeType"]);
    if (fromMimeType != null) {
      setValueByPath(toObject, ["mimeType"], fromMimeType);
    }
    return toObject;
  }
  function imageFromVertex(fromObject) {
    const toObject = {};
    const fromGcsUri = getValueByPath(fromObject, ["gcsUri"]);
    if (fromGcsUri != null) {
      setValueByPath(toObject, ["gcsUri"], fromGcsUri);
    }
    const fromImageBytes = getValueByPath(fromObject, [
      "bytesBase64Encoded"
    ]);
    if (fromImageBytes != null) {
      setValueByPath(toObject, ["imageBytes"], tBytes(fromImageBytes));
    }
    const fromMimeType = getValueByPath(fromObject, ["mimeType"]);
    if (fromMimeType != null) {
      setValueByPath(toObject, ["mimeType"], fromMimeType);
    }
    return toObject;
  }
  function imageToMldev(fromObject) {
    const toObject = {};
    if (getValueByPath(fromObject, ["gcsUri"]) !== void 0) {
      throw new Error("gcsUri parameter is not supported in Gemini API.");
    }
    const fromImageBytes = getValueByPath(fromObject, ["imageBytes"]);
    if (fromImageBytes != null) {
      setValueByPath(toObject, ["bytesBase64Encoded"], tBytes(fromImageBytes));
    }
    const fromMimeType = getValueByPath(fromObject, ["mimeType"]);
    if (fromMimeType != null) {
      setValueByPath(toObject, ["mimeType"], fromMimeType);
    }
    return toObject;
  }
  function imageToVertex(fromObject) {
    const toObject = {};
    const fromGcsUri = getValueByPath(fromObject, ["gcsUri"]);
    if (fromGcsUri != null) {
      setValueByPath(toObject, ["gcsUri"], fromGcsUri);
    }
    const fromImageBytes = getValueByPath(fromObject, ["imageBytes"]);
    if (fromImageBytes != null) {
      setValueByPath(toObject, ["bytesBase64Encoded"], tBytes(fromImageBytes));
    }
    const fromMimeType = getValueByPath(fromObject, ["mimeType"]);
    if (fromMimeType != null) {
      setValueByPath(toObject, ["mimeType"], fromMimeType);
    }
    return toObject;
  }
  function listModelsConfigToMldev(apiClient, fromObject, parentObject) {
    const toObject = {};
    const fromPageSize = getValueByPath(fromObject, ["pageSize"]);
    if (parentObject !== void 0 && fromPageSize != null) {
      setValueByPath(parentObject, ["_query", "pageSize"], fromPageSize);
    }
    const fromPageToken = getValueByPath(fromObject, ["pageToken"]);
    if (parentObject !== void 0 && fromPageToken != null) {
      setValueByPath(parentObject, ["_query", "pageToken"], fromPageToken);
    }
    const fromFilter = getValueByPath(fromObject, ["filter"]);
    if (parentObject !== void 0 && fromFilter != null) {
      setValueByPath(parentObject, ["_query", "filter"], fromFilter);
    }
    const fromQueryBase = getValueByPath(fromObject, ["queryBase"]);
    if (parentObject !== void 0 && fromQueryBase != null) {
      setValueByPath(parentObject, ["_url", "models_url"], tModelsUrl(apiClient, fromQueryBase));
    }
    return toObject;
  }
  function listModelsConfigToVertex(apiClient, fromObject, parentObject) {
    const toObject = {};
    const fromPageSize = getValueByPath(fromObject, ["pageSize"]);
    if (parentObject !== void 0 && fromPageSize != null) {
      setValueByPath(parentObject, ["_query", "pageSize"], fromPageSize);
    }
    const fromPageToken = getValueByPath(fromObject, ["pageToken"]);
    if (parentObject !== void 0 && fromPageToken != null) {
      setValueByPath(parentObject, ["_query", "pageToken"], fromPageToken);
    }
    const fromFilter = getValueByPath(fromObject, ["filter"]);
    if (parentObject !== void 0 && fromFilter != null) {
      setValueByPath(parentObject, ["_query", "filter"], fromFilter);
    }
    const fromQueryBase = getValueByPath(fromObject, ["queryBase"]);
    if (parentObject !== void 0 && fromQueryBase != null) {
      setValueByPath(parentObject, ["_url", "models_url"], tModelsUrl(apiClient, fromQueryBase));
    }
    return toObject;
  }
  function listModelsParametersToMldev(apiClient, fromObject) {
    const toObject = {};
    const fromConfig = getValueByPath(fromObject, ["config"]);
    if (fromConfig != null) {
      listModelsConfigToMldev(apiClient, fromConfig, toObject);
    }
    return toObject;
  }
  function listModelsParametersToVertex(apiClient, fromObject) {
    const toObject = {};
    const fromConfig = getValueByPath(fromObject, ["config"]);
    if (fromConfig != null) {
      listModelsConfigToVertex(apiClient, fromConfig, toObject);
    }
    return toObject;
  }
  function listModelsResponseFromMldev(fromObject) {
    const toObject = {};
    const fromSdkHttpResponse = getValueByPath(fromObject, [
      "sdkHttpResponse"
    ]);
    if (fromSdkHttpResponse != null) {
      setValueByPath(toObject, ["sdkHttpResponse"], fromSdkHttpResponse);
    }
    const fromNextPageToken = getValueByPath(fromObject, [
      "nextPageToken"
    ]);
    if (fromNextPageToken != null) {
      setValueByPath(toObject, ["nextPageToken"], fromNextPageToken);
    }
    const fromModels = getValueByPath(fromObject, ["_self"]);
    if (fromModels != null) {
      let transformedList = tExtractModels(fromModels);
      if (Array.isArray(transformedList)) {
        transformedList = transformedList.map((item) => {
          return modelFromMldev(item);
        });
      }
      setValueByPath(toObject, ["models"], transformedList);
    }
    return toObject;
  }
  function listModelsResponseFromVertex(fromObject) {
    const toObject = {};
    const fromSdkHttpResponse = getValueByPath(fromObject, [
      "sdkHttpResponse"
    ]);
    if (fromSdkHttpResponse != null) {
      setValueByPath(toObject, ["sdkHttpResponse"], fromSdkHttpResponse);
    }
    const fromNextPageToken = getValueByPath(fromObject, [
      "nextPageToken"
    ]);
    if (fromNextPageToken != null) {
      setValueByPath(toObject, ["nextPageToken"], fromNextPageToken);
    }
    const fromModels = getValueByPath(fromObject, ["_self"]);
    if (fromModels != null) {
      let transformedList = tExtractModels(fromModels);
      if (Array.isArray(transformedList)) {
        transformedList = transformedList.map((item) => {
          return modelFromVertex(item);
        });
      }
      setValueByPath(toObject, ["models"], transformedList);
    }
    return toObject;
  }
  function maskReferenceConfigToVertex(fromObject) {
    const toObject = {};
    const fromMaskMode = getValueByPath(fromObject, ["maskMode"]);
    if (fromMaskMode != null) {
      setValueByPath(toObject, ["maskMode"], fromMaskMode);
    }
    const fromSegmentationClasses = getValueByPath(fromObject, [
      "segmentationClasses"
    ]);
    if (fromSegmentationClasses != null) {
      setValueByPath(toObject, ["maskClasses"], fromSegmentationClasses);
    }
    const fromMaskDilation = getValueByPath(fromObject, ["maskDilation"]);
    if (fromMaskDilation != null) {
      setValueByPath(toObject, ["dilation"], fromMaskDilation);
    }
    return toObject;
  }
  function modelFromMldev(fromObject) {
    const toObject = {};
    const fromName = getValueByPath(fromObject, ["name"]);
    if (fromName != null) {
      setValueByPath(toObject, ["name"], fromName);
    }
    const fromDisplayName = getValueByPath(fromObject, ["displayName"]);
    if (fromDisplayName != null) {
      setValueByPath(toObject, ["displayName"], fromDisplayName);
    }
    const fromDescription = getValueByPath(fromObject, ["description"]);
    if (fromDescription != null) {
      setValueByPath(toObject, ["description"], fromDescription);
    }
    const fromVersion = getValueByPath(fromObject, ["version"]);
    if (fromVersion != null) {
      setValueByPath(toObject, ["version"], fromVersion);
    }
    const fromTunedModelInfo = getValueByPath(fromObject, ["_self"]);
    if (fromTunedModelInfo != null) {
      setValueByPath(toObject, ["tunedModelInfo"], tunedModelInfoFromMldev(fromTunedModelInfo));
    }
    const fromInputTokenLimit = getValueByPath(fromObject, [
      "inputTokenLimit"
    ]);
    if (fromInputTokenLimit != null) {
      setValueByPath(toObject, ["inputTokenLimit"], fromInputTokenLimit);
    }
    const fromOutputTokenLimit = getValueByPath(fromObject, [
      "outputTokenLimit"
    ]);
    if (fromOutputTokenLimit != null) {
      setValueByPath(toObject, ["outputTokenLimit"], fromOutputTokenLimit);
    }
    const fromSupportedActions = getValueByPath(fromObject, [
      "supportedGenerationMethods"
    ]);
    if (fromSupportedActions != null) {
      setValueByPath(toObject, ["supportedActions"], fromSupportedActions);
    }
    const fromTemperature = getValueByPath(fromObject, ["temperature"]);
    if (fromTemperature != null) {
      setValueByPath(toObject, ["temperature"], fromTemperature);
    }
    const fromMaxTemperature = getValueByPath(fromObject, [
      "maxTemperature"
    ]);
    if (fromMaxTemperature != null) {
      setValueByPath(toObject, ["maxTemperature"], fromMaxTemperature);
    }
    const fromTopP = getValueByPath(fromObject, ["topP"]);
    if (fromTopP != null) {
      setValueByPath(toObject, ["topP"], fromTopP);
    }
    const fromTopK = getValueByPath(fromObject, ["topK"]);
    if (fromTopK != null) {
      setValueByPath(toObject, ["topK"], fromTopK);
    }
    const fromThinking = getValueByPath(fromObject, ["thinking"]);
    if (fromThinking != null) {
      setValueByPath(toObject, ["thinking"], fromThinking);
    }
    return toObject;
  }
  function modelFromVertex(fromObject) {
    const toObject = {};
    const fromName = getValueByPath(fromObject, ["name"]);
    if (fromName != null) {
      setValueByPath(toObject, ["name"], fromName);
    }
    const fromDisplayName = getValueByPath(fromObject, ["displayName"]);
    if (fromDisplayName != null) {
      setValueByPath(toObject, ["displayName"], fromDisplayName);
    }
    const fromDescription = getValueByPath(fromObject, ["description"]);
    if (fromDescription != null) {
      setValueByPath(toObject, ["description"], fromDescription);
    }
    const fromVersion = getValueByPath(fromObject, ["versionId"]);
    if (fromVersion != null) {
      setValueByPath(toObject, ["version"], fromVersion);
    }
    const fromEndpoints = getValueByPath(fromObject, ["deployedModels"]);
    if (fromEndpoints != null) {
      let transformedList = fromEndpoints;
      if (Array.isArray(transformedList)) {
        transformedList = transformedList.map((item) => {
          return endpointFromVertex(item);
        });
      }
      setValueByPath(toObject, ["endpoints"], transformedList);
    }
    const fromLabels = getValueByPath(fromObject, ["labels"]);
    if (fromLabels != null) {
      setValueByPath(toObject, ["labels"], fromLabels);
    }
    const fromTunedModelInfo = getValueByPath(fromObject, ["_self"]);
    if (fromTunedModelInfo != null) {
      setValueByPath(toObject, ["tunedModelInfo"], tunedModelInfoFromVertex(fromTunedModelInfo));
    }
    const fromDefaultCheckpointId = getValueByPath(fromObject, [
      "defaultCheckpointId"
    ]);
    if (fromDefaultCheckpointId != null) {
      setValueByPath(toObject, ["defaultCheckpointId"], fromDefaultCheckpointId);
    }
    const fromCheckpoints = getValueByPath(fromObject, ["checkpoints"]);
    if (fromCheckpoints != null) {
      let transformedList = fromCheckpoints;
      if (Array.isArray(transformedList)) {
        transformedList = transformedList.map((item) => {
          return item;
        });
      }
      setValueByPath(toObject, ["checkpoints"], transformedList);
    }
    return toObject;
  }
  function partToMldev$1(fromObject) {
    const toObject = {};
    const fromMediaResolution = getValueByPath(fromObject, [
      "mediaResolution"
    ]);
    if (fromMediaResolution != null) {
      setValueByPath(toObject, ["mediaResolution"], fromMediaResolution);
    }
    const fromCodeExecutionResult = getValueByPath(fromObject, [
      "codeExecutionResult"
    ]);
    if (fromCodeExecutionResult != null) {
      setValueByPath(toObject, ["codeExecutionResult"], fromCodeExecutionResult);
    }
    const fromExecutableCode = getValueByPath(fromObject, [
      "executableCode"
    ]);
    if (fromExecutableCode != null) {
      setValueByPath(toObject, ["executableCode"], fromExecutableCode);
    }
    const fromFileData = getValueByPath(fromObject, ["fileData"]);
    if (fromFileData != null) {
      setValueByPath(toObject, ["fileData"], fileDataToMldev$1(fromFileData));
    }
    const fromFunctionCall = getValueByPath(fromObject, ["functionCall"]);
    if (fromFunctionCall != null) {
      setValueByPath(toObject, ["functionCall"], functionCallToMldev$1(fromFunctionCall));
    }
    const fromFunctionResponse = getValueByPath(fromObject, [
      "functionResponse"
    ]);
    if (fromFunctionResponse != null) {
      setValueByPath(toObject, ["functionResponse"], fromFunctionResponse);
    }
    const fromInlineData = getValueByPath(fromObject, ["inlineData"]);
    if (fromInlineData != null) {
      setValueByPath(toObject, ["inlineData"], blobToMldev$1(fromInlineData));
    }
    const fromText = getValueByPath(fromObject, ["text"]);
    if (fromText != null) {
      setValueByPath(toObject, ["text"], fromText);
    }
    const fromThought = getValueByPath(fromObject, ["thought"]);
    if (fromThought != null) {
      setValueByPath(toObject, ["thought"], fromThought);
    }
    const fromThoughtSignature = getValueByPath(fromObject, [
      "thoughtSignature"
    ]);
    if (fromThoughtSignature != null) {
      setValueByPath(toObject, ["thoughtSignature"], fromThoughtSignature);
    }
    const fromVideoMetadata = getValueByPath(fromObject, [
      "videoMetadata"
    ]);
    if (fromVideoMetadata != null) {
      setValueByPath(toObject, ["videoMetadata"], fromVideoMetadata);
    }
    return toObject;
  }
  function productImageToVertex(fromObject) {
    const toObject = {};
    const fromProductImage = getValueByPath(fromObject, ["productImage"]);
    if (fromProductImage != null) {
      setValueByPath(toObject, ["image"], imageToVertex(fromProductImage));
    }
    return toObject;
  }
  function recontextImageConfigToVertex(fromObject, parentObject) {
    const toObject = {};
    const fromNumberOfImages = getValueByPath(fromObject, [
      "numberOfImages"
    ]);
    if (parentObject !== void 0 && fromNumberOfImages != null) {
      setValueByPath(parentObject, ["parameters", "sampleCount"], fromNumberOfImages);
    }
    const fromBaseSteps = getValueByPath(fromObject, ["baseSteps"]);
    if (parentObject !== void 0 && fromBaseSteps != null) {
      setValueByPath(parentObject, ["parameters", "baseSteps"], fromBaseSteps);
    }
    const fromOutputGcsUri = getValueByPath(fromObject, ["outputGcsUri"]);
    if (parentObject !== void 0 && fromOutputGcsUri != null) {
      setValueByPath(parentObject, ["parameters", "storageUri"], fromOutputGcsUri);
    }
    const fromSeed = getValueByPath(fromObject, ["seed"]);
    if (parentObject !== void 0 && fromSeed != null) {
      setValueByPath(parentObject, ["parameters", "seed"], fromSeed);
    }
    const fromSafetyFilterLevel = getValueByPath(fromObject, [
      "safetyFilterLevel"
    ]);
    if (parentObject !== void 0 && fromSafetyFilterLevel != null) {
      setValueByPath(parentObject, ["parameters", "safetySetting"], fromSafetyFilterLevel);
    }
    const fromPersonGeneration = getValueByPath(fromObject, [
      "personGeneration"
    ]);
    if (parentObject !== void 0 && fromPersonGeneration != null) {
      setValueByPath(parentObject, ["parameters", "personGeneration"], fromPersonGeneration);
    }
    const fromAddWatermark = getValueByPath(fromObject, ["addWatermark"]);
    if (parentObject !== void 0 && fromAddWatermark != null) {
      setValueByPath(parentObject, ["parameters", "addWatermark"], fromAddWatermark);
    }
    const fromOutputMimeType = getValueByPath(fromObject, [
      "outputMimeType"
    ]);
    if (parentObject !== void 0 && fromOutputMimeType != null) {
      setValueByPath(parentObject, ["parameters", "outputOptions", "mimeType"], fromOutputMimeType);
    }
    const fromOutputCompressionQuality = getValueByPath(fromObject, [
      "outputCompressionQuality"
    ]);
    if (parentObject !== void 0 && fromOutputCompressionQuality != null) {
      setValueByPath(parentObject, ["parameters", "outputOptions", "compressionQuality"], fromOutputCompressionQuality);
    }
    const fromEnhancePrompt = getValueByPath(fromObject, [
      "enhancePrompt"
    ]);
    if (parentObject !== void 0 && fromEnhancePrompt != null) {
      setValueByPath(parentObject, ["parameters", "enhancePrompt"], fromEnhancePrompt);
    }
    const fromLabels = getValueByPath(fromObject, ["labels"]);
    if (parentObject !== void 0 && fromLabels != null) {
      setValueByPath(parentObject, ["labels"], fromLabels);
    }
    return toObject;
  }
  function recontextImageParametersToVertex(apiClient, fromObject) {
    const toObject = {};
    const fromModel = getValueByPath(fromObject, ["model"]);
    if (fromModel != null) {
      setValueByPath(toObject, ["_url", "model"], tModel(apiClient, fromModel));
    }
    const fromSource = getValueByPath(fromObject, ["source"]);
    if (fromSource != null) {
      recontextImageSourceToVertex(fromSource, toObject);
    }
    const fromConfig = getValueByPath(fromObject, ["config"]);
    if (fromConfig != null) {
      recontextImageConfigToVertex(fromConfig, toObject);
    }
    return toObject;
  }
  function recontextImageResponseFromVertex(fromObject) {
    const toObject = {};
    const fromGeneratedImages = getValueByPath(fromObject, [
      "predictions"
    ]);
    if (fromGeneratedImages != null) {
      let transformedList = fromGeneratedImages;
      if (Array.isArray(transformedList)) {
        transformedList = transformedList.map((item) => {
          return generatedImageFromVertex(item);
        });
      }
      setValueByPath(toObject, ["generatedImages"], transformedList);
    }
    return toObject;
  }
  function recontextImageSourceToVertex(fromObject, parentObject) {
    const toObject = {};
    const fromPrompt = getValueByPath(fromObject, ["prompt"]);
    if (parentObject !== void 0 && fromPrompt != null) {
      setValueByPath(parentObject, ["instances[0]", "prompt"], fromPrompt);
    }
    const fromPersonImage = getValueByPath(fromObject, ["personImage"]);
    if (parentObject !== void 0 && fromPersonImage != null) {
      setValueByPath(parentObject, ["instances[0]", "personImage", "image"], imageToVertex(fromPersonImage));
    }
    const fromProductImages = getValueByPath(fromObject, [
      "productImages"
    ]);
    if (parentObject !== void 0 && fromProductImages != null) {
      let transformedList = fromProductImages;
      if (Array.isArray(transformedList)) {
        transformedList = transformedList.map((item) => {
          return productImageToVertex(item);
        });
      }
      setValueByPath(parentObject, ["instances[0]", "productImages"], transformedList);
    }
    return toObject;
  }
  function referenceImageAPIInternalToVertex(fromObject) {
    const toObject = {};
    const fromReferenceImage = getValueByPath(fromObject, [
      "referenceImage"
    ]);
    if (fromReferenceImage != null) {
      setValueByPath(toObject, ["referenceImage"], imageToVertex(fromReferenceImage));
    }
    const fromReferenceId = getValueByPath(fromObject, ["referenceId"]);
    if (fromReferenceId != null) {
      setValueByPath(toObject, ["referenceId"], fromReferenceId);
    }
    const fromReferenceType = getValueByPath(fromObject, [
      "referenceType"
    ]);
    if (fromReferenceType != null) {
      setValueByPath(toObject, ["referenceType"], fromReferenceType);
    }
    const fromMaskImageConfig = getValueByPath(fromObject, [
      "maskImageConfig"
    ]);
    if (fromMaskImageConfig != null) {
      setValueByPath(toObject, ["maskImageConfig"], maskReferenceConfigToVertex(fromMaskImageConfig));
    }
    const fromControlImageConfig = getValueByPath(fromObject, [
      "controlImageConfig"
    ]);
    if (fromControlImageConfig != null) {
      setValueByPath(toObject, ["controlImageConfig"], controlReferenceConfigToVertex(fromControlImageConfig));
    }
    const fromStyleImageConfig = getValueByPath(fromObject, [
      "styleImageConfig"
    ]);
    if (fromStyleImageConfig != null) {
      setValueByPath(toObject, ["styleImageConfig"], fromStyleImageConfig);
    }
    const fromSubjectImageConfig = getValueByPath(fromObject, [
      "subjectImageConfig"
    ]);
    if (fromSubjectImageConfig != null) {
      setValueByPath(toObject, ["subjectImageConfig"], fromSubjectImageConfig);
    }
    return toObject;
  }
  function safetyAttributesFromMldev(fromObject) {
    const toObject = {};
    const fromCategories = getValueByPath(fromObject, [
      "safetyAttributes",
      "categories"
    ]);
    if (fromCategories != null) {
      setValueByPath(toObject, ["categories"], fromCategories);
    }
    const fromScores = getValueByPath(fromObject, [
      "safetyAttributes",
      "scores"
    ]);
    if (fromScores != null) {
      setValueByPath(toObject, ["scores"], fromScores);
    }
    const fromContentType = getValueByPath(fromObject, ["contentType"]);
    if (fromContentType != null) {
      setValueByPath(toObject, ["contentType"], fromContentType);
    }
    return toObject;
  }
  function safetyAttributesFromVertex(fromObject) {
    const toObject = {};
    const fromCategories = getValueByPath(fromObject, [
      "safetyAttributes",
      "categories"
    ]);
    if (fromCategories != null) {
      setValueByPath(toObject, ["categories"], fromCategories);
    }
    const fromScores = getValueByPath(fromObject, [
      "safetyAttributes",
      "scores"
    ]);
    if (fromScores != null) {
      setValueByPath(toObject, ["scores"], fromScores);
    }
    const fromContentType = getValueByPath(fromObject, ["contentType"]);
    if (fromContentType != null) {
      setValueByPath(toObject, ["contentType"], fromContentType);
    }
    return toObject;
  }
  function safetySettingToMldev(fromObject) {
    const toObject = {};
    const fromCategory = getValueByPath(fromObject, ["category"]);
    if (fromCategory != null) {
      setValueByPath(toObject, ["category"], fromCategory);
    }
    if (getValueByPath(fromObject, ["method"]) !== void 0) {
      throw new Error("method parameter is not supported in Gemini API.");
    }
    const fromThreshold = getValueByPath(fromObject, ["threshold"]);
    if (fromThreshold != null) {
      setValueByPath(toObject, ["threshold"], fromThreshold);
    }
    return toObject;
  }
  function scribbleImageToVertex(fromObject) {
    const toObject = {};
    const fromImage = getValueByPath(fromObject, ["image"]);
    if (fromImage != null) {
      setValueByPath(toObject, ["image"], imageToVertex(fromImage));
    }
    return toObject;
  }
  function segmentImageConfigToVertex(fromObject, parentObject) {
    const toObject = {};
    const fromMode = getValueByPath(fromObject, ["mode"]);
    if (parentObject !== void 0 && fromMode != null) {
      setValueByPath(parentObject, ["parameters", "mode"], fromMode);
    }
    const fromMaxPredictions = getValueByPath(fromObject, [
      "maxPredictions"
    ]);
    if (parentObject !== void 0 && fromMaxPredictions != null) {
      setValueByPath(parentObject, ["parameters", "maxPredictions"], fromMaxPredictions);
    }
    const fromConfidenceThreshold = getValueByPath(fromObject, [
      "confidenceThreshold"
    ]);
    if (parentObject !== void 0 && fromConfidenceThreshold != null) {
      setValueByPath(parentObject, ["parameters", "confidenceThreshold"], fromConfidenceThreshold);
    }
    const fromMaskDilation = getValueByPath(fromObject, ["maskDilation"]);
    if (parentObject !== void 0 && fromMaskDilation != null) {
      setValueByPath(parentObject, ["parameters", "maskDilation"], fromMaskDilation);
    }
    const fromBinaryColorThreshold = getValueByPath(fromObject, [
      "binaryColorThreshold"
    ]);
    if (parentObject !== void 0 && fromBinaryColorThreshold != null) {
      setValueByPath(parentObject, ["parameters", "binaryColorThreshold"], fromBinaryColorThreshold);
    }
    const fromLabels = getValueByPath(fromObject, ["labels"]);
    if (parentObject !== void 0 && fromLabels != null) {
      setValueByPath(parentObject, ["labels"], fromLabels);
    }
    return toObject;
  }
  function segmentImageParametersToVertex(apiClient, fromObject) {
    const toObject = {};
    const fromModel = getValueByPath(fromObject, ["model"]);
    if (fromModel != null) {
      setValueByPath(toObject, ["_url", "model"], tModel(apiClient, fromModel));
    }
    const fromSource = getValueByPath(fromObject, ["source"]);
    if (fromSource != null) {
      segmentImageSourceToVertex(fromSource, toObject);
    }
    const fromConfig = getValueByPath(fromObject, ["config"]);
    if (fromConfig != null) {
      segmentImageConfigToVertex(fromConfig, toObject);
    }
    return toObject;
  }
  function segmentImageResponseFromVertex(fromObject) {
    const toObject = {};
    const fromGeneratedMasks = getValueByPath(fromObject, ["predictions"]);
    if (fromGeneratedMasks != null) {
      let transformedList = fromGeneratedMasks;
      if (Array.isArray(transformedList)) {
        transformedList = transformedList.map((item) => {
          return generatedImageMaskFromVertex(item);
        });
      }
      setValueByPath(toObject, ["generatedMasks"], transformedList);
    }
    return toObject;
  }
  function segmentImageSourceToVertex(fromObject, parentObject) {
    const toObject = {};
    const fromPrompt = getValueByPath(fromObject, ["prompt"]);
    if (parentObject !== void 0 && fromPrompt != null) {
      setValueByPath(parentObject, ["instances[0]", "prompt"], fromPrompt);
    }
    const fromImage = getValueByPath(fromObject, ["image"]);
    if (parentObject !== void 0 && fromImage != null) {
      setValueByPath(parentObject, ["instances[0]", "image"], imageToVertex(fromImage));
    }
    const fromScribbleImage = getValueByPath(fromObject, [
      "scribbleImage"
    ]);
    if (parentObject !== void 0 && fromScribbleImage != null) {
      setValueByPath(parentObject, ["instances[0]", "scribble"], scribbleImageToVertex(fromScribbleImage));
    }
    return toObject;
  }
  function speechConfigToVertex(fromObject) {
    const toObject = {};
    const fromLanguageCode = getValueByPath(fromObject, ["languageCode"]);
    if (fromLanguageCode != null) {
      setValueByPath(toObject, ["languageCode"], fromLanguageCode);
    }
    const fromVoiceConfig = getValueByPath(fromObject, ["voiceConfig"]);
    if (fromVoiceConfig != null) {
      setValueByPath(toObject, ["voiceConfig"], fromVoiceConfig);
    }
    if (getValueByPath(fromObject, ["multiSpeakerVoiceConfig"]) !== void 0) {
      throw new Error("multiSpeakerVoiceConfig parameter is not supported in Vertex AI.");
    }
    return toObject;
  }
  function toolConfigToMldev(fromObject) {
    const toObject = {};
    const fromFunctionCallingConfig = getValueByPath(fromObject, [
      "functionCallingConfig"
    ]);
    if (fromFunctionCallingConfig != null) {
      setValueByPath(toObject, ["functionCallingConfig"], functionCallingConfigToMldev(fromFunctionCallingConfig));
    }
    const fromRetrievalConfig = getValueByPath(fromObject, [
      "retrievalConfig"
    ]);
    if (fromRetrievalConfig != null) {
      setValueByPath(toObject, ["retrievalConfig"], fromRetrievalConfig);
    }
    return toObject;
  }
  function toolToMldev$1(fromObject) {
    const toObject = {};
    const fromFunctionDeclarations = getValueByPath(fromObject, [
      "functionDeclarations"
    ]);
    if (fromFunctionDeclarations != null) {
      let transformedList = fromFunctionDeclarations;
      if (Array.isArray(transformedList)) {
        transformedList = transformedList.map((item) => {
          return item;
        });
      }
      setValueByPath(toObject, ["functionDeclarations"], transformedList);
    }
    if (getValueByPath(fromObject, ["retrieval"]) !== void 0) {
      throw new Error("retrieval parameter is not supported in Gemini API.");
    }
    const fromGoogleSearchRetrieval = getValueByPath(fromObject, [
      "googleSearchRetrieval"
    ]);
    if (fromGoogleSearchRetrieval != null) {
      setValueByPath(toObject, ["googleSearchRetrieval"], fromGoogleSearchRetrieval);
    }
    const fromComputerUse = getValueByPath(fromObject, ["computerUse"]);
    if (fromComputerUse != null) {
      setValueByPath(toObject, ["computerUse"], fromComputerUse);
    }
    const fromFileSearch = getValueByPath(fromObject, ["fileSearch"]);
    if (fromFileSearch != null) {
      setValueByPath(toObject, ["fileSearch"], fromFileSearch);
    }
    const fromCodeExecution = getValueByPath(fromObject, [
      "codeExecution"
    ]);
    if (fromCodeExecution != null) {
      setValueByPath(toObject, ["codeExecution"], fromCodeExecution);
    }
    if (getValueByPath(fromObject, ["enterpriseWebSearch"]) !== void 0) {
      throw new Error("enterpriseWebSearch parameter is not supported in Gemini API.");
    }
    const fromGoogleMaps = getValueByPath(fromObject, ["googleMaps"]);
    if (fromGoogleMaps != null) {
      setValueByPath(toObject, ["googleMaps"], googleMapsToMldev$1(fromGoogleMaps));
    }
    const fromGoogleSearch = getValueByPath(fromObject, ["googleSearch"]);
    if (fromGoogleSearch != null) {
      setValueByPath(toObject, ["googleSearch"], googleSearchToMldev$1(fromGoogleSearch));
    }
    const fromUrlContext = getValueByPath(fromObject, ["urlContext"]);
    if (fromUrlContext != null) {
      setValueByPath(toObject, ["urlContext"], fromUrlContext);
    }
    return toObject;
  }
  function toolToVertex(fromObject) {
    const toObject = {};
    const fromFunctionDeclarations = getValueByPath(fromObject, [
      "functionDeclarations"
    ]);
    if (fromFunctionDeclarations != null) {
      let transformedList = fromFunctionDeclarations;
      if (Array.isArray(transformedList)) {
        transformedList = transformedList.map((item) => {
          return functionDeclarationToVertex(item);
        });
      }
      setValueByPath(toObject, ["functionDeclarations"], transformedList);
    }
    const fromRetrieval = getValueByPath(fromObject, ["retrieval"]);
    if (fromRetrieval != null) {
      setValueByPath(toObject, ["retrieval"], fromRetrieval);
    }
    const fromGoogleSearchRetrieval = getValueByPath(fromObject, [
      "googleSearchRetrieval"
    ]);
    if (fromGoogleSearchRetrieval != null) {
      setValueByPath(toObject, ["googleSearchRetrieval"], fromGoogleSearchRetrieval);
    }
    const fromComputerUse = getValueByPath(fromObject, ["computerUse"]);
    if (fromComputerUse != null) {
      setValueByPath(toObject, ["computerUse"], fromComputerUse);
    }
    if (getValueByPath(fromObject, ["fileSearch"]) !== void 0) {
      throw new Error("fileSearch parameter is not supported in Vertex AI.");
    }
    const fromCodeExecution = getValueByPath(fromObject, [
      "codeExecution"
    ]);
    if (fromCodeExecution != null) {
      setValueByPath(toObject, ["codeExecution"], fromCodeExecution);
    }
    const fromEnterpriseWebSearch = getValueByPath(fromObject, [
      "enterpriseWebSearch"
    ]);
    if (fromEnterpriseWebSearch != null) {
      setValueByPath(toObject, ["enterpriseWebSearch"], fromEnterpriseWebSearch);
    }
    const fromGoogleMaps = getValueByPath(fromObject, ["googleMaps"]);
    if (fromGoogleMaps != null) {
      setValueByPath(toObject, ["googleMaps"], fromGoogleMaps);
    }
    const fromGoogleSearch = getValueByPath(fromObject, ["googleSearch"]);
    if (fromGoogleSearch != null) {
      setValueByPath(toObject, ["googleSearch"], fromGoogleSearch);
    }
    const fromUrlContext = getValueByPath(fromObject, ["urlContext"]);
    if (fromUrlContext != null) {
      setValueByPath(toObject, ["urlContext"], fromUrlContext);
    }
    return toObject;
  }
  function tunedModelInfoFromMldev(fromObject) {
    const toObject = {};
    const fromBaseModel = getValueByPath(fromObject, ["baseModel"]);
    if (fromBaseModel != null) {
      setValueByPath(toObject, ["baseModel"], fromBaseModel);
    }
    const fromCreateTime = getValueByPath(fromObject, ["createTime"]);
    if (fromCreateTime != null) {
      setValueByPath(toObject, ["createTime"], fromCreateTime);
    }
    const fromUpdateTime = getValueByPath(fromObject, ["updateTime"]);
    if (fromUpdateTime != null) {
      setValueByPath(toObject, ["updateTime"], fromUpdateTime);
    }
    return toObject;
  }
  function tunedModelInfoFromVertex(fromObject) {
    const toObject = {};
    const fromBaseModel = getValueByPath(fromObject, [
      "labels",
      "google-vertex-llm-tuning-base-model-id"
    ]);
    if (fromBaseModel != null) {
      setValueByPath(toObject, ["baseModel"], fromBaseModel);
    }
    const fromCreateTime = getValueByPath(fromObject, ["createTime"]);
    if (fromCreateTime != null) {
      setValueByPath(toObject, ["createTime"], fromCreateTime);
    }
    const fromUpdateTime = getValueByPath(fromObject, ["updateTime"]);
    if (fromUpdateTime != null) {
      setValueByPath(toObject, ["updateTime"], fromUpdateTime);
    }
    return toObject;
  }
  function updateModelConfigToMldev(fromObject, parentObject) {
    const toObject = {};
    const fromDisplayName = getValueByPath(fromObject, ["displayName"]);
    if (parentObject !== void 0 && fromDisplayName != null) {
      setValueByPath(parentObject, ["displayName"], fromDisplayName);
    }
    const fromDescription = getValueByPath(fromObject, ["description"]);
    if (parentObject !== void 0 && fromDescription != null) {
      setValueByPath(parentObject, ["description"], fromDescription);
    }
    const fromDefaultCheckpointId = getValueByPath(fromObject, [
      "defaultCheckpointId"
    ]);
    if (parentObject !== void 0 && fromDefaultCheckpointId != null) {
      setValueByPath(parentObject, ["defaultCheckpointId"], fromDefaultCheckpointId);
    }
    return toObject;
  }
  function updateModelConfigToVertex(fromObject, parentObject) {
    const toObject = {};
    const fromDisplayName = getValueByPath(fromObject, ["displayName"]);
    if (parentObject !== void 0 && fromDisplayName != null) {
      setValueByPath(parentObject, ["displayName"], fromDisplayName);
    }
    const fromDescription = getValueByPath(fromObject, ["description"]);
    if (parentObject !== void 0 && fromDescription != null) {
      setValueByPath(parentObject, ["description"], fromDescription);
    }
    const fromDefaultCheckpointId = getValueByPath(fromObject, [
      "defaultCheckpointId"
    ]);
    if (parentObject !== void 0 && fromDefaultCheckpointId != null) {
      setValueByPath(parentObject, ["defaultCheckpointId"], fromDefaultCheckpointId);
    }
    return toObject;
  }
  function updateModelParametersToMldev(apiClient, fromObject) {
    const toObject = {};
    const fromModel = getValueByPath(fromObject, ["model"]);
    if (fromModel != null) {
      setValueByPath(toObject, ["_url", "name"], tModel(apiClient, fromModel));
    }
    const fromConfig = getValueByPath(fromObject, ["config"]);
    if (fromConfig != null) {
      updateModelConfigToMldev(fromConfig, toObject);
    }
    return toObject;
  }
  function updateModelParametersToVertex(apiClient, fromObject) {
    const toObject = {};
    const fromModel = getValueByPath(fromObject, ["model"]);
    if (fromModel != null) {
      setValueByPath(toObject, ["_url", "model"], tModel(apiClient, fromModel));
    }
    const fromConfig = getValueByPath(fromObject, ["config"]);
    if (fromConfig != null) {
      updateModelConfigToVertex(fromConfig, toObject);
    }
    return toObject;
  }
  function upscaleImageAPIConfigInternalToVertex(fromObject, parentObject) {
    const toObject = {};
    const fromOutputGcsUri = getValueByPath(fromObject, ["outputGcsUri"]);
    if (parentObject !== void 0 && fromOutputGcsUri != null) {
      setValueByPath(parentObject, ["parameters", "storageUri"], fromOutputGcsUri);
    }
    const fromSafetyFilterLevel = getValueByPath(fromObject, [
      "safetyFilterLevel"
    ]);
    if (parentObject !== void 0 && fromSafetyFilterLevel != null) {
      setValueByPath(parentObject, ["parameters", "safetySetting"], fromSafetyFilterLevel);
    }
    const fromPersonGeneration = getValueByPath(fromObject, [
      "personGeneration"
    ]);
    if (parentObject !== void 0 && fromPersonGeneration != null) {
      setValueByPath(parentObject, ["parameters", "personGeneration"], fromPersonGeneration);
    }
    const fromIncludeRaiReason = getValueByPath(fromObject, [
      "includeRaiReason"
    ]);
    if (parentObject !== void 0 && fromIncludeRaiReason != null) {
      setValueByPath(parentObject, ["parameters", "includeRaiReason"], fromIncludeRaiReason);
    }
    const fromOutputMimeType = getValueByPath(fromObject, [
      "outputMimeType"
    ]);
    if (parentObject !== void 0 && fromOutputMimeType != null) {
      setValueByPath(parentObject, ["parameters", "outputOptions", "mimeType"], fromOutputMimeType);
    }
    const fromOutputCompressionQuality = getValueByPath(fromObject, [
      "outputCompressionQuality"
    ]);
    if (parentObject !== void 0 && fromOutputCompressionQuality != null) {
      setValueByPath(parentObject, ["parameters", "outputOptions", "compressionQuality"], fromOutputCompressionQuality);
    }
    const fromEnhanceInputImage = getValueByPath(fromObject, [
      "enhanceInputImage"
    ]);
    if (parentObject !== void 0 && fromEnhanceInputImage != null) {
      setValueByPath(parentObject, ["parameters", "upscaleConfig", "enhanceInputImage"], fromEnhanceInputImage);
    }
    const fromImagePreservationFactor = getValueByPath(fromObject, [
      "imagePreservationFactor"
    ]);
    if (parentObject !== void 0 && fromImagePreservationFactor != null) {
      setValueByPath(parentObject, ["parameters", "upscaleConfig", "imagePreservationFactor"], fromImagePreservationFactor);
    }
    const fromLabels = getValueByPath(fromObject, ["labels"]);
    if (parentObject !== void 0 && fromLabels != null) {
      setValueByPath(parentObject, ["labels"], fromLabels);
    }
    const fromNumberOfImages = getValueByPath(fromObject, [
      "numberOfImages"
    ]);
    if (parentObject !== void 0 && fromNumberOfImages != null) {
      setValueByPath(parentObject, ["parameters", "sampleCount"], fromNumberOfImages);
    }
    const fromMode = getValueByPath(fromObject, ["mode"]);
    if (parentObject !== void 0 && fromMode != null) {
      setValueByPath(parentObject, ["parameters", "mode"], fromMode);
    }
    return toObject;
  }
  function upscaleImageAPIParametersInternalToVertex(apiClient, fromObject) {
    const toObject = {};
    const fromModel = getValueByPath(fromObject, ["model"]);
    if (fromModel != null) {
      setValueByPath(toObject, ["_url", "model"], tModel(apiClient, fromModel));
    }
    const fromImage = getValueByPath(fromObject, ["image"]);
    if (fromImage != null) {
      setValueByPath(toObject, ["instances[0]", "image"], imageToVertex(fromImage));
    }
    const fromUpscaleFactor = getValueByPath(fromObject, [
      "upscaleFactor"
    ]);
    if (fromUpscaleFactor != null) {
      setValueByPath(toObject, ["parameters", "upscaleConfig", "upscaleFactor"], fromUpscaleFactor);
    }
    const fromConfig = getValueByPath(fromObject, ["config"]);
    if (fromConfig != null) {
      upscaleImageAPIConfigInternalToVertex(fromConfig, toObject);
    }
    return toObject;
  }
  function upscaleImageResponseFromVertex(fromObject) {
    const toObject = {};
    const fromSdkHttpResponse = getValueByPath(fromObject, [
      "sdkHttpResponse"
    ]);
    if (fromSdkHttpResponse != null) {
      setValueByPath(toObject, ["sdkHttpResponse"], fromSdkHttpResponse);
    }
    const fromGeneratedImages = getValueByPath(fromObject, [
      "predictions"
    ]);
    if (fromGeneratedImages != null) {
      let transformedList = fromGeneratedImages;
      if (Array.isArray(transformedList)) {
        transformedList = transformedList.map((item) => {
          return generatedImageFromVertex(item);
        });
      }
      setValueByPath(toObject, ["generatedImages"], transformedList);
    }
    return toObject;
  }
  function videoFromMldev(fromObject) {
    const toObject = {};
    const fromUri = getValueByPath(fromObject, ["uri"]);
    if (fromUri != null) {
      setValueByPath(toObject, ["uri"], fromUri);
    }
    const fromVideoBytes = getValueByPath(fromObject, ["encodedVideo"]);
    if (fromVideoBytes != null) {
      setValueByPath(toObject, ["videoBytes"], tBytes(fromVideoBytes));
    }
    const fromMimeType = getValueByPath(fromObject, ["encoding"]);
    if (fromMimeType != null) {
      setValueByPath(toObject, ["mimeType"], fromMimeType);
    }
    return toObject;
  }
  function videoFromVertex(fromObject) {
    const toObject = {};
    const fromUri = getValueByPath(fromObject, ["gcsUri"]);
    if (fromUri != null) {
      setValueByPath(toObject, ["uri"], fromUri);
    }
    const fromVideoBytes = getValueByPath(fromObject, [
      "bytesBase64Encoded"
    ]);
    if (fromVideoBytes != null) {
      setValueByPath(toObject, ["videoBytes"], tBytes(fromVideoBytes));
    }
    const fromMimeType = getValueByPath(fromObject, ["mimeType"]);
    if (fromMimeType != null) {
      setValueByPath(toObject, ["mimeType"], fromMimeType);
    }
    return toObject;
  }
  function videoGenerationMaskToVertex(fromObject) {
    const toObject = {};
    const fromImage = getValueByPath(fromObject, ["image"]);
    if (fromImage != null) {
      setValueByPath(toObject, ["_self"], imageToVertex(fromImage));
    }
    const fromMaskMode = getValueByPath(fromObject, ["maskMode"]);
    if (fromMaskMode != null) {
      setValueByPath(toObject, ["maskMode"], fromMaskMode);
    }
    return toObject;
  }
  function videoGenerationReferenceImageToMldev(fromObject) {
    const toObject = {};
    const fromImage = getValueByPath(fromObject, ["image"]);
    if (fromImage != null) {
      setValueByPath(toObject, ["image"], imageToMldev(fromImage));
    }
    const fromReferenceType = getValueByPath(fromObject, [
      "referenceType"
    ]);
    if (fromReferenceType != null) {
      setValueByPath(toObject, ["referenceType"], fromReferenceType);
    }
    return toObject;
  }
  function videoGenerationReferenceImageToVertex(fromObject) {
    const toObject = {};
    const fromImage = getValueByPath(fromObject, ["image"]);
    if (fromImage != null) {
      setValueByPath(toObject, ["image"], imageToVertex(fromImage));
    }
    const fromReferenceType = getValueByPath(fromObject, [
      "referenceType"
    ]);
    if (fromReferenceType != null) {
      setValueByPath(toObject, ["referenceType"], fromReferenceType);
    }
    return toObject;
  }
  function videoToMldev(fromObject) {
    const toObject = {};
    const fromUri = getValueByPath(fromObject, ["uri"]);
    if (fromUri != null) {
      setValueByPath(toObject, ["uri"], fromUri);
    }
    const fromVideoBytes = getValueByPath(fromObject, ["videoBytes"]);
    if (fromVideoBytes != null) {
      setValueByPath(toObject, ["encodedVideo"], tBytes(fromVideoBytes));
    }
    const fromMimeType = getValueByPath(fromObject, ["mimeType"]);
    if (fromMimeType != null) {
      setValueByPath(toObject, ["encoding"], fromMimeType);
    }
    return toObject;
  }
  function videoToVertex(fromObject) {
    const toObject = {};
    const fromUri = getValueByPath(fromObject, ["uri"]);
    if (fromUri != null) {
      setValueByPath(toObject, ["gcsUri"], fromUri);
    }
    const fromVideoBytes = getValueByPath(fromObject, ["videoBytes"]);
    if (fromVideoBytes != null) {
      setValueByPath(toObject, ["bytesBase64Encoded"], tBytes(fromVideoBytes));
    }
    const fromMimeType = getValueByPath(fromObject, ["mimeType"]);
    if (fromMimeType != null) {
      setValueByPath(toObject, ["mimeType"], fromMimeType);
    }
    return toObject;
  }
  async function throwErrorIfNotOK(response) {
    var _a;
    if (response === void 0) {
      throw new Error("response is undefined");
    }
    if (!response.ok) {
      const status = response.status;
      let errorBody;
      if ((_a = response.headers.get("content-type")) === null || _a === void 0 ? void 0 : _a.includes("application/json")) {
        errorBody = await response.json();
      } else {
        errorBody = {
          error: {
            message: await response.text(),
            code: response.status,
            status: response.statusText
          }
        };
      }
      const errorMessage = JSON.stringify(errorBody);
      if (status >= 400 && status < 600) {
        const apiError = new ApiError({
          message: errorMessage,
          status
        });
        throw apiError;
      }
      throw new Error(errorMessage);
    }
  }
  function includeExtraBodyToRequestInit(requestInit, extraBody) {
    if (!extraBody || Object.keys(extraBody).length === 0) {
      return;
    }
    if (requestInit.body instanceof Blob) {
      console.warn("includeExtraBodyToRequestInit: extraBody provided but current request body is a Blob. extraBody will be ignored as merging is not supported for Blob bodies.");
      return;
    }
    let currentBodyObject = {};
    if (typeof requestInit.body === "string" && requestInit.body.length > 0) {
      try {
        const parsedBody = JSON.parse(requestInit.body);
        if (typeof parsedBody === "object" && parsedBody !== null && !Array.isArray(parsedBody)) {
          currentBodyObject = parsedBody;
        } else {
          console.warn("includeExtraBodyToRequestInit: Original request body is valid JSON but not a non-array object. Skip applying extraBody to the request body.");
          return;
        }
      } catch (e) {
        console.warn("includeExtraBodyToRequestInit: Original request body is not valid JSON. Skip applying extraBody to the request body.");
        return;
      }
    }
    function deepMerge(target, source) {
      const output = Object.assign({}, target);
      for (const key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          const sourceValue = source[key];
          const targetValue = output[key];
          if (sourceValue && typeof sourceValue === "object" && !Array.isArray(sourceValue) && targetValue && typeof targetValue === "object" && !Array.isArray(targetValue)) {
            output[key] = deepMerge(targetValue, sourceValue);
          } else {
            if (targetValue && sourceValue && typeof targetValue !== typeof sourceValue) {
              console.warn(`includeExtraBodyToRequestInit:deepMerge: Type mismatch for key "${key}". Original type: ${typeof targetValue}, New type: ${typeof sourceValue}. Overwriting.`);
            }
            output[key] = sourceValue;
          }
        }
      }
      return output;
    }
    const mergedBody = deepMerge(currentBodyObject, extraBody);
    requestInit.body = JSON.stringify(mergedBody);
  }
  function hasMcpToolUsage(tools) {
    for (const tool of tools) {
      if (isMcpCallableTool(tool)) {
        return true;
      }
      if (typeof tool === "object" && "inputSchema" in tool) {
        return true;
      }
    }
    return hasMcpToolUsageFromMcpToTool;
  }
  function setMcpUsageHeader(headers) {
    var _a;
    const existingHeader = (_a = headers[GOOGLE_API_CLIENT_HEADER]) !== null && _a !== void 0 ? _a : "";
    headers[GOOGLE_API_CLIENT_HEADER] = (existingHeader + ` ${MCP_LABEL}`).trimStart();
  }
  function isMcpCallableTool(object) {
    return object !== null && typeof object === "object" && object instanceof McpCallableTool;
  }
  function listAllTools(mcpClient, maxTools = 100) {
    return __asyncGenerator(this, arguments, function* listAllTools_1() {
      let cursor = void 0;
      let numTools = 0;
      while (numTools < maxTools) {
        const t = yield __await(mcpClient.listTools({ cursor }));
        for (const tool of t.tools) {
          yield yield __await(tool);
          numTools++;
        }
        if (!t.nextCursor) {
          break;
        }
        cursor = t.nextCursor;
      }
    });
  }
  function isMcpClient(client) {
    return client !== null && typeof client === "object" && "listTools" in client && typeof client.listTools === "function";
  }
  function mcpToTool(...args) {
    hasMcpToolUsageFromMcpToTool = true;
    if (args.length === 0) {
      throw new Error("No MCP clients provided");
    }
    const maybeConfig = args[args.length - 1];
    if (isMcpClient(maybeConfig)) {
      return McpCallableTool.create(args, {});
    }
    return McpCallableTool.create(args.slice(0, args.length - 1), maybeConfig);
  }
  async function handleWebSocketMessage$1(apiClient, onmessage, event) {
    const serverMessage = new LiveMusicServerMessage();
    let data;
    if (event.data instanceof Blob) {
      data = JSON.parse(await event.data.text());
    } else {
      data = JSON.parse(event.data);
    }
    Object.assign(serverMessage, data);
    onmessage(serverMessage);
  }
  function headersToMap$1(headers) {
    const headerMap = {};
    headers.forEach((value, key) => {
      headerMap[key] = value;
    });
    return headerMap;
  }
  function mapToHeaders$1(map) {
    const headers = new Headers();
    for (const [key, value] of Object.entries(map)) {
      headers.append(key, value);
    }
    return headers;
  }
  async function handleWebSocketMessage(apiClient, onmessage, event) {
    const serverMessage = new LiveServerMessage();
    let jsonData;
    if (event.data instanceof Blob) {
      jsonData = await event.data.text();
    } else if (event.data instanceof ArrayBuffer) {
      jsonData = new TextDecoder().decode(event.data);
    } else {
      jsonData = event.data;
    }
    const data = JSON.parse(jsonData);
    if (apiClient.isVertexAI()) {
      const resp = liveServerMessageFromVertex(data);
      Object.assign(serverMessage, resp);
    } else {
      const resp = data;
      Object.assign(serverMessage, resp);
    }
    onmessage(serverMessage);
  }
  function headersToMap(headers) {
    const headerMap = {};
    headers.forEach((value, key) => {
      headerMap[key] = value;
    });
    return headerMap;
  }
  function mapToHeaders(map) {
    const headers = new Headers();
    for (const [key, value] of Object.entries(map)) {
      headers.append(key, value);
    }
    return headers;
  }
  function shouldDisableAfc(config) {
    var _a, _b, _c;
    if ((_a = config === null || config === void 0 ? void 0 : config.automaticFunctionCalling) === null || _a === void 0 ? void 0 : _a.disable) {
      return true;
    }
    let callableToolsPresent = false;
    for (const tool of (_b = config === null || config === void 0 ? void 0 : config.tools) !== null && _b !== void 0 ? _b : []) {
      if (isCallableTool(tool)) {
        callableToolsPresent = true;
        break;
      }
    }
    if (!callableToolsPresent) {
      return true;
    }
    const maxCalls = (_c = config === null || config === void 0 ? void 0 : config.automaticFunctionCalling) === null || _c === void 0 ? void 0 : _c.maximumRemoteCalls;
    if (maxCalls && (maxCalls < 0 || !Number.isInteger(maxCalls)) || maxCalls == 0) {
      console.warn("Invalid maximumRemoteCalls value provided for automatic function calling. Disabled automatic function calling. Please provide a valid integer value greater than 0. maximumRemoteCalls provided:", maxCalls);
      return true;
    }
    return false;
  }
  function isCallableTool(tool) {
    return "callTool" in tool && typeof tool.callTool === "function";
  }
  function hasCallableTools(params) {
    var _a, _b, _c;
    return (_c = (_b = (_a = params.config) === null || _a === void 0 ? void 0 : _a.tools) === null || _b === void 0 ? void 0 : _b.some((tool) => isCallableTool(tool))) !== null && _c !== void 0 ? _c : false;
  }
  function findAfcIncompatibleToolIndexes(params) {
    var _a;
    const afcIncompatibleToolIndexes = [];
    if (!((_a = params === null || params === void 0 ? void 0 : params.config) === null || _a === void 0 ? void 0 : _a.tools)) {
      return afcIncompatibleToolIndexes;
    }
    params.config.tools.forEach((tool, index) => {
      if (isCallableTool(tool)) {
        return;
      }
      const geminiTool = tool;
      if (geminiTool.functionDeclarations && geminiTool.functionDeclarations.length > 0) {
        afcIncompatibleToolIndexes.push(index);
      }
    });
    return afcIncompatibleToolIndexes;
  }
  function shouldAppendAfcHistory(config) {
    var _a;
    return !((_a = config === null || config === void 0 ? void 0 : config.automaticFunctionCalling) === null || _a === void 0 ? void 0 : _a.ignoreCallHistory);
  }
  function blobToMldev(fromObject) {
    const toObject = {};
    const fromData = getValueByPath(fromObject, ["data"]);
    if (fromData != null) {
      setValueByPath(toObject, ["data"], fromData);
    }
    if (getValueByPath(fromObject, ["displayName"]) !== void 0) {
      throw new Error("displayName parameter is not supported in Gemini API.");
    }
    const fromMimeType = getValueByPath(fromObject, ["mimeType"]);
    if (fromMimeType != null) {
      setValueByPath(toObject, ["mimeType"], fromMimeType);
    }
    return toObject;
  }
  function contentToMldev(fromObject) {
    const toObject = {};
    const fromParts = getValueByPath(fromObject, ["parts"]);
    if (fromParts != null) {
      let transformedList = fromParts;
      if (Array.isArray(transformedList)) {
        transformedList = transformedList.map((item) => {
          return partToMldev(item);
        });
      }
      setValueByPath(toObject, ["parts"], transformedList);
    }
    const fromRole = getValueByPath(fromObject, ["role"]);
    if (fromRole != null) {
      setValueByPath(toObject, ["role"], fromRole);
    }
    return toObject;
  }
  function createAuthTokenConfigToMldev(apiClient, fromObject, parentObject) {
    const toObject = {};
    const fromExpireTime = getValueByPath(fromObject, ["expireTime"]);
    if (parentObject !== void 0 && fromExpireTime != null) {
      setValueByPath(parentObject, ["expireTime"], fromExpireTime);
    }
    const fromNewSessionExpireTime = getValueByPath(fromObject, [
      "newSessionExpireTime"
    ]);
    if (parentObject !== void 0 && fromNewSessionExpireTime != null) {
      setValueByPath(parentObject, ["newSessionExpireTime"], fromNewSessionExpireTime);
    }
    const fromUses = getValueByPath(fromObject, ["uses"]);
    if (parentObject !== void 0 && fromUses != null) {
      setValueByPath(parentObject, ["uses"], fromUses);
    }
    const fromLiveConnectConstraints = getValueByPath(fromObject, [
      "liveConnectConstraints"
    ]);
    if (parentObject !== void 0 && fromLiveConnectConstraints != null) {
      setValueByPath(parentObject, ["bidiGenerateContentSetup"], liveConnectConstraintsToMldev(apiClient, fromLiveConnectConstraints));
    }
    const fromLockAdditionalFields = getValueByPath(fromObject, [
      "lockAdditionalFields"
    ]);
    if (parentObject !== void 0 && fromLockAdditionalFields != null) {
      setValueByPath(parentObject, ["fieldMask"], fromLockAdditionalFields);
    }
    return toObject;
  }
  function createAuthTokenParametersToMldev(apiClient, fromObject) {
    const toObject = {};
    const fromConfig = getValueByPath(fromObject, ["config"]);
    if (fromConfig != null) {
      setValueByPath(toObject, ["config"], createAuthTokenConfigToMldev(apiClient, fromConfig, toObject));
    }
    return toObject;
  }
  function fileDataToMldev(fromObject) {
    const toObject = {};
    if (getValueByPath(fromObject, ["displayName"]) !== void 0) {
      throw new Error("displayName parameter is not supported in Gemini API.");
    }
    const fromFileUri = getValueByPath(fromObject, ["fileUri"]);
    if (fromFileUri != null) {
      setValueByPath(toObject, ["fileUri"], fromFileUri);
    }
    const fromMimeType = getValueByPath(fromObject, ["mimeType"]);
    if (fromMimeType != null) {
      setValueByPath(toObject, ["mimeType"], fromMimeType);
    }
    return toObject;
  }
  function functionCallToMldev(fromObject) {
    const toObject = {};
    const fromId = getValueByPath(fromObject, ["id"]);
    if (fromId != null) {
      setValueByPath(toObject, ["id"], fromId);
    }
    const fromArgs = getValueByPath(fromObject, ["args"]);
    if (fromArgs != null) {
      setValueByPath(toObject, ["args"], fromArgs);
    }
    const fromName = getValueByPath(fromObject, ["name"]);
    if (fromName != null) {
      setValueByPath(toObject, ["name"], fromName);
    }
    if (getValueByPath(fromObject, ["partialArgs"]) !== void 0) {
      throw new Error("partialArgs parameter is not supported in Gemini API.");
    }
    if (getValueByPath(fromObject, ["willContinue"]) !== void 0) {
      throw new Error("willContinue parameter is not supported in Gemini API.");
    }
    return toObject;
  }
  function googleMapsToMldev(fromObject) {
    const toObject = {};
    if (getValueByPath(fromObject, ["authConfig"]) !== void 0) {
      throw new Error("authConfig parameter is not supported in Gemini API.");
    }
    const fromEnableWidget = getValueByPath(fromObject, ["enableWidget"]);
    if (fromEnableWidget != null) {
      setValueByPath(toObject, ["enableWidget"], fromEnableWidget);
    }
    return toObject;
  }
  function googleSearchToMldev(fromObject) {
    const toObject = {};
    if (getValueByPath(fromObject, ["excludeDomains"]) !== void 0) {
      throw new Error("excludeDomains parameter is not supported in Gemini API.");
    }
    if (getValueByPath(fromObject, ["blockingConfidence"]) !== void 0) {
      throw new Error("blockingConfidence parameter is not supported in Gemini API.");
    }
    const fromTimeRangeFilter = getValueByPath(fromObject, [
      "timeRangeFilter"
    ]);
    if (fromTimeRangeFilter != null) {
      setValueByPath(toObject, ["timeRangeFilter"], fromTimeRangeFilter);
    }
    return toObject;
  }
  function liveConnectConfigToMldev(fromObject, parentObject) {
    const toObject = {};
    const fromGenerationConfig = getValueByPath(fromObject, [
      "generationConfig"
    ]);
    if (parentObject !== void 0 && fromGenerationConfig != null) {
      setValueByPath(parentObject, ["setup", "generationConfig"], fromGenerationConfig);
    }
    const fromResponseModalities = getValueByPath(fromObject, [
      "responseModalities"
    ]);
    if (parentObject !== void 0 && fromResponseModalities != null) {
      setValueByPath(parentObject, ["setup", "generationConfig", "responseModalities"], fromResponseModalities);
    }
    const fromTemperature = getValueByPath(fromObject, ["temperature"]);
    if (parentObject !== void 0 && fromTemperature != null) {
      setValueByPath(parentObject, ["setup", "generationConfig", "temperature"], fromTemperature);
    }
    const fromTopP = getValueByPath(fromObject, ["topP"]);
    if (parentObject !== void 0 && fromTopP != null) {
      setValueByPath(parentObject, ["setup", "generationConfig", "topP"], fromTopP);
    }
    const fromTopK = getValueByPath(fromObject, ["topK"]);
    if (parentObject !== void 0 && fromTopK != null) {
      setValueByPath(parentObject, ["setup", "generationConfig", "topK"], fromTopK);
    }
    const fromMaxOutputTokens = getValueByPath(fromObject, [
      "maxOutputTokens"
    ]);
    if (parentObject !== void 0 && fromMaxOutputTokens != null) {
      setValueByPath(parentObject, ["setup", "generationConfig", "maxOutputTokens"], fromMaxOutputTokens);
    }
    const fromMediaResolution = getValueByPath(fromObject, [
      "mediaResolution"
    ]);
    if (parentObject !== void 0 && fromMediaResolution != null) {
      setValueByPath(parentObject, ["setup", "generationConfig", "mediaResolution"], fromMediaResolution);
    }
    const fromSeed = getValueByPath(fromObject, ["seed"]);
    if (parentObject !== void 0 && fromSeed != null) {
      setValueByPath(parentObject, ["setup", "generationConfig", "seed"], fromSeed);
    }
    const fromSpeechConfig = getValueByPath(fromObject, ["speechConfig"]);
    if (parentObject !== void 0 && fromSpeechConfig != null) {
      setValueByPath(parentObject, ["setup", "generationConfig", "speechConfig"], tLiveSpeechConfig(fromSpeechConfig));
    }
    const fromThinkingConfig = getValueByPath(fromObject, [
      "thinkingConfig"
    ]);
    if (parentObject !== void 0 && fromThinkingConfig != null) {
      setValueByPath(parentObject, ["setup", "generationConfig", "thinkingConfig"], fromThinkingConfig);
    }
    const fromEnableAffectiveDialog = getValueByPath(fromObject, [
      "enableAffectiveDialog"
    ]);
    if (parentObject !== void 0 && fromEnableAffectiveDialog != null) {
      setValueByPath(parentObject, ["setup", "generationConfig", "enableAffectiveDialog"], fromEnableAffectiveDialog);
    }
    const fromSystemInstruction = getValueByPath(fromObject, [
      "systemInstruction"
    ]);
    if (parentObject !== void 0 && fromSystemInstruction != null) {
      setValueByPath(parentObject, ["setup", "systemInstruction"], contentToMldev(tContent(fromSystemInstruction)));
    }
    const fromTools = getValueByPath(fromObject, ["tools"]);
    if (parentObject !== void 0 && fromTools != null) {
      let transformedList = tTools(fromTools);
      if (Array.isArray(transformedList)) {
        transformedList = transformedList.map((item) => {
          return toolToMldev(tTool(item));
        });
      }
      setValueByPath(parentObject, ["setup", "tools"], transformedList);
    }
    const fromSessionResumption = getValueByPath(fromObject, [
      "sessionResumption"
    ]);
    if (parentObject !== void 0 && fromSessionResumption != null) {
      setValueByPath(parentObject, ["setup", "sessionResumption"], sessionResumptionConfigToMldev(fromSessionResumption));
    }
    const fromInputAudioTranscription = getValueByPath(fromObject, [
      "inputAudioTranscription"
    ]);
    if (parentObject !== void 0 && fromInputAudioTranscription != null) {
      setValueByPath(parentObject, ["setup", "inputAudioTranscription"], fromInputAudioTranscription);
    }
    const fromOutputAudioTranscription = getValueByPath(fromObject, [
      "outputAudioTranscription"
    ]);
    if (parentObject !== void 0 && fromOutputAudioTranscription != null) {
      setValueByPath(parentObject, ["setup", "outputAudioTranscription"], fromOutputAudioTranscription);
    }
    const fromRealtimeInputConfig = getValueByPath(fromObject, [
      "realtimeInputConfig"
    ]);
    if (parentObject !== void 0 && fromRealtimeInputConfig != null) {
      setValueByPath(parentObject, ["setup", "realtimeInputConfig"], fromRealtimeInputConfig);
    }
    const fromContextWindowCompression = getValueByPath(fromObject, [
      "contextWindowCompression"
    ]);
    if (parentObject !== void 0 && fromContextWindowCompression != null) {
      setValueByPath(parentObject, ["setup", "contextWindowCompression"], fromContextWindowCompression);
    }
    const fromProactivity = getValueByPath(fromObject, ["proactivity"]);
    if (parentObject !== void 0 && fromProactivity != null) {
      setValueByPath(parentObject, ["setup", "proactivity"], fromProactivity);
    }
    return toObject;
  }
  function liveConnectConstraintsToMldev(apiClient, fromObject) {
    const toObject = {};
    const fromModel = getValueByPath(fromObject, ["model"]);
    if (fromModel != null) {
      setValueByPath(toObject, ["setup", "model"], tModel(apiClient, fromModel));
    }
    const fromConfig = getValueByPath(fromObject, ["config"]);
    if (fromConfig != null) {
      setValueByPath(toObject, ["config"], liveConnectConfigToMldev(fromConfig, toObject));
    }
    return toObject;
  }
  function partToMldev(fromObject) {
    const toObject = {};
    const fromMediaResolution = getValueByPath(fromObject, [
      "mediaResolution"
    ]);
    if (fromMediaResolution != null) {
      setValueByPath(toObject, ["mediaResolution"], fromMediaResolution);
    }
    const fromCodeExecutionResult = getValueByPath(fromObject, [
      "codeExecutionResult"
    ]);
    if (fromCodeExecutionResult != null) {
      setValueByPath(toObject, ["codeExecutionResult"], fromCodeExecutionResult);
    }
    const fromExecutableCode = getValueByPath(fromObject, [
      "executableCode"
    ]);
    if (fromExecutableCode != null) {
      setValueByPath(toObject, ["executableCode"], fromExecutableCode);
    }
    const fromFileData = getValueByPath(fromObject, ["fileData"]);
    if (fromFileData != null) {
      setValueByPath(toObject, ["fileData"], fileDataToMldev(fromFileData));
    }
    const fromFunctionCall = getValueByPath(fromObject, ["functionCall"]);
    if (fromFunctionCall != null) {
      setValueByPath(toObject, ["functionCall"], functionCallToMldev(fromFunctionCall));
    }
    const fromFunctionResponse = getValueByPath(fromObject, [
      "functionResponse"
    ]);
    if (fromFunctionResponse != null) {
      setValueByPath(toObject, ["functionResponse"], fromFunctionResponse);
    }
    const fromInlineData = getValueByPath(fromObject, ["inlineData"]);
    if (fromInlineData != null) {
      setValueByPath(toObject, ["inlineData"], blobToMldev(fromInlineData));
    }
    const fromText = getValueByPath(fromObject, ["text"]);
    if (fromText != null) {
      setValueByPath(toObject, ["text"], fromText);
    }
    const fromThought = getValueByPath(fromObject, ["thought"]);
    if (fromThought != null) {
      setValueByPath(toObject, ["thought"], fromThought);
    }
    const fromThoughtSignature = getValueByPath(fromObject, [
      "thoughtSignature"
    ]);
    if (fromThoughtSignature != null) {
      setValueByPath(toObject, ["thoughtSignature"], fromThoughtSignature);
    }
    const fromVideoMetadata = getValueByPath(fromObject, [
      "videoMetadata"
    ]);
    if (fromVideoMetadata != null) {
      setValueByPath(toObject, ["videoMetadata"], fromVideoMetadata);
    }
    return toObject;
  }
  function sessionResumptionConfigToMldev(fromObject) {
    const toObject = {};
    const fromHandle = getValueByPath(fromObject, ["handle"]);
    if (fromHandle != null) {
      setValueByPath(toObject, ["handle"], fromHandle);
    }
    if (getValueByPath(fromObject, ["transparent"]) !== void 0) {
      throw new Error("transparent parameter is not supported in Gemini API.");
    }
    return toObject;
  }
  function toolToMldev(fromObject) {
    const toObject = {};
    const fromFunctionDeclarations = getValueByPath(fromObject, [
      "functionDeclarations"
    ]);
    if (fromFunctionDeclarations != null) {
      let transformedList = fromFunctionDeclarations;
      if (Array.isArray(transformedList)) {
        transformedList = transformedList.map((item) => {
          return item;
        });
      }
      setValueByPath(toObject, ["functionDeclarations"], transformedList);
    }
    if (getValueByPath(fromObject, ["retrieval"]) !== void 0) {
      throw new Error("retrieval parameter is not supported in Gemini API.");
    }
    const fromGoogleSearchRetrieval = getValueByPath(fromObject, [
      "googleSearchRetrieval"
    ]);
    if (fromGoogleSearchRetrieval != null) {
      setValueByPath(toObject, ["googleSearchRetrieval"], fromGoogleSearchRetrieval);
    }
    const fromComputerUse = getValueByPath(fromObject, ["computerUse"]);
    if (fromComputerUse != null) {
      setValueByPath(toObject, ["computerUse"], fromComputerUse);
    }
    const fromFileSearch = getValueByPath(fromObject, ["fileSearch"]);
    if (fromFileSearch != null) {
      setValueByPath(toObject, ["fileSearch"], fromFileSearch);
    }
    const fromCodeExecution = getValueByPath(fromObject, [
      "codeExecution"
    ]);
    if (fromCodeExecution != null) {
      setValueByPath(toObject, ["codeExecution"], fromCodeExecution);
    }
    if (getValueByPath(fromObject, ["enterpriseWebSearch"]) !== void 0) {
      throw new Error("enterpriseWebSearch parameter is not supported in Gemini API.");
    }
    const fromGoogleMaps = getValueByPath(fromObject, ["googleMaps"]);
    if (fromGoogleMaps != null) {
      setValueByPath(toObject, ["googleMaps"], googleMapsToMldev(fromGoogleMaps));
    }
    const fromGoogleSearch = getValueByPath(fromObject, ["googleSearch"]);
    if (fromGoogleSearch != null) {
      setValueByPath(toObject, ["googleSearch"], googleSearchToMldev(fromGoogleSearch));
    }
    const fromUrlContext = getValueByPath(fromObject, ["urlContext"]);
    if (fromUrlContext != null) {
      setValueByPath(toObject, ["urlContext"], fromUrlContext);
    }
    return toObject;
  }
  function getFieldMasks(setup) {
    const fields = [];
    for (const key in setup) {
      if (Object.prototype.hasOwnProperty.call(setup, key)) {
        const value = setup[key];
        if (typeof value === "object" && value != null && Object.keys(value).length > 0) {
          const field = Object.keys(value).map((kk) => `${key}.${kk}`);
          fields.push(...field);
        } else {
          fields.push(key);
        }
      }
    }
    return fields.join(",");
  }
  function convertBidiSetupToTokenSetup(requestDict, config) {
    let setupForMaskGeneration = null;
    const bidiGenerateContentSetupValue = requestDict["bidiGenerateContentSetup"];
    if (typeof bidiGenerateContentSetupValue === "object" && bidiGenerateContentSetupValue !== null && "setup" in bidiGenerateContentSetupValue) {
      const innerSetup = bidiGenerateContentSetupValue.setup;
      if (typeof innerSetup === "object" && innerSetup !== null) {
        requestDict["bidiGenerateContentSetup"] = innerSetup;
        setupForMaskGeneration = innerSetup;
      } else {
        delete requestDict["bidiGenerateContentSetup"];
      }
    } else if (bidiGenerateContentSetupValue !== void 0) {
      delete requestDict["bidiGenerateContentSetup"];
    }
    const preExistingFieldMask = requestDict["fieldMask"];
    if (setupForMaskGeneration) {
      const generatedMaskFromBidi = getFieldMasks(setupForMaskGeneration);
      if (Array.isArray(config === null || config === void 0 ? void 0 : config.lockAdditionalFields) && (config === null || config === void 0 ? void 0 : config.lockAdditionalFields.length) === 0) {
        if (generatedMaskFromBidi) {
          requestDict["fieldMask"] = generatedMaskFromBidi;
        } else {
          delete requestDict["fieldMask"];
        }
      } else if ((config === null || config === void 0 ? void 0 : config.lockAdditionalFields) && config.lockAdditionalFields.length > 0 && preExistingFieldMask !== null && Array.isArray(preExistingFieldMask) && preExistingFieldMask.length > 0) {
        const generationConfigFields = [
          "temperature",
          "topK",
          "topP",
          "maxOutputTokens",
          "responseModalities",
          "seed",
          "speechConfig"
        ];
        let mappedFieldsFromPreExisting = [];
        if (preExistingFieldMask.length > 0) {
          mappedFieldsFromPreExisting = preExistingFieldMask.map((field) => {
            if (generationConfigFields.includes(field)) {
              return `generationConfig.${field}`;
            }
            return field;
          });
        }
        const finalMaskParts = [];
        if (generatedMaskFromBidi) {
          finalMaskParts.push(generatedMaskFromBidi);
        }
        if (mappedFieldsFromPreExisting.length > 0) {
          finalMaskParts.push(...mappedFieldsFromPreExisting);
        }
        if (finalMaskParts.length > 0) {
          requestDict["fieldMask"] = finalMaskParts.join(",");
        } else {
          delete requestDict["fieldMask"];
        }
      } else {
        delete requestDict["fieldMask"];
      }
    } else {
      if (preExistingFieldMask !== null && Array.isArray(preExistingFieldMask) && preExistingFieldMask.length > 0) {
        requestDict["fieldMask"] = preExistingFieldMask.join(",");
      } else {
        delete requestDict["fieldMask"];
      }
    }
    return requestDict;
  }
  function createFileSearchStoreConfigToMldev(fromObject, parentObject) {
    const toObject = {};
    const fromDisplayName = getValueByPath(fromObject, ["displayName"]);
    if (parentObject !== void 0 && fromDisplayName != null) {
      setValueByPath(parentObject, ["displayName"], fromDisplayName);
    }
    return toObject;
  }
  function createFileSearchStoreParametersToMldev(fromObject) {
    const toObject = {};
    const fromConfig = getValueByPath(fromObject, ["config"]);
    if (fromConfig != null) {
      createFileSearchStoreConfigToMldev(fromConfig, toObject);
    }
    return toObject;
  }
  function deleteFileSearchStoreConfigToMldev(fromObject, parentObject) {
    const toObject = {};
    const fromForce = getValueByPath(fromObject, ["force"]);
    if (parentObject !== void 0 && fromForce != null) {
      setValueByPath(parentObject, ["_query", "force"], fromForce);
    }
    return toObject;
  }
  function deleteFileSearchStoreParametersToMldev(fromObject) {
    const toObject = {};
    const fromName = getValueByPath(fromObject, ["name"]);
    if (fromName != null) {
      setValueByPath(toObject, ["_url", "name"], fromName);
    }
    const fromConfig = getValueByPath(fromObject, ["config"]);
    if (fromConfig != null) {
      deleteFileSearchStoreConfigToMldev(fromConfig, toObject);
    }
    return toObject;
  }
  function getFileSearchStoreParametersToMldev(fromObject) {
    const toObject = {};
    const fromName = getValueByPath(fromObject, ["name"]);
    if (fromName != null) {
      setValueByPath(toObject, ["_url", "name"], fromName);
    }
    return toObject;
  }
  function importFileConfigToMldev(fromObject, parentObject) {
    const toObject = {};
    const fromCustomMetadata = getValueByPath(fromObject, [
      "customMetadata"
    ]);
    if (parentObject !== void 0 && fromCustomMetadata != null) {
      let transformedList = fromCustomMetadata;
      if (Array.isArray(transformedList)) {
        transformedList = transformedList.map((item) => {
          return item;
        });
      }
      setValueByPath(parentObject, ["customMetadata"], transformedList);
    }
    const fromChunkingConfig = getValueByPath(fromObject, [
      "chunkingConfig"
    ]);
    if (parentObject !== void 0 && fromChunkingConfig != null) {
      setValueByPath(parentObject, ["chunkingConfig"], fromChunkingConfig);
    }
    return toObject;
  }
  function importFileOperationFromMldev(fromObject) {
    const toObject = {};
    const fromName = getValueByPath(fromObject, ["name"]);
    if (fromName != null) {
      setValueByPath(toObject, ["name"], fromName);
    }
    const fromMetadata = getValueByPath(fromObject, ["metadata"]);
    if (fromMetadata != null) {
      setValueByPath(toObject, ["metadata"], fromMetadata);
    }
    const fromDone = getValueByPath(fromObject, ["done"]);
    if (fromDone != null) {
      setValueByPath(toObject, ["done"], fromDone);
    }
    const fromError = getValueByPath(fromObject, ["error"]);
    if (fromError != null) {
      setValueByPath(toObject, ["error"], fromError);
    }
    const fromResponse = getValueByPath(fromObject, ["response"]);
    if (fromResponse != null) {
      setValueByPath(toObject, ["response"], importFileResponseFromMldev(fromResponse));
    }
    return toObject;
  }
  function importFileParametersToMldev(fromObject) {
    const toObject = {};
    const fromFileSearchStoreName = getValueByPath(fromObject, [
      "fileSearchStoreName"
    ]);
    if (fromFileSearchStoreName != null) {
      setValueByPath(toObject, ["_url", "file_search_store_name"], fromFileSearchStoreName);
    }
    const fromFileName = getValueByPath(fromObject, ["fileName"]);
    if (fromFileName != null) {
      setValueByPath(toObject, ["fileName"], fromFileName);
    }
    const fromConfig = getValueByPath(fromObject, ["config"]);
    if (fromConfig != null) {
      importFileConfigToMldev(fromConfig, toObject);
    }
    return toObject;
  }
  function importFileResponseFromMldev(fromObject) {
    const toObject = {};
    const fromSdkHttpResponse = getValueByPath(fromObject, [
      "sdkHttpResponse"
    ]);
    if (fromSdkHttpResponse != null) {
      setValueByPath(toObject, ["sdkHttpResponse"], fromSdkHttpResponse);
    }
    const fromParent = getValueByPath(fromObject, ["parent"]);
    if (fromParent != null) {
      setValueByPath(toObject, ["parent"], fromParent);
    }
    const fromDocumentName = getValueByPath(fromObject, ["documentName"]);
    if (fromDocumentName != null) {
      setValueByPath(toObject, ["documentName"], fromDocumentName);
    }
    return toObject;
  }
  function listFileSearchStoresConfigToMldev(fromObject, parentObject) {
    const toObject = {};
    const fromPageSize = getValueByPath(fromObject, ["pageSize"]);
    if (parentObject !== void 0 && fromPageSize != null) {
      setValueByPath(parentObject, ["_query", "pageSize"], fromPageSize);
    }
    const fromPageToken = getValueByPath(fromObject, ["pageToken"]);
    if (parentObject !== void 0 && fromPageToken != null) {
      setValueByPath(parentObject, ["_query", "pageToken"], fromPageToken);
    }
    return toObject;
  }
  function listFileSearchStoresParametersToMldev(fromObject) {
    const toObject = {};
    const fromConfig = getValueByPath(fromObject, ["config"]);
    if (fromConfig != null) {
      listFileSearchStoresConfigToMldev(fromConfig, toObject);
    }
    return toObject;
  }
  function listFileSearchStoresResponseFromMldev(fromObject) {
    const toObject = {};
    const fromSdkHttpResponse = getValueByPath(fromObject, [
      "sdkHttpResponse"
    ]);
    if (fromSdkHttpResponse != null) {
      setValueByPath(toObject, ["sdkHttpResponse"], fromSdkHttpResponse);
    }
    const fromNextPageToken = getValueByPath(fromObject, [
      "nextPageToken"
    ]);
    if (fromNextPageToken != null) {
      setValueByPath(toObject, ["nextPageToken"], fromNextPageToken);
    }
    const fromFileSearchStores = getValueByPath(fromObject, [
      "fileSearchStores"
    ]);
    if (fromFileSearchStores != null) {
      let transformedList = fromFileSearchStores;
      if (Array.isArray(transformedList)) {
        transformedList = transformedList.map((item) => {
          return item;
        });
      }
      setValueByPath(toObject, ["fileSearchStores"], transformedList);
    }
    return toObject;
  }
  function uploadToFileSearchStoreConfigToMldev(fromObject, parentObject) {
    const toObject = {};
    const fromMimeType = getValueByPath(fromObject, ["mimeType"]);
    if (parentObject !== void 0 && fromMimeType != null) {
      setValueByPath(parentObject, ["mimeType"], fromMimeType);
    }
    const fromDisplayName = getValueByPath(fromObject, ["displayName"]);
    if (parentObject !== void 0 && fromDisplayName != null) {
      setValueByPath(parentObject, ["displayName"], fromDisplayName);
    }
    const fromCustomMetadata = getValueByPath(fromObject, [
      "customMetadata"
    ]);
    if (parentObject !== void 0 && fromCustomMetadata != null) {
      let transformedList = fromCustomMetadata;
      if (Array.isArray(transformedList)) {
        transformedList = transformedList.map((item) => {
          return item;
        });
      }
      setValueByPath(parentObject, ["customMetadata"], transformedList);
    }
    const fromChunkingConfig = getValueByPath(fromObject, [
      "chunkingConfig"
    ]);
    if (parentObject !== void 0 && fromChunkingConfig != null) {
      setValueByPath(parentObject, ["chunkingConfig"], fromChunkingConfig);
    }
    return toObject;
  }
  function uploadToFileSearchStoreParametersToMldev(fromObject) {
    const toObject = {};
    const fromFileSearchStoreName = getValueByPath(fromObject, [
      "fileSearchStoreName"
    ]);
    if (fromFileSearchStoreName != null) {
      setValueByPath(toObject, ["_url", "file_search_store_name"], fromFileSearchStoreName);
    }
    const fromConfig = getValueByPath(fromObject, ["config"]);
    if (fromConfig != null) {
      uploadToFileSearchStoreConfigToMldev(fromConfig, toObject);
    }
    return toObject;
  }
  function uploadToFileSearchStoreResumableResponseFromMldev(fromObject) {
    const toObject = {};
    const fromSdkHttpResponse = getValueByPath(fromObject, [
      "sdkHttpResponse"
    ]);
    if (fromSdkHttpResponse != null) {
      setValueByPath(toObject, ["sdkHttpResponse"], fromSdkHttpResponse);
    }
    return toObject;
  }
  function deleteDocumentConfigToMldev(fromObject, parentObject) {
    const toObject = {};
    const fromForce = getValueByPath(fromObject, ["force"]);
    if (parentObject !== void 0 && fromForce != null) {
      setValueByPath(parentObject, ["_query", "force"], fromForce);
    }
    return toObject;
  }
  function deleteDocumentParametersToMldev(fromObject) {
    const toObject = {};
    const fromName = getValueByPath(fromObject, ["name"]);
    if (fromName != null) {
      setValueByPath(toObject, ["_url", "name"], fromName);
    }
    const fromConfig = getValueByPath(fromObject, ["config"]);
    if (fromConfig != null) {
      deleteDocumentConfigToMldev(fromConfig, toObject);
    }
    return toObject;
  }
  function getDocumentParametersToMldev(fromObject) {
    const toObject = {};
    const fromName = getValueByPath(fromObject, ["name"]);
    if (fromName != null) {
      setValueByPath(toObject, ["_url", "name"], fromName);
    }
    return toObject;
  }
  function listDocumentsConfigToMldev(fromObject, parentObject) {
    const toObject = {};
    const fromPageSize = getValueByPath(fromObject, ["pageSize"]);
    if (parentObject !== void 0 && fromPageSize != null) {
      setValueByPath(parentObject, ["_query", "pageSize"], fromPageSize);
    }
    const fromPageToken = getValueByPath(fromObject, ["pageToken"]);
    if (parentObject !== void 0 && fromPageToken != null) {
      setValueByPath(parentObject, ["_query", "pageToken"], fromPageToken);
    }
    return toObject;
  }
  function listDocumentsParametersToMldev(fromObject) {
    const toObject = {};
    const fromParent = getValueByPath(fromObject, ["parent"]);
    if (fromParent != null) {
      setValueByPath(toObject, ["_url", "parent"], fromParent);
    }
    const fromConfig = getValueByPath(fromObject, ["config"]);
    if (fromConfig != null) {
      listDocumentsConfigToMldev(fromConfig, toObject);
    }
    return toObject;
  }
  function listDocumentsResponseFromMldev(fromObject) {
    const toObject = {};
    const fromSdkHttpResponse = getValueByPath(fromObject, [
      "sdkHttpResponse"
    ]);
    if (fromSdkHttpResponse != null) {
      setValueByPath(toObject, ["sdkHttpResponse"], fromSdkHttpResponse);
    }
    const fromNextPageToken = getValueByPath(fromObject, [
      "nextPageToken"
    ]);
    if (fromNextPageToken != null) {
      setValueByPath(toObject, ["nextPageToken"], fromNextPageToken);
    }
    const fromDocuments = getValueByPath(fromObject, ["documents"]);
    if (fromDocuments != null) {
      let transformedList = fromDocuments;
      if (Array.isArray(transformedList)) {
        transformedList = transformedList.map((item) => {
          return item;
        });
      }
      setValueByPath(toObject, ["documents"], transformedList);
    }
    return toObject;
  }
  function cancelTuningJobParametersToMldev(fromObject, _rootObject) {
    const toObject = {};
    const fromName = getValueByPath(fromObject, ["name"]);
    if (fromName != null) {
      setValueByPath(toObject, ["_url", "name"], fromName);
    }
    return toObject;
  }
  function cancelTuningJobParametersToVertex(fromObject, _rootObject) {
    const toObject = {};
    const fromName = getValueByPath(fromObject, ["name"]);
    if (fromName != null) {
      setValueByPath(toObject, ["_url", "name"], fromName);
    }
    return toObject;
  }
  function createTuningJobConfigToMldev(fromObject, parentObject, _rootObject) {
    const toObject = {};
    if (getValueByPath(fromObject, ["validationDataset"]) !== void 0) {
      throw new Error("validationDataset parameter is not supported in Gemini API.");
    }
    const fromTunedModelDisplayName = getValueByPath(fromObject, [
      "tunedModelDisplayName"
    ]);
    if (parentObject !== void 0 && fromTunedModelDisplayName != null) {
      setValueByPath(parentObject, ["displayName"], fromTunedModelDisplayName);
    }
    if (getValueByPath(fromObject, ["description"]) !== void 0) {
      throw new Error("description parameter is not supported in Gemini API.");
    }
    const fromEpochCount = getValueByPath(fromObject, ["epochCount"]);
    if (parentObject !== void 0 && fromEpochCount != null) {
      setValueByPath(parentObject, ["tuningTask", "hyperparameters", "epochCount"], fromEpochCount);
    }
    const fromLearningRateMultiplier = getValueByPath(fromObject, [
      "learningRateMultiplier"
    ]);
    if (fromLearningRateMultiplier != null) {
      setValueByPath(toObject, ["tuningTask", "hyperparameters", "learningRateMultiplier"], fromLearningRateMultiplier);
    }
    if (getValueByPath(fromObject, ["exportLastCheckpointOnly"]) !== void 0) {
      throw new Error("exportLastCheckpointOnly parameter is not supported in Gemini API.");
    }
    if (getValueByPath(fromObject, ["preTunedModelCheckpointId"]) !== void 0) {
      throw new Error("preTunedModelCheckpointId parameter is not supported in Gemini API.");
    }
    if (getValueByPath(fromObject, ["adapterSize"]) !== void 0) {
      throw new Error("adapterSize parameter is not supported in Gemini API.");
    }
    const fromBatchSize = getValueByPath(fromObject, ["batchSize"]);
    if (parentObject !== void 0 && fromBatchSize != null) {
      setValueByPath(parentObject, ["tuningTask", "hyperparameters", "batchSize"], fromBatchSize);
    }
    const fromLearningRate = getValueByPath(fromObject, ["learningRate"]);
    if (parentObject !== void 0 && fromLearningRate != null) {
      setValueByPath(parentObject, ["tuningTask", "hyperparameters", "learningRate"], fromLearningRate);
    }
    if (getValueByPath(fromObject, ["labels"]) !== void 0) {
      throw new Error("labels parameter is not supported in Gemini API.");
    }
    if (getValueByPath(fromObject, ["beta"]) !== void 0) {
      throw new Error("beta parameter is not supported in Gemini API.");
    }
    return toObject;
  }
  function createTuningJobConfigToVertex(fromObject, parentObject, rootObject) {
    const toObject = {};
    let discriminatorValidationDataset = getValueByPath(rootObject, [
      "config",
      "method"
    ]);
    if (discriminatorValidationDataset === void 0) {
      discriminatorValidationDataset = "SUPERVISED_FINE_TUNING";
    }
    if (discriminatorValidationDataset === "SUPERVISED_FINE_TUNING") {
      const fromValidationDataset = getValueByPath(fromObject, [
        "validationDataset"
      ]);
      if (parentObject !== void 0 && fromValidationDataset != null) {
        setValueByPath(parentObject, ["supervisedTuningSpec"], tuningValidationDatasetToVertex(fromValidationDataset));
      }
    } else if (discriminatorValidationDataset === "PREFERENCE_TUNING") {
      const fromValidationDataset = getValueByPath(fromObject, [
        "validationDataset"
      ]);
      if (parentObject !== void 0 && fromValidationDataset != null) {
        setValueByPath(parentObject, ["preferenceOptimizationSpec"], tuningValidationDatasetToVertex(fromValidationDataset));
      }
    }
    const fromTunedModelDisplayName = getValueByPath(fromObject, [
      "tunedModelDisplayName"
    ]);
    if (parentObject !== void 0 && fromTunedModelDisplayName != null) {
      setValueByPath(parentObject, ["tunedModelDisplayName"], fromTunedModelDisplayName);
    }
    const fromDescription = getValueByPath(fromObject, ["description"]);
    if (parentObject !== void 0 && fromDescription != null) {
      setValueByPath(parentObject, ["description"], fromDescription);
    }
    let discriminatorEpochCount = getValueByPath(rootObject, [
      "config",
      "method"
    ]);
    if (discriminatorEpochCount === void 0) {
      discriminatorEpochCount = "SUPERVISED_FINE_TUNING";
    }
    if (discriminatorEpochCount === "SUPERVISED_FINE_TUNING") {
      const fromEpochCount = getValueByPath(fromObject, ["epochCount"]);
      if (parentObject !== void 0 && fromEpochCount != null) {
        setValueByPath(parentObject, ["supervisedTuningSpec", "hyperParameters", "epochCount"], fromEpochCount);
      }
    } else if (discriminatorEpochCount === "PREFERENCE_TUNING") {
      const fromEpochCount = getValueByPath(fromObject, ["epochCount"]);
      if (parentObject !== void 0 && fromEpochCount != null) {
        setValueByPath(parentObject, ["preferenceOptimizationSpec", "hyperParameters", "epochCount"], fromEpochCount);
      }
    }
    let discriminatorLearningRateMultiplier = getValueByPath(rootObject, [
      "config",
      "method"
    ]);
    if (discriminatorLearningRateMultiplier === void 0) {
      discriminatorLearningRateMultiplier = "SUPERVISED_FINE_TUNING";
    }
    if (discriminatorLearningRateMultiplier === "SUPERVISED_FINE_TUNING") {
      const fromLearningRateMultiplier = getValueByPath(fromObject, [
        "learningRateMultiplier"
      ]);
      if (parentObject !== void 0 && fromLearningRateMultiplier != null) {
        setValueByPath(parentObject, ["supervisedTuningSpec", "hyperParameters", "learningRateMultiplier"], fromLearningRateMultiplier);
      }
    } else if (discriminatorLearningRateMultiplier === "PREFERENCE_TUNING") {
      const fromLearningRateMultiplier = getValueByPath(fromObject, [
        "learningRateMultiplier"
      ]);
      if (parentObject !== void 0 && fromLearningRateMultiplier != null) {
        setValueByPath(parentObject, [
          "preferenceOptimizationSpec",
          "hyperParameters",
          "learningRateMultiplier"
        ], fromLearningRateMultiplier);
      }
    }
    let discriminatorExportLastCheckpointOnly = getValueByPath(rootObject, ["config", "method"]);
    if (discriminatorExportLastCheckpointOnly === void 0) {
      discriminatorExportLastCheckpointOnly = "SUPERVISED_FINE_TUNING";
    }
    if (discriminatorExportLastCheckpointOnly === "SUPERVISED_FINE_TUNING") {
      const fromExportLastCheckpointOnly = getValueByPath(fromObject, [
        "exportLastCheckpointOnly"
      ]);
      if (parentObject !== void 0 && fromExportLastCheckpointOnly != null) {
        setValueByPath(parentObject, ["supervisedTuningSpec", "exportLastCheckpointOnly"], fromExportLastCheckpointOnly);
      }
    } else if (discriminatorExportLastCheckpointOnly === "PREFERENCE_TUNING") {
      const fromExportLastCheckpointOnly = getValueByPath(fromObject, [
        "exportLastCheckpointOnly"
      ]);
      if (parentObject !== void 0 && fromExportLastCheckpointOnly != null) {
        setValueByPath(parentObject, ["preferenceOptimizationSpec", "exportLastCheckpointOnly"], fromExportLastCheckpointOnly);
      }
    }
    let discriminatorAdapterSize = getValueByPath(rootObject, [
      "config",
      "method"
    ]);
    if (discriminatorAdapterSize === void 0) {
      discriminatorAdapterSize = "SUPERVISED_FINE_TUNING";
    }
    if (discriminatorAdapterSize === "SUPERVISED_FINE_TUNING") {
      const fromAdapterSize = getValueByPath(fromObject, ["adapterSize"]);
      if (parentObject !== void 0 && fromAdapterSize != null) {
        setValueByPath(parentObject, ["supervisedTuningSpec", "hyperParameters", "adapterSize"], fromAdapterSize);
      }
    } else if (discriminatorAdapterSize === "PREFERENCE_TUNING") {
      const fromAdapterSize = getValueByPath(fromObject, ["adapterSize"]);
      if (parentObject !== void 0 && fromAdapterSize != null) {
        setValueByPath(parentObject, ["preferenceOptimizationSpec", "hyperParameters", "adapterSize"], fromAdapterSize);
      }
    }
    if (getValueByPath(fromObject, ["batchSize"]) !== void 0) {
      throw new Error("batchSize parameter is not supported in Vertex AI.");
    }
    if (getValueByPath(fromObject, ["learningRate"]) !== void 0) {
      throw new Error("learningRate parameter is not supported in Vertex AI.");
    }
    const fromLabels = getValueByPath(fromObject, ["labels"]);
    if (parentObject !== void 0 && fromLabels != null) {
      setValueByPath(parentObject, ["labels"], fromLabels);
    }
    const fromBeta = getValueByPath(fromObject, ["beta"]);
    if (parentObject !== void 0 && fromBeta != null) {
      setValueByPath(parentObject, ["preferenceOptimizationSpec", "hyperParameters", "beta"], fromBeta);
    }
    return toObject;
  }
  function createTuningJobParametersPrivateToMldev(fromObject, rootObject) {
    const toObject = {};
    const fromBaseModel = getValueByPath(fromObject, ["baseModel"]);
    if (fromBaseModel != null) {
      setValueByPath(toObject, ["baseModel"], fromBaseModel);
    }
    const fromPreTunedModel = getValueByPath(fromObject, [
      "preTunedModel"
    ]);
    if (fromPreTunedModel != null) {
      setValueByPath(toObject, ["preTunedModel"], fromPreTunedModel);
    }
    const fromTrainingDataset = getValueByPath(fromObject, [
      "trainingDataset"
    ]);
    if (fromTrainingDataset != null) {
      tuningDatasetToMldev(fromTrainingDataset);
    }
    const fromConfig = getValueByPath(fromObject, ["config"]);
    if (fromConfig != null) {
      createTuningJobConfigToMldev(fromConfig, toObject);
    }
    return toObject;
  }
  function createTuningJobParametersPrivateToVertex(fromObject, rootObject) {
    const toObject = {};
    const fromBaseModel = getValueByPath(fromObject, ["baseModel"]);
    if (fromBaseModel != null) {
      setValueByPath(toObject, ["baseModel"], fromBaseModel);
    }
    const fromPreTunedModel = getValueByPath(fromObject, [
      "preTunedModel"
    ]);
    if (fromPreTunedModel != null) {
      setValueByPath(toObject, ["preTunedModel"], fromPreTunedModel);
    }
    const fromTrainingDataset = getValueByPath(fromObject, [
      "trainingDataset"
    ]);
    if (fromTrainingDataset != null) {
      tuningDatasetToVertex(fromTrainingDataset, toObject, rootObject);
    }
    const fromConfig = getValueByPath(fromObject, ["config"]);
    if (fromConfig != null) {
      createTuningJobConfigToVertex(fromConfig, toObject, rootObject);
    }
    return toObject;
  }
  function getTuningJobParametersToMldev(fromObject, _rootObject) {
    const toObject = {};
    const fromName = getValueByPath(fromObject, ["name"]);
    if (fromName != null) {
      setValueByPath(toObject, ["_url", "name"], fromName);
    }
    return toObject;
  }
  function getTuningJobParametersToVertex(fromObject, _rootObject) {
    const toObject = {};
    const fromName = getValueByPath(fromObject, ["name"]);
    if (fromName != null) {
      setValueByPath(toObject, ["_url", "name"], fromName);
    }
    return toObject;
  }
  function listTuningJobsConfigToMldev(fromObject, parentObject, _rootObject) {
    const toObject = {};
    const fromPageSize = getValueByPath(fromObject, ["pageSize"]);
    if (parentObject !== void 0 && fromPageSize != null) {
      setValueByPath(parentObject, ["_query", "pageSize"], fromPageSize);
    }
    const fromPageToken = getValueByPath(fromObject, ["pageToken"]);
    if (parentObject !== void 0 && fromPageToken != null) {
      setValueByPath(parentObject, ["_query", "pageToken"], fromPageToken);
    }
    const fromFilter = getValueByPath(fromObject, ["filter"]);
    if (parentObject !== void 0 && fromFilter != null) {
      setValueByPath(parentObject, ["_query", "filter"], fromFilter);
    }
    return toObject;
  }
  function listTuningJobsConfigToVertex(fromObject, parentObject, _rootObject) {
    const toObject = {};
    const fromPageSize = getValueByPath(fromObject, ["pageSize"]);
    if (parentObject !== void 0 && fromPageSize != null) {
      setValueByPath(parentObject, ["_query", "pageSize"], fromPageSize);
    }
    const fromPageToken = getValueByPath(fromObject, ["pageToken"]);
    if (parentObject !== void 0 && fromPageToken != null) {
      setValueByPath(parentObject, ["_query", "pageToken"], fromPageToken);
    }
    const fromFilter = getValueByPath(fromObject, ["filter"]);
    if (parentObject !== void 0 && fromFilter != null) {
      setValueByPath(parentObject, ["_query", "filter"], fromFilter);
    }
    return toObject;
  }
  function listTuningJobsParametersToMldev(fromObject, rootObject) {
    const toObject = {};
    const fromConfig = getValueByPath(fromObject, ["config"]);
    if (fromConfig != null) {
      listTuningJobsConfigToMldev(fromConfig, toObject);
    }
    return toObject;
  }
  function listTuningJobsParametersToVertex(fromObject, rootObject) {
    const toObject = {};
    const fromConfig = getValueByPath(fromObject, ["config"]);
    if (fromConfig != null) {
      listTuningJobsConfigToVertex(fromConfig, toObject);
    }
    return toObject;
  }
  function listTuningJobsResponseFromMldev(fromObject, rootObject) {
    const toObject = {};
    const fromSdkHttpResponse = getValueByPath(fromObject, [
      "sdkHttpResponse"
    ]);
    if (fromSdkHttpResponse != null) {
      setValueByPath(toObject, ["sdkHttpResponse"], fromSdkHttpResponse);
    }
    const fromNextPageToken = getValueByPath(fromObject, [
      "nextPageToken"
    ]);
    if (fromNextPageToken != null) {
      setValueByPath(toObject, ["nextPageToken"], fromNextPageToken);
    }
    const fromTuningJobs = getValueByPath(fromObject, ["tunedModels"]);
    if (fromTuningJobs != null) {
      let transformedList = fromTuningJobs;
      if (Array.isArray(transformedList)) {
        transformedList = transformedList.map((item) => {
          return tuningJobFromMldev(item);
        });
      }
      setValueByPath(toObject, ["tuningJobs"], transformedList);
    }
    return toObject;
  }
  function listTuningJobsResponseFromVertex(fromObject, rootObject) {
    const toObject = {};
    const fromSdkHttpResponse = getValueByPath(fromObject, [
      "sdkHttpResponse"
    ]);
    if (fromSdkHttpResponse != null) {
      setValueByPath(toObject, ["sdkHttpResponse"], fromSdkHttpResponse);
    }
    const fromNextPageToken = getValueByPath(fromObject, [
      "nextPageToken"
    ]);
    if (fromNextPageToken != null) {
      setValueByPath(toObject, ["nextPageToken"], fromNextPageToken);
    }
    const fromTuningJobs = getValueByPath(fromObject, ["tuningJobs"]);
    if (fromTuningJobs != null) {
      let transformedList = fromTuningJobs;
      if (Array.isArray(transformedList)) {
        transformedList = transformedList.map((item) => {
          return tuningJobFromVertex(item);
        });
      }
      setValueByPath(toObject, ["tuningJobs"], transformedList);
    }
    return toObject;
  }
  function tunedModelFromMldev(fromObject, _rootObject) {
    const toObject = {};
    const fromModel = getValueByPath(fromObject, ["name"]);
    if (fromModel != null) {
      setValueByPath(toObject, ["model"], fromModel);
    }
    const fromEndpoint = getValueByPath(fromObject, ["name"]);
    if (fromEndpoint != null) {
      setValueByPath(toObject, ["endpoint"], fromEndpoint);
    }
    return toObject;
  }
  function tuningDatasetToMldev(fromObject, _rootObject) {
    const toObject = {};
    if (getValueByPath(fromObject, ["gcsUri"]) !== void 0) {
      throw new Error("gcsUri parameter is not supported in Gemini API.");
    }
    if (getValueByPath(fromObject, ["vertexDatasetResource"]) !== void 0) {
      throw new Error("vertexDatasetResource parameter is not supported in Gemini API.");
    }
    const fromExamples = getValueByPath(fromObject, ["examples"]);
    if (fromExamples != null) {
      let transformedList = fromExamples;
      if (Array.isArray(transformedList)) {
        transformedList = transformedList.map((item) => {
          return item;
        });
      }
      setValueByPath(toObject, ["examples", "examples"], transformedList);
    }
    return toObject;
  }
  function tuningDatasetToVertex(fromObject, parentObject, rootObject) {
    const toObject = {};
    let discriminatorGcsUri = getValueByPath(rootObject, [
      "config",
      "method"
    ]);
    if (discriminatorGcsUri === void 0) {
      discriminatorGcsUri = "SUPERVISED_FINE_TUNING";
    }
    if (discriminatorGcsUri === "SUPERVISED_FINE_TUNING") {
      const fromGcsUri = getValueByPath(fromObject, ["gcsUri"]);
      if (parentObject !== void 0 && fromGcsUri != null) {
        setValueByPath(parentObject, ["supervisedTuningSpec", "trainingDatasetUri"], fromGcsUri);
      }
    } else if (discriminatorGcsUri === "PREFERENCE_TUNING") {
      const fromGcsUri = getValueByPath(fromObject, ["gcsUri"]);
      if (parentObject !== void 0 && fromGcsUri != null) {
        setValueByPath(parentObject, ["preferenceOptimizationSpec", "trainingDatasetUri"], fromGcsUri);
      }
    }
    let discriminatorVertexDatasetResource = getValueByPath(rootObject, [
      "config",
      "method"
    ]);
    if (discriminatorVertexDatasetResource === void 0) {
      discriminatorVertexDatasetResource = "SUPERVISED_FINE_TUNING";
    }
    if (discriminatorVertexDatasetResource === "SUPERVISED_FINE_TUNING") {
      const fromVertexDatasetResource = getValueByPath(fromObject, [
        "vertexDatasetResource"
      ]);
      if (parentObject !== void 0 && fromVertexDatasetResource != null) {
        setValueByPath(parentObject, ["supervisedTuningSpec", "trainingDatasetUri"], fromVertexDatasetResource);
      }
    } else if (discriminatorVertexDatasetResource === "PREFERENCE_TUNING") {
      const fromVertexDatasetResource = getValueByPath(fromObject, [
        "vertexDatasetResource"
      ]);
      if (parentObject !== void 0 && fromVertexDatasetResource != null) {
        setValueByPath(parentObject, ["preferenceOptimizationSpec", "trainingDatasetUri"], fromVertexDatasetResource);
      }
    }
    if (getValueByPath(fromObject, ["examples"]) !== void 0) {
      throw new Error("examples parameter is not supported in Vertex AI.");
    }
    return toObject;
  }
  function tuningJobFromMldev(fromObject, rootObject) {
    const toObject = {};
    const fromSdkHttpResponse = getValueByPath(fromObject, [
      "sdkHttpResponse"
    ]);
    if (fromSdkHttpResponse != null) {
      setValueByPath(toObject, ["sdkHttpResponse"], fromSdkHttpResponse);
    }
    const fromName = getValueByPath(fromObject, ["name"]);
    if (fromName != null) {
      setValueByPath(toObject, ["name"], fromName);
    }
    const fromState = getValueByPath(fromObject, ["state"]);
    if (fromState != null) {
      setValueByPath(toObject, ["state"], tTuningJobStatus(fromState));
    }
    const fromCreateTime = getValueByPath(fromObject, ["createTime"]);
    if (fromCreateTime != null) {
      setValueByPath(toObject, ["createTime"], fromCreateTime);
    }
    const fromStartTime = getValueByPath(fromObject, [
      "tuningTask",
      "startTime"
    ]);
    if (fromStartTime != null) {
      setValueByPath(toObject, ["startTime"], fromStartTime);
    }
    const fromEndTime = getValueByPath(fromObject, [
      "tuningTask",
      "completeTime"
    ]);
    if (fromEndTime != null) {
      setValueByPath(toObject, ["endTime"], fromEndTime);
    }
    const fromUpdateTime = getValueByPath(fromObject, ["updateTime"]);
    if (fromUpdateTime != null) {
      setValueByPath(toObject, ["updateTime"], fromUpdateTime);
    }
    const fromDescription = getValueByPath(fromObject, ["description"]);
    if (fromDescription != null) {
      setValueByPath(toObject, ["description"], fromDescription);
    }
    const fromBaseModel = getValueByPath(fromObject, ["baseModel"]);
    if (fromBaseModel != null) {
      setValueByPath(toObject, ["baseModel"], fromBaseModel);
    }
    const fromTunedModel = getValueByPath(fromObject, ["_self"]);
    if (fromTunedModel != null) {
      setValueByPath(toObject, ["tunedModel"], tunedModelFromMldev(fromTunedModel));
    }
    return toObject;
  }
  function tuningJobFromVertex(fromObject, _rootObject) {
    const toObject = {};
    const fromSdkHttpResponse = getValueByPath(fromObject, [
      "sdkHttpResponse"
    ]);
    if (fromSdkHttpResponse != null) {
      setValueByPath(toObject, ["sdkHttpResponse"], fromSdkHttpResponse);
    }
    const fromName = getValueByPath(fromObject, ["name"]);
    if (fromName != null) {
      setValueByPath(toObject, ["name"], fromName);
    }
    const fromState = getValueByPath(fromObject, ["state"]);
    if (fromState != null) {
      setValueByPath(toObject, ["state"], tTuningJobStatus(fromState));
    }
    const fromCreateTime = getValueByPath(fromObject, ["createTime"]);
    if (fromCreateTime != null) {
      setValueByPath(toObject, ["createTime"], fromCreateTime);
    }
    const fromStartTime = getValueByPath(fromObject, ["startTime"]);
    if (fromStartTime != null) {
      setValueByPath(toObject, ["startTime"], fromStartTime);
    }
    const fromEndTime = getValueByPath(fromObject, ["endTime"]);
    if (fromEndTime != null) {
      setValueByPath(toObject, ["endTime"], fromEndTime);
    }
    const fromUpdateTime = getValueByPath(fromObject, ["updateTime"]);
    if (fromUpdateTime != null) {
      setValueByPath(toObject, ["updateTime"], fromUpdateTime);
    }
    const fromError = getValueByPath(fromObject, ["error"]);
    if (fromError != null) {
      setValueByPath(toObject, ["error"], fromError);
    }
    const fromDescription = getValueByPath(fromObject, ["description"]);
    if (fromDescription != null) {
      setValueByPath(toObject, ["description"], fromDescription);
    }
    const fromBaseModel = getValueByPath(fromObject, ["baseModel"]);
    if (fromBaseModel != null) {
      setValueByPath(toObject, ["baseModel"], fromBaseModel);
    }
    const fromTunedModel = getValueByPath(fromObject, ["tunedModel"]);
    if (fromTunedModel != null) {
      setValueByPath(toObject, ["tunedModel"], fromTunedModel);
    }
    const fromPreTunedModel = getValueByPath(fromObject, [
      "preTunedModel"
    ]);
    if (fromPreTunedModel != null) {
      setValueByPath(toObject, ["preTunedModel"], fromPreTunedModel);
    }
    const fromSupervisedTuningSpec = getValueByPath(fromObject, [
      "supervisedTuningSpec"
    ]);
    if (fromSupervisedTuningSpec != null) {
      setValueByPath(toObject, ["supervisedTuningSpec"], fromSupervisedTuningSpec);
    }
    const fromPreferenceOptimizationSpec = getValueByPath(fromObject, [
      "preferenceOptimizationSpec"
    ]);
    if (fromPreferenceOptimizationSpec != null) {
      setValueByPath(toObject, ["preferenceOptimizationSpec"], fromPreferenceOptimizationSpec);
    }
    const fromTuningDataStats = getValueByPath(fromObject, [
      "tuningDataStats"
    ]);
    if (fromTuningDataStats != null) {
      setValueByPath(toObject, ["tuningDataStats"], fromTuningDataStats);
    }
    const fromEncryptionSpec = getValueByPath(fromObject, [
      "encryptionSpec"
    ]);
    if (fromEncryptionSpec != null) {
      setValueByPath(toObject, ["encryptionSpec"], fromEncryptionSpec);
    }
    const fromPartnerModelTuningSpec = getValueByPath(fromObject, [
      "partnerModelTuningSpec"
    ]);
    if (fromPartnerModelTuningSpec != null) {
      setValueByPath(toObject, ["partnerModelTuningSpec"], fromPartnerModelTuningSpec);
    }
    const fromCustomBaseModel = getValueByPath(fromObject, [
      "customBaseModel"
    ]);
    if (fromCustomBaseModel != null) {
      setValueByPath(toObject, ["customBaseModel"], fromCustomBaseModel);
    }
    const fromExperiment = getValueByPath(fromObject, ["experiment"]);
    if (fromExperiment != null) {
      setValueByPath(toObject, ["experiment"], fromExperiment);
    }
    const fromLabels = getValueByPath(fromObject, ["labels"]);
    if (fromLabels != null) {
      setValueByPath(toObject, ["labels"], fromLabels);
    }
    const fromOutputUri = getValueByPath(fromObject, ["outputUri"]);
    if (fromOutputUri != null) {
      setValueByPath(toObject, ["outputUri"], fromOutputUri);
    }
    const fromPipelineJob = getValueByPath(fromObject, ["pipelineJob"]);
    if (fromPipelineJob != null) {
      setValueByPath(toObject, ["pipelineJob"], fromPipelineJob);
    }
    const fromServiceAccount = getValueByPath(fromObject, [
      "serviceAccount"
    ]);
    if (fromServiceAccount != null) {
      setValueByPath(toObject, ["serviceAccount"], fromServiceAccount);
    }
    const fromTunedModelDisplayName = getValueByPath(fromObject, [
      "tunedModelDisplayName"
    ]);
    if (fromTunedModelDisplayName != null) {
      setValueByPath(toObject, ["tunedModelDisplayName"], fromTunedModelDisplayName);
    }
    const fromVeoTuningSpec = getValueByPath(fromObject, [
      "veoTuningSpec"
    ]);
    if (fromVeoTuningSpec != null) {
      setValueByPath(toObject, ["veoTuningSpec"], fromVeoTuningSpec);
    }
    return toObject;
  }
  function tuningOperationFromMldev(fromObject, _rootObject) {
    const toObject = {};
    const fromSdkHttpResponse = getValueByPath(fromObject, [
      "sdkHttpResponse"
    ]);
    if (fromSdkHttpResponse != null) {
      setValueByPath(toObject, ["sdkHttpResponse"], fromSdkHttpResponse);
    }
    const fromName = getValueByPath(fromObject, ["name"]);
    if (fromName != null) {
      setValueByPath(toObject, ["name"], fromName);
    }
    const fromMetadata = getValueByPath(fromObject, ["metadata"]);
    if (fromMetadata != null) {
      setValueByPath(toObject, ["metadata"], fromMetadata);
    }
    const fromDone = getValueByPath(fromObject, ["done"]);
    if (fromDone != null) {
      setValueByPath(toObject, ["done"], fromDone);
    }
    const fromError = getValueByPath(fromObject, ["error"]);
    if (fromError != null) {
      setValueByPath(toObject, ["error"], fromError);
    }
    return toObject;
  }
  function tuningValidationDatasetToVertex(fromObject, _rootObject) {
    const toObject = {};
    const fromGcsUri = getValueByPath(fromObject, ["gcsUri"]);
    if (fromGcsUri != null) {
      setValueByPath(toObject, ["validationDatasetUri"], fromGcsUri);
    }
    const fromVertexDatasetResource = getValueByPath(fromObject, [
      "vertexDatasetResource"
    ]);
    if (fromVertexDatasetResource != null) {
      setValueByPath(toObject, ["validationDatasetUri"], fromVertexDatasetResource);
    }
    return toObject;
  }
  async function uploadBlob(file, uploadUrl, apiClient) {
    var _a;
    const response = await uploadBlobInternal(file, uploadUrl, apiClient);
    const responseJson = await (response === null || response === void 0 ? void 0 : response.json());
    if (((_a = response === null || response === void 0 ? void 0 : response.headers) === null || _a === void 0 ? void 0 : _a[X_GOOG_UPLOAD_STATUS_HEADER_FIELD]) !== "final") {
      throw new Error("Failed to upload file: Upload status is not finalized.");
    }
    return responseJson["file"];
  }
  async function uploadBlobToFileSearchStore(file, uploadUrl, apiClient) {
    var _a;
    const response = await uploadBlobInternal(file, uploadUrl, apiClient);
    const responseJson = await (response === null || response === void 0 ? void 0 : response.json());
    if (((_a = response === null || response === void 0 ? void 0 : response.headers) === null || _a === void 0 ? void 0 : _a[X_GOOG_UPLOAD_STATUS_HEADER_FIELD]) !== "final") {
      throw new Error("Failed to upload file: Upload status is not finalized.");
    }
    const resp = uploadToFileSearchStoreOperationFromMldev(responseJson);
    const typedResp = new UploadToFileSearchStoreOperation();
    Object.assign(typedResp, resp);
    return typedResp;
  }
  async function uploadBlobInternal(file, uploadUrl, apiClient) {
    var _a, _b;
    let fileSize = 0;
    let offset = 0;
    let response = new HttpResponse(new Response());
    let uploadCommand = "upload";
    fileSize = file.size;
    while (offset < fileSize) {
      const chunkSize = Math.min(MAX_CHUNK_SIZE, fileSize - offset);
      const chunk = file.slice(offset, offset + chunkSize);
      if (offset + chunkSize >= fileSize) {
        uploadCommand += ", finalize";
      }
      let retryCount = 0;
      let currentDelayMs = INITIAL_RETRY_DELAY_MS;
      while (retryCount < MAX_RETRY_COUNT) {
        response = await apiClient.request({
          path: "",
          body: chunk,
          httpMethod: "POST",
          httpOptions: {
            apiVersion: "",
            baseUrl: uploadUrl,
            headers: {
              "X-Goog-Upload-Command": uploadCommand,
              "X-Goog-Upload-Offset": String(offset),
              "Content-Length": String(chunkSize)
            }
          }
        });
        if ((_a = response === null || response === void 0 ? void 0 : response.headers) === null || _a === void 0 ? void 0 : _a[X_GOOG_UPLOAD_STATUS_HEADER_FIELD]) {
          break;
        }
        retryCount++;
        await sleep(currentDelayMs);
        currentDelayMs = currentDelayMs * DELAY_MULTIPLIER;
      }
      offset += chunkSize;
      if (((_b = response === null || response === void 0 ? void 0 : response.headers) === null || _b === void 0 ? void 0 : _b[X_GOOG_UPLOAD_STATUS_HEADER_FIELD]) !== "active") {
        break;
      }
      if (fileSize <= offset) {
        throw new Error("All content has been uploaded, but the upload status is not finalized.");
      }
    }
    return response;
  }
  async function getBlobStat(file) {
    const fileStat = { size: file.size, type: file.type };
    return fileStat;
  }
  function sleep(ms) {
    return new Promise((resolvePromise) => setTimeout(resolvePromise, ms));
  }
  var _defaultBaseGeminiUrl, _defaultBaseVertexUrl, BaseModule, Outcome, Language, FunctionResponseScheduling, Type, Mode, ApiSpec, AuthType, HttpElementLocation, PhishBlockThreshold, ThinkingLevel, HarmCategory, HarmBlockMethod, HarmBlockThreshold, FinishReason, HarmProbability, HarmSeverity, UrlRetrievalStatus, BlockedReason, TrafficType, Modality, MediaResolution, TuningMode, AdapterSize, JobState, TuningTask, PartMediaResolutionLevel, FeatureSelectionPreference, Behavior, DynamicRetrievalConfigMode, Environment, FunctionCallingConfigMode, SafetyFilterLevel, PersonGeneration, ImagePromptLanguage, MaskReferenceMode, ControlReferenceType, SubjectReferenceType, EditMode, SegmentMode, VideoGenerationReferenceType, VideoGenerationMaskMode, VideoCompressionQuality, TuningMethod, DocumentState, FileState, FileSource, TurnCompleteReason, MediaModality, StartSensitivity, EndSensitivity, ActivityHandling, TurnCoverage, Scale, MusicGenerationMode, LiveMusicPlaybackControl, FunctionResponseBlob, FunctionResponseFileData, FunctionResponsePart, FunctionResponse, HttpResponse, GenerateContentResponsePromptFeedback, GenerateContentResponseUsageMetadata, GenerateContentResponse, EmbedContentResponse, GenerateImagesResponse, EditImageResponse, UpscaleImageResponse, RecontextImageResponse, SegmentImageResponse, ListModelsResponse, DeleteModelResponse, CountTokensResponse, ComputeTokensResponse, GenerateVideosResponse, GenerateVideosOperation, ListTuningJobsResponse, DeleteCachedContentResponse, ListCachedContentsResponse, ListDocumentsResponse, ListFileSearchStoresResponse, UploadToFileSearchStoreResumableResponse, ImportFileResponse, ImportFileOperation, ListFilesResponse, CreateFileResponse, DeleteFileResponse, InlinedResponse, SingleEmbedContentResponse, InlinedEmbedContentResponse, ListBatchJobsResponse, ReplayResponse, RawReferenceImage, MaskReferenceImage, ControlReferenceImage, StyleReferenceImage, SubjectReferenceImage, ContentReferenceImage, LiveServerMessage, LiveClientToolResponse, LiveSendToolResponseParameters, LiveMusicServerMessage, UploadToFileSearchStoreResponse, UploadToFileSearchStoreOperation, PagedItem, Pager, Batches, Caches, Chats, Chat, ApiError, Files, CONTENT_TYPE_HEADER, SERVER_TIMEOUT_HEADER, USER_AGENT_HEADER, GOOGLE_API_CLIENT_HEADER, SDK_VERSION, LIBRARY_LABEL, VERTEX_AI_API_DEFAULT_VERSION, GOOGLE_AI_API_DEFAULT_VERSION, responseLineRE, ApiClient, MCP_LABEL, hasMcpToolUsageFromMcpToTool, McpCallableTool, LiveMusic, LiveMusicSession, FUNCTION_RESPONSE_REQUIRES_ID, Live, defaultLiveSendClientContentParamerters, Session, DEFAULT_MAX_REMOTE_CALLS, Models, Operations, Tokens, Documents, FileSearchStores, Tunings, BrowserDownloader, MAX_CHUNK_SIZE, MAX_RETRY_COUNT, INITIAL_RETRY_DELAY_MS, DELAY_MULTIPLIER, X_GOOG_UPLOAD_STATUS_HEADER_FIELD, BrowserUploader, BrowserWebSocketFactory, BrowserWebSocket, GOOGLE_API_KEY_HEADER, WebAuth, LANGUAGE_LABEL_PREFIX, GoogleGenAI;
  var init_web = __esm({
    "node_modules/@google/genai/dist/web/index.mjs"() {
      _defaultBaseGeminiUrl = void 0;
      _defaultBaseVertexUrl = void 0;
      BaseModule = class {
      };
      (function(Outcome2) {
        Outcome2["OUTCOME_UNSPECIFIED"] = "OUTCOME_UNSPECIFIED";
        Outcome2["OUTCOME_OK"] = "OUTCOME_OK";
        Outcome2["OUTCOME_FAILED"] = "OUTCOME_FAILED";
        Outcome2["OUTCOME_DEADLINE_EXCEEDED"] = "OUTCOME_DEADLINE_EXCEEDED";
      })(Outcome || (Outcome = {}));
      (function(Language3) {
        Language3["LANGUAGE_UNSPECIFIED"] = "LANGUAGE_UNSPECIFIED";
        Language3["PYTHON"] = "PYTHON";
      })(Language || (Language = {}));
      (function(FunctionResponseScheduling2) {
        FunctionResponseScheduling2["SCHEDULING_UNSPECIFIED"] = "SCHEDULING_UNSPECIFIED";
        FunctionResponseScheduling2["SILENT"] = "SILENT";
        FunctionResponseScheduling2["WHEN_IDLE"] = "WHEN_IDLE";
        FunctionResponseScheduling2["INTERRUPT"] = "INTERRUPT";
      })(FunctionResponseScheduling || (FunctionResponseScheduling = {}));
      (function(Type2) {
        Type2["TYPE_UNSPECIFIED"] = "TYPE_UNSPECIFIED";
        Type2["STRING"] = "STRING";
        Type2["NUMBER"] = "NUMBER";
        Type2["INTEGER"] = "INTEGER";
        Type2["BOOLEAN"] = "BOOLEAN";
        Type2["ARRAY"] = "ARRAY";
        Type2["OBJECT"] = "OBJECT";
        Type2["NULL"] = "NULL";
      })(Type || (Type = {}));
      (function(Mode2) {
        Mode2["MODE_UNSPECIFIED"] = "MODE_UNSPECIFIED";
        Mode2["MODE_DYNAMIC"] = "MODE_DYNAMIC";
      })(Mode || (Mode = {}));
      (function(ApiSpec2) {
        ApiSpec2["API_SPEC_UNSPECIFIED"] = "API_SPEC_UNSPECIFIED";
        ApiSpec2["SIMPLE_SEARCH"] = "SIMPLE_SEARCH";
        ApiSpec2["ELASTIC_SEARCH"] = "ELASTIC_SEARCH";
      })(ApiSpec || (ApiSpec = {}));
      (function(AuthType2) {
        AuthType2["AUTH_TYPE_UNSPECIFIED"] = "AUTH_TYPE_UNSPECIFIED";
        AuthType2["NO_AUTH"] = "NO_AUTH";
        AuthType2["API_KEY_AUTH"] = "API_KEY_AUTH";
        AuthType2["HTTP_BASIC_AUTH"] = "HTTP_BASIC_AUTH";
        AuthType2["GOOGLE_SERVICE_ACCOUNT_AUTH"] = "GOOGLE_SERVICE_ACCOUNT_AUTH";
        AuthType2["OAUTH"] = "OAUTH";
        AuthType2["OIDC_AUTH"] = "OIDC_AUTH";
      })(AuthType || (AuthType = {}));
      (function(HttpElementLocation2) {
        HttpElementLocation2["HTTP_IN_UNSPECIFIED"] = "HTTP_IN_UNSPECIFIED";
        HttpElementLocation2["HTTP_IN_QUERY"] = "HTTP_IN_QUERY";
        HttpElementLocation2["HTTP_IN_HEADER"] = "HTTP_IN_HEADER";
        HttpElementLocation2["HTTP_IN_PATH"] = "HTTP_IN_PATH";
        HttpElementLocation2["HTTP_IN_BODY"] = "HTTP_IN_BODY";
        HttpElementLocation2["HTTP_IN_COOKIE"] = "HTTP_IN_COOKIE";
      })(HttpElementLocation || (HttpElementLocation = {}));
      (function(PhishBlockThreshold2) {
        PhishBlockThreshold2["PHISH_BLOCK_THRESHOLD_UNSPECIFIED"] = "PHISH_BLOCK_THRESHOLD_UNSPECIFIED";
        PhishBlockThreshold2["BLOCK_LOW_AND_ABOVE"] = "BLOCK_LOW_AND_ABOVE";
        PhishBlockThreshold2["BLOCK_MEDIUM_AND_ABOVE"] = "BLOCK_MEDIUM_AND_ABOVE";
        PhishBlockThreshold2["BLOCK_HIGH_AND_ABOVE"] = "BLOCK_HIGH_AND_ABOVE";
        PhishBlockThreshold2["BLOCK_HIGHER_AND_ABOVE"] = "BLOCK_HIGHER_AND_ABOVE";
        PhishBlockThreshold2["BLOCK_VERY_HIGH_AND_ABOVE"] = "BLOCK_VERY_HIGH_AND_ABOVE";
        PhishBlockThreshold2["BLOCK_ONLY_EXTREMELY_HIGH"] = "BLOCK_ONLY_EXTREMELY_HIGH";
      })(PhishBlockThreshold || (PhishBlockThreshold = {}));
      (function(ThinkingLevel2) {
        ThinkingLevel2["THINKING_LEVEL_UNSPECIFIED"] = "THINKING_LEVEL_UNSPECIFIED";
        ThinkingLevel2["LOW"] = "LOW";
        ThinkingLevel2["HIGH"] = "HIGH";
      })(ThinkingLevel || (ThinkingLevel = {}));
      (function(HarmCategory2) {
        HarmCategory2["HARM_CATEGORY_UNSPECIFIED"] = "HARM_CATEGORY_UNSPECIFIED";
        HarmCategory2["HARM_CATEGORY_HARASSMENT"] = "HARM_CATEGORY_HARASSMENT";
        HarmCategory2["HARM_CATEGORY_HATE_SPEECH"] = "HARM_CATEGORY_HATE_SPEECH";
        HarmCategory2["HARM_CATEGORY_SEXUALLY_EXPLICIT"] = "HARM_CATEGORY_SEXUALLY_EXPLICIT";
        HarmCategory2["HARM_CATEGORY_DANGEROUS_CONTENT"] = "HARM_CATEGORY_DANGEROUS_CONTENT";
        HarmCategory2["HARM_CATEGORY_CIVIC_INTEGRITY"] = "HARM_CATEGORY_CIVIC_INTEGRITY";
        HarmCategory2["HARM_CATEGORY_IMAGE_HATE"] = "HARM_CATEGORY_IMAGE_HATE";
        HarmCategory2["HARM_CATEGORY_IMAGE_DANGEROUS_CONTENT"] = "HARM_CATEGORY_IMAGE_DANGEROUS_CONTENT";
        HarmCategory2["HARM_CATEGORY_IMAGE_HARASSMENT"] = "HARM_CATEGORY_IMAGE_HARASSMENT";
        HarmCategory2["HARM_CATEGORY_IMAGE_SEXUALLY_EXPLICIT"] = "HARM_CATEGORY_IMAGE_SEXUALLY_EXPLICIT";
        HarmCategory2["HARM_CATEGORY_JAILBREAK"] = "HARM_CATEGORY_JAILBREAK";
      })(HarmCategory || (HarmCategory = {}));
      (function(HarmBlockMethod2) {
        HarmBlockMethod2["HARM_BLOCK_METHOD_UNSPECIFIED"] = "HARM_BLOCK_METHOD_UNSPECIFIED";
        HarmBlockMethod2["SEVERITY"] = "SEVERITY";
        HarmBlockMethod2["PROBABILITY"] = "PROBABILITY";
      })(HarmBlockMethod || (HarmBlockMethod = {}));
      (function(HarmBlockThreshold2) {
        HarmBlockThreshold2["HARM_BLOCK_THRESHOLD_UNSPECIFIED"] = "HARM_BLOCK_THRESHOLD_UNSPECIFIED";
        HarmBlockThreshold2["BLOCK_LOW_AND_ABOVE"] = "BLOCK_LOW_AND_ABOVE";
        HarmBlockThreshold2["BLOCK_MEDIUM_AND_ABOVE"] = "BLOCK_MEDIUM_AND_ABOVE";
        HarmBlockThreshold2["BLOCK_ONLY_HIGH"] = "BLOCK_ONLY_HIGH";
        HarmBlockThreshold2["BLOCK_NONE"] = "BLOCK_NONE";
        HarmBlockThreshold2["OFF"] = "OFF";
      })(HarmBlockThreshold || (HarmBlockThreshold = {}));
      (function(FinishReason2) {
        FinishReason2["FINISH_REASON_UNSPECIFIED"] = "FINISH_REASON_UNSPECIFIED";
        FinishReason2["STOP"] = "STOP";
        FinishReason2["MAX_TOKENS"] = "MAX_TOKENS";
        FinishReason2["SAFETY"] = "SAFETY";
        FinishReason2["RECITATION"] = "RECITATION";
        FinishReason2["LANGUAGE"] = "LANGUAGE";
        FinishReason2["OTHER"] = "OTHER";
        FinishReason2["BLOCKLIST"] = "BLOCKLIST";
        FinishReason2["PROHIBITED_CONTENT"] = "PROHIBITED_CONTENT";
        FinishReason2["SPII"] = "SPII";
        FinishReason2["MALFORMED_FUNCTION_CALL"] = "MALFORMED_FUNCTION_CALL";
        FinishReason2["IMAGE_SAFETY"] = "IMAGE_SAFETY";
        FinishReason2["UNEXPECTED_TOOL_CALL"] = "UNEXPECTED_TOOL_CALL";
        FinishReason2["IMAGE_PROHIBITED_CONTENT"] = "IMAGE_PROHIBITED_CONTENT";
        FinishReason2["NO_IMAGE"] = "NO_IMAGE";
      })(FinishReason || (FinishReason = {}));
      (function(HarmProbability2) {
        HarmProbability2["HARM_PROBABILITY_UNSPECIFIED"] = "HARM_PROBABILITY_UNSPECIFIED";
        HarmProbability2["NEGLIGIBLE"] = "NEGLIGIBLE";
        HarmProbability2["LOW"] = "LOW";
        HarmProbability2["MEDIUM"] = "MEDIUM";
        HarmProbability2["HIGH"] = "HIGH";
      })(HarmProbability || (HarmProbability = {}));
      (function(HarmSeverity2) {
        HarmSeverity2["HARM_SEVERITY_UNSPECIFIED"] = "HARM_SEVERITY_UNSPECIFIED";
        HarmSeverity2["HARM_SEVERITY_NEGLIGIBLE"] = "HARM_SEVERITY_NEGLIGIBLE";
        HarmSeverity2["HARM_SEVERITY_LOW"] = "HARM_SEVERITY_LOW";
        HarmSeverity2["HARM_SEVERITY_MEDIUM"] = "HARM_SEVERITY_MEDIUM";
        HarmSeverity2["HARM_SEVERITY_HIGH"] = "HARM_SEVERITY_HIGH";
      })(HarmSeverity || (HarmSeverity = {}));
      (function(UrlRetrievalStatus2) {
        UrlRetrievalStatus2["URL_RETRIEVAL_STATUS_UNSPECIFIED"] = "URL_RETRIEVAL_STATUS_UNSPECIFIED";
        UrlRetrievalStatus2["URL_RETRIEVAL_STATUS_SUCCESS"] = "URL_RETRIEVAL_STATUS_SUCCESS";
        UrlRetrievalStatus2["URL_RETRIEVAL_STATUS_ERROR"] = "URL_RETRIEVAL_STATUS_ERROR";
        UrlRetrievalStatus2["URL_RETRIEVAL_STATUS_PAYWALL"] = "URL_RETRIEVAL_STATUS_PAYWALL";
        UrlRetrievalStatus2["URL_RETRIEVAL_STATUS_UNSAFE"] = "URL_RETRIEVAL_STATUS_UNSAFE";
      })(UrlRetrievalStatus || (UrlRetrievalStatus = {}));
      (function(BlockedReason2) {
        BlockedReason2["BLOCKED_REASON_UNSPECIFIED"] = "BLOCKED_REASON_UNSPECIFIED";
        BlockedReason2["SAFETY"] = "SAFETY";
        BlockedReason2["OTHER"] = "OTHER";
        BlockedReason2["BLOCKLIST"] = "BLOCKLIST";
        BlockedReason2["PROHIBITED_CONTENT"] = "PROHIBITED_CONTENT";
        BlockedReason2["IMAGE_SAFETY"] = "IMAGE_SAFETY";
        BlockedReason2["MODEL_ARMOR"] = "MODEL_ARMOR";
        BlockedReason2["JAILBREAK"] = "JAILBREAK";
      })(BlockedReason || (BlockedReason = {}));
      (function(TrafficType2) {
        TrafficType2["TRAFFIC_TYPE_UNSPECIFIED"] = "TRAFFIC_TYPE_UNSPECIFIED";
        TrafficType2["ON_DEMAND"] = "ON_DEMAND";
        TrafficType2["PROVISIONED_THROUGHPUT"] = "PROVISIONED_THROUGHPUT";
      })(TrafficType || (TrafficType = {}));
      (function(Modality2) {
        Modality2["MODALITY_UNSPECIFIED"] = "MODALITY_UNSPECIFIED";
        Modality2["TEXT"] = "TEXT";
        Modality2["IMAGE"] = "IMAGE";
        Modality2["AUDIO"] = "AUDIO";
      })(Modality || (Modality = {}));
      (function(MediaResolution2) {
        MediaResolution2["MEDIA_RESOLUTION_UNSPECIFIED"] = "MEDIA_RESOLUTION_UNSPECIFIED";
        MediaResolution2["MEDIA_RESOLUTION_LOW"] = "MEDIA_RESOLUTION_LOW";
        MediaResolution2["MEDIA_RESOLUTION_MEDIUM"] = "MEDIA_RESOLUTION_MEDIUM";
        MediaResolution2["MEDIA_RESOLUTION_HIGH"] = "MEDIA_RESOLUTION_HIGH";
      })(MediaResolution || (MediaResolution = {}));
      (function(TuningMode2) {
        TuningMode2["TUNING_MODE_UNSPECIFIED"] = "TUNING_MODE_UNSPECIFIED";
        TuningMode2["TUNING_MODE_FULL"] = "TUNING_MODE_FULL";
        TuningMode2["TUNING_MODE_PEFT_ADAPTER"] = "TUNING_MODE_PEFT_ADAPTER";
      })(TuningMode || (TuningMode = {}));
      (function(AdapterSize2) {
        AdapterSize2["ADAPTER_SIZE_UNSPECIFIED"] = "ADAPTER_SIZE_UNSPECIFIED";
        AdapterSize2["ADAPTER_SIZE_ONE"] = "ADAPTER_SIZE_ONE";
        AdapterSize2["ADAPTER_SIZE_TWO"] = "ADAPTER_SIZE_TWO";
        AdapterSize2["ADAPTER_SIZE_FOUR"] = "ADAPTER_SIZE_FOUR";
        AdapterSize2["ADAPTER_SIZE_EIGHT"] = "ADAPTER_SIZE_EIGHT";
        AdapterSize2["ADAPTER_SIZE_SIXTEEN"] = "ADAPTER_SIZE_SIXTEEN";
        AdapterSize2["ADAPTER_SIZE_THIRTY_TWO"] = "ADAPTER_SIZE_THIRTY_TWO";
      })(AdapterSize || (AdapterSize = {}));
      (function(JobState2) {
        JobState2["JOB_STATE_UNSPECIFIED"] = "JOB_STATE_UNSPECIFIED";
        JobState2["JOB_STATE_QUEUED"] = "JOB_STATE_QUEUED";
        JobState2["JOB_STATE_PENDING"] = "JOB_STATE_PENDING";
        JobState2["JOB_STATE_RUNNING"] = "JOB_STATE_RUNNING";
        JobState2["JOB_STATE_SUCCEEDED"] = "JOB_STATE_SUCCEEDED";
        JobState2["JOB_STATE_FAILED"] = "JOB_STATE_FAILED";
        JobState2["JOB_STATE_CANCELLING"] = "JOB_STATE_CANCELLING";
        JobState2["JOB_STATE_CANCELLED"] = "JOB_STATE_CANCELLED";
        JobState2["JOB_STATE_PAUSED"] = "JOB_STATE_PAUSED";
        JobState2["JOB_STATE_EXPIRED"] = "JOB_STATE_EXPIRED";
        JobState2["JOB_STATE_UPDATING"] = "JOB_STATE_UPDATING";
        JobState2["JOB_STATE_PARTIALLY_SUCCEEDED"] = "JOB_STATE_PARTIALLY_SUCCEEDED";
      })(JobState || (JobState = {}));
      (function(TuningTask2) {
        TuningTask2["TUNING_TASK_UNSPECIFIED"] = "TUNING_TASK_UNSPECIFIED";
        TuningTask2["TUNING_TASK_I2V"] = "TUNING_TASK_I2V";
        TuningTask2["TUNING_TASK_T2V"] = "TUNING_TASK_T2V";
        TuningTask2["TUNING_TASK_R2V"] = "TUNING_TASK_R2V";
      })(TuningTask || (TuningTask = {}));
      (function(PartMediaResolutionLevel2) {
        PartMediaResolutionLevel2["MEDIA_RESOLUTION_UNSPECIFIED"] = "MEDIA_RESOLUTION_UNSPECIFIED";
        PartMediaResolutionLevel2["MEDIA_RESOLUTION_LOW"] = "MEDIA_RESOLUTION_LOW";
        PartMediaResolutionLevel2["MEDIA_RESOLUTION_MEDIUM"] = "MEDIA_RESOLUTION_MEDIUM";
        PartMediaResolutionLevel2["MEDIA_RESOLUTION_HIGH"] = "MEDIA_RESOLUTION_HIGH";
      })(PartMediaResolutionLevel || (PartMediaResolutionLevel = {}));
      (function(FeatureSelectionPreference2) {
        FeatureSelectionPreference2["FEATURE_SELECTION_PREFERENCE_UNSPECIFIED"] = "FEATURE_SELECTION_PREFERENCE_UNSPECIFIED";
        FeatureSelectionPreference2["PRIORITIZE_QUALITY"] = "PRIORITIZE_QUALITY";
        FeatureSelectionPreference2["BALANCED"] = "BALANCED";
        FeatureSelectionPreference2["PRIORITIZE_COST"] = "PRIORITIZE_COST";
      })(FeatureSelectionPreference || (FeatureSelectionPreference = {}));
      (function(Behavior2) {
        Behavior2["UNSPECIFIED"] = "UNSPECIFIED";
        Behavior2["BLOCKING"] = "BLOCKING";
        Behavior2["NON_BLOCKING"] = "NON_BLOCKING";
      })(Behavior || (Behavior = {}));
      (function(DynamicRetrievalConfigMode2) {
        DynamicRetrievalConfigMode2["MODE_UNSPECIFIED"] = "MODE_UNSPECIFIED";
        DynamicRetrievalConfigMode2["MODE_DYNAMIC"] = "MODE_DYNAMIC";
      })(DynamicRetrievalConfigMode || (DynamicRetrievalConfigMode = {}));
      (function(Environment2) {
        Environment2["ENVIRONMENT_UNSPECIFIED"] = "ENVIRONMENT_UNSPECIFIED";
        Environment2["ENVIRONMENT_BROWSER"] = "ENVIRONMENT_BROWSER";
      })(Environment || (Environment = {}));
      (function(FunctionCallingConfigMode2) {
        FunctionCallingConfigMode2["MODE_UNSPECIFIED"] = "MODE_UNSPECIFIED";
        FunctionCallingConfigMode2["AUTO"] = "AUTO";
        FunctionCallingConfigMode2["ANY"] = "ANY";
        FunctionCallingConfigMode2["NONE"] = "NONE";
        FunctionCallingConfigMode2["VALIDATED"] = "VALIDATED";
      })(FunctionCallingConfigMode || (FunctionCallingConfigMode = {}));
      (function(SafetyFilterLevel2) {
        SafetyFilterLevel2["BLOCK_LOW_AND_ABOVE"] = "BLOCK_LOW_AND_ABOVE";
        SafetyFilterLevel2["BLOCK_MEDIUM_AND_ABOVE"] = "BLOCK_MEDIUM_AND_ABOVE";
        SafetyFilterLevel2["BLOCK_ONLY_HIGH"] = "BLOCK_ONLY_HIGH";
        SafetyFilterLevel2["BLOCK_NONE"] = "BLOCK_NONE";
      })(SafetyFilterLevel || (SafetyFilterLevel = {}));
      (function(PersonGeneration2) {
        PersonGeneration2["DONT_ALLOW"] = "DONT_ALLOW";
        PersonGeneration2["ALLOW_ADULT"] = "ALLOW_ADULT";
        PersonGeneration2["ALLOW_ALL"] = "ALLOW_ALL";
      })(PersonGeneration || (PersonGeneration = {}));
      (function(ImagePromptLanguage2) {
        ImagePromptLanguage2["auto"] = "auto";
        ImagePromptLanguage2["en"] = "en";
        ImagePromptLanguage2["ja"] = "ja";
        ImagePromptLanguage2["ko"] = "ko";
        ImagePromptLanguage2["hi"] = "hi";
        ImagePromptLanguage2["zh"] = "zh";
        ImagePromptLanguage2["pt"] = "pt";
        ImagePromptLanguage2["es"] = "es";
      })(ImagePromptLanguage || (ImagePromptLanguage = {}));
      (function(MaskReferenceMode2) {
        MaskReferenceMode2["MASK_MODE_DEFAULT"] = "MASK_MODE_DEFAULT";
        MaskReferenceMode2["MASK_MODE_USER_PROVIDED"] = "MASK_MODE_USER_PROVIDED";
        MaskReferenceMode2["MASK_MODE_BACKGROUND"] = "MASK_MODE_BACKGROUND";
        MaskReferenceMode2["MASK_MODE_FOREGROUND"] = "MASK_MODE_FOREGROUND";
        MaskReferenceMode2["MASK_MODE_SEMANTIC"] = "MASK_MODE_SEMANTIC";
      })(MaskReferenceMode || (MaskReferenceMode = {}));
      (function(ControlReferenceType2) {
        ControlReferenceType2["CONTROL_TYPE_DEFAULT"] = "CONTROL_TYPE_DEFAULT";
        ControlReferenceType2["CONTROL_TYPE_CANNY"] = "CONTROL_TYPE_CANNY";
        ControlReferenceType2["CONTROL_TYPE_SCRIBBLE"] = "CONTROL_TYPE_SCRIBBLE";
        ControlReferenceType2["CONTROL_TYPE_FACE_MESH"] = "CONTROL_TYPE_FACE_MESH";
      })(ControlReferenceType || (ControlReferenceType = {}));
      (function(SubjectReferenceType2) {
        SubjectReferenceType2["SUBJECT_TYPE_DEFAULT"] = "SUBJECT_TYPE_DEFAULT";
        SubjectReferenceType2["SUBJECT_TYPE_PERSON"] = "SUBJECT_TYPE_PERSON";
        SubjectReferenceType2["SUBJECT_TYPE_ANIMAL"] = "SUBJECT_TYPE_ANIMAL";
        SubjectReferenceType2["SUBJECT_TYPE_PRODUCT"] = "SUBJECT_TYPE_PRODUCT";
      })(SubjectReferenceType || (SubjectReferenceType = {}));
      (function(EditMode2) {
        EditMode2["EDIT_MODE_DEFAULT"] = "EDIT_MODE_DEFAULT";
        EditMode2["EDIT_MODE_INPAINT_REMOVAL"] = "EDIT_MODE_INPAINT_REMOVAL";
        EditMode2["EDIT_MODE_INPAINT_INSERTION"] = "EDIT_MODE_INPAINT_INSERTION";
        EditMode2["EDIT_MODE_OUTPAINT"] = "EDIT_MODE_OUTPAINT";
        EditMode2["EDIT_MODE_CONTROLLED_EDITING"] = "EDIT_MODE_CONTROLLED_EDITING";
        EditMode2["EDIT_MODE_STYLE"] = "EDIT_MODE_STYLE";
        EditMode2["EDIT_MODE_BGSWAP"] = "EDIT_MODE_BGSWAP";
        EditMode2["EDIT_MODE_PRODUCT_IMAGE"] = "EDIT_MODE_PRODUCT_IMAGE";
      })(EditMode || (EditMode = {}));
      (function(SegmentMode2) {
        SegmentMode2["FOREGROUND"] = "FOREGROUND";
        SegmentMode2["BACKGROUND"] = "BACKGROUND";
        SegmentMode2["PROMPT"] = "PROMPT";
        SegmentMode2["SEMANTIC"] = "SEMANTIC";
        SegmentMode2["INTERACTIVE"] = "INTERACTIVE";
      })(SegmentMode || (SegmentMode = {}));
      (function(VideoGenerationReferenceType2) {
        VideoGenerationReferenceType2["ASSET"] = "ASSET";
        VideoGenerationReferenceType2["STYLE"] = "STYLE";
      })(VideoGenerationReferenceType || (VideoGenerationReferenceType = {}));
      (function(VideoGenerationMaskMode2) {
        VideoGenerationMaskMode2["INSERT"] = "INSERT";
        VideoGenerationMaskMode2["REMOVE"] = "REMOVE";
        VideoGenerationMaskMode2["REMOVE_STATIC"] = "REMOVE_STATIC";
        VideoGenerationMaskMode2["OUTPAINT"] = "OUTPAINT";
      })(VideoGenerationMaskMode || (VideoGenerationMaskMode = {}));
      (function(VideoCompressionQuality2) {
        VideoCompressionQuality2["OPTIMIZED"] = "OPTIMIZED";
        VideoCompressionQuality2["LOSSLESS"] = "LOSSLESS";
      })(VideoCompressionQuality || (VideoCompressionQuality = {}));
      (function(TuningMethod2) {
        TuningMethod2["SUPERVISED_FINE_TUNING"] = "SUPERVISED_FINE_TUNING";
        TuningMethod2["PREFERENCE_TUNING"] = "PREFERENCE_TUNING";
      })(TuningMethod || (TuningMethod = {}));
      (function(DocumentState2) {
        DocumentState2["STATE_UNSPECIFIED"] = "STATE_UNSPECIFIED";
        DocumentState2["STATE_PENDING"] = "STATE_PENDING";
        DocumentState2["STATE_ACTIVE"] = "STATE_ACTIVE";
        DocumentState2["STATE_FAILED"] = "STATE_FAILED";
      })(DocumentState || (DocumentState = {}));
      (function(FileState2) {
        FileState2["STATE_UNSPECIFIED"] = "STATE_UNSPECIFIED";
        FileState2["PROCESSING"] = "PROCESSING";
        FileState2["ACTIVE"] = "ACTIVE";
        FileState2["FAILED"] = "FAILED";
      })(FileState || (FileState = {}));
      (function(FileSource2) {
        FileSource2["SOURCE_UNSPECIFIED"] = "SOURCE_UNSPECIFIED";
        FileSource2["UPLOADED"] = "UPLOADED";
        FileSource2["GENERATED"] = "GENERATED";
      })(FileSource || (FileSource = {}));
      (function(TurnCompleteReason2) {
        TurnCompleteReason2["TURN_COMPLETE_REASON_UNSPECIFIED"] = "TURN_COMPLETE_REASON_UNSPECIFIED";
        TurnCompleteReason2["MALFORMED_FUNCTION_CALL"] = "MALFORMED_FUNCTION_CALL";
        TurnCompleteReason2["RESPONSE_REJECTED"] = "RESPONSE_REJECTED";
        TurnCompleteReason2["NEED_MORE_INPUT"] = "NEED_MORE_INPUT";
      })(TurnCompleteReason || (TurnCompleteReason = {}));
      (function(MediaModality2) {
        MediaModality2["MODALITY_UNSPECIFIED"] = "MODALITY_UNSPECIFIED";
        MediaModality2["TEXT"] = "TEXT";
        MediaModality2["IMAGE"] = "IMAGE";
        MediaModality2["VIDEO"] = "VIDEO";
        MediaModality2["AUDIO"] = "AUDIO";
        MediaModality2["DOCUMENT"] = "DOCUMENT";
      })(MediaModality || (MediaModality = {}));
      (function(StartSensitivity2) {
        StartSensitivity2["START_SENSITIVITY_UNSPECIFIED"] = "START_SENSITIVITY_UNSPECIFIED";
        StartSensitivity2["START_SENSITIVITY_HIGH"] = "START_SENSITIVITY_HIGH";
        StartSensitivity2["START_SENSITIVITY_LOW"] = "START_SENSITIVITY_LOW";
      })(StartSensitivity || (StartSensitivity = {}));
      (function(EndSensitivity2) {
        EndSensitivity2["END_SENSITIVITY_UNSPECIFIED"] = "END_SENSITIVITY_UNSPECIFIED";
        EndSensitivity2["END_SENSITIVITY_HIGH"] = "END_SENSITIVITY_HIGH";
        EndSensitivity2["END_SENSITIVITY_LOW"] = "END_SENSITIVITY_LOW";
      })(EndSensitivity || (EndSensitivity = {}));
      (function(ActivityHandling2) {
        ActivityHandling2["ACTIVITY_HANDLING_UNSPECIFIED"] = "ACTIVITY_HANDLING_UNSPECIFIED";
        ActivityHandling2["START_OF_ACTIVITY_INTERRUPTS"] = "START_OF_ACTIVITY_INTERRUPTS";
        ActivityHandling2["NO_INTERRUPTION"] = "NO_INTERRUPTION";
      })(ActivityHandling || (ActivityHandling = {}));
      (function(TurnCoverage2) {
        TurnCoverage2["TURN_COVERAGE_UNSPECIFIED"] = "TURN_COVERAGE_UNSPECIFIED";
        TurnCoverage2["TURN_INCLUDES_ONLY_ACTIVITY"] = "TURN_INCLUDES_ONLY_ACTIVITY";
        TurnCoverage2["TURN_INCLUDES_ALL_INPUT"] = "TURN_INCLUDES_ALL_INPUT";
      })(TurnCoverage || (TurnCoverage = {}));
      (function(Scale2) {
        Scale2["SCALE_UNSPECIFIED"] = "SCALE_UNSPECIFIED";
        Scale2["C_MAJOR_A_MINOR"] = "C_MAJOR_A_MINOR";
        Scale2["D_FLAT_MAJOR_B_FLAT_MINOR"] = "D_FLAT_MAJOR_B_FLAT_MINOR";
        Scale2["D_MAJOR_B_MINOR"] = "D_MAJOR_B_MINOR";
        Scale2["E_FLAT_MAJOR_C_MINOR"] = "E_FLAT_MAJOR_C_MINOR";
        Scale2["E_MAJOR_D_FLAT_MINOR"] = "E_MAJOR_D_FLAT_MINOR";
        Scale2["F_MAJOR_D_MINOR"] = "F_MAJOR_D_MINOR";
        Scale2["G_FLAT_MAJOR_E_FLAT_MINOR"] = "G_FLAT_MAJOR_E_FLAT_MINOR";
        Scale2["G_MAJOR_E_MINOR"] = "G_MAJOR_E_MINOR";
        Scale2["A_FLAT_MAJOR_F_MINOR"] = "A_FLAT_MAJOR_F_MINOR";
        Scale2["A_MAJOR_G_FLAT_MINOR"] = "A_MAJOR_G_FLAT_MINOR";
        Scale2["B_FLAT_MAJOR_G_MINOR"] = "B_FLAT_MAJOR_G_MINOR";
        Scale2["B_MAJOR_A_FLAT_MINOR"] = "B_MAJOR_A_FLAT_MINOR";
      })(Scale || (Scale = {}));
      (function(MusicGenerationMode2) {
        MusicGenerationMode2["MUSIC_GENERATION_MODE_UNSPECIFIED"] = "MUSIC_GENERATION_MODE_UNSPECIFIED";
        MusicGenerationMode2["QUALITY"] = "QUALITY";
        MusicGenerationMode2["DIVERSITY"] = "DIVERSITY";
        MusicGenerationMode2["VOCALIZATION"] = "VOCALIZATION";
      })(MusicGenerationMode || (MusicGenerationMode = {}));
      (function(LiveMusicPlaybackControl2) {
        LiveMusicPlaybackControl2["PLAYBACK_CONTROL_UNSPECIFIED"] = "PLAYBACK_CONTROL_UNSPECIFIED";
        LiveMusicPlaybackControl2["PLAY"] = "PLAY";
        LiveMusicPlaybackControl2["PAUSE"] = "PAUSE";
        LiveMusicPlaybackControl2["STOP"] = "STOP";
        LiveMusicPlaybackControl2["RESET_CONTEXT"] = "RESET_CONTEXT";
      })(LiveMusicPlaybackControl || (LiveMusicPlaybackControl = {}));
      FunctionResponseBlob = class {
      };
      FunctionResponseFileData = class {
      };
      FunctionResponsePart = class {
      };
      FunctionResponse = class {
      };
      HttpResponse = class {
        constructor(response) {
          const headers = {};
          for (const pair of response.headers.entries()) {
            headers[pair[0]] = pair[1];
          }
          this.headers = headers;
          this.responseInternal = response;
        }
        json() {
          return this.responseInternal.json();
        }
      };
      GenerateContentResponsePromptFeedback = class {
      };
      GenerateContentResponseUsageMetadata = class {
      };
      GenerateContentResponse = class {
        /**
         * Returns the concatenation of all text parts from the first candidate in the response.
         *
         * @remarks
         * If there are multiple candidates in the response, the text from the first
         * one will be returned.
         * If there are non-text parts in the response, the concatenation of all text
         * parts will be returned, and a warning will be logged.
         * If there are thought parts in the response, the concatenation of all text
         * parts excluding the thought parts will be returned.
         *
         * @example
         * ```ts
         * const response = await ai.models.generateContent({
         *   model: 'gemini-2.0-flash',
         *   contents:
         *     'Why is the sky blue?',
         * });
         *
         * console.debug(response.text);
         * ```
         */
        get text() {
          var _a, _b, _c, _d, _e, _f, _g, _h;
          if (((_d = (_c = (_b = (_a = this.candidates) === null || _a === void 0 ? void 0 : _a[0]) === null || _b === void 0 ? void 0 : _b.content) === null || _c === void 0 ? void 0 : _c.parts) === null || _d === void 0 ? void 0 : _d.length) === 0) {
            return void 0;
          }
          if (this.candidates && this.candidates.length > 1) {
            console.warn("there are multiple candidates in the response, returning text from the first one.");
          }
          let text = "";
          let anyTextPartText = false;
          const nonTextParts = [];
          for (const part of (_h = (_g = (_f = (_e = this.candidates) === null || _e === void 0 ? void 0 : _e[0]) === null || _f === void 0 ? void 0 : _f.content) === null || _g === void 0 ? void 0 : _g.parts) !== null && _h !== void 0 ? _h : []) {
            for (const [fieldName, fieldValue] of Object.entries(part)) {
              if (fieldName !== "text" && fieldName !== "thought" && fieldName !== "thoughtSignature" && (fieldValue !== null || fieldValue !== void 0)) {
                nonTextParts.push(fieldName);
              }
            }
            if (typeof part.text === "string") {
              if (typeof part.thought === "boolean" && part.thought) {
                continue;
              }
              anyTextPartText = true;
              text += part.text;
            }
          }
          if (nonTextParts.length > 0) {
            console.warn(`there are non-text parts ${nonTextParts} in the response, returning concatenation of all text parts. Please refer to the non text parts for a full response from model.`);
          }
          return anyTextPartText ? text : void 0;
        }
        /**
         * Returns the concatenation of all inline data parts from the first candidate
         * in the response.
         *
         * @remarks
         * If there are multiple candidates in the response, the inline data from the
         * first one will be returned. If there are non-inline data parts in the
         * response, the concatenation of all inline data parts will be returned, and
         * a warning will be logged.
         */
        get data() {
          var _a, _b, _c, _d, _e, _f, _g, _h;
          if (((_d = (_c = (_b = (_a = this.candidates) === null || _a === void 0 ? void 0 : _a[0]) === null || _b === void 0 ? void 0 : _b.content) === null || _c === void 0 ? void 0 : _c.parts) === null || _d === void 0 ? void 0 : _d.length) === 0) {
            return void 0;
          }
          if (this.candidates && this.candidates.length > 1) {
            console.warn("there are multiple candidates in the response, returning data from the first one.");
          }
          let data = "";
          const nonDataParts = [];
          for (const part of (_h = (_g = (_f = (_e = this.candidates) === null || _e === void 0 ? void 0 : _e[0]) === null || _f === void 0 ? void 0 : _f.content) === null || _g === void 0 ? void 0 : _g.parts) !== null && _h !== void 0 ? _h : []) {
            for (const [fieldName, fieldValue] of Object.entries(part)) {
              if (fieldName !== "inlineData" && (fieldValue !== null || fieldValue !== void 0)) {
                nonDataParts.push(fieldName);
              }
            }
            if (part.inlineData && typeof part.inlineData.data === "string") {
              data += atob(part.inlineData.data);
            }
          }
          if (nonDataParts.length > 0) {
            console.warn(`there are non-data parts ${nonDataParts} in the response, returning concatenation of all data parts. Please refer to the non data parts for a full response from model.`);
          }
          return data.length > 0 ? btoa(data) : void 0;
        }
        /**
         * Returns the function calls from the first candidate in the response.
         *
         * @remarks
         * If there are multiple candidates in the response, the function calls from
         * the first one will be returned.
         * If there are no function calls in the response, undefined will be returned.
         *
         * @example
         * ```ts
         * const controlLightFunctionDeclaration: FunctionDeclaration = {
         *   name: 'controlLight',
         *   parameters: {
         *   type: Type.OBJECT,
         *   description: 'Set the brightness and color temperature of a room light.',
         *   properties: {
         *     brightness: {
         *       type: Type.NUMBER,
         *       description:
         *         'Light level from 0 to 100. Zero is off and 100 is full brightness.',
         *     },
         *     colorTemperature: {
         *       type: Type.STRING,
         *       description:
         *         'Color temperature of the light fixture which can be `daylight`, `cool` or `warm`.',
         *     },
         *   },
         *   required: ['brightness', 'colorTemperature'],
         *  };
         *  const response = await ai.models.generateContent({
         *     model: 'gemini-2.0-flash',
         *     contents: 'Dim the lights so the room feels cozy and warm.',
         *     config: {
         *       tools: [{functionDeclarations: [controlLightFunctionDeclaration]}],
         *       toolConfig: {
         *         functionCallingConfig: {
         *           mode: FunctionCallingConfigMode.ANY,
         *           allowedFunctionNames: ['controlLight'],
         *         },
         *       },
         *     },
         *   });
         *  console.debug(JSON.stringify(response.functionCalls));
         * ```
         */
        get functionCalls() {
          var _a, _b, _c, _d, _e, _f, _g, _h;
          if (((_d = (_c = (_b = (_a = this.candidates) === null || _a === void 0 ? void 0 : _a[0]) === null || _b === void 0 ? void 0 : _b.content) === null || _c === void 0 ? void 0 : _c.parts) === null || _d === void 0 ? void 0 : _d.length) === 0) {
            return void 0;
          }
          if (this.candidates && this.candidates.length > 1) {
            console.warn("there are multiple candidates in the response, returning function calls from the first one.");
          }
          const functionCalls = (_h = (_g = (_f = (_e = this.candidates) === null || _e === void 0 ? void 0 : _e[0]) === null || _f === void 0 ? void 0 : _f.content) === null || _g === void 0 ? void 0 : _g.parts) === null || _h === void 0 ? void 0 : _h.filter((part) => part.functionCall).map((part) => part.functionCall).filter((functionCall) => functionCall !== void 0);
          if ((functionCalls === null || functionCalls === void 0 ? void 0 : functionCalls.length) === 0) {
            return void 0;
          }
          return functionCalls;
        }
        /**
         * Returns the first executable code from the first candidate in the response.
         *
         * @remarks
         * If there are multiple candidates in the response, the executable code from
         * the first one will be returned.
         * If there are no executable code in the response, undefined will be
         * returned.
         *
         * @example
         * ```ts
         * const response = await ai.models.generateContent({
         *   model: 'gemini-2.0-flash',
         *   contents:
         *     'What is the sum of the first 50 prime numbers? Generate and run code for the calculation, and make sure you get all 50.'
         *   config: {
         *     tools: [{codeExecution: {}}],
         *   },
         * });
         *
         * console.debug(response.executableCode);
         * ```
         */
        get executableCode() {
          var _a, _b, _c, _d, _e, _f, _g, _h, _j;
          if (((_d = (_c = (_b = (_a = this.candidates) === null || _a === void 0 ? void 0 : _a[0]) === null || _b === void 0 ? void 0 : _b.content) === null || _c === void 0 ? void 0 : _c.parts) === null || _d === void 0 ? void 0 : _d.length) === 0) {
            return void 0;
          }
          if (this.candidates && this.candidates.length > 1) {
            console.warn("there are multiple candidates in the response, returning executable code from the first one.");
          }
          const executableCode = (_h = (_g = (_f = (_e = this.candidates) === null || _e === void 0 ? void 0 : _e[0]) === null || _f === void 0 ? void 0 : _f.content) === null || _g === void 0 ? void 0 : _g.parts) === null || _h === void 0 ? void 0 : _h.filter((part) => part.executableCode).map((part) => part.executableCode).filter((executableCode2) => executableCode2 !== void 0);
          if ((executableCode === null || executableCode === void 0 ? void 0 : executableCode.length) === 0) {
            return void 0;
          }
          return (_j = executableCode === null || executableCode === void 0 ? void 0 : executableCode[0]) === null || _j === void 0 ? void 0 : _j.code;
        }
        /**
         * Returns the first code execution result from the first candidate in the response.
         *
         * @remarks
         * If there are multiple candidates in the response, the code execution result from
         * the first one will be returned.
         * If there are no code execution result in the response, undefined will be returned.
         *
         * @example
         * ```ts
         * const response = await ai.models.generateContent({
         *   model: 'gemini-2.0-flash',
         *   contents:
         *     'What is the sum of the first 50 prime numbers? Generate and run code for the calculation, and make sure you get all 50.'
         *   config: {
         *     tools: [{codeExecution: {}}],
         *   },
         * });
         *
         * console.debug(response.codeExecutionResult);
         * ```
         */
        get codeExecutionResult() {
          var _a, _b, _c, _d, _e, _f, _g, _h, _j;
          if (((_d = (_c = (_b = (_a = this.candidates) === null || _a === void 0 ? void 0 : _a[0]) === null || _b === void 0 ? void 0 : _b.content) === null || _c === void 0 ? void 0 : _c.parts) === null || _d === void 0 ? void 0 : _d.length) === 0) {
            return void 0;
          }
          if (this.candidates && this.candidates.length > 1) {
            console.warn("there are multiple candidates in the response, returning code execution result from the first one.");
          }
          const codeExecutionResult = (_h = (_g = (_f = (_e = this.candidates) === null || _e === void 0 ? void 0 : _e[0]) === null || _f === void 0 ? void 0 : _f.content) === null || _g === void 0 ? void 0 : _g.parts) === null || _h === void 0 ? void 0 : _h.filter((part) => part.codeExecutionResult).map((part) => part.codeExecutionResult).filter((codeExecutionResult2) => codeExecutionResult2 !== void 0);
          if ((codeExecutionResult === null || codeExecutionResult === void 0 ? void 0 : codeExecutionResult.length) === 0) {
            return void 0;
          }
          return (_j = codeExecutionResult === null || codeExecutionResult === void 0 ? void 0 : codeExecutionResult[0]) === null || _j === void 0 ? void 0 : _j.output;
        }
      };
      EmbedContentResponse = class {
      };
      GenerateImagesResponse = class {
      };
      EditImageResponse = class {
      };
      UpscaleImageResponse = class {
      };
      RecontextImageResponse = class {
      };
      SegmentImageResponse = class {
      };
      ListModelsResponse = class {
      };
      DeleteModelResponse = class {
      };
      CountTokensResponse = class {
      };
      ComputeTokensResponse = class {
      };
      GenerateVideosResponse = class {
      };
      GenerateVideosOperation = class _GenerateVideosOperation {
        /**
         * Instantiates an Operation of the same type as the one being called with the fields set from the API response.
         * @internal
         */
        _fromAPIResponse({ apiResponse, _isVertexAI }) {
          const operation = new _GenerateVideosOperation();
          let response;
          const op = apiResponse;
          if (_isVertexAI) {
            response = generateVideosOperationFromVertex$1(op);
          } else {
            response = generateVideosOperationFromMldev$1(op);
          }
          Object.assign(operation, response);
          return operation;
        }
      };
      ListTuningJobsResponse = class {
      };
      DeleteCachedContentResponse = class {
      };
      ListCachedContentsResponse = class {
      };
      ListDocumentsResponse = class {
      };
      ListFileSearchStoresResponse = class {
      };
      UploadToFileSearchStoreResumableResponse = class {
      };
      ImportFileResponse = class {
      };
      ImportFileOperation = class _ImportFileOperation {
        /**
         * Instantiates an Operation of the same type as the one being called with the fields set from the API response.
         * @internal
         */
        _fromAPIResponse({ apiResponse, _isVertexAI }) {
          const operation = new _ImportFileOperation();
          const op = apiResponse;
          const response = importFileOperationFromMldev$1(op);
          Object.assign(operation, response);
          return operation;
        }
      };
      ListFilesResponse = class {
      };
      CreateFileResponse = class {
      };
      DeleteFileResponse = class {
      };
      InlinedResponse = class {
      };
      SingleEmbedContentResponse = class {
      };
      InlinedEmbedContentResponse = class {
      };
      ListBatchJobsResponse = class {
      };
      ReplayResponse = class {
      };
      RawReferenceImage = class {
        /** Internal method to convert to ReferenceImageAPIInternal. */
        toReferenceImageAPI() {
          const referenceImageAPI = {
            referenceType: "REFERENCE_TYPE_RAW",
            referenceImage: this.referenceImage,
            referenceId: this.referenceId
          };
          return referenceImageAPI;
        }
      };
      MaskReferenceImage = class {
        /** Internal method to convert to ReferenceImageAPIInternal. */
        toReferenceImageAPI() {
          const referenceImageAPI = {
            referenceType: "REFERENCE_TYPE_MASK",
            referenceImage: this.referenceImage,
            referenceId: this.referenceId,
            maskImageConfig: this.config
          };
          return referenceImageAPI;
        }
      };
      ControlReferenceImage = class {
        /** Internal method to convert to ReferenceImageAPIInternal. */
        toReferenceImageAPI() {
          const referenceImageAPI = {
            referenceType: "REFERENCE_TYPE_CONTROL",
            referenceImage: this.referenceImage,
            referenceId: this.referenceId,
            controlImageConfig: this.config
          };
          return referenceImageAPI;
        }
      };
      StyleReferenceImage = class {
        /** Internal method to convert to ReferenceImageAPIInternal. */
        toReferenceImageAPI() {
          const referenceImageAPI = {
            referenceType: "REFERENCE_TYPE_STYLE",
            referenceImage: this.referenceImage,
            referenceId: this.referenceId,
            styleImageConfig: this.config
          };
          return referenceImageAPI;
        }
      };
      SubjectReferenceImage = class {
        /* Internal method to convert to ReferenceImageAPIInternal. */
        toReferenceImageAPI() {
          const referenceImageAPI = {
            referenceType: "REFERENCE_TYPE_SUBJECT",
            referenceImage: this.referenceImage,
            referenceId: this.referenceId,
            subjectImageConfig: this.config
          };
          return referenceImageAPI;
        }
      };
      ContentReferenceImage = class {
        /** Internal method to convert to ReferenceImageAPIInternal. */
        toReferenceImageAPI() {
          const referenceImageAPI = {
            referenceType: "REFERENCE_TYPE_CONTENT",
            referenceImage: this.referenceImage,
            referenceId: this.referenceId
          };
          return referenceImageAPI;
        }
      };
      LiveServerMessage = class {
        /**
         * Returns the concatenation of all text parts from the server content if present.
         *
         * @remarks
         * If there are non-text parts in the response, the concatenation of all text
         * parts will be returned, and a warning will be logged.
         */
        get text() {
          var _a, _b, _c;
          let text = "";
          let anyTextPartFound = false;
          const nonTextParts = [];
          for (const part of (_c = (_b = (_a = this.serverContent) === null || _a === void 0 ? void 0 : _a.modelTurn) === null || _b === void 0 ? void 0 : _b.parts) !== null && _c !== void 0 ? _c : []) {
            for (const [fieldName, fieldValue] of Object.entries(part)) {
              if (fieldName !== "text" && fieldName !== "thought" && fieldValue !== null) {
                nonTextParts.push(fieldName);
              }
            }
            if (typeof part.text === "string") {
              if (typeof part.thought === "boolean" && part.thought) {
                continue;
              }
              anyTextPartFound = true;
              text += part.text;
            }
          }
          if (nonTextParts.length > 0) {
            console.warn(`there are non-text parts ${nonTextParts} in the response, returning concatenation of all text parts. Please refer to the non text parts for a full response from model.`);
          }
          return anyTextPartFound ? text : void 0;
        }
        /**
         * Returns the concatenation of all inline data parts from the server content if present.
         *
         * @remarks
         * If there are non-inline data parts in the
         * response, the concatenation of all inline data parts will be returned, and
         * a warning will be logged.
         */
        get data() {
          var _a, _b, _c;
          let data = "";
          const nonDataParts = [];
          for (const part of (_c = (_b = (_a = this.serverContent) === null || _a === void 0 ? void 0 : _a.modelTurn) === null || _b === void 0 ? void 0 : _b.parts) !== null && _c !== void 0 ? _c : []) {
            for (const [fieldName, fieldValue] of Object.entries(part)) {
              if (fieldName !== "inlineData" && fieldValue !== null) {
                nonDataParts.push(fieldName);
              }
            }
            if (part.inlineData && typeof part.inlineData.data === "string") {
              data += atob(part.inlineData.data);
            }
          }
          if (nonDataParts.length > 0) {
            console.warn(`there are non-data parts ${nonDataParts} in the response, returning concatenation of all data parts. Please refer to the non data parts for a full response from model.`);
          }
          return data.length > 0 ? btoa(data) : void 0;
        }
      };
      LiveClientToolResponse = class {
      };
      LiveSendToolResponseParameters = class {
        constructor() {
          this.functionResponses = [];
        }
      };
      LiveMusicServerMessage = class {
        /**
         * Returns the first audio chunk from the server content, if present.
         *
         * @remarks
         * If there are no audio chunks in the response, undefined will be returned.
         */
        get audioChunk() {
          if (this.serverContent && this.serverContent.audioChunks && this.serverContent.audioChunks.length > 0) {
            return this.serverContent.audioChunks[0];
          }
          return void 0;
        }
      };
      UploadToFileSearchStoreResponse = class {
      };
      UploadToFileSearchStoreOperation = class _UploadToFileSearchStoreOperation {
        /**
         * Instantiates an Operation of the same type as the one being called with the fields set from the API response.
         * @internal
         */
        _fromAPIResponse({ apiResponse, _isVertexAI }) {
          const operation = new _UploadToFileSearchStoreOperation();
          const op = apiResponse;
          const response = uploadToFileSearchStoreOperationFromMldev(op);
          Object.assign(operation, response);
          return operation;
        }
      };
      (function(PagedItem2) {
        PagedItem2["PAGED_ITEM_BATCH_JOBS"] = "batchJobs";
        PagedItem2["PAGED_ITEM_MODELS"] = "models";
        PagedItem2["PAGED_ITEM_TUNING_JOBS"] = "tuningJobs";
        PagedItem2["PAGED_ITEM_FILES"] = "files";
        PagedItem2["PAGED_ITEM_CACHED_CONTENTS"] = "cachedContents";
        PagedItem2["PAGED_ITEM_FILE_SEARCH_STORES"] = "fileSearchStores";
        PagedItem2["PAGED_ITEM_DOCUMENTS"] = "documents";
      })(PagedItem || (PagedItem = {}));
      Pager = class {
        constructor(name, request, response, params) {
          this.pageInternal = [];
          this.paramsInternal = {};
          this.requestInternal = request;
          this.init(name, response, params);
        }
        init(name, response, params) {
          var _a, _b;
          this.nameInternal = name;
          this.pageInternal = response[this.nameInternal] || [];
          this.sdkHttpResponseInternal = response === null || response === void 0 ? void 0 : response.sdkHttpResponse;
          this.idxInternal = 0;
          let requestParams = { config: {} };
          if (!params || Object.keys(params).length === 0) {
            requestParams = { config: {} };
          } else if (typeof params === "object") {
            requestParams = Object.assign({}, params);
          } else {
            requestParams = params;
          }
          if (requestParams["config"]) {
            requestParams["config"]["pageToken"] = response["nextPageToken"];
          }
          this.paramsInternal = requestParams;
          this.pageInternalSize = (_b = (_a = requestParams["config"]) === null || _a === void 0 ? void 0 : _a["pageSize"]) !== null && _b !== void 0 ? _b : this.pageInternal.length;
        }
        initNextPage(response) {
          this.init(this.nameInternal, response, this.paramsInternal);
        }
        /**
         * Returns the current page, which is a list of items.
         *
         * @remarks
         * The first page is retrieved when the pager is created. The returned list of
         * items could be a subset of the entire list.
         */
        get page() {
          return this.pageInternal;
        }
        /**
         * Returns the type of paged item (for example, ``batch_jobs``).
         */
        get name() {
          return this.nameInternal;
        }
        /**
         * Returns the length of the page fetched each time by this pager.
         *
         * @remarks
         * The number of items in the page is less than or equal to the page length.
         */
        get pageSize() {
          return this.pageInternalSize;
        }
        /**
         * Returns the headers of the API response.
         */
        get sdkHttpResponse() {
          return this.sdkHttpResponseInternal;
        }
        /**
         * Returns the parameters when making the API request for the next page.
         *
         * @remarks
         * Parameters contain a set of optional configs that can be
         * used to customize the API request. For example, the `pageToken` parameter
         * contains the token to request the next page.
         */
        get params() {
          return this.paramsInternal;
        }
        /**
         * Returns the total number of items in the current page.
         */
        get pageLength() {
          return this.pageInternal.length;
        }
        /**
         * Returns the item at the given index.
         */
        getItem(index) {
          return this.pageInternal[index];
        }
        /**
         * Returns an async iterator that support iterating through all items
         * retrieved from the API.
         *
         * @remarks
         * The iterator will automatically fetch the next page if there are more items
         * to fetch from the API.
         *
         * @example
         *
         * ```ts
         * const pager = await ai.files.list({config: {pageSize: 10}});
         * for await (const file of pager) {
         *   console.log(file.name);
         * }
         * ```
         */
        [Symbol.asyncIterator]() {
          return {
            next: async () => {
              if (this.idxInternal >= this.pageLength) {
                if (this.hasNextPage()) {
                  await this.nextPage();
                } else {
                  return { value: void 0, done: true };
                }
              }
              const item = this.getItem(this.idxInternal);
              this.idxInternal += 1;
              return { value: item, done: false };
            },
            return: async () => {
              return { value: void 0, done: true };
            }
          };
        }
        /**
         * Fetches the next page of items. This makes a new API request.
         *
         * @throws {Error} If there are no more pages to fetch.
         *
         * @example
         *
         * ```ts
         * const pager = await ai.files.list({config: {pageSize: 10}});
         * let page = pager.page;
         * while (true) {
         *   for (const file of page) {
         *     console.log(file.name);
         *   }
         *   if (!pager.hasNextPage()) {
         *     break;
         *   }
         *   page = await pager.nextPage();
         * }
         * ```
         */
        async nextPage() {
          if (!this.hasNextPage()) {
            throw new Error("No more pages to fetch.");
          }
          const response = await this.requestInternal(this.params);
          this.initNextPage(response);
          return this.page;
        }
        /**
         * Returns true if there are more pages to fetch from the API.
         */
        hasNextPage() {
          var _a;
          if (((_a = this.params["config"]) === null || _a === void 0 ? void 0 : _a["pageToken"]) !== void 0) {
            return true;
          }
          return false;
        }
      };
      Batches = class extends BaseModule {
        constructor(apiClient) {
          super();
          this.apiClient = apiClient;
          this.create = async (params) => {
            if (this.apiClient.isVertexAI()) {
              params.config = this.formatDestination(params.src, params.config);
            }
            return this.createInternal(params);
          };
          this.createEmbeddings = async (params) => {
            console.warn("batches.createEmbeddings() is experimental and may change without notice.");
            if (this.apiClient.isVertexAI()) {
              throw new Error("Vertex AI does not support batches.createEmbeddings.");
            }
            return this.createEmbeddingsInternal(params);
          };
          this.list = async (params = {}) => {
            return new Pager(PagedItem.PAGED_ITEM_BATCH_JOBS, (x) => this.listInternal(x), await this.listInternal(params), params);
          };
        }
        // Helper function to handle inlined generate content requests
        createInlinedGenerateContentRequest(params) {
          const body = createBatchJobParametersToMldev(
            this.apiClient,
            // Use instance apiClient
            params
          );
          const urlParams = body["_url"];
          const path = formatMap("{model}:batchGenerateContent", urlParams);
          const batch = body["batch"];
          const inputConfig = batch["inputConfig"];
          const requestsWrapper = inputConfig["requests"];
          const requests = requestsWrapper["requests"];
          const newRequests = [];
          for (const request of requests) {
            const requestDict = Object.assign({}, request);
            if (requestDict["systemInstruction"]) {
              const systemInstructionValue = requestDict["systemInstruction"];
              delete requestDict["systemInstruction"];
              const requestContent = requestDict["request"];
              requestContent["systemInstruction"] = systemInstructionValue;
              requestDict["request"] = requestContent;
            }
            newRequests.push(requestDict);
          }
          requestsWrapper["requests"] = newRequests;
          delete body["config"];
          delete body["_url"];
          delete body["_query"];
          return { path, body };
        }
        // Helper function to get the first GCS URI
        getGcsUri(src) {
          if (typeof src === "string") {
            return src.startsWith("gs://") ? src : void 0;
          }
          if (!Array.isArray(src) && src.gcsUri && src.gcsUri.length > 0) {
            return src.gcsUri[0];
          }
          return void 0;
        }
        // Helper function to get the BigQuery URI
        getBigqueryUri(src) {
          if (typeof src === "string") {
            return src.startsWith("bq://") ? src : void 0;
          }
          if (!Array.isArray(src)) {
            return src.bigqueryUri;
          }
          return void 0;
        }
        // Function to format the destination configuration for Vertex AI
        formatDestination(src, config) {
          const newConfig = config ? Object.assign({}, config) : {};
          const timestampStr = Date.now().toString();
          if (!newConfig.displayName) {
            newConfig.displayName = `genaiBatchJob_${timestampStr}`;
          }
          if (newConfig.dest === void 0) {
            const gcsUri = this.getGcsUri(src);
            const bigqueryUri = this.getBigqueryUri(src);
            if (gcsUri) {
              if (gcsUri.endsWith(".jsonl")) {
                newConfig.dest = `${gcsUri.slice(0, -6)}/dest`;
              } else {
                newConfig.dest = `${gcsUri}_dest_${timestampStr}`;
              }
            } else if (bigqueryUri) {
              newConfig.dest = `${bigqueryUri}_dest_${timestampStr}`;
            } else {
              throw new Error("Unsupported source for Vertex AI: No GCS or BigQuery URI found.");
            }
          }
          return newConfig;
        }
        /**
         * Internal method to create batch job.
         *
         * @param params - The parameters for create batch job request.
         * @return The created batch job.
         *
         */
        async createInternal(params) {
          var _a, _b, _c, _d;
          let response;
          let path = "";
          let queryParams = {};
          if (this.apiClient.isVertexAI()) {
            const body = createBatchJobParametersToVertex(this.apiClient, params);
            path = formatMap("batchPredictionJobs", body["_url"]);
            queryParams = body["_query"];
            delete body["_url"];
            delete body["_query"];
            response = this.apiClient.request({
              path,
              queryParams,
              body: JSON.stringify(body),
              httpMethod: "POST",
              httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,
              abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
            }).then((httpResponse) => {
              return httpResponse.json();
            });
            return response.then((apiResponse) => {
              const resp = batchJobFromVertex(apiResponse);
              return resp;
            });
          } else {
            const body = createBatchJobParametersToMldev(this.apiClient, params);
            path = formatMap("{model}:batchGenerateContent", body["_url"]);
            queryParams = body["_query"];
            delete body["_url"];
            delete body["_query"];
            response = this.apiClient.request({
              path,
              queryParams,
              body: JSON.stringify(body),
              httpMethod: "POST",
              httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,
              abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal
            }).then((httpResponse) => {
              return httpResponse.json();
            });
            return response.then((apiResponse) => {
              const resp = batchJobFromMldev(apiResponse);
              return resp;
            });
          }
        }
        /**
         * Internal method to create batch job.
         *
         * @param params - The parameters for create batch job request.
         * @return The created batch job.
         *
         */
        async createEmbeddingsInternal(params) {
          var _a, _b;
          let response;
          let path = "";
          let queryParams = {};
          if (this.apiClient.isVertexAI()) {
            throw new Error("This method is only supported by the Gemini Developer API.");
          } else {
            const body = createEmbeddingsBatchJobParametersToMldev(this.apiClient, params);
            path = formatMap("{model}:asyncBatchEmbedContent", body["_url"]);
            queryParams = body["_query"];
            delete body["_url"];
            delete body["_query"];
            response = this.apiClient.request({
              path,
              queryParams,
              body: JSON.stringify(body),
              httpMethod: "POST",
              httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,
              abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
            }).then((httpResponse) => {
              return httpResponse.json();
            });
            return response.then((apiResponse) => {
              const resp = batchJobFromMldev(apiResponse);
              return resp;
            });
          }
        }
        /**
         * Gets batch job configurations.
         *
         * @param params - The parameters for the get request.
         * @return The batch job.
         *
         * @example
         * ```ts
         * await ai.batches.get({name: '...'}); // The server-generated resource name.
         * ```
         */
        async get(params) {
          var _a, _b, _c, _d;
          let response;
          let path = "";
          let queryParams = {};
          if (this.apiClient.isVertexAI()) {
            const body = getBatchJobParametersToVertex(this.apiClient, params);
            path = formatMap("batchPredictionJobs/{name}", body["_url"]);
            queryParams = body["_query"];
            delete body["_url"];
            delete body["_query"];
            response = this.apiClient.request({
              path,
              queryParams,
              body: JSON.stringify(body),
              httpMethod: "GET",
              httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,
              abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
            }).then((httpResponse) => {
              return httpResponse.json();
            });
            return response.then((apiResponse) => {
              const resp = batchJobFromVertex(apiResponse);
              return resp;
            });
          } else {
            const body = getBatchJobParametersToMldev(this.apiClient, params);
            path = formatMap("batches/{name}", body["_url"]);
            queryParams = body["_query"];
            delete body["_url"];
            delete body["_query"];
            response = this.apiClient.request({
              path,
              queryParams,
              body: JSON.stringify(body),
              httpMethod: "GET",
              httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,
              abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal
            }).then((httpResponse) => {
              return httpResponse.json();
            });
            return response.then((apiResponse) => {
              const resp = batchJobFromMldev(apiResponse);
              return resp;
            });
          }
        }
        /**
         * Cancels a batch job.
         *
         * @param params - The parameters for the cancel request.
         * @return The empty response returned by the API.
         *
         * @example
         * ```ts
         * await ai.batches.cancel({name: '...'}); // The server-generated resource name.
         * ```
         */
        async cancel(params) {
          var _a, _b, _c, _d;
          let path = "";
          let queryParams = {};
          if (this.apiClient.isVertexAI()) {
            const body = cancelBatchJobParametersToVertex(this.apiClient, params);
            path = formatMap("batchPredictionJobs/{name}:cancel", body["_url"]);
            queryParams = body["_query"];
            delete body["_url"];
            delete body["_query"];
            await this.apiClient.request({
              path,
              queryParams,
              body: JSON.stringify(body),
              httpMethod: "POST",
              httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,
              abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
            });
          } else {
            const body = cancelBatchJobParametersToMldev(this.apiClient, params);
            path = formatMap("batches/{name}:cancel", body["_url"]);
            queryParams = body["_query"];
            delete body["_url"];
            delete body["_query"];
            await this.apiClient.request({
              path,
              queryParams,
              body: JSON.stringify(body),
              httpMethod: "POST",
              httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,
              abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal
            });
          }
        }
        async listInternal(params) {
          var _a, _b, _c, _d;
          let response;
          let path = "";
          let queryParams = {};
          if (this.apiClient.isVertexAI()) {
            const body = listBatchJobsParametersToVertex(params);
            path = formatMap("batchPredictionJobs", body["_url"]);
            queryParams = body["_query"];
            delete body["_url"];
            delete body["_query"];
            response = this.apiClient.request({
              path,
              queryParams,
              body: JSON.stringify(body),
              httpMethod: "GET",
              httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,
              abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
            }).then((httpResponse) => {
              return httpResponse.json().then((jsonResponse) => {
                const response2 = jsonResponse;
                response2.sdkHttpResponse = {
                  headers: httpResponse.headers
                };
                return response2;
              });
            });
            return response.then((apiResponse) => {
              const resp = listBatchJobsResponseFromVertex(apiResponse);
              const typedResp = new ListBatchJobsResponse();
              Object.assign(typedResp, resp);
              return typedResp;
            });
          } else {
            const body = listBatchJobsParametersToMldev(params);
            path = formatMap("batches", body["_url"]);
            queryParams = body["_query"];
            delete body["_url"];
            delete body["_query"];
            response = this.apiClient.request({
              path,
              queryParams,
              body: JSON.stringify(body),
              httpMethod: "GET",
              httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,
              abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal
            }).then((httpResponse) => {
              return httpResponse.json().then((jsonResponse) => {
                const response2 = jsonResponse;
                response2.sdkHttpResponse = {
                  headers: httpResponse.headers
                };
                return response2;
              });
            });
            return response.then((apiResponse) => {
              const resp = listBatchJobsResponseFromMldev(apiResponse);
              const typedResp = new ListBatchJobsResponse();
              Object.assign(typedResp, resp);
              return typedResp;
            });
          }
        }
        /**
         * Deletes a batch job.
         *
         * @param params - The parameters for the delete request.
         * @return The empty response returned by the API.
         *
         * @example
         * ```ts
         * await ai.batches.delete({name: '...'}); // The server-generated resource name.
         * ```
         */
        async delete(params) {
          var _a, _b, _c, _d;
          let response;
          let path = "";
          let queryParams = {};
          if (this.apiClient.isVertexAI()) {
            const body = deleteBatchJobParametersToVertex(this.apiClient, params);
            path = formatMap("batchPredictionJobs/{name}", body["_url"]);
            queryParams = body["_query"];
            delete body["_url"];
            delete body["_query"];
            response = this.apiClient.request({
              path,
              queryParams,
              body: JSON.stringify(body),
              httpMethod: "DELETE",
              httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,
              abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
            }).then((httpResponse) => {
              return httpResponse.json().then((jsonResponse) => {
                const response2 = jsonResponse;
                response2.sdkHttpResponse = {
                  headers: httpResponse.headers
                };
                return response2;
              });
            });
            return response.then((apiResponse) => {
              const resp = deleteResourceJobFromVertex(apiResponse);
              return resp;
            });
          } else {
            const body = deleteBatchJobParametersToMldev(this.apiClient, params);
            path = formatMap("batches/{name}", body["_url"]);
            queryParams = body["_query"];
            delete body["_url"];
            delete body["_query"];
            response = this.apiClient.request({
              path,
              queryParams,
              body: JSON.stringify(body),
              httpMethod: "DELETE",
              httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,
              abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal
            }).then((httpResponse) => {
              return httpResponse.json().then((jsonResponse) => {
                const response2 = jsonResponse;
                response2.sdkHttpResponse = {
                  headers: httpResponse.headers
                };
                return response2;
              });
            });
            return response.then((apiResponse) => {
              const resp = deleteResourceJobFromMldev(apiResponse);
              return resp;
            });
          }
        }
      };
      Caches = class extends BaseModule {
        constructor(apiClient) {
          super();
          this.apiClient = apiClient;
          this.list = async (params = {}) => {
            return new Pager(PagedItem.PAGED_ITEM_CACHED_CONTENTS, (x) => this.listInternal(x), await this.listInternal(params), params);
          };
        }
        /**
         * Creates a cached contents resource.
         *
         * @remarks
         * Context caching is only supported for specific models. See [Gemini
         * Developer API reference](https://ai.google.dev/gemini-api/docs/caching?lang=node/context-cac)
         * and [Vertex AI reference](https://cloud.google.com/vertex-ai/generative-ai/docs/context-cache/context-cache-overview#supported_models)
         * for more information.
         *
         * @param params - The parameters for the create request.
         * @return The created cached content.
         *
         * @example
         * ```ts
         * const contents = ...; // Initialize the content to cache.
         * const response = await ai.caches.create({
         *   model: 'gemini-2.0-flash-001',
         *   config: {
         *    'contents': contents,
         *    'displayName': 'test cache',
         *    'systemInstruction': 'What is the sum of the two pdfs?',
         *    'ttl': '86400s',
         *  }
         * });
         * ```
         */
        async create(params) {
          var _a, _b, _c, _d;
          let response;
          let path = "";
          let queryParams = {};
          if (this.apiClient.isVertexAI()) {
            const body = createCachedContentParametersToVertex(this.apiClient, params);
            path = formatMap("cachedContents", body["_url"]);
            queryParams = body["_query"];
            delete body["_url"];
            delete body["_query"];
            response = this.apiClient.request({
              path,
              queryParams,
              body: JSON.stringify(body),
              httpMethod: "POST",
              httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,
              abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
            }).then((httpResponse) => {
              return httpResponse.json();
            });
            return response.then((resp) => {
              return resp;
            });
          } else {
            const body = createCachedContentParametersToMldev(this.apiClient, params);
            path = formatMap("cachedContents", body["_url"]);
            queryParams = body["_query"];
            delete body["_url"];
            delete body["_query"];
            response = this.apiClient.request({
              path,
              queryParams,
              body: JSON.stringify(body),
              httpMethod: "POST",
              httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,
              abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal
            }).then((httpResponse) => {
              return httpResponse.json();
            });
            return response.then((resp) => {
              return resp;
            });
          }
        }
        /**
         * Gets cached content configurations.
         *
         * @param params - The parameters for the get request.
         * @return The cached content.
         *
         * @example
         * ```ts
         * await ai.caches.get({name: '...'}); // The server-generated resource name.
         * ```
         */
        async get(params) {
          var _a, _b, _c, _d;
          let response;
          let path = "";
          let queryParams = {};
          if (this.apiClient.isVertexAI()) {
            const body = getCachedContentParametersToVertex(this.apiClient, params);
            path = formatMap("{name}", body["_url"]);
            queryParams = body["_query"];
            delete body["_url"];
            delete body["_query"];
            response = this.apiClient.request({
              path,
              queryParams,
              body: JSON.stringify(body),
              httpMethod: "GET",
              httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,
              abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
            }).then((httpResponse) => {
              return httpResponse.json();
            });
            return response.then((resp) => {
              return resp;
            });
          } else {
            const body = getCachedContentParametersToMldev(this.apiClient, params);
            path = formatMap("{name}", body["_url"]);
            queryParams = body["_query"];
            delete body["_url"];
            delete body["_query"];
            response = this.apiClient.request({
              path,
              queryParams,
              body: JSON.stringify(body),
              httpMethod: "GET",
              httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,
              abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal
            }).then((httpResponse) => {
              return httpResponse.json();
            });
            return response.then((resp) => {
              return resp;
            });
          }
        }
        /**
         * Deletes cached content.
         *
         * @param params - The parameters for the delete request.
         * @return The empty response returned by the API.
         *
         * @example
         * ```ts
         * await ai.caches.delete({name: '...'}); // The server-generated resource name.
         * ```
         */
        async delete(params) {
          var _a, _b, _c, _d;
          let response;
          let path = "";
          let queryParams = {};
          if (this.apiClient.isVertexAI()) {
            const body = deleteCachedContentParametersToVertex(this.apiClient, params);
            path = formatMap("{name}", body["_url"]);
            queryParams = body["_query"];
            delete body["_url"];
            delete body["_query"];
            response = this.apiClient.request({
              path,
              queryParams,
              body: JSON.stringify(body),
              httpMethod: "DELETE",
              httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,
              abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
            }).then((httpResponse) => {
              return httpResponse.json().then((jsonResponse) => {
                const response2 = jsonResponse;
                response2.sdkHttpResponse = {
                  headers: httpResponse.headers
                };
                return response2;
              });
            });
            return response.then((apiResponse) => {
              const resp = deleteCachedContentResponseFromVertex(apiResponse);
              const typedResp = new DeleteCachedContentResponse();
              Object.assign(typedResp, resp);
              return typedResp;
            });
          } else {
            const body = deleteCachedContentParametersToMldev(this.apiClient, params);
            path = formatMap("{name}", body["_url"]);
            queryParams = body["_query"];
            delete body["_url"];
            delete body["_query"];
            response = this.apiClient.request({
              path,
              queryParams,
              body: JSON.stringify(body),
              httpMethod: "DELETE",
              httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,
              abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal
            }).then((httpResponse) => {
              return httpResponse.json().then((jsonResponse) => {
                const response2 = jsonResponse;
                response2.sdkHttpResponse = {
                  headers: httpResponse.headers
                };
                return response2;
              });
            });
            return response.then((apiResponse) => {
              const resp = deleteCachedContentResponseFromMldev(apiResponse);
              const typedResp = new DeleteCachedContentResponse();
              Object.assign(typedResp, resp);
              return typedResp;
            });
          }
        }
        /**
         * Updates cached content configurations.
         *
         * @param params - The parameters for the update request.
         * @return The updated cached content.
         *
         * @example
         * ```ts
         * const response = await ai.caches.update({
         *   name: '...',  // The server-generated resource name.
         *   config: {'ttl': '7600s'}
         * });
         * ```
         */
        async update(params) {
          var _a, _b, _c, _d;
          let response;
          let path = "";
          let queryParams = {};
          if (this.apiClient.isVertexAI()) {
            const body = updateCachedContentParametersToVertex(this.apiClient, params);
            path = formatMap("{name}", body["_url"]);
            queryParams = body["_query"];
            delete body["_url"];
            delete body["_query"];
            response = this.apiClient.request({
              path,
              queryParams,
              body: JSON.stringify(body),
              httpMethod: "PATCH",
              httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,
              abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
            }).then((httpResponse) => {
              return httpResponse.json();
            });
            return response.then((resp) => {
              return resp;
            });
          } else {
            const body = updateCachedContentParametersToMldev(this.apiClient, params);
            path = formatMap("{name}", body["_url"]);
            queryParams = body["_query"];
            delete body["_url"];
            delete body["_query"];
            response = this.apiClient.request({
              path,
              queryParams,
              body: JSON.stringify(body),
              httpMethod: "PATCH",
              httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,
              abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal
            }).then((httpResponse) => {
              return httpResponse.json();
            });
            return response.then((resp) => {
              return resp;
            });
          }
        }
        async listInternal(params) {
          var _a, _b, _c, _d;
          let response;
          let path = "";
          let queryParams = {};
          if (this.apiClient.isVertexAI()) {
            const body = listCachedContentsParametersToVertex(params);
            path = formatMap("cachedContents", body["_url"]);
            queryParams = body["_query"];
            delete body["_url"];
            delete body["_query"];
            response = this.apiClient.request({
              path,
              queryParams,
              body: JSON.stringify(body),
              httpMethod: "GET",
              httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,
              abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
            }).then((httpResponse) => {
              return httpResponse.json().then((jsonResponse) => {
                const response2 = jsonResponse;
                response2.sdkHttpResponse = {
                  headers: httpResponse.headers
                };
                return response2;
              });
            });
            return response.then((apiResponse) => {
              const resp = listCachedContentsResponseFromVertex(apiResponse);
              const typedResp = new ListCachedContentsResponse();
              Object.assign(typedResp, resp);
              return typedResp;
            });
          } else {
            const body = listCachedContentsParametersToMldev(params);
            path = formatMap("cachedContents", body["_url"]);
            queryParams = body["_query"];
            delete body["_url"];
            delete body["_query"];
            response = this.apiClient.request({
              path,
              queryParams,
              body: JSON.stringify(body),
              httpMethod: "GET",
              httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,
              abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal
            }).then((httpResponse) => {
              return httpResponse.json().then((jsonResponse) => {
                const response2 = jsonResponse;
                response2.sdkHttpResponse = {
                  headers: httpResponse.headers
                };
                return response2;
              });
            });
            return response.then((apiResponse) => {
              const resp = listCachedContentsResponseFromMldev(apiResponse);
              const typedResp = new ListCachedContentsResponse();
              Object.assign(typedResp, resp);
              return typedResp;
            });
          }
        }
      };
      Chats = class {
        constructor(modelsModule, apiClient) {
          this.modelsModule = modelsModule;
          this.apiClient = apiClient;
        }
        /**
         * Creates a new chat session.
         *
         * @remarks
         * The config in the params will be used for all requests within the chat
         * session unless overridden by a per-request `config` in
         * @see {@link types.SendMessageParameters#config}.
         *
         * @param params - Parameters for creating a chat session.
         * @returns A new chat session.
         *
         * @example
         * ```ts
         * const chat = ai.chats.create({
         *   model: 'gemini-2.0-flash'
         *   config: {
         *     temperature: 0.5,
         *     maxOutputTokens: 1024,
         *   }
         * });
         * ```
         */
        create(params) {
          return new Chat(
            this.apiClient,
            this.modelsModule,
            params.model,
            params.config,
            // Deep copy the history to avoid mutating the history outside of the
            // chat session.
            structuredClone(params.history)
          );
        }
      };
      Chat = class {
        constructor(apiClient, modelsModule, model, config = {}, history = []) {
          this.apiClient = apiClient;
          this.modelsModule = modelsModule;
          this.model = model;
          this.config = config;
          this.history = history;
          this.sendPromise = Promise.resolve();
          validateHistory(history);
        }
        /**
         * Sends a message to the model and returns the response.
         *
         * @remarks
         * This method will wait for the previous message to be processed before
         * sending the next message.
         *
         * @see {@link Chat#sendMessageStream} for streaming method.
         * @param params - parameters for sending messages within a chat session.
         * @returns The model's response.
         *
         * @example
         * ```ts
         * const chat = ai.chats.create({model: 'gemini-2.0-flash'});
         * const response = await chat.sendMessage({
         *   message: 'Why is the sky blue?'
         * });
         * console.log(response.text);
         * ```
         */
        async sendMessage(params) {
          var _a;
          await this.sendPromise;
          const inputContent = tContent(params.message);
          const responsePromise = this.modelsModule.generateContent({
            model: this.model,
            contents: this.getHistory(true).concat(inputContent),
            config: (_a = params.config) !== null && _a !== void 0 ? _a : this.config
          });
          this.sendPromise = (async () => {
            var _a2, _b, _c;
            const response = await responsePromise;
            const outputContent = (_b = (_a2 = response.candidates) === null || _a2 === void 0 ? void 0 : _a2[0]) === null || _b === void 0 ? void 0 : _b.content;
            const fullAutomaticFunctionCallingHistory = response.automaticFunctionCallingHistory;
            const index = this.getHistory(true).length;
            let automaticFunctionCallingHistory = [];
            if (fullAutomaticFunctionCallingHistory != null) {
              automaticFunctionCallingHistory = (_c = fullAutomaticFunctionCallingHistory.slice(index)) !== null && _c !== void 0 ? _c : [];
            }
            const modelOutput = outputContent ? [outputContent] : [];
            this.recordHistory(inputContent, modelOutput, automaticFunctionCallingHistory);
            return;
          })();
          await this.sendPromise.catch(() => {
            this.sendPromise = Promise.resolve();
          });
          return responsePromise;
        }
        /**
         * Sends a message to the model and returns the response in chunks.
         *
         * @remarks
         * This method will wait for the previous message to be processed before
         * sending the next message.
         *
         * @see {@link Chat#sendMessage} for non-streaming method.
         * @param params - parameters for sending the message.
         * @return The model's response.
         *
         * @example
         * ```ts
         * const chat = ai.chats.create({model: 'gemini-2.0-flash'});
         * const response = await chat.sendMessageStream({
         *   message: 'Why is the sky blue?'
         * });
         * for await (const chunk of response) {
         *   console.log(chunk.text);
         * }
         * ```
         */
        async sendMessageStream(params) {
          var _a;
          await this.sendPromise;
          const inputContent = tContent(params.message);
          const streamResponse = this.modelsModule.generateContentStream({
            model: this.model,
            contents: this.getHistory(true).concat(inputContent),
            config: (_a = params.config) !== null && _a !== void 0 ? _a : this.config
          });
          this.sendPromise = streamResponse.then(() => void 0).catch(() => void 0);
          const response = await streamResponse;
          const result = this.processStreamResponse(response, inputContent);
          return result;
        }
        /**
         * Returns the chat history.
         *
         * @remarks
         * The history is a list of contents alternating between user and model.
         *
         * There are two types of history:
         * - The `curated history` contains only the valid turns between user and
         * model, which will be included in the subsequent requests sent to the model.
         * - The `comprehensive history` contains all turns, including invalid or
         *   empty model outputs, providing a complete record of the history.
         *
         * The history is updated after receiving the response from the model,
         * for streaming response, it means receiving the last chunk of the response.
         *
         * The `comprehensive history` is returned by default. To get the `curated
         * history`, set the `curated` parameter to `true`.
         *
         * @param curated - whether to return the curated history or the comprehensive
         *     history.
         * @return History contents alternating between user and model for the entire
         *     chat session.
         */
        getHistory(curated = false) {
          const history = curated ? extractCuratedHistory(this.history) : this.history;
          return structuredClone(history);
        }
        processStreamResponse(streamResponse, inputContent) {
          var _a, _b;
          return __asyncGenerator(this, arguments, function* processStreamResponse_1() {
            var _c, e_1, _d, _e;
            const outputContent = [];
            try {
              for (var _f = true, streamResponse_1 = __asyncValues(streamResponse), streamResponse_1_1; streamResponse_1_1 = yield __await(streamResponse_1.next()), _c = streamResponse_1_1.done, !_c; _f = true) {
                _e = streamResponse_1_1.value;
                _f = false;
                const chunk = _e;
                if (isValidResponse(chunk)) {
                  const content = (_b = (_a = chunk.candidates) === null || _a === void 0 ? void 0 : _a[0]) === null || _b === void 0 ? void 0 : _b.content;
                  if (content !== void 0) {
                    outputContent.push(content);
                  }
                }
                yield yield __await(chunk);
              }
            } catch (e_1_1) {
              e_1 = { error: e_1_1 };
            } finally {
              try {
                if (!_f && !_c && (_d = streamResponse_1.return))
                  yield __await(_d.call(streamResponse_1));
              } finally {
                if (e_1)
                  throw e_1.error;
              }
            }
            this.recordHistory(inputContent, outputContent);
          });
        }
        recordHistory(userInput, modelOutput, automaticFunctionCallingHistory) {
          let outputContents = [];
          if (modelOutput.length > 0 && modelOutput.every((content) => content.role !== void 0)) {
            outputContents = modelOutput;
          } else {
            outputContents.push({
              role: "model",
              parts: []
            });
          }
          if (automaticFunctionCallingHistory && automaticFunctionCallingHistory.length > 0) {
            this.history.push(...extractCuratedHistory(automaticFunctionCallingHistory));
          } else {
            this.history.push(userInput);
          }
          this.history.push(...outputContents);
        }
      };
      ApiError = class _ApiError extends Error {
        constructor(options) {
          super(options.message);
          this.name = "ApiError";
          this.status = options.status;
          Object.setPrototypeOf(this, _ApiError.prototype);
        }
      };
      Files = class extends BaseModule {
        constructor(apiClient) {
          super();
          this.apiClient = apiClient;
          this.list = async (params = {}) => {
            return new Pager(PagedItem.PAGED_ITEM_FILES, (x) => this.listInternal(x), await this.listInternal(params), params);
          };
        }
        /**
         * Uploads a file asynchronously to the Gemini API.
         * This method is not available in Vertex AI.
         * Supported upload sources:
         * - Node.js: File path (string) or Blob object.
         * - Browser: Blob object (e.g., File).
         *
         * @remarks
         * The `mimeType` can be specified in the `config` parameter. If omitted:
         *  - For file path (string) inputs, the `mimeType` will be inferred from the
         *     file extension.
         *  - For Blob object inputs, the `mimeType` will be set to the Blob's `type`
         *     property.
         * Somex eamples for file extension to mimeType mapping:
         * .txt -> text/plain
         * .json -> application/json
         * .jpg  -> image/jpeg
         * .png -> image/png
         * .mp3 -> audio/mpeg
         * .mp4 -> video/mp4
         *
         * This section can contain multiple paragraphs and code examples.
         *
         * @param params - Optional parameters specified in the
         *        `types.UploadFileParameters` interface.
         *         @see {@link types.UploadFileParameters#config} for the optional
         *         config in the parameters.
         * @return A promise that resolves to a `types.File` object.
         * @throws An error if called on a Vertex AI client.
         * @throws An error if the `mimeType` is not provided and can not be inferred,
         * the `mimeType` can be provided in the `params.config` parameter.
         * @throws An error occurs if a suitable upload location cannot be established.
         *
         * @example
         * The following code uploads a file to Gemini API.
         *
         * ```ts
         * const file = await ai.files.upload({file: 'file.txt', config: {
         *   mimeType: 'text/plain',
         * }});
         * console.log(file.name);
         * ```
         */
        async upload(params) {
          if (this.apiClient.isVertexAI()) {
            throw new Error("Vertex AI does not support uploading files. You can share files through a GCS bucket.");
          }
          return this.apiClient.uploadFile(params.file, params.config).then((resp) => {
            return resp;
          });
        }
        /**
         * Downloads a remotely stored file asynchronously to a location specified in
         * the `params` object. This method only works on Node environment, to
         * download files in the browser, use a browser compliant method like an <a>
         * tag.
         *
         * @param params - The parameters for the download request.
         *
         * @example
         * The following code downloads an example file named "files/mehozpxf877d" as
         * "file.txt".
         *
         * ```ts
         * await ai.files.download({file: file.name, downloadPath: 'file.txt'});
         * ```
         */
        async download(params) {
          await this.apiClient.downloadFile(params);
        }
        async listInternal(params) {
          var _a, _b;
          let response;
          let path = "";
          let queryParams = {};
          if (this.apiClient.isVertexAI()) {
            throw new Error("This method is only supported by the Gemini Developer API.");
          } else {
            const body = listFilesParametersToMldev(params);
            path = formatMap("files", body["_url"]);
            queryParams = body["_query"];
            delete body["_url"];
            delete body["_query"];
            response = this.apiClient.request({
              path,
              queryParams,
              body: JSON.stringify(body),
              httpMethod: "GET",
              httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,
              abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
            }).then((httpResponse) => {
              return httpResponse.json().then((jsonResponse) => {
                const response2 = jsonResponse;
                response2.sdkHttpResponse = {
                  headers: httpResponse.headers
                };
                return response2;
              });
            });
            return response.then((apiResponse) => {
              const resp = listFilesResponseFromMldev(apiResponse);
              const typedResp = new ListFilesResponse();
              Object.assign(typedResp, resp);
              return typedResp;
            });
          }
        }
        async createInternal(params) {
          var _a, _b;
          let response;
          let path = "";
          let queryParams = {};
          if (this.apiClient.isVertexAI()) {
            throw new Error("This method is only supported by the Gemini Developer API.");
          } else {
            const body = createFileParametersToMldev(params);
            path = formatMap("upload/v1beta/files", body["_url"]);
            queryParams = body["_query"];
            delete body["_url"];
            delete body["_query"];
            response = this.apiClient.request({
              path,
              queryParams,
              body: JSON.stringify(body),
              httpMethod: "POST",
              httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,
              abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
            }).then((httpResponse) => {
              return httpResponse.json();
            });
            return response.then((apiResponse) => {
              const resp = createFileResponseFromMldev(apiResponse);
              const typedResp = new CreateFileResponse();
              Object.assign(typedResp, resp);
              return typedResp;
            });
          }
        }
        /**
         * Retrieves the file information from the service.
         *
         * @param params - The parameters for the get request
         * @return The Promise that resolves to the types.File object requested.
         *
         * @example
         * ```ts
         * const config: GetFileParameters = {
         *   name: fileName,
         * };
         * file = await ai.files.get(config);
         * console.log(file.name);
         * ```
         */
        async get(params) {
          var _a, _b;
          let response;
          let path = "";
          let queryParams = {};
          if (this.apiClient.isVertexAI()) {
            throw new Error("This method is only supported by the Gemini Developer API.");
          } else {
            const body = getFileParametersToMldev(params);
            path = formatMap("files/{file}", body["_url"]);
            queryParams = body["_query"];
            delete body["_url"];
            delete body["_query"];
            response = this.apiClient.request({
              path,
              queryParams,
              body: JSON.stringify(body),
              httpMethod: "GET",
              httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,
              abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
            }).then((httpResponse) => {
              return httpResponse.json();
            });
            return response.then((resp) => {
              return resp;
            });
          }
        }
        /**
         * Deletes a remotely stored file.
         *
         * @param params - The parameters for the delete request.
         * @return The DeleteFileResponse, the response for the delete method.
         *
         * @example
         * The following code deletes an example file named "files/mehozpxf877d".
         *
         * ```ts
         * await ai.files.delete({name: file.name});
         * ```
         */
        async delete(params) {
          var _a, _b;
          let response;
          let path = "";
          let queryParams = {};
          if (this.apiClient.isVertexAI()) {
            throw new Error("This method is only supported by the Gemini Developer API.");
          } else {
            const body = deleteFileParametersToMldev(params);
            path = formatMap("files/{file}", body["_url"]);
            queryParams = body["_query"];
            delete body["_url"];
            delete body["_query"];
            response = this.apiClient.request({
              path,
              queryParams,
              body: JSON.stringify(body),
              httpMethod: "DELETE",
              httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,
              abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
            }).then((httpResponse) => {
              return httpResponse.json().then((jsonResponse) => {
                const response2 = jsonResponse;
                response2.sdkHttpResponse = {
                  headers: httpResponse.headers
                };
                return response2;
              });
            });
            return response.then((apiResponse) => {
              const resp = deleteFileResponseFromMldev(apiResponse);
              const typedResp = new DeleteFileResponse();
              Object.assign(typedResp, resp);
              return typedResp;
            });
          }
        }
      };
      CONTENT_TYPE_HEADER = "Content-Type";
      SERVER_TIMEOUT_HEADER = "X-Server-Timeout";
      USER_AGENT_HEADER = "User-Agent";
      GOOGLE_API_CLIENT_HEADER = "x-goog-api-client";
      SDK_VERSION = "1.30.0";
      LIBRARY_LABEL = `google-genai-sdk/${SDK_VERSION}`;
      VERTEX_AI_API_DEFAULT_VERSION = "v1beta1";
      GOOGLE_AI_API_DEFAULT_VERSION = "v1beta";
      responseLineRE = /^\s*data: (.*)(?:\n\n|\r\r|\r\n\r\n)/;
      ApiClient = class {
        constructor(opts) {
          var _a, _b;
          this.clientOptions = Object.assign(Object.assign({}, opts), { project: opts.project, location: opts.location, apiKey: opts.apiKey, vertexai: opts.vertexai });
          const initHttpOptions = {};
          if (this.clientOptions.vertexai) {
            initHttpOptions.apiVersion = (_a = this.clientOptions.apiVersion) !== null && _a !== void 0 ? _a : VERTEX_AI_API_DEFAULT_VERSION;
            initHttpOptions.baseUrl = this.baseUrlFromProjectLocation();
            this.normalizeAuthParameters();
          } else {
            initHttpOptions.apiVersion = (_b = this.clientOptions.apiVersion) !== null && _b !== void 0 ? _b : GOOGLE_AI_API_DEFAULT_VERSION;
            initHttpOptions.baseUrl = `https://generativelanguage.googleapis.com/`;
          }
          initHttpOptions.headers = this.getDefaultHeaders();
          this.clientOptions.httpOptions = initHttpOptions;
          if (opts.httpOptions) {
            this.clientOptions.httpOptions = this.patchHttpOptions(initHttpOptions, opts.httpOptions);
          }
        }
        /**
         * Determines the base URL for Vertex AI based on project and location.
         * Uses the global endpoint if location is 'global' or if project/location
         * are not specified (implying API key usage).
         * @private
         */
        baseUrlFromProjectLocation() {
          if (this.clientOptions.project && this.clientOptions.location && this.clientOptions.location !== "global") {
            return `https://${this.clientOptions.location}-aiplatform.googleapis.com/`;
          }
          return `https://aiplatform.googleapis.com/`;
        }
        /**
         * Normalizes authentication parameters for Vertex AI.
         * If project and location are provided, API key is cleared.
         * If project and location are not provided (implying API key usage),
         * project and location are cleared.
         * @private
         */
        normalizeAuthParameters() {
          if (this.clientOptions.project && this.clientOptions.location) {
            this.clientOptions.apiKey = void 0;
            return;
          }
          this.clientOptions.project = void 0;
          this.clientOptions.location = void 0;
        }
        isVertexAI() {
          var _a;
          return (_a = this.clientOptions.vertexai) !== null && _a !== void 0 ? _a : false;
        }
        getProject() {
          return this.clientOptions.project;
        }
        getLocation() {
          return this.clientOptions.location;
        }
        getApiVersion() {
          if (this.clientOptions.httpOptions && this.clientOptions.httpOptions.apiVersion !== void 0) {
            return this.clientOptions.httpOptions.apiVersion;
          }
          throw new Error("API version is not set.");
        }
        getBaseUrl() {
          if (this.clientOptions.httpOptions && this.clientOptions.httpOptions.baseUrl !== void 0) {
            return this.clientOptions.httpOptions.baseUrl;
          }
          throw new Error("Base URL is not set.");
        }
        getRequestUrl() {
          return this.getRequestUrlInternal(this.clientOptions.httpOptions);
        }
        getHeaders() {
          if (this.clientOptions.httpOptions && this.clientOptions.httpOptions.headers !== void 0) {
            return this.clientOptions.httpOptions.headers;
          } else {
            throw new Error("Headers are not set.");
          }
        }
        getRequestUrlInternal(httpOptions) {
          if (!httpOptions || httpOptions.baseUrl === void 0 || httpOptions.apiVersion === void 0) {
            throw new Error("HTTP options are not correctly set.");
          }
          const baseUrl = httpOptions.baseUrl.endsWith("/") ? httpOptions.baseUrl.slice(0, -1) : httpOptions.baseUrl;
          const urlElement = [baseUrl];
          if (httpOptions.apiVersion && httpOptions.apiVersion !== "") {
            urlElement.push(httpOptions.apiVersion);
          }
          return urlElement.join("/");
        }
        getBaseResourcePath() {
          return `projects/${this.clientOptions.project}/locations/${this.clientOptions.location}`;
        }
        getApiKey() {
          return this.clientOptions.apiKey;
        }
        getWebsocketBaseUrl() {
          const baseUrl = this.getBaseUrl();
          const urlParts = new URL(baseUrl);
          urlParts.protocol = urlParts.protocol == "http:" ? "ws" : "wss";
          return urlParts.toString();
        }
        setBaseUrl(url) {
          if (this.clientOptions.httpOptions) {
            this.clientOptions.httpOptions.baseUrl = url;
          } else {
            throw new Error("HTTP options are not correctly set.");
          }
        }
        constructUrl(path, httpOptions, prependProjectLocation) {
          const urlElement = [this.getRequestUrlInternal(httpOptions)];
          if (prependProjectLocation) {
            urlElement.push(this.getBaseResourcePath());
          }
          if (path !== "") {
            urlElement.push(path);
          }
          const url = new URL(`${urlElement.join("/")}`);
          return url;
        }
        shouldPrependVertexProjectPath(request) {
          if (this.clientOptions.apiKey) {
            return false;
          }
          if (!this.clientOptions.vertexai) {
            return false;
          }
          if (request.path.startsWith("projects/")) {
            return false;
          }
          if (request.httpMethod === "GET" && request.path.startsWith("publishers/google/models")) {
            return false;
          }
          return true;
        }
        async request(request) {
          let patchedHttpOptions = this.clientOptions.httpOptions;
          if (request.httpOptions) {
            patchedHttpOptions = this.patchHttpOptions(this.clientOptions.httpOptions, request.httpOptions);
          }
          const prependProjectLocation = this.shouldPrependVertexProjectPath(request);
          const url = this.constructUrl(request.path, patchedHttpOptions, prependProjectLocation);
          if (request.queryParams) {
            for (const [key, value] of Object.entries(request.queryParams)) {
              url.searchParams.append(key, String(value));
            }
          }
          let requestInit = {};
          if (request.httpMethod === "GET") {
            if (request.body && request.body !== "{}") {
              throw new Error("Request body should be empty for GET request, but got non empty request body");
            }
          } else {
            requestInit.body = request.body;
          }
          requestInit = await this.includeExtraHttpOptionsToRequestInit(requestInit, patchedHttpOptions, url.toString(), request.abortSignal);
          return this.unaryApiCall(url, requestInit, request.httpMethod);
        }
        patchHttpOptions(baseHttpOptions, requestHttpOptions) {
          const patchedHttpOptions = JSON.parse(JSON.stringify(baseHttpOptions));
          for (const [key, value] of Object.entries(requestHttpOptions)) {
            if (typeof value === "object") {
              patchedHttpOptions[key] = Object.assign(Object.assign({}, patchedHttpOptions[key]), value);
            } else if (value !== void 0) {
              patchedHttpOptions[key] = value;
            }
          }
          return patchedHttpOptions;
        }
        async requestStream(request) {
          let patchedHttpOptions = this.clientOptions.httpOptions;
          if (request.httpOptions) {
            patchedHttpOptions = this.patchHttpOptions(this.clientOptions.httpOptions, request.httpOptions);
          }
          const prependProjectLocation = this.shouldPrependVertexProjectPath(request);
          const url = this.constructUrl(request.path, patchedHttpOptions, prependProjectLocation);
          if (!url.searchParams.has("alt") || url.searchParams.get("alt") !== "sse") {
            url.searchParams.set("alt", "sse");
          }
          let requestInit = {};
          requestInit.body = request.body;
          requestInit = await this.includeExtraHttpOptionsToRequestInit(requestInit, patchedHttpOptions, url.toString(), request.abortSignal);
          return this.streamApiCall(url, requestInit, request.httpMethod);
        }
        async includeExtraHttpOptionsToRequestInit(requestInit, httpOptions, url, abortSignal) {
          if (httpOptions && httpOptions.timeout || abortSignal) {
            const abortController = new AbortController();
            const signal = abortController.signal;
            if (httpOptions.timeout && (httpOptions === null || httpOptions === void 0 ? void 0 : httpOptions.timeout) > 0) {
              const timeoutHandle = setTimeout(() => abortController.abort(), httpOptions.timeout);
              if (timeoutHandle && typeof timeoutHandle.unref === "function") {
                timeoutHandle.unref();
              }
            }
            if (abortSignal) {
              abortSignal.addEventListener("abort", () => {
                abortController.abort();
              });
            }
            requestInit.signal = signal;
          }
          if (httpOptions && httpOptions.extraBody !== null) {
            includeExtraBodyToRequestInit(requestInit, httpOptions.extraBody);
          }
          requestInit.headers = await this.getHeadersInternal(httpOptions, url);
          return requestInit;
        }
        async unaryApiCall(url, requestInit, httpMethod) {
          return this.apiCall(url.toString(), Object.assign(Object.assign({}, requestInit), { method: httpMethod })).then(async (response) => {
            await throwErrorIfNotOK(response);
            return new HttpResponse(response);
          }).catch((e) => {
            if (e instanceof Error) {
              throw e;
            } else {
              throw new Error(JSON.stringify(e));
            }
          });
        }
        async streamApiCall(url, requestInit, httpMethod) {
          return this.apiCall(url.toString(), Object.assign(Object.assign({}, requestInit), { method: httpMethod })).then(async (response) => {
            await throwErrorIfNotOK(response);
            return this.processStreamResponse(response);
          }).catch((e) => {
            if (e instanceof Error) {
              throw e;
            } else {
              throw new Error(JSON.stringify(e));
            }
          });
        }
        processStreamResponse(response) {
          var _a;
          return __asyncGenerator(this, arguments, function* processStreamResponse_1() {
            const reader = (_a = response === null || response === void 0 ? void 0 : response.body) === null || _a === void 0 ? void 0 : _a.getReader();
            const decoder = new TextDecoder("utf-8");
            if (!reader) {
              throw new Error("Response body is empty");
            }
            try {
              let buffer = "";
              while (true) {
                const { done, value } = yield __await(reader.read());
                if (done) {
                  if (buffer.trim().length > 0) {
                    throw new Error("Incomplete JSON segment at the end");
                  }
                  break;
                }
                const chunkString = decoder.decode(value, { stream: true });
                try {
                  const chunkJson = JSON.parse(chunkString);
                  if ("error" in chunkJson) {
                    const errorJson = JSON.parse(JSON.stringify(chunkJson["error"]));
                    const status = errorJson["status"];
                    const code = errorJson["code"];
                    const errorMessage = `got status: ${status}. ${JSON.stringify(chunkJson)}`;
                    if (code >= 400 && code < 600) {
                      const apiError = new ApiError({
                        message: errorMessage,
                        status: code
                      });
                      throw apiError;
                    }
                  }
                } catch (e) {
                  const error = e;
                  if (error.name === "ApiError") {
                    throw e;
                  }
                }
                buffer += chunkString;
                let match = buffer.match(responseLineRE);
                while (match) {
                  const processedChunkString = match[1];
                  try {
                    const partialResponse = new Response(processedChunkString, {
                      headers: response === null || response === void 0 ? void 0 : response.headers,
                      status: response === null || response === void 0 ? void 0 : response.status,
                      statusText: response === null || response === void 0 ? void 0 : response.statusText
                    });
                    yield yield __await(new HttpResponse(partialResponse));
                    buffer = buffer.slice(match[0].length);
                    match = buffer.match(responseLineRE);
                  } catch (e) {
                    throw new Error(`exception parsing stream chunk ${processedChunkString}. ${e}`);
                  }
                }
              }
            } finally {
              reader.releaseLock();
            }
          });
        }
        async apiCall(url, requestInit) {
          return fetch(url, requestInit).catch((e) => {
            throw new Error(`exception ${e} sending request`);
          });
        }
        getDefaultHeaders() {
          const headers = {};
          const versionHeaderValue = LIBRARY_LABEL + " " + this.clientOptions.userAgentExtra;
          headers[USER_AGENT_HEADER] = versionHeaderValue;
          headers[GOOGLE_API_CLIENT_HEADER] = versionHeaderValue;
          headers[CONTENT_TYPE_HEADER] = "application/json";
          return headers;
        }
        async getHeadersInternal(httpOptions, url) {
          const headers = new Headers();
          if (httpOptions && httpOptions.headers) {
            for (const [key, value] of Object.entries(httpOptions.headers)) {
              headers.append(key, value);
            }
            if (httpOptions.timeout && httpOptions.timeout > 0) {
              headers.append(SERVER_TIMEOUT_HEADER, String(Math.ceil(httpOptions.timeout / 1e3)));
            }
          }
          await this.clientOptions.auth.addAuthHeaders(headers, url);
          return headers;
        }
        getFileName(file) {
          var _a;
          let fileName = "";
          if (typeof file === "string") {
            fileName = file.replace(/[/\\]+$/, "");
            fileName = (_a = fileName.split(/[/\\]/).pop()) !== null && _a !== void 0 ? _a : "";
          }
          return fileName;
        }
        /**
         * Uploads a file asynchronously using Gemini API only, this is not supported
         * in Vertex AI.
         *
         * @param file The string path to the file to be uploaded or a Blob object.
         * @param config Optional parameters specified in the `UploadFileConfig`
         *     interface. @see {@link types.UploadFileConfig}
         * @return A promise that resolves to a `File` object.
         * @throws An error if called on a Vertex AI client.
         * @throws An error if the `mimeType` is not provided and can not be inferred,
         */
        async uploadFile(file, config) {
          var _a;
          const fileToUpload = {};
          if (config != null) {
            fileToUpload.mimeType = config.mimeType;
            fileToUpload.name = config.name;
            fileToUpload.displayName = config.displayName;
          }
          if (fileToUpload.name && !fileToUpload.name.startsWith("files/")) {
            fileToUpload.name = `files/${fileToUpload.name}`;
          }
          const uploader = this.clientOptions.uploader;
          const fileStat = await uploader.stat(file);
          fileToUpload.sizeBytes = String(fileStat.size);
          const mimeType = (_a = config === null || config === void 0 ? void 0 : config.mimeType) !== null && _a !== void 0 ? _a : fileStat.type;
          if (mimeType === void 0 || mimeType === "") {
            throw new Error("Can not determine mimeType. Please provide mimeType in the config.");
          }
          fileToUpload.mimeType = mimeType;
          const body = {
            file: fileToUpload
          };
          const fileName = this.getFileName(file);
          const path = formatMap("upload/v1beta/files", body["_url"]);
          const uploadUrl = await this.fetchUploadUrl(path, fileToUpload.sizeBytes, fileToUpload.mimeType, fileName, body, config === null || config === void 0 ? void 0 : config.httpOptions);
          return uploader.upload(file, uploadUrl, this);
        }
        /**
         * Uploads a file to a given file search store asynchronously using Gemini API only, this is not supported
         * in Vertex AI.
         *
         * @param fileSearchStoreName The name of the file search store to upload the file to.
         * @param file The string path to the file to be uploaded or a Blob object.
         * @param config Optional parameters specified in the `UploadFileConfig`
         *     interface. @see {@link UploadFileConfig}
         * @return A promise that resolves to a `File` object.
         * @throws An error if called on a Vertex AI client.
         * @throws An error if the `mimeType` is not provided and can not be inferred,
         */
        async uploadFileToFileSearchStore(fileSearchStoreName, file, config) {
          var _a;
          const uploader = this.clientOptions.uploader;
          const fileStat = await uploader.stat(file);
          const sizeBytes = String(fileStat.size);
          const mimeType = (_a = config === null || config === void 0 ? void 0 : config.mimeType) !== null && _a !== void 0 ? _a : fileStat.type;
          if (mimeType === void 0 || mimeType === "") {
            throw new Error("Can not determine mimeType. Please provide mimeType in the config.");
          }
          const path = `upload/v1beta/${fileSearchStoreName}:uploadToFileSearchStore`;
          const fileName = this.getFileName(file);
          const body = {};
          if (config === null || config === void 0 ? void 0 : config.customMetadata) {
            body["customMetadata"] = config.customMetadata;
          }
          if (config === null || config === void 0 ? void 0 : config.chunkingConfig) {
            body["chunkingConfig"] = config.chunkingConfig;
          }
          const uploadUrl = await this.fetchUploadUrl(path, sizeBytes, mimeType, fileName, body, config === null || config === void 0 ? void 0 : config.httpOptions);
          return uploader.uploadToFileSearchStore(file, uploadUrl, this);
        }
        /**
         * Downloads a file asynchronously to the specified path.
         *
         * @params params - The parameters for the download request, see {@link
         * types.DownloadFileParameters}
         */
        async downloadFile(params) {
          const downloader = this.clientOptions.downloader;
          await downloader.download(params, this);
        }
        async fetchUploadUrl(path, sizeBytes, mimeType, fileName, body, configHttpOptions) {
          var _a;
          let httpOptions = {};
          if (configHttpOptions) {
            httpOptions = configHttpOptions;
          } else {
            httpOptions = {
              apiVersion: "",
              headers: Object.assign({ "Content-Type": "application/json", "X-Goog-Upload-Protocol": "resumable", "X-Goog-Upload-Command": "start", "X-Goog-Upload-Header-Content-Length": `${sizeBytes}`, "X-Goog-Upload-Header-Content-Type": `${mimeType}` }, fileName ? { "X-Goog-Upload-File-Name": fileName } : {})
            };
          }
          const httpResponse = await this.request({
            path,
            body: JSON.stringify(body),
            httpMethod: "POST",
            httpOptions
          });
          if (!httpResponse || !(httpResponse === null || httpResponse === void 0 ? void 0 : httpResponse.headers)) {
            throw new Error("Server did not return an HttpResponse or the returned HttpResponse did not have headers.");
          }
          const uploadUrl = (_a = httpResponse === null || httpResponse === void 0 ? void 0 : httpResponse.headers) === null || _a === void 0 ? void 0 : _a["x-goog-upload-url"];
          if (uploadUrl === void 0) {
            throw new Error("Failed to get upload url. Server did not return the x-google-upload-url in the headers");
          }
          return uploadUrl;
        }
      };
      MCP_LABEL = "mcp_used/unknown";
      hasMcpToolUsageFromMcpToTool = false;
      McpCallableTool = class _McpCallableTool {
        constructor(mcpClients = [], config) {
          this.mcpTools = [];
          this.functionNameToMcpClient = {};
          this.mcpClients = mcpClients;
          this.config = config;
        }
        /**
         * Creates a McpCallableTool.
         */
        static create(mcpClients, config) {
          return new _McpCallableTool(mcpClients, config);
        }
        /**
         * Validates the function names are not duplicate and initialize the function
         * name to MCP client mapping.
         *
         * @throws {Error} if the MCP tools from the MCP clients have duplicate tool
         *     names.
         */
        async initialize() {
          var _a, e_1, _b, _c;
          if (this.mcpTools.length > 0) {
            return;
          }
          const functionMap = {};
          const mcpTools = [];
          for (const mcpClient of this.mcpClients) {
            try {
              for (var _d = true, _e = (e_1 = void 0, __asyncValues(listAllTools(mcpClient))), _f; _f = await _e.next(), _a = _f.done, !_a; _d = true) {
                _c = _f.value;
                _d = false;
                const mcpTool = _c;
                mcpTools.push(mcpTool);
                const mcpToolName = mcpTool.name;
                if (functionMap[mcpToolName]) {
                  throw new Error(`Duplicate function name ${mcpToolName} found in MCP tools. Please ensure function names are unique.`);
                }
                functionMap[mcpToolName] = mcpClient;
              }
            } catch (e_1_1) {
              e_1 = { error: e_1_1 };
            } finally {
              try {
                if (!_d && !_a && (_b = _e.return))
                  await _b.call(_e);
              } finally {
                if (e_1)
                  throw e_1.error;
              }
            }
          }
          this.mcpTools = mcpTools;
          this.functionNameToMcpClient = functionMap;
        }
        async tool() {
          await this.initialize();
          return mcpToolsToGeminiTool(this.mcpTools, this.config);
        }
        async callTool(functionCalls) {
          await this.initialize();
          const functionCallResponseParts = [];
          for (const functionCall of functionCalls) {
            if (functionCall.name in this.functionNameToMcpClient) {
              const mcpClient = this.functionNameToMcpClient[functionCall.name];
              let requestOptions = void 0;
              if (this.config.timeout) {
                requestOptions = {
                  timeout: this.config.timeout
                };
              }
              const callToolResponse = await mcpClient.callTool(
                {
                  name: functionCall.name,
                  arguments: functionCall.args
                },
                // Set the result schema to undefined to allow MCP to rely on the
                // default schema.
                void 0,
                requestOptions
              );
              functionCallResponseParts.push({
                functionResponse: {
                  name: functionCall.name,
                  response: callToolResponse.isError ? { error: callToolResponse } : callToolResponse
                }
              });
            }
          }
          return functionCallResponseParts;
        }
      };
      LiveMusic = class {
        constructor(apiClient, auth, webSocketFactory) {
          this.apiClient = apiClient;
          this.auth = auth;
          this.webSocketFactory = webSocketFactory;
        }
        /**
             Establishes a connection to the specified model and returns a
             LiveMusicSession object representing that connection.
        
             @experimental
        
             @remarks
        
             @param params - The parameters for establishing a connection to the model.
             @return A live session.
        
             @example
             ```ts
             let model = 'models/lyria-realtime-exp';
             const session = await ai.live.music.connect({
               model: model,
               callbacks: {
                 onmessage: (e: MessageEvent) => {
                   console.log('Received message from the server: %s\n', debug(e.data));
                 },
                 onerror: (e: ErrorEvent) => {
                   console.log('Error occurred: %s\n', debug(e.error));
                 },
                 onclose: (e: CloseEvent) => {
                   console.log('Connection closed.');
                 },
               },
             });
             ```
            */
        async connect(params) {
          var _a, _b;
          if (this.apiClient.isVertexAI()) {
            throw new Error("Live music is not supported for Vertex AI.");
          }
          console.warn("Live music generation is experimental and may change in future versions.");
          const websocketBaseUrl = this.apiClient.getWebsocketBaseUrl();
          const apiVersion = this.apiClient.getApiVersion();
          const headers = mapToHeaders$1(this.apiClient.getDefaultHeaders());
          const apiKey = this.apiClient.getApiKey();
          const url = `${websocketBaseUrl}/ws/google.ai.generativelanguage.${apiVersion}.GenerativeService.BidiGenerateMusic?key=${apiKey}`;
          let onopenResolve = () => {
          };
          const onopenPromise = new Promise((resolve) => {
            onopenResolve = resolve;
          });
          const callbacks = params.callbacks;
          const onopenAwaitedCallback = function() {
            onopenResolve({});
          };
          const apiClient = this.apiClient;
          const websocketCallbacks = {
            onopen: onopenAwaitedCallback,
            onmessage: (event) => {
              void handleWebSocketMessage$1(apiClient, callbacks.onmessage, event);
            },
            onerror: (_a = callbacks === null || callbacks === void 0 ? void 0 : callbacks.onerror) !== null && _a !== void 0 ? _a : function(e) {
            },
            onclose: (_b = callbacks === null || callbacks === void 0 ? void 0 : callbacks.onclose) !== null && _b !== void 0 ? _b : function(e) {
            }
          };
          const conn = this.webSocketFactory.create(url, headersToMap$1(headers), websocketCallbacks);
          conn.connect();
          await onopenPromise;
          const model = tModel(this.apiClient, params.model);
          const setup = { model };
          const clientMessage = { setup };
          conn.send(JSON.stringify(clientMessage));
          return new LiveMusicSession(conn, this.apiClient);
        }
      };
      LiveMusicSession = class {
        constructor(conn, apiClient) {
          this.conn = conn;
          this.apiClient = apiClient;
        }
        /**
            Sets inputs to steer music generation. Updates the session's current
            weighted prompts.
        
            @param params - Contains one property, `weightedPrompts`.
        
              - `weightedPrompts` to send to the model; weights are normalized to
                sum to 1.0.
        
            @experimental
           */
        async setWeightedPrompts(params) {
          if (!params.weightedPrompts || Object.keys(params.weightedPrompts).length === 0) {
            throw new Error("Weighted prompts must be set and contain at least one entry.");
          }
          const clientContent = liveMusicSetWeightedPromptsParametersToMldev(params);
          this.conn.send(JSON.stringify({ clientContent }));
        }
        /**
            Sets a configuration to the model. Updates the session's current
            music generation config.
        
            @param params - Contains one property, `musicGenerationConfig`.
        
              - `musicGenerationConfig` to set in the model. Passing an empty or
            undefined config to the model will reset the config to defaults.
        
            @experimental
           */
        async setMusicGenerationConfig(params) {
          if (!params.musicGenerationConfig) {
            params.musicGenerationConfig = {};
          }
          const setConfigParameters = liveMusicSetConfigParametersToMldev(params);
          this.conn.send(JSON.stringify(setConfigParameters));
        }
        sendPlaybackControl(playbackControl) {
          const clientMessage = { playbackControl };
          this.conn.send(JSON.stringify(clientMessage));
        }
        /**
         * Start the music stream.
         *
         * @experimental
         */
        play() {
          this.sendPlaybackControl(LiveMusicPlaybackControl.PLAY);
        }
        /**
         * Temporarily halt the music stream. Use `play` to resume from the current
         * position.
         *
         * @experimental
         */
        pause() {
          this.sendPlaybackControl(LiveMusicPlaybackControl.PAUSE);
        }
        /**
         * Stop the music stream and reset the state. Retains the current prompts
         * and config.
         *
         * @experimental
         */
        stop() {
          this.sendPlaybackControl(LiveMusicPlaybackControl.STOP);
        }
        /**
         * Resets the context of the music generation without stopping it.
         * Retains the current prompts and config.
         *
         * @experimental
         */
        resetContext() {
          this.sendPlaybackControl(LiveMusicPlaybackControl.RESET_CONTEXT);
        }
        /**
             Terminates the WebSocket connection.
        
             @experimental
           */
        close() {
          this.conn.close();
        }
      };
      FUNCTION_RESPONSE_REQUIRES_ID = "FunctionResponse request must have an `id` field from the response of a ToolCall.FunctionalCalls in Google AI.";
      Live = class {
        constructor(apiClient, auth, webSocketFactory) {
          this.apiClient = apiClient;
          this.auth = auth;
          this.webSocketFactory = webSocketFactory;
          this.music = new LiveMusic(this.apiClient, this.auth, this.webSocketFactory);
        }
        /**
             Establishes a connection to the specified model with the given
             configuration and returns a Session object representing that connection.
        
             @experimental Built-in MCP support is an experimental feature, may change in
             future versions.
        
             @remarks
        
             @param params - The parameters for establishing a connection to the model.
             @return A live session.
        
             @example
             ```ts
             let model: string;
             if (GOOGLE_GENAI_USE_VERTEXAI) {
               model = 'gemini-2.0-flash-live-preview-04-09';
             } else {
               model = 'gemini-live-2.5-flash-preview';
             }
             const session = await ai.live.connect({
               model: model,
               config: {
                 responseModalities: [Modality.AUDIO],
               },
               callbacks: {
                 onopen: () => {
                   console.log('Connected to the socket.');
                 },
                 onmessage: (e: MessageEvent) => {
                   console.log('Received message from the server: %s\n', debug(e.data));
                 },
                 onerror: (e: ErrorEvent) => {
                   console.log('Error occurred: %s\n', debug(e.error));
                 },
                 onclose: (e: CloseEvent) => {
                   console.log('Connection closed.');
                 },
               },
             });
             ```
            */
        async connect(params) {
          var _a, _b, _c, _d, _e, _f;
          if (params.config && params.config.httpOptions) {
            throw new Error("The Live module does not support httpOptions at request-level in LiveConnectConfig yet. Please use the client-level httpOptions configuration instead.");
          }
          const websocketBaseUrl = this.apiClient.getWebsocketBaseUrl();
          const apiVersion = this.apiClient.getApiVersion();
          let url;
          const clientHeaders = this.apiClient.getHeaders();
          if (params.config && params.config.tools && hasMcpToolUsage(params.config.tools)) {
            setMcpUsageHeader(clientHeaders);
          }
          const headers = mapToHeaders(clientHeaders);
          if (this.apiClient.isVertexAI()) {
            url = `${websocketBaseUrl}/ws/google.cloud.aiplatform.${apiVersion}.LlmBidiService/BidiGenerateContent`;
            await this.auth.addAuthHeaders(headers, url);
          } else {
            const apiKey = this.apiClient.getApiKey();
            let method = "BidiGenerateContent";
            let keyName = "key";
            if (apiKey === null || apiKey === void 0 ? void 0 : apiKey.startsWith("auth_tokens/")) {
              console.warn("Warning: Ephemeral token support is experimental and may change in future versions.");
              if (apiVersion !== "v1alpha") {
                console.warn("Warning: The SDK's ephemeral token support is in v1alpha only. Please use const ai = new GoogleGenAI({apiKey: token.name, httpOptions: { apiVersion: 'v1alpha' }}); before session connection.");
              }
              method = "BidiGenerateContentConstrained";
              keyName = "access_token";
            }
            url = `${websocketBaseUrl}/ws/google.ai.generativelanguage.${apiVersion}.GenerativeService.${method}?${keyName}=${apiKey}`;
          }
          let onopenResolve = () => {
          };
          const onopenPromise = new Promise((resolve) => {
            onopenResolve = resolve;
          });
          const callbacks = params.callbacks;
          const onopenAwaitedCallback = function() {
            var _a2;
            (_a2 = callbacks === null || callbacks === void 0 ? void 0 : callbacks.onopen) === null || _a2 === void 0 ? void 0 : _a2.call(callbacks);
            onopenResolve({});
          };
          const apiClient = this.apiClient;
          const websocketCallbacks = {
            onopen: onopenAwaitedCallback,
            onmessage: (event) => {
              void handleWebSocketMessage(apiClient, callbacks.onmessage, event);
            },
            onerror: (_a = callbacks === null || callbacks === void 0 ? void 0 : callbacks.onerror) !== null && _a !== void 0 ? _a : function(e) {
            },
            onclose: (_b = callbacks === null || callbacks === void 0 ? void 0 : callbacks.onclose) !== null && _b !== void 0 ? _b : function(e) {
            }
          };
          const conn = this.webSocketFactory.create(url, headersToMap(headers), websocketCallbacks);
          conn.connect();
          await onopenPromise;
          let transformedModel = tModel(this.apiClient, params.model);
          if (this.apiClient.isVertexAI() && transformedModel.startsWith("publishers/")) {
            const project = this.apiClient.getProject();
            const location = this.apiClient.getLocation();
            transformedModel = `projects/${project}/locations/${location}/` + transformedModel;
          }
          let clientMessage = {};
          if (this.apiClient.isVertexAI() && ((_c = params.config) === null || _c === void 0 ? void 0 : _c.responseModalities) === void 0) {
            if (params.config === void 0) {
              params.config = { responseModalities: [Modality.AUDIO] };
            } else {
              params.config.responseModalities = [Modality.AUDIO];
            }
          }
          if ((_d = params.config) === null || _d === void 0 ? void 0 : _d.generationConfig) {
            console.warn("Setting `LiveConnectConfig.generation_config` is deprecated, please set the fields on `LiveConnectConfig` directly. This will become an error in a future version (not before Q3 2025).");
          }
          const inputTools = (_f = (_e = params.config) === null || _e === void 0 ? void 0 : _e.tools) !== null && _f !== void 0 ? _f : [];
          const convertedTools = [];
          for (const tool of inputTools) {
            if (this.isCallableTool(tool)) {
              const callableTool = tool;
              convertedTools.push(await callableTool.tool());
            } else {
              convertedTools.push(tool);
            }
          }
          if (convertedTools.length > 0) {
            params.config.tools = convertedTools;
          }
          const liveConnectParameters = {
            model: transformedModel,
            config: params.config,
            callbacks: params.callbacks
          };
          if (this.apiClient.isVertexAI()) {
            clientMessage = liveConnectParametersToVertex(this.apiClient, liveConnectParameters);
          } else {
            clientMessage = liveConnectParametersToMldev(this.apiClient, liveConnectParameters);
          }
          delete clientMessage["config"];
          conn.send(JSON.stringify(clientMessage));
          return new Session(conn, this.apiClient);
        }
        // TODO: b/416041229 - Abstract this method to a common place.
        isCallableTool(tool) {
          return "callTool" in tool && typeof tool.callTool === "function";
        }
      };
      defaultLiveSendClientContentParamerters = {
        turnComplete: true
      };
      Session = class {
        constructor(conn, apiClient) {
          this.conn = conn;
          this.apiClient = apiClient;
        }
        tLiveClientContent(apiClient, params) {
          if (params.turns !== null && params.turns !== void 0) {
            let contents = [];
            try {
              contents = tContents(params.turns);
              if (!apiClient.isVertexAI()) {
                contents = contents.map((item) => contentToMldev$1(item));
              }
            } catch (_a) {
              throw new Error(`Failed to parse client content "turns", type: '${typeof params.turns}'`);
            }
            return {
              clientContent: { turns: contents, turnComplete: params.turnComplete }
            };
          }
          return {
            clientContent: { turnComplete: params.turnComplete }
          };
        }
        tLiveClienttToolResponse(apiClient, params) {
          let functionResponses = [];
          if (params.functionResponses == null) {
            throw new Error("functionResponses is required.");
          }
          if (!Array.isArray(params.functionResponses)) {
            functionResponses = [params.functionResponses];
          } else {
            functionResponses = params.functionResponses;
          }
          if (functionResponses.length === 0) {
            throw new Error("functionResponses is required.");
          }
          for (const functionResponse of functionResponses) {
            if (typeof functionResponse !== "object" || functionResponse === null || !("name" in functionResponse) || !("response" in functionResponse)) {
              throw new Error(`Could not parse function response, type '${typeof functionResponse}'.`);
            }
            if (!apiClient.isVertexAI() && !("id" in functionResponse)) {
              throw new Error(FUNCTION_RESPONSE_REQUIRES_ID);
            }
          }
          const clientMessage = {
            toolResponse: { functionResponses }
          };
          return clientMessage;
        }
        /**
            Send a message over the established connection.
        
            @param params - Contains two **optional** properties, `turns` and
                `turnComplete`.
        
              - `turns` will be converted to a `Content[]`
              - `turnComplete: true` [default] indicates that you are done sending
                content and expect a response. If `turnComplete: false`, the server
                will wait for additional messages before starting generation.
        
            @experimental
        
            @remarks
            There are two ways to send messages to the live API:
            `sendClientContent` and `sendRealtimeInput`.
        
            `sendClientContent` messages are added to the model context **in order**.
            Having a conversation using `sendClientContent` messages is roughly
            equivalent to using the `Chat.sendMessageStream`, except that the state of
            the `chat` history is stored on the API server instead of locally.
        
            Because of `sendClientContent`'s order guarantee, the model cannot respons
            as quickly to `sendClientContent` messages as to `sendRealtimeInput`
            messages. This makes the biggest difference when sending objects that have
            significant preprocessing time (typically images).
        
            The `sendClientContent` message sends a `Content[]`
            which has more options than the `Blob` sent by `sendRealtimeInput`.
        
            So the main use-cases for `sendClientContent` over `sendRealtimeInput` are:
        
            - Sending anything that can't be represented as a `Blob` (text,
            `sendClientContent({turns="Hello?"}`)).
            - Managing turns when not using audio input and voice activity detection.
              (`sendClientContent({turnComplete:true})` or the short form
            `sendClientContent()`)
            - Prefilling a conversation context
              ```
              sendClientContent({
                  turns: [
                    Content({role:user, parts:...}),
                    Content({role:user, parts:...}),
                    ...
                  ]
              })
              ```
            @experimental
           */
        sendClientContent(params) {
          params = Object.assign(Object.assign({}, defaultLiveSendClientContentParamerters), params);
          const clientMessage = this.tLiveClientContent(this.apiClient, params);
          this.conn.send(JSON.stringify(clientMessage));
        }
        /**
            Send a realtime message over the established connection.
        
            @param params - Contains one property, `media`.
        
              - `media` will be converted to a `Blob`
        
            @experimental
        
            @remarks
            Use `sendRealtimeInput` for realtime audio chunks and video frames (images).
        
            With `sendRealtimeInput` the api will respond to audio automatically
            based on voice activity detection (VAD).
        
            `sendRealtimeInput` is optimized for responsivness at the expense of
            deterministic ordering guarantees. Audio and video tokens are to the
            context when they become available.
        
            Note: The Call signature expects a `Blob` object, but only a subset
            of audio and image mimetypes are allowed.
           */
        sendRealtimeInput(params) {
          let clientMessage = {};
          if (this.apiClient.isVertexAI()) {
            clientMessage = {
              "realtimeInput": liveSendRealtimeInputParametersToVertex(params)
            };
          } else {
            clientMessage = {
              "realtimeInput": liveSendRealtimeInputParametersToMldev(params)
            };
          }
          this.conn.send(JSON.stringify(clientMessage));
        }
        /**
            Send a function response message over the established connection.
        
            @param params - Contains property `functionResponses`.
        
              - `functionResponses` will be converted to a `functionResponses[]`
        
            @remarks
            Use `sendFunctionResponse` to reply to `LiveServerToolCall` from the server.
        
            Use {@link types.LiveConnectConfig#tools} to configure the callable functions.
        
            @experimental
           */
        sendToolResponse(params) {
          if (params.functionResponses == null) {
            throw new Error("Tool response parameters are required.");
          }
          const clientMessage = this.tLiveClienttToolResponse(this.apiClient, params);
          this.conn.send(JSON.stringify(clientMessage));
        }
        /**
             Terminates the WebSocket connection.
        
             @experimental
        
             @example
             ```ts
             let model: string;
             if (GOOGLE_GENAI_USE_VERTEXAI) {
               model = 'gemini-2.0-flash-live-preview-04-09';
             } else {
               model = 'gemini-live-2.5-flash-preview';
             }
             const session = await ai.live.connect({
               model: model,
               config: {
                 responseModalities: [Modality.AUDIO],
               }
             });
        
             session.close();
             ```
           */
        close() {
          this.conn.close();
        }
      };
      DEFAULT_MAX_REMOTE_CALLS = 10;
      Models = class extends BaseModule {
        constructor(apiClient) {
          super();
          this.apiClient = apiClient;
          this.generateContent = async (params) => {
            var _a, _b, _c, _d, _e;
            const transformedParams = await this.processParamsMaybeAddMcpUsage(params);
            this.maybeMoveToResponseJsonSchem(params);
            if (!hasCallableTools(params) || shouldDisableAfc(params.config)) {
              return await this.generateContentInternal(transformedParams);
            }
            const incompatibleToolIndexes = findAfcIncompatibleToolIndexes(params);
            if (incompatibleToolIndexes.length > 0) {
              const formattedIndexes = incompatibleToolIndexes.map((index) => `tools[${index}]`).join(", ");
              throw new Error(`Automatic function calling with CallableTools (or MCP objects) and basic FunctionDeclarations is not yet supported. Incompatible tools found at ${formattedIndexes}.`);
            }
            let response;
            let functionResponseContent;
            const automaticFunctionCallingHistory = tContents(transformedParams.contents);
            const maxRemoteCalls = (_c = (_b = (_a = transformedParams.config) === null || _a === void 0 ? void 0 : _a.automaticFunctionCalling) === null || _b === void 0 ? void 0 : _b.maximumRemoteCalls) !== null && _c !== void 0 ? _c : DEFAULT_MAX_REMOTE_CALLS;
            let remoteCalls = 0;
            while (remoteCalls < maxRemoteCalls) {
              response = await this.generateContentInternal(transformedParams);
              if (!response.functionCalls || response.functionCalls.length === 0) {
                break;
              }
              const responseContent = response.candidates[0].content;
              const functionResponseParts = [];
              for (const tool of (_e = (_d = params.config) === null || _d === void 0 ? void 0 : _d.tools) !== null && _e !== void 0 ? _e : []) {
                if (isCallableTool(tool)) {
                  const callableTool = tool;
                  const parts = await callableTool.callTool(response.functionCalls);
                  functionResponseParts.push(...parts);
                }
              }
              remoteCalls++;
              functionResponseContent = {
                role: "user",
                parts: functionResponseParts
              };
              transformedParams.contents = tContents(transformedParams.contents);
              transformedParams.contents.push(responseContent);
              transformedParams.contents.push(functionResponseContent);
              if (shouldAppendAfcHistory(transformedParams.config)) {
                automaticFunctionCallingHistory.push(responseContent);
                automaticFunctionCallingHistory.push(functionResponseContent);
              }
            }
            if (shouldAppendAfcHistory(transformedParams.config)) {
              response.automaticFunctionCallingHistory = automaticFunctionCallingHistory;
            }
            return response;
          };
          this.generateContentStream = async (params) => {
            var _a, _b, _c, _d, _e;
            this.maybeMoveToResponseJsonSchem(params);
            if (shouldDisableAfc(params.config)) {
              const transformedParams = await this.processParamsMaybeAddMcpUsage(params);
              return await this.generateContentStreamInternal(transformedParams);
            }
            const incompatibleToolIndexes = findAfcIncompatibleToolIndexes(params);
            if (incompatibleToolIndexes.length > 0) {
              const formattedIndexes = incompatibleToolIndexes.map((index) => `tools[${index}]`).join(", ");
              throw new Error(`Incompatible tools found at ${formattedIndexes}. Automatic function calling with CallableTools (or MCP objects) and basic FunctionDeclarations" is not yet supported.`);
            }
            const streamFunctionCall = (_c = (_b = (_a = params === null || params === void 0 ? void 0 : params.config) === null || _a === void 0 ? void 0 : _a.toolConfig) === null || _b === void 0 ? void 0 : _b.functionCallingConfig) === null || _c === void 0 ? void 0 : _c.streamFunctionCallArguments;
            const disableAfc = (_e = (_d = params === null || params === void 0 ? void 0 : params.config) === null || _d === void 0 ? void 0 : _d.automaticFunctionCalling) === null || _e === void 0 ? void 0 : _e.disable;
            if (streamFunctionCall && !disableAfc) {
              throw new Error("Running in streaming mode with 'streamFunctionCallArguments' enabled, this feature is not compatible with automatic function calling (AFC). Please set 'config.automaticFunctionCalling.disable' to true to disable AFC or leave 'config.toolConfig.functionCallingConfig.streamFunctionCallArguments' to be undefined or set to false to disable streaming function call arguments feature.");
            }
            return await this.processAfcStream(params);
          };
          this.generateImages = async (params) => {
            return await this.generateImagesInternal(params).then((apiResponse) => {
              var _a;
              let positivePromptSafetyAttributes;
              const generatedImages = [];
              if (apiResponse === null || apiResponse === void 0 ? void 0 : apiResponse.generatedImages) {
                for (const generatedImage of apiResponse.generatedImages) {
                  if (generatedImage && (generatedImage === null || generatedImage === void 0 ? void 0 : generatedImage.safetyAttributes) && ((_a = generatedImage === null || generatedImage === void 0 ? void 0 : generatedImage.safetyAttributes) === null || _a === void 0 ? void 0 : _a.contentType) === "Positive Prompt") {
                    positivePromptSafetyAttributes = generatedImage === null || generatedImage === void 0 ? void 0 : generatedImage.safetyAttributes;
                  } else {
                    generatedImages.push(generatedImage);
                  }
                }
              }
              let response;
              if (positivePromptSafetyAttributes) {
                response = {
                  generatedImages,
                  positivePromptSafetyAttributes,
                  sdkHttpResponse: apiResponse.sdkHttpResponse
                };
              } else {
                response = {
                  generatedImages,
                  sdkHttpResponse: apiResponse.sdkHttpResponse
                };
              }
              return response;
            });
          };
          this.list = async (params) => {
            var _a;
            const defaultConfig = {
              queryBase: true
            };
            const actualConfig = Object.assign(Object.assign({}, defaultConfig), params === null || params === void 0 ? void 0 : params.config);
            const actualParams = {
              config: actualConfig
            };
            if (this.apiClient.isVertexAI()) {
              if (!actualParams.config.queryBase) {
                if ((_a = actualParams.config) === null || _a === void 0 ? void 0 : _a.filter) {
                  throw new Error("Filtering tuned models list for Vertex AI is not currently supported");
                } else {
                  actualParams.config.filter = "labels.tune-type:*";
                }
              }
            }
            return new Pager(PagedItem.PAGED_ITEM_MODELS, (x) => this.listInternal(x), await this.listInternal(actualParams), actualParams);
          };
          this.editImage = async (params) => {
            const paramsInternal = {
              model: params.model,
              prompt: params.prompt,
              referenceImages: [],
              config: params.config
            };
            if (params.referenceImages) {
              if (params.referenceImages) {
                paramsInternal.referenceImages = params.referenceImages.map((img) => img.toReferenceImageAPI());
              }
            }
            return await this.editImageInternal(paramsInternal);
          };
          this.upscaleImage = async (params) => {
            let apiConfig = {
              numberOfImages: 1,
              mode: "upscale"
            };
            if (params.config) {
              apiConfig = Object.assign(Object.assign({}, apiConfig), params.config);
            }
            const apiParams = {
              model: params.model,
              image: params.image,
              upscaleFactor: params.upscaleFactor,
              config: apiConfig
            };
            return await this.upscaleImageInternal(apiParams);
          };
          this.generateVideos = async (params) => {
            var _a, _b, _c, _d, _e, _f;
            if ((params.prompt || params.image || params.video) && params.source) {
              throw new Error("Source and prompt/image/video are mutually exclusive. Please only use source.");
            }
            if (!this.apiClient.isVertexAI()) {
              if (((_a = params.video) === null || _a === void 0 ? void 0 : _a.uri) && ((_b = params.video) === null || _b === void 0 ? void 0 : _b.videoBytes)) {
                params.video = {
                  uri: params.video.uri,
                  mimeType: params.video.mimeType
                };
              } else if (((_d = (_c = params.source) === null || _c === void 0 ? void 0 : _c.video) === null || _d === void 0 ? void 0 : _d.uri) && ((_f = (_e = params.source) === null || _e === void 0 ? void 0 : _e.video) === null || _f === void 0 ? void 0 : _f.videoBytes)) {
                params.source.video = {
                  uri: params.source.video.uri,
                  mimeType: params.source.video.mimeType
                };
              }
            }
            return await this.generateVideosInternal(params);
          };
        }
        /**
         * This logic is needed for GenerateContentConfig only.
         * Previously we made GenerateContentConfig.responseSchema field to accept
         * unknown. Since v1.9.0, we switch to use backend JSON schema support.
         * To maintain backward compatibility, we move the data that was treated as
         * JSON schema from the responseSchema field to the responseJsonSchema field.
         */
        maybeMoveToResponseJsonSchem(params) {
          if (params.config && params.config.responseSchema) {
            if (!params.config.responseJsonSchema) {
              if (Object.keys(params.config.responseSchema).includes("$schema")) {
                params.config.responseJsonSchema = params.config.responseSchema;
                delete params.config.responseSchema;
              }
            }
          }
          return;
        }
        /**
         * Transforms the CallableTools in the parameters to be simply Tools, it
         * copies the params into a new object and replaces the tools, it does not
         * modify the original params. Also sets the MCP usage header if there are
         * MCP tools in the parameters.
         */
        async processParamsMaybeAddMcpUsage(params) {
          var _a, _b, _c;
          const tools = (_a = params.config) === null || _a === void 0 ? void 0 : _a.tools;
          if (!tools) {
            return params;
          }
          const transformedTools = await Promise.all(tools.map(async (tool) => {
            if (isCallableTool(tool)) {
              const callableTool = tool;
              return await callableTool.tool();
            }
            return tool;
          }));
          const newParams = {
            model: params.model,
            contents: params.contents,
            config: Object.assign(Object.assign({}, params.config), { tools: transformedTools })
          };
          newParams.config.tools = transformedTools;
          if (params.config && params.config.tools && hasMcpToolUsage(params.config.tools)) {
            const headers = (_c = (_b = params.config.httpOptions) === null || _b === void 0 ? void 0 : _b.headers) !== null && _c !== void 0 ? _c : {};
            let newHeaders = Object.assign({}, headers);
            if (Object.keys(newHeaders).length === 0) {
              newHeaders = this.apiClient.getDefaultHeaders();
            }
            setMcpUsageHeader(newHeaders);
            newParams.config.httpOptions = Object.assign(Object.assign({}, params.config.httpOptions), { headers: newHeaders });
          }
          return newParams;
        }
        async initAfcToolsMap(params) {
          var _a, _b, _c;
          const afcTools = /* @__PURE__ */ new Map();
          for (const tool of (_b = (_a = params.config) === null || _a === void 0 ? void 0 : _a.tools) !== null && _b !== void 0 ? _b : []) {
            if (isCallableTool(tool)) {
              const callableTool = tool;
              const toolDeclaration = await callableTool.tool();
              for (const declaration of (_c = toolDeclaration.functionDeclarations) !== null && _c !== void 0 ? _c : []) {
                if (!declaration.name) {
                  throw new Error("Function declaration name is required.");
                }
                if (afcTools.has(declaration.name)) {
                  throw new Error(`Duplicate tool declaration name: ${declaration.name}`);
                }
                afcTools.set(declaration.name, callableTool);
              }
            }
          }
          return afcTools;
        }
        async processAfcStream(params) {
          var _a, _b, _c;
          const maxRemoteCalls = (_c = (_b = (_a = params.config) === null || _a === void 0 ? void 0 : _a.automaticFunctionCalling) === null || _b === void 0 ? void 0 : _b.maximumRemoteCalls) !== null && _c !== void 0 ? _c : DEFAULT_MAX_REMOTE_CALLS;
          let wereFunctionsCalled = false;
          let remoteCallCount = 0;
          const afcToolsMap = await this.initAfcToolsMap(params);
          return function(models, afcTools, params2) {
            var _a2, _b2;
            return __asyncGenerator(this, arguments, function* () {
              var _c2, e_1, _d, _e;
              while (remoteCallCount < maxRemoteCalls) {
                if (wereFunctionsCalled) {
                  remoteCallCount++;
                  wereFunctionsCalled = false;
                }
                const transformedParams = yield __await(models.processParamsMaybeAddMcpUsage(params2));
                const response = yield __await(models.generateContentStreamInternal(transformedParams));
                const functionResponses = [];
                const responseContents = [];
                try {
                  for (var _f = true, response_1 = (e_1 = void 0, __asyncValues(response)), response_1_1; response_1_1 = yield __await(response_1.next()), _c2 = response_1_1.done, !_c2; _f = true) {
                    _e = response_1_1.value;
                    _f = false;
                    const chunk = _e;
                    yield yield __await(chunk);
                    if (chunk.candidates && ((_a2 = chunk.candidates[0]) === null || _a2 === void 0 ? void 0 : _a2.content)) {
                      responseContents.push(chunk.candidates[0].content);
                      for (const part of (_b2 = chunk.candidates[0].content.parts) !== null && _b2 !== void 0 ? _b2 : []) {
                        if (remoteCallCount < maxRemoteCalls && part.functionCall) {
                          if (!part.functionCall.name) {
                            throw new Error("Function call name was not returned by the model.");
                          }
                          if (!afcTools.has(part.functionCall.name)) {
                            throw new Error(`Automatic function calling was requested, but not all the tools the model used implement the CallableTool interface. Available tools: ${afcTools.keys()}, mising tool: ${part.functionCall.name}`);
                          } else {
                            const responseParts = yield __await(afcTools.get(part.functionCall.name).callTool([part.functionCall]));
                            functionResponses.push(...responseParts);
                          }
                        }
                      }
                    }
                  }
                } catch (e_1_1) {
                  e_1 = { error: e_1_1 };
                } finally {
                  try {
                    if (!_f && !_c2 && (_d = response_1.return))
                      yield __await(_d.call(response_1));
                  } finally {
                    if (e_1)
                      throw e_1.error;
                  }
                }
                if (functionResponses.length > 0) {
                  wereFunctionsCalled = true;
                  const typedResponseChunk = new GenerateContentResponse();
                  typedResponseChunk.candidates = [
                    {
                      content: {
                        role: "user",
                        parts: functionResponses
                      }
                    }
                  ];
                  yield yield __await(typedResponseChunk);
                  const newContents = [];
                  newContents.push(...responseContents);
                  newContents.push({
                    role: "user",
                    parts: functionResponses
                  });
                  const updatedContents = tContents(params2.contents).concat(newContents);
                  params2.contents = updatedContents;
                } else {
                  break;
                }
              }
            });
          }(this, afcToolsMap, params);
        }
        async generateContentInternal(params) {
          var _a, _b, _c, _d;
          let response;
          let path = "";
          let queryParams = {};
          if (this.apiClient.isVertexAI()) {
            const body = generateContentParametersToVertex(this.apiClient, params);
            path = formatMap("{model}:generateContent", body["_url"]);
            queryParams = body["_query"];
            delete body["_url"];
            delete body["_query"];
            response = this.apiClient.request({
              path,
              queryParams,
              body: JSON.stringify(body),
              httpMethod: "POST",
              httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,
              abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
            }).then((httpResponse) => {
              return httpResponse.json().then((jsonResponse) => {
                const response2 = jsonResponse;
                response2.sdkHttpResponse = {
                  headers: httpResponse.headers
                };
                return response2;
              });
            });
            return response.then((apiResponse) => {
              const resp = generateContentResponseFromVertex(apiResponse);
              const typedResp = new GenerateContentResponse();
              Object.assign(typedResp, resp);
              return typedResp;
            });
          } else {
            const body = generateContentParametersToMldev(this.apiClient, params);
            path = formatMap("{model}:generateContent", body["_url"]);
            queryParams = body["_query"];
            delete body["_url"];
            delete body["_query"];
            response = this.apiClient.request({
              path,
              queryParams,
              body: JSON.stringify(body),
              httpMethod: "POST",
              httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,
              abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal
            }).then((httpResponse) => {
              return httpResponse.json().then((jsonResponse) => {
                const response2 = jsonResponse;
                response2.sdkHttpResponse = {
                  headers: httpResponse.headers
                };
                return response2;
              });
            });
            return response.then((apiResponse) => {
              const resp = generateContentResponseFromMldev(apiResponse);
              const typedResp = new GenerateContentResponse();
              Object.assign(typedResp, resp);
              return typedResp;
            });
          }
        }
        async generateContentStreamInternal(params) {
          var _a, _b, _c, _d;
          let response;
          let path = "";
          let queryParams = {};
          if (this.apiClient.isVertexAI()) {
            const body = generateContentParametersToVertex(this.apiClient, params);
            path = formatMap("{model}:streamGenerateContent?alt=sse", body["_url"]);
            queryParams = body["_query"];
            delete body["_url"];
            delete body["_query"];
            const apiClient = this.apiClient;
            response = apiClient.requestStream({
              path,
              queryParams,
              body: JSON.stringify(body),
              httpMethod: "POST",
              httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,
              abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
            });
            return response.then(function(apiResponse) {
              return __asyncGenerator(this, arguments, function* () {
                var _a2, e_2, _b2, _c2;
                try {
                  for (var _d2 = true, apiResponse_1 = __asyncValues(apiResponse), apiResponse_1_1; apiResponse_1_1 = yield __await(apiResponse_1.next()), _a2 = apiResponse_1_1.done, !_a2; _d2 = true) {
                    _c2 = apiResponse_1_1.value;
                    _d2 = false;
                    const chunk = _c2;
                    const resp = generateContentResponseFromVertex(yield __await(chunk.json()));
                    resp["sdkHttpResponse"] = {
                      headers: chunk.headers
                    };
                    const typedResp = new GenerateContentResponse();
                    Object.assign(typedResp, resp);
                    yield yield __await(typedResp);
                  }
                } catch (e_2_1) {
                  e_2 = { error: e_2_1 };
                } finally {
                  try {
                    if (!_d2 && !_a2 && (_b2 = apiResponse_1.return))
                      yield __await(_b2.call(apiResponse_1));
                  } finally {
                    if (e_2)
                      throw e_2.error;
                  }
                }
              });
            });
          } else {
            const body = generateContentParametersToMldev(this.apiClient, params);
            path = formatMap("{model}:streamGenerateContent?alt=sse", body["_url"]);
            queryParams = body["_query"];
            delete body["_url"];
            delete body["_query"];
            const apiClient = this.apiClient;
            response = apiClient.requestStream({
              path,
              queryParams,
              body: JSON.stringify(body),
              httpMethod: "POST",
              httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,
              abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal
            });
            return response.then(function(apiResponse) {
              return __asyncGenerator(this, arguments, function* () {
                var _a2, e_3, _b2, _c2;
                try {
                  for (var _d2 = true, apiResponse_2 = __asyncValues(apiResponse), apiResponse_2_1; apiResponse_2_1 = yield __await(apiResponse_2.next()), _a2 = apiResponse_2_1.done, !_a2; _d2 = true) {
                    _c2 = apiResponse_2_1.value;
                    _d2 = false;
                    const chunk = _c2;
                    const resp = generateContentResponseFromMldev(yield __await(chunk.json()));
                    resp["sdkHttpResponse"] = {
                      headers: chunk.headers
                    };
                    const typedResp = new GenerateContentResponse();
                    Object.assign(typedResp, resp);
                    yield yield __await(typedResp);
                  }
                } catch (e_3_1) {
                  e_3 = { error: e_3_1 };
                } finally {
                  try {
                    if (!_d2 && !_a2 && (_b2 = apiResponse_2.return))
                      yield __await(_b2.call(apiResponse_2));
                  } finally {
                    if (e_3)
                      throw e_3.error;
                  }
                }
              });
            });
          }
        }
        /**
         * Calculates embeddings for the given contents. Only text is supported.
         *
         * @param params - The parameters for embedding contents.
         * @return The response from the API.
         *
         * @example
         * ```ts
         * const response = await ai.models.embedContent({
         *  model: 'text-embedding-004',
         *  contents: [
         *    'What is your name?',
         *    'What is your favorite color?',
         *  ],
         *  config: {
         *    outputDimensionality: 64,
         *  },
         * });
         * console.log(response);
         * ```
         */
        async embedContent(params) {
          var _a, _b, _c, _d;
          let response;
          let path = "";
          let queryParams = {};
          if (this.apiClient.isVertexAI()) {
            const body = embedContentParametersToVertex(this.apiClient, params);
            path = formatMap("{model}:predict", body["_url"]);
            queryParams = body["_query"];
            delete body["_url"];
            delete body["_query"];
            response = this.apiClient.request({
              path,
              queryParams,
              body: JSON.stringify(body),
              httpMethod: "POST",
              httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,
              abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
            }).then((httpResponse) => {
              return httpResponse.json().then((jsonResponse) => {
                const response2 = jsonResponse;
                response2.sdkHttpResponse = {
                  headers: httpResponse.headers
                };
                return response2;
              });
            });
            return response.then((apiResponse) => {
              const resp = embedContentResponseFromVertex(apiResponse);
              const typedResp = new EmbedContentResponse();
              Object.assign(typedResp, resp);
              return typedResp;
            });
          } else {
            const body = embedContentParametersToMldev(this.apiClient, params);
            path = formatMap("{model}:batchEmbedContents", body["_url"]);
            queryParams = body["_query"];
            delete body["_url"];
            delete body["_query"];
            response = this.apiClient.request({
              path,
              queryParams,
              body: JSON.stringify(body),
              httpMethod: "POST",
              httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,
              abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal
            }).then((httpResponse) => {
              return httpResponse.json().then((jsonResponse) => {
                const response2 = jsonResponse;
                response2.sdkHttpResponse = {
                  headers: httpResponse.headers
                };
                return response2;
              });
            });
            return response.then((apiResponse) => {
              const resp = embedContentResponseFromMldev(apiResponse);
              const typedResp = new EmbedContentResponse();
              Object.assign(typedResp, resp);
              return typedResp;
            });
          }
        }
        /**
         * Private method for generating images.
         */
        async generateImagesInternal(params) {
          var _a, _b, _c, _d;
          let response;
          let path = "";
          let queryParams = {};
          if (this.apiClient.isVertexAI()) {
            const body = generateImagesParametersToVertex(this.apiClient, params);
            path = formatMap("{model}:predict", body["_url"]);
            queryParams = body["_query"];
            delete body["_url"];
            delete body["_query"];
            response = this.apiClient.request({
              path,
              queryParams,
              body: JSON.stringify(body),
              httpMethod: "POST",
              httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,
              abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
            }).then((httpResponse) => {
              return httpResponse.json().then((jsonResponse) => {
                const response2 = jsonResponse;
                response2.sdkHttpResponse = {
                  headers: httpResponse.headers
                };
                return response2;
              });
            });
            return response.then((apiResponse) => {
              const resp = generateImagesResponseFromVertex(apiResponse);
              const typedResp = new GenerateImagesResponse();
              Object.assign(typedResp, resp);
              return typedResp;
            });
          } else {
            const body = generateImagesParametersToMldev(this.apiClient, params);
            path = formatMap("{model}:predict", body["_url"]);
            queryParams = body["_query"];
            delete body["_url"];
            delete body["_query"];
            response = this.apiClient.request({
              path,
              queryParams,
              body: JSON.stringify(body),
              httpMethod: "POST",
              httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,
              abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal
            }).then((httpResponse) => {
              return httpResponse.json().then((jsonResponse) => {
                const response2 = jsonResponse;
                response2.sdkHttpResponse = {
                  headers: httpResponse.headers
                };
                return response2;
              });
            });
            return response.then((apiResponse) => {
              const resp = generateImagesResponseFromMldev(apiResponse);
              const typedResp = new GenerateImagesResponse();
              Object.assign(typedResp, resp);
              return typedResp;
            });
          }
        }
        /**
         * Private method for editing an image.
         */
        async editImageInternal(params) {
          var _a, _b;
          let response;
          let path = "";
          let queryParams = {};
          if (this.apiClient.isVertexAI()) {
            const body = editImageParametersInternalToVertex(this.apiClient, params);
            path = formatMap("{model}:predict", body["_url"]);
            queryParams = body["_query"];
            delete body["_url"];
            delete body["_query"];
            response = this.apiClient.request({
              path,
              queryParams,
              body: JSON.stringify(body),
              httpMethod: "POST",
              httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,
              abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
            }).then((httpResponse) => {
              return httpResponse.json().then((jsonResponse) => {
                const response2 = jsonResponse;
                response2.sdkHttpResponse = {
                  headers: httpResponse.headers
                };
                return response2;
              });
            });
            return response.then((apiResponse) => {
              const resp = editImageResponseFromVertex(apiResponse);
              const typedResp = new EditImageResponse();
              Object.assign(typedResp, resp);
              return typedResp;
            });
          } else {
            throw new Error("This method is only supported by the Vertex AI.");
          }
        }
        /**
         * Private method for upscaling an image.
         */
        async upscaleImageInternal(params) {
          var _a, _b;
          let response;
          let path = "";
          let queryParams = {};
          if (this.apiClient.isVertexAI()) {
            const body = upscaleImageAPIParametersInternalToVertex(this.apiClient, params);
            path = formatMap("{model}:predict", body["_url"]);
            queryParams = body["_query"];
            delete body["_url"];
            delete body["_query"];
            response = this.apiClient.request({
              path,
              queryParams,
              body: JSON.stringify(body),
              httpMethod: "POST",
              httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,
              abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
            }).then((httpResponse) => {
              return httpResponse.json().then((jsonResponse) => {
                const response2 = jsonResponse;
                response2.sdkHttpResponse = {
                  headers: httpResponse.headers
                };
                return response2;
              });
            });
            return response.then((apiResponse) => {
              const resp = upscaleImageResponseFromVertex(apiResponse);
              const typedResp = new UpscaleImageResponse();
              Object.assign(typedResp, resp);
              return typedResp;
            });
          } else {
            throw new Error("This method is only supported by the Vertex AI.");
          }
        }
        /**
         * Recontextualizes an image.
         *
         * There are two types of recontextualization currently supported:
         * 1) Imagen Product Recontext - Generate images of products in new scenes
         *    and contexts.
         * 2) Virtual Try-On: Generate images of persons modeling fashion products.
         *
         * @param params - The parameters for recontextualizing an image.
         * @return The response from the API.
         *
         * @example
         * ```ts
         * const response1 = await ai.models.recontextImage({
         *  model: 'imagen-product-recontext-preview-06-30',
         *  source: {
         *    prompt: 'In a modern kitchen setting.',
         *    productImages: [productImage],
         *  },
         *  config: {
         *    numberOfImages: 1,
         *  },
         * });
         * console.log(response1?.generatedImages?.[0]?.image?.imageBytes);
         *
         * const response2 = await ai.models.recontextImage({
         *  model: 'virtual-try-on-preview-08-04',
         *  source: {
         *    personImage: personImage,
         *    productImages: [productImage],
         *  },
         *  config: {
         *    numberOfImages: 1,
         *  },
         * });
         * console.log(response2?.generatedImages?.[0]?.image?.imageBytes);
         * ```
         */
        async recontextImage(params) {
          var _a, _b;
          let response;
          let path = "";
          let queryParams = {};
          if (this.apiClient.isVertexAI()) {
            const body = recontextImageParametersToVertex(this.apiClient, params);
            path = formatMap("{model}:predict", body["_url"]);
            queryParams = body["_query"];
            delete body["_url"];
            delete body["_query"];
            response = this.apiClient.request({
              path,
              queryParams,
              body: JSON.stringify(body),
              httpMethod: "POST",
              httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,
              abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
            }).then((httpResponse) => {
              return httpResponse.json();
            });
            return response.then((apiResponse) => {
              const resp = recontextImageResponseFromVertex(apiResponse);
              const typedResp = new RecontextImageResponse();
              Object.assign(typedResp, resp);
              return typedResp;
            });
          } else {
            throw new Error("This method is only supported by the Vertex AI.");
          }
        }
        /**
         * Segments an image, creating a mask of a specified area.
         *
         * @param params - The parameters for segmenting an image.
         * @return The response from the API.
         *
         * @example
         * ```ts
         * const response = await ai.models.segmentImage({
         *  model: 'image-segmentation-001',
         *  source: {
         *    image: image,
         *  },
         *  config: {
         *    mode: 'foreground',
         *  },
         * });
         * console.log(response?.generatedMasks?.[0]?.mask?.imageBytes);
         * ```
         */
        async segmentImage(params) {
          var _a, _b;
          let response;
          let path = "";
          let queryParams = {};
          if (this.apiClient.isVertexAI()) {
            const body = segmentImageParametersToVertex(this.apiClient, params);
            path = formatMap("{model}:predict", body["_url"]);
            queryParams = body["_query"];
            delete body["_url"];
            delete body["_query"];
            response = this.apiClient.request({
              path,
              queryParams,
              body: JSON.stringify(body),
              httpMethod: "POST",
              httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,
              abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
            }).then((httpResponse) => {
              return httpResponse.json();
            });
            return response.then((apiResponse) => {
              const resp = segmentImageResponseFromVertex(apiResponse);
              const typedResp = new SegmentImageResponse();
              Object.assign(typedResp, resp);
              return typedResp;
            });
          } else {
            throw new Error("This method is only supported by the Vertex AI.");
          }
        }
        /**
         * Fetches information about a model by name.
         *
         * @example
         * ```ts
         * const modelInfo = await ai.models.get({model: 'gemini-2.0-flash'});
         * ```
         */
        async get(params) {
          var _a, _b, _c, _d;
          let response;
          let path = "";
          let queryParams = {};
          if (this.apiClient.isVertexAI()) {
            const body = getModelParametersToVertex(this.apiClient, params);
            path = formatMap("{name}", body["_url"]);
            queryParams = body["_query"];
            delete body["_url"];
            delete body["_query"];
            response = this.apiClient.request({
              path,
              queryParams,
              body: JSON.stringify(body),
              httpMethod: "GET",
              httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,
              abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
            }).then((httpResponse) => {
              return httpResponse.json();
            });
            return response.then((apiResponse) => {
              const resp = modelFromVertex(apiResponse);
              return resp;
            });
          } else {
            const body = getModelParametersToMldev(this.apiClient, params);
            path = formatMap("{name}", body["_url"]);
            queryParams = body["_query"];
            delete body["_url"];
            delete body["_query"];
            response = this.apiClient.request({
              path,
              queryParams,
              body: JSON.stringify(body),
              httpMethod: "GET",
              httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,
              abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal
            }).then((httpResponse) => {
              return httpResponse.json();
            });
            return response.then((apiResponse) => {
              const resp = modelFromMldev(apiResponse);
              return resp;
            });
          }
        }
        async listInternal(params) {
          var _a, _b, _c, _d;
          let response;
          let path = "";
          let queryParams = {};
          if (this.apiClient.isVertexAI()) {
            const body = listModelsParametersToVertex(this.apiClient, params);
            path = formatMap("{models_url}", body["_url"]);
            queryParams = body["_query"];
            delete body["_url"];
            delete body["_query"];
            response = this.apiClient.request({
              path,
              queryParams,
              body: JSON.stringify(body),
              httpMethod: "GET",
              httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,
              abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
            }).then((httpResponse) => {
              return httpResponse.json().then((jsonResponse) => {
                const response2 = jsonResponse;
                response2.sdkHttpResponse = {
                  headers: httpResponse.headers
                };
                return response2;
              });
            });
            return response.then((apiResponse) => {
              const resp = listModelsResponseFromVertex(apiResponse);
              const typedResp = new ListModelsResponse();
              Object.assign(typedResp, resp);
              return typedResp;
            });
          } else {
            const body = listModelsParametersToMldev(this.apiClient, params);
            path = formatMap("{models_url}", body["_url"]);
            queryParams = body["_query"];
            delete body["_url"];
            delete body["_query"];
            response = this.apiClient.request({
              path,
              queryParams,
              body: JSON.stringify(body),
              httpMethod: "GET",
              httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,
              abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal
            }).then((httpResponse) => {
              return httpResponse.json().then((jsonResponse) => {
                const response2 = jsonResponse;
                response2.sdkHttpResponse = {
                  headers: httpResponse.headers
                };
                return response2;
              });
            });
            return response.then((apiResponse) => {
              const resp = listModelsResponseFromMldev(apiResponse);
              const typedResp = new ListModelsResponse();
              Object.assign(typedResp, resp);
              return typedResp;
            });
          }
        }
        /**
         * Updates a tuned model by its name.
         *
         * @param params - The parameters for updating the model.
         * @return The response from the API.
         *
         * @example
         * ```ts
         * const response = await ai.models.update({
         *   model: 'tuned-model-name',
         *   config: {
         *     displayName: 'New display name',
         *     description: 'New description',
         *   },
         * });
         * ```
         */
        async update(params) {
          var _a, _b, _c, _d;
          let response;
          let path = "";
          let queryParams = {};
          if (this.apiClient.isVertexAI()) {
            const body = updateModelParametersToVertex(this.apiClient, params);
            path = formatMap("{model}", body["_url"]);
            queryParams = body["_query"];
            delete body["_url"];
            delete body["_query"];
            response = this.apiClient.request({
              path,
              queryParams,
              body: JSON.stringify(body),
              httpMethod: "PATCH",
              httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,
              abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
            }).then((httpResponse) => {
              return httpResponse.json();
            });
            return response.then((apiResponse) => {
              const resp = modelFromVertex(apiResponse);
              return resp;
            });
          } else {
            const body = updateModelParametersToMldev(this.apiClient, params);
            path = formatMap("{name}", body["_url"]);
            queryParams = body["_query"];
            delete body["_url"];
            delete body["_query"];
            response = this.apiClient.request({
              path,
              queryParams,
              body: JSON.stringify(body),
              httpMethod: "PATCH",
              httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,
              abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal
            }).then((httpResponse) => {
              return httpResponse.json();
            });
            return response.then((apiResponse) => {
              const resp = modelFromMldev(apiResponse);
              return resp;
            });
          }
        }
        /**
         * Deletes a tuned model by its name.
         *
         * @param params - The parameters for deleting the model.
         * @return The response from the API.
         *
         * @example
         * ```ts
         * const response = await ai.models.delete({model: 'tuned-model-name'});
         * ```
         */
        async delete(params) {
          var _a, _b, _c, _d;
          let response;
          let path = "";
          let queryParams = {};
          if (this.apiClient.isVertexAI()) {
            const body = deleteModelParametersToVertex(this.apiClient, params);
            path = formatMap("{name}", body["_url"]);
            queryParams = body["_query"];
            delete body["_url"];
            delete body["_query"];
            response = this.apiClient.request({
              path,
              queryParams,
              body: JSON.stringify(body),
              httpMethod: "DELETE",
              httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,
              abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
            }).then((httpResponse) => {
              return httpResponse.json().then((jsonResponse) => {
                const response2 = jsonResponse;
                response2.sdkHttpResponse = {
                  headers: httpResponse.headers
                };
                return response2;
              });
            });
            return response.then((apiResponse) => {
              const resp = deleteModelResponseFromVertex(apiResponse);
              const typedResp = new DeleteModelResponse();
              Object.assign(typedResp, resp);
              return typedResp;
            });
          } else {
            const body = deleteModelParametersToMldev(this.apiClient, params);
            path = formatMap("{name}", body["_url"]);
            queryParams = body["_query"];
            delete body["_url"];
            delete body["_query"];
            response = this.apiClient.request({
              path,
              queryParams,
              body: JSON.stringify(body),
              httpMethod: "DELETE",
              httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,
              abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal
            }).then((httpResponse) => {
              return httpResponse.json().then((jsonResponse) => {
                const response2 = jsonResponse;
                response2.sdkHttpResponse = {
                  headers: httpResponse.headers
                };
                return response2;
              });
            });
            return response.then((apiResponse) => {
              const resp = deleteModelResponseFromMldev(apiResponse);
              const typedResp = new DeleteModelResponse();
              Object.assign(typedResp, resp);
              return typedResp;
            });
          }
        }
        /**
         * Counts the number of tokens in the given contents. Multimodal input is
         * supported for Gemini models.
         *
         * @param params - The parameters for counting tokens.
         * @return The response from the API.
         *
         * @example
         * ```ts
         * const response = await ai.models.countTokens({
         *  model: 'gemini-2.0-flash',
         *  contents: 'The quick brown fox jumps over the lazy dog.'
         * });
         * console.log(response);
         * ```
         */
        async countTokens(params) {
          var _a, _b, _c, _d;
          let response;
          let path = "";
          let queryParams = {};
          if (this.apiClient.isVertexAI()) {
            const body = countTokensParametersToVertex(this.apiClient, params);
            path = formatMap("{model}:countTokens", body["_url"]);
            queryParams = body["_query"];
            delete body["_url"];
            delete body["_query"];
            response = this.apiClient.request({
              path,
              queryParams,
              body: JSON.stringify(body),
              httpMethod: "POST",
              httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,
              abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
            }).then((httpResponse) => {
              return httpResponse.json().then((jsonResponse) => {
                const response2 = jsonResponse;
                response2.sdkHttpResponse = {
                  headers: httpResponse.headers
                };
                return response2;
              });
            });
            return response.then((apiResponse) => {
              const resp = countTokensResponseFromVertex(apiResponse);
              const typedResp = new CountTokensResponse();
              Object.assign(typedResp, resp);
              return typedResp;
            });
          } else {
            const body = countTokensParametersToMldev(this.apiClient, params);
            path = formatMap("{model}:countTokens", body["_url"]);
            queryParams = body["_query"];
            delete body["_url"];
            delete body["_query"];
            response = this.apiClient.request({
              path,
              queryParams,
              body: JSON.stringify(body),
              httpMethod: "POST",
              httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,
              abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal
            }).then((httpResponse) => {
              return httpResponse.json().then((jsonResponse) => {
                const response2 = jsonResponse;
                response2.sdkHttpResponse = {
                  headers: httpResponse.headers
                };
                return response2;
              });
            });
            return response.then((apiResponse) => {
              const resp = countTokensResponseFromMldev(apiResponse);
              const typedResp = new CountTokensResponse();
              Object.assign(typedResp, resp);
              return typedResp;
            });
          }
        }
        /**
         * Given a list of contents, returns a corresponding TokensInfo containing
         * the list of tokens and list of token ids.
         *
         * This method is not supported by the Gemini Developer API.
         *
         * @param params - The parameters for computing tokens.
         * @return The response from the API.
         *
         * @example
         * ```ts
         * const response = await ai.models.computeTokens({
         *  model: 'gemini-2.0-flash',
         *  contents: 'What is your name?'
         * });
         * console.log(response);
         * ```
         */
        async computeTokens(params) {
          var _a, _b;
          let response;
          let path = "";
          let queryParams = {};
          if (this.apiClient.isVertexAI()) {
            const body = computeTokensParametersToVertex(this.apiClient, params);
            path = formatMap("{model}:computeTokens", body["_url"]);
            queryParams = body["_query"];
            delete body["_url"];
            delete body["_query"];
            response = this.apiClient.request({
              path,
              queryParams,
              body: JSON.stringify(body),
              httpMethod: "POST",
              httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,
              abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
            }).then((httpResponse) => {
              return httpResponse.json().then((jsonResponse) => {
                const response2 = jsonResponse;
                response2.sdkHttpResponse = {
                  headers: httpResponse.headers
                };
                return response2;
              });
            });
            return response.then((apiResponse) => {
              const resp = computeTokensResponseFromVertex(apiResponse);
              const typedResp = new ComputeTokensResponse();
              Object.assign(typedResp, resp);
              return typedResp;
            });
          } else {
            throw new Error("This method is only supported by the Vertex AI.");
          }
        }
        /**
         * Private method for generating videos.
         */
        async generateVideosInternal(params) {
          var _a, _b, _c, _d;
          let response;
          let path = "";
          let queryParams = {};
          if (this.apiClient.isVertexAI()) {
            const body = generateVideosParametersToVertex(this.apiClient, params);
            path = formatMap("{model}:predictLongRunning", body["_url"]);
            queryParams = body["_query"];
            delete body["_url"];
            delete body["_query"];
            response = this.apiClient.request({
              path,
              queryParams,
              body: JSON.stringify(body),
              httpMethod: "POST",
              httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,
              abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
            }).then((httpResponse) => {
              return httpResponse.json();
            });
            return response.then((apiResponse) => {
              const resp = generateVideosOperationFromVertex(apiResponse);
              const typedResp = new GenerateVideosOperation();
              Object.assign(typedResp, resp);
              return typedResp;
            });
          } else {
            const body = generateVideosParametersToMldev(this.apiClient, params);
            path = formatMap("{model}:predictLongRunning", body["_url"]);
            queryParams = body["_query"];
            delete body["_url"];
            delete body["_query"];
            response = this.apiClient.request({
              path,
              queryParams,
              body: JSON.stringify(body),
              httpMethod: "POST",
              httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,
              abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal
            }).then((httpResponse) => {
              return httpResponse.json();
            });
            return response.then((apiResponse) => {
              const resp = generateVideosOperationFromMldev(apiResponse);
              const typedResp = new GenerateVideosOperation();
              Object.assign(typedResp, resp);
              return typedResp;
            });
          }
        }
      };
      Operations = class extends BaseModule {
        constructor(apiClient) {
          super();
          this.apiClient = apiClient;
        }
        /**
         * Gets the status of a long-running operation.
         *
         * @param parameters The parameters for the get operation request.
         * @return The updated Operation object, with the latest status or result.
         */
        async getVideosOperation(parameters) {
          const operation = parameters.operation;
          const config = parameters.config;
          if (operation.name === void 0 || operation.name === "") {
            throw new Error("Operation name is required.");
          }
          if (this.apiClient.isVertexAI()) {
            const resourceName2 = operation.name.split("/operations/")[0];
            let httpOptions = void 0;
            if (config && "httpOptions" in config) {
              httpOptions = config.httpOptions;
            }
            const rawOperation = await this.fetchPredictVideosOperationInternal({
              operationName: operation.name,
              resourceName: resourceName2,
              config: { httpOptions }
            });
            return operation._fromAPIResponse({
              apiResponse: rawOperation,
              _isVertexAI: true
            });
          } else {
            const rawOperation = await this.getVideosOperationInternal({
              operationName: operation.name,
              config
            });
            return operation._fromAPIResponse({
              apiResponse: rawOperation,
              _isVertexAI: false
            });
          }
        }
        /**
         * Gets the status of a long-running operation.
         *
         * @param parameters The parameters for the get operation request.
         * @return The updated Operation object, with the latest status or result.
         */
        async get(parameters) {
          const operation = parameters.operation;
          const config = parameters.config;
          if (operation.name === void 0 || operation.name === "") {
            throw new Error("Operation name is required.");
          }
          if (this.apiClient.isVertexAI()) {
            const resourceName2 = operation.name.split("/operations/")[0];
            let httpOptions = void 0;
            if (config && "httpOptions" in config) {
              httpOptions = config.httpOptions;
            }
            const rawOperation = await this.fetchPredictVideosOperationInternal({
              operationName: operation.name,
              resourceName: resourceName2,
              config: { httpOptions }
            });
            return operation._fromAPIResponse({
              apiResponse: rawOperation,
              _isVertexAI: true
            });
          } else {
            const rawOperation = await this.getVideosOperationInternal({
              operationName: operation.name,
              config
            });
            return operation._fromAPIResponse({
              apiResponse: rawOperation,
              _isVertexAI: false
            });
          }
        }
        async getVideosOperationInternal(params) {
          var _a, _b, _c, _d;
          let response;
          let path = "";
          let queryParams = {};
          if (this.apiClient.isVertexAI()) {
            const body = getOperationParametersToVertex(params);
            path = formatMap("{operationName}", body["_url"]);
            queryParams = body["_query"];
            delete body["_url"];
            delete body["_query"];
            response = this.apiClient.request({
              path,
              queryParams,
              body: JSON.stringify(body),
              httpMethod: "GET",
              httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,
              abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
            }).then((httpResponse) => {
              return httpResponse.json();
            });
            return response;
          } else {
            const body = getOperationParametersToMldev(params);
            path = formatMap("{operationName}", body["_url"]);
            queryParams = body["_query"];
            delete body["_url"];
            delete body["_query"];
            response = this.apiClient.request({
              path,
              queryParams,
              body: JSON.stringify(body),
              httpMethod: "GET",
              httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,
              abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal
            }).then((httpResponse) => {
              return httpResponse.json();
            });
            return response;
          }
        }
        async fetchPredictVideosOperationInternal(params) {
          var _a, _b;
          let response;
          let path = "";
          let queryParams = {};
          if (this.apiClient.isVertexAI()) {
            const body = fetchPredictOperationParametersToVertex(params);
            path = formatMap("{resourceName}:fetchPredictOperation", body["_url"]);
            queryParams = body["_query"];
            delete body["_url"];
            delete body["_query"];
            response = this.apiClient.request({
              path,
              queryParams,
              body: JSON.stringify(body),
              httpMethod: "POST",
              httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,
              abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
            }).then((httpResponse) => {
              return httpResponse.json();
            });
            return response;
          } else {
            throw new Error("This method is only supported by the Vertex AI.");
          }
        }
      };
      Tokens = class extends BaseModule {
        constructor(apiClient) {
          super();
          this.apiClient = apiClient;
        }
        /**
         * Creates an ephemeral auth token resource.
         *
         * @experimental
         *
         * @remarks
         * Ephemeral auth tokens is only supported in the Gemini Developer API.
         * It can be used for the session connection to the Live constrained API.
         * Support in v1alpha only.
         *
         * @param params - The parameters for the create request.
         * @return The created auth token.
         *
         * @example
         * ```ts
         * const ai = new GoogleGenAI({
         *     apiKey: token.name,
         *     httpOptions: { apiVersion: 'v1alpha' }  // Support in v1alpha only.
         * });
         *
         * // Case 1: If LiveEphemeralParameters is unset, unlock LiveConnectConfig
         * // when using the token in Live API sessions. Each session connection can
         * // use a different configuration.
         * const config: CreateAuthTokenConfig = {
         *     uses: 3,
         *     expireTime: '2025-05-01T00:00:00Z',
         * }
         * const token = await ai.tokens.create(config);
         *
         * // Case 2: If LiveEphemeralParameters is set, lock all fields in
         * // LiveConnectConfig when using the token in Live API sessions. For
         * // example, changing `outputAudioTranscription` in the Live API
         * // connection will be ignored by the API.
         * const config: CreateAuthTokenConfig =
         *     uses: 3,
         *     expireTime: '2025-05-01T00:00:00Z',
         *     LiveEphemeralParameters: {
         *        model: 'gemini-2.0-flash-001',
         *        config: {
         *           'responseModalities': ['AUDIO'],
         *           'systemInstruction': 'Always answer in English.',
         *        }
         *     }
         * }
         * const token = await ai.tokens.create(config);
         *
         * // Case 3: If LiveEphemeralParameters is set and lockAdditionalFields is
         * // set, lock LiveConnectConfig with set and additional fields (e.g.
         * // responseModalities, systemInstruction, temperature in this example) when
         * // using the token in Live API sessions.
         * const config: CreateAuthTokenConfig =
         *     uses: 3,
         *     expireTime: '2025-05-01T00:00:00Z',
         *     LiveEphemeralParameters: {
         *        model: 'gemini-2.0-flash-001',
         *        config: {
         *           'responseModalities': ['AUDIO'],
         *           'systemInstruction': 'Always answer in English.',
         *        }
         *     },
         *     lockAdditionalFields: ['temperature'],
         * }
         * const token = await ai.tokens.create(config);
         *
         * // Case 4: If LiveEphemeralParameters is set and lockAdditionalFields is
         * // empty array, lock LiveConnectConfig with set fields (e.g.
         * // responseModalities, systemInstruction in this example) when using the
         * // token in Live API sessions.
         * const config: CreateAuthTokenConfig =
         *     uses: 3,
         *     expireTime: '2025-05-01T00:00:00Z',
         *     LiveEphemeralParameters: {
         *        model: 'gemini-2.0-flash-001',
         *        config: {
         *           'responseModalities': ['AUDIO'],
         *           'systemInstruction': 'Always answer in English.',
         *        }
         *     },
         *     lockAdditionalFields: [],
         * }
         * const token = await ai.tokens.create(config);
         * ```
         */
        async create(params) {
          var _a, _b;
          let response;
          let path = "";
          let queryParams = {};
          if (this.apiClient.isVertexAI()) {
            throw new Error("The client.tokens.create method is only supported by the Gemini Developer API.");
          } else {
            const body = createAuthTokenParametersToMldev(this.apiClient, params);
            path = formatMap("auth_tokens", body["_url"]);
            queryParams = body["_query"];
            delete body["config"];
            delete body["_url"];
            delete body["_query"];
            const transformedBody = convertBidiSetupToTokenSetup(body, params.config);
            response = this.apiClient.request({
              path,
              queryParams,
              body: JSON.stringify(transformedBody),
              httpMethod: "POST",
              httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,
              abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
            }).then((httpResponse) => {
              return httpResponse.json();
            });
            return response.then((resp) => {
              return resp;
            });
          }
        }
      };
      Documents = class extends BaseModule {
        constructor(apiClient) {
          super();
          this.apiClient = apiClient;
          this.list = async (params) => {
            return new Pager(PagedItem.PAGED_ITEM_DOCUMENTS, (x) => this.listInternal({
              parent: params.parent,
              config: x.config
            }), await this.listInternal(params), params);
          };
        }
        /**
         * Gets a Document.
         *
         * @param params - The parameters for getting a document.
         * @return Document.
         */
        async get(params) {
          var _a, _b;
          let response;
          let path = "";
          let queryParams = {};
          if (this.apiClient.isVertexAI()) {
            throw new Error("This method is only supported by the Gemini Developer API.");
          } else {
            const body = getDocumentParametersToMldev(params);
            path = formatMap("{name}", body["_url"]);
            queryParams = body["_query"];
            delete body["_url"];
            delete body["_query"];
            response = this.apiClient.request({
              path,
              queryParams,
              body: JSON.stringify(body),
              httpMethod: "GET",
              httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,
              abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
            }).then((httpResponse) => {
              return httpResponse.json();
            });
            return response.then((resp) => {
              return resp;
            });
          }
        }
        /**
         * Deletes a Document.
         *
         * @param params - The parameters for deleting a document.
         */
        async delete(params) {
          var _a, _b;
          let path = "";
          let queryParams = {};
          if (this.apiClient.isVertexAI()) {
            throw new Error("This method is only supported by the Gemini Developer API.");
          } else {
            const body = deleteDocumentParametersToMldev(params);
            path = formatMap("{name}", body["_url"]);
            queryParams = body["_query"];
            delete body["_url"];
            delete body["_query"];
            await this.apiClient.request({
              path,
              queryParams,
              body: JSON.stringify(body),
              httpMethod: "DELETE",
              httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,
              abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
            });
          }
        }
        /**
         * Lists all Documents in a FileSearchStore.
         *
         * @param params - The parameters for listing documents.
         * @return ListDocumentsResponse.
         */
        async listInternal(params) {
          var _a, _b;
          let response;
          let path = "";
          let queryParams = {};
          if (this.apiClient.isVertexAI()) {
            throw new Error("This method is only supported by the Gemini Developer API.");
          } else {
            const body = listDocumentsParametersToMldev(params);
            path = formatMap("{parent}/documents", body["_url"]);
            queryParams = body["_query"];
            delete body["_url"];
            delete body["_query"];
            response = this.apiClient.request({
              path,
              queryParams,
              body: JSON.stringify(body),
              httpMethod: "GET",
              httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,
              abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
            }).then((httpResponse) => {
              return httpResponse.json();
            });
            return response.then((apiResponse) => {
              const resp = listDocumentsResponseFromMldev(apiResponse);
              const typedResp = new ListDocumentsResponse();
              Object.assign(typedResp, resp);
              return typedResp;
            });
          }
        }
      };
      FileSearchStores = class extends BaseModule {
        constructor(apiClient, documents = new Documents(apiClient)) {
          super();
          this.apiClient = apiClient;
          this.documents = documents;
          this.list = async (params = {}) => {
            return new Pager(PagedItem.PAGED_ITEM_FILE_SEARCH_STORES, (x) => this.listInternal(x), await this.listInternal(params), params);
          };
        }
        /**
         * Uploads a file asynchronously to a given File Search Store.
         * This method is not available in Vertex AI.
         * Supported upload sources:
         * - Node.js: File path (string) or Blob object.
         * - Browser: Blob object (e.g., File).
         *
         * @remarks
         * The `mimeType` can be specified in the `config` parameter. If omitted:
         *  - For file path (string) inputs, the `mimeType` will be inferred from the
         *     file extension.
         *  - For Blob object inputs, the `mimeType` will be set to the Blob's `type`
         *     property.
         *
         * This section can contain multiple paragraphs and code examples.
         *
         * @param params - Optional parameters specified in the
         *        `types.UploadToFileSearchStoreParameters` interface.
         *         @see {@link types.UploadToFileSearchStoreParameters#config} for the optional
         *         config in the parameters.
         * @return A promise that resolves to a long running operation.
         * @throws An error if called on a Vertex AI client.
         * @throws An error if the `mimeType` is not provided and can not be inferred,
         * the `mimeType` can be provided in the `params.config` parameter.
         * @throws An error occurs if a suitable upload location cannot be established.
         *
         * @example
         * The following code uploads a file to a given file search store.
         *
         * ```ts
         * const operation = await ai.fileSearchStores.upload({fileSearchStoreName: 'fileSearchStores/foo-bar', file: 'file.txt', config: {
         *   mimeType: 'text/plain',
         * }});
         * console.log(operation.name);
         * ```
         */
        async uploadToFileSearchStore(params) {
          if (this.apiClient.isVertexAI()) {
            throw new Error("Vertex AI does not support uploading files to a file search store.");
          }
          return this.apiClient.uploadFileToFileSearchStore(params.fileSearchStoreName, params.file, params.config);
        }
        /**
         * Creates a File Search Store.
         *
         * @param params - The parameters for creating a File Search Store.
         * @return FileSearchStore.
         */
        async create(params) {
          var _a, _b;
          let response;
          let path = "";
          let queryParams = {};
          if (this.apiClient.isVertexAI()) {
            throw new Error("This method is only supported by the Gemini Developer API.");
          } else {
            const body = createFileSearchStoreParametersToMldev(params);
            path = formatMap("fileSearchStores", body["_url"]);
            queryParams = body["_query"];
            delete body["_url"];
            delete body["_query"];
            response = this.apiClient.request({
              path,
              queryParams,
              body: JSON.stringify(body),
              httpMethod: "POST",
              httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,
              abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
            }).then((httpResponse) => {
              return httpResponse.json();
            });
            return response.then((resp) => {
              return resp;
            });
          }
        }
        /**
         * Gets a File Search Store.
         *
         * @param params - The parameters for getting a File Search Store.
         * @return FileSearchStore.
         */
        async get(params) {
          var _a, _b;
          let response;
          let path = "";
          let queryParams = {};
          if (this.apiClient.isVertexAI()) {
            throw new Error("This method is only supported by the Gemini Developer API.");
          } else {
            const body = getFileSearchStoreParametersToMldev(params);
            path = formatMap("{name}", body["_url"]);
            queryParams = body["_query"];
            delete body["_url"];
            delete body["_query"];
            response = this.apiClient.request({
              path,
              queryParams,
              body: JSON.stringify(body),
              httpMethod: "GET",
              httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,
              abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
            }).then((httpResponse) => {
              return httpResponse.json();
            });
            return response.then((resp) => {
              return resp;
            });
          }
        }
        /**
         * Deletes a File Search Store.
         *
         * @param params - The parameters for deleting a File Search Store.
         */
        async delete(params) {
          var _a, _b;
          let path = "";
          let queryParams = {};
          if (this.apiClient.isVertexAI()) {
            throw new Error("This method is only supported by the Gemini Developer API.");
          } else {
            const body = deleteFileSearchStoreParametersToMldev(params);
            path = formatMap("{name}", body["_url"]);
            queryParams = body["_query"];
            delete body["_url"];
            delete body["_query"];
            await this.apiClient.request({
              path,
              queryParams,
              body: JSON.stringify(body),
              httpMethod: "DELETE",
              httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,
              abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
            });
          }
        }
        /**
         * Lists all FileSearchStore owned by the user.
         *
         * @param params - The parameters for listing file search stores.
         * @return ListFileSearchStoresResponse.
         */
        async listInternal(params) {
          var _a, _b;
          let response;
          let path = "";
          let queryParams = {};
          if (this.apiClient.isVertexAI()) {
            throw new Error("This method is only supported by the Gemini Developer API.");
          } else {
            const body = listFileSearchStoresParametersToMldev(params);
            path = formatMap("fileSearchStores", body["_url"]);
            queryParams = body["_query"];
            delete body["_url"];
            delete body["_query"];
            response = this.apiClient.request({
              path,
              queryParams,
              body: JSON.stringify(body),
              httpMethod: "GET",
              httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,
              abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
            }).then((httpResponse) => {
              return httpResponse.json();
            });
            return response.then((apiResponse) => {
              const resp = listFileSearchStoresResponseFromMldev(apiResponse);
              const typedResp = new ListFileSearchStoresResponse();
              Object.assign(typedResp, resp);
              return typedResp;
            });
          }
        }
        async uploadToFileSearchStoreInternal(params) {
          var _a, _b;
          let response;
          let path = "";
          let queryParams = {};
          if (this.apiClient.isVertexAI()) {
            throw new Error("This method is only supported by the Gemini Developer API.");
          } else {
            const body = uploadToFileSearchStoreParametersToMldev(params);
            path = formatMap("upload/v1beta/{file_search_store_name}:uploadToFileSearchStore", body["_url"]);
            queryParams = body["_query"];
            delete body["_url"];
            delete body["_query"];
            response = this.apiClient.request({
              path,
              queryParams,
              body: JSON.stringify(body),
              httpMethod: "POST",
              httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,
              abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
            }).then((httpResponse) => {
              return httpResponse.json();
            });
            return response.then((apiResponse) => {
              const resp = uploadToFileSearchStoreResumableResponseFromMldev(apiResponse);
              const typedResp = new UploadToFileSearchStoreResumableResponse();
              Object.assign(typedResp, resp);
              return typedResp;
            });
          }
        }
        /**
         * Imports a File from File Service to a FileSearchStore.
         *
         * This is a long-running operation, see aip.dev/151
         *
         * @param params - The parameters for importing a file to a file search store.
         * @return ImportFileOperation.
         */
        async importFile(params) {
          var _a, _b;
          let response;
          let path = "";
          let queryParams = {};
          if (this.apiClient.isVertexAI()) {
            throw new Error("This method is only supported by the Gemini Developer API.");
          } else {
            const body = importFileParametersToMldev(params);
            path = formatMap("{file_search_store_name}:importFile", body["_url"]);
            queryParams = body["_query"];
            delete body["_url"];
            delete body["_query"];
            response = this.apiClient.request({
              path,
              queryParams,
              body: JSON.stringify(body),
              httpMethod: "POST",
              httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,
              abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
            }).then((httpResponse) => {
              return httpResponse.json();
            });
            return response.then((apiResponse) => {
              const resp = importFileOperationFromMldev(apiResponse);
              const typedResp = new ImportFileOperation();
              Object.assign(typedResp, resp);
              return typedResp;
            });
          }
        }
      };
      Tunings = class extends BaseModule {
        constructor(apiClient) {
          super();
          this.apiClient = apiClient;
          this.get = async (params) => {
            return await this.getInternal(params);
          };
          this.list = async (params = {}) => {
            return new Pager(PagedItem.PAGED_ITEM_TUNING_JOBS, (x) => this.listInternal(x), await this.listInternal(params), params);
          };
          this.tune = async (params) => {
            var _a;
            if (this.apiClient.isVertexAI()) {
              if (params.baseModel.startsWith("projects/")) {
                const preTunedModel = {
                  tunedModelName: params.baseModel
                };
                if ((_a = params.config) === null || _a === void 0 ? void 0 : _a.preTunedModelCheckpointId) {
                  preTunedModel.checkpointId = params.config.preTunedModelCheckpointId;
                }
                const paramsPrivate = Object.assign(Object.assign({}, params), { preTunedModel });
                paramsPrivate.baseModel = void 0;
                return await this.tuneInternal(paramsPrivate);
              } else {
                const paramsPrivate = Object.assign({}, params);
                return await this.tuneInternal(paramsPrivate);
              }
            } else {
              const paramsPrivate = Object.assign({}, params);
              const operation = await this.tuneMldevInternal(paramsPrivate);
              let tunedModelName = "";
              if (operation["metadata"] !== void 0 && operation["metadata"]["tunedModel"] !== void 0) {
                tunedModelName = operation["metadata"]["tunedModel"];
              } else if (operation["name"] !== void 0 && operation["name"].includes("/operations/")) {
                tunedModelName = operation["name"].split("/operations/")[0];
              }
              const tuningJob = {
                name: tunedModelName,
                state: JobState.JOB_STATE_QUEUED
              };
              return tuningJob;
            }
          };
        }
        async getInternal(params) {
          var _a, _b, _c, _d;
          let response;
          let path = "";
          let queryParams = {};
          if (this.apiClient.isVertexAI()) {
            const body = getTuningJobParametersToVertex(params);
            path = formatMap("{name}", body["_url"]);
            queryParams = body["_query"];
            delete body["_url"];
            delete body["_query"];
            response = this.apiClient.request({
              path,
              queryParams,
              body: JSON.stringify(body),
              httpMethod: "GET",
              httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,
              abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
            }).then((httpResponse) => {
              return httpResponse.json().then((jsonResponse) => {
                const response2 = jsonResponse;
                response2.sdkHttpResponse = {
                  headers: httpResponse.headers
                };
                return response2;
              });
            });
            return response.then((apiResponse) => {
              const resp = tuningJobFromVertex(apiResponse);
              return resp;
            });
          } else {
            const body = getTuningJobParametersToMldev(params);
            path = formatMap("{name}", body["_url"]);
            queryParams = body["_query"];
            delete body["_url"];
            delete body["_query"];
            response = this.apiClient.request({
              path,
              queryParams,
              body: JSON.stringify(body),
              httpMethod: "GET",
              httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,
              abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal
            }).then((httpResponse) => {
              return httpResponse.json().then((jsonResponse) => {
                const response2 = jsonResponse;
                response2.sdkHttpResponse = {
                  headers: httpResponse.headers
                };
                return response2;
              });
            });
            return response.then((apiResponse) => {
              const resp = tuningJobFromMldev(apiResponse);
              return resp;
            });
          }
        }
        async listInternal(params) {
          var _a, _b, _c, _d;
          let response;
          let path = "";
          let queryParams = {};
          if (this.apiClient.isVertexAI()) {
            const body = listTuningJobsParametersToVertex(params);
            path = formatMap("tuningJobs", body["_url"]);
            queryParams = body["_query"];
            delete body["_url"];
            delete body["_query"];
            response = this.apiClient.request({
              path,
              queryParams,
              body: JSON.stringify(body),
              httpMethod: "GET",
              httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,
              abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
            }).then((httpResponse) => {
              return httpResponse.json().then((jsonResponse) => {
                const response2 = jsonResponse;
                response2.sdkHttpResponse = {
                  headers: httpResponse.headers
                };
                return response2;
              });
            });
            return response.then((apiResponse) => {
              const resp = listTuningJobsResponseFromVertex(apiResponse);
              const typedResp = new ListTuningJobsResponse();
              Object.assign(typedResp, resp);
              return typedResp;
            });
          } else {
            const body = listTuningJobsParametersToMldev(params);
            path = formatMap("tunedModels", body["_url"]);
            queryParams = body["_query"];
            delete body["_url"];
            delete body["_query"];
            response = this.apiClient.request({
              path,
              queryParams,
              body: JSON.stringify(body),
              httpMethod: "GET",
              httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,
              abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal
            }).then((httpResponse) => {
              return httpResponse.json().then((jsonResponse) => {
                const response2 = jsonResponse;
                response2.sdkHttpResponse = {
                  headers: httpResponse.headers
                };
                return response2;
              });
            });
            return response.then((apiResponse) => {
              const resp = listTuningJobsResponseFromMldev(apiResponse);
              const typedResp = new ListTuningJobsResponse();
              Object.assign(typedResp, resp);
              return typedResp;
            });
          }
        }
        /**
         * Cancels a tuning job.
         *
         * @param params - The parameters for the cancel request.
         * @return The empty response returned by the API.
         *
         * @example
         * ```ts
         * await ai.tunings.cancel({name: '...'}); // The server-generated resource name.
         * ```
         */
        async cancel(params) {
          var _a, _b, _c, _d;
          let path = "";
          let queryParams = {};
          if (this.apiClient.isVertexAI()) {
            const body = cancelTuningJobParametersToVertex(params);
            path = formatMap("{name}:cancel", body["_url"]);
            queryParams = body["_query"];
            delete body["_url"];
            delete body["_query"];
            await this.apiClient.request({
              path,
              queryParams,
              body: JSON.stringify(body),
              httpMethod: "POST",
              httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,
              abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
            });
          } else {
            const body = cancelTuningJobParametersToMldev(params);
            path = formatMap("{name}:cancel", body["_url"]);
            queryParams = body["_query"];
            delete body["_url"];
            delete body["_query"];
            await this.apiClient.request({
              path,
              queryParams,
              body: JSON.stringify(body),
              httpMethod: "POST",
              httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,
              abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal
            });
          }
        }
        async tuneInternal(params) {
          var _a, _b;
          let response;
          let path = "";
          let queryParams = {};
          if (this.apiClient.isVertexAI()) {
            const body = createTuningJobParametersPrivateToVertex(params, params);
            path = formatMap("tuningJobs", body["_url"]);
            queryParams = body["_query"];
            delete body["_url"];
            delete body["_query"];
            response = this.apiClient.request({
              path,
              queryParams,
              body: JSON.stringify(body),
              httpMethod: "POST",
              httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,
              abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
            }).then((httpResponse) => {
              return httpResponse.json().then((jsonResponse) => {
                const response2 = jsonResponse;
                response2.sdkHttpResponse = {
                  headers: httpResponse.headers
                };
                return response2;
              });
            });
            return response.then((apiResponse) => {
              const resp = tuningJobFromVertex(apiResponse);
              return resp;
            });
          } else {
            throw new Error("This method is only supported by the Vertex AI.");
          }
        }
        async tuneMldevInternal(params) {
          var _a, _b;
          let response;
          let path = "";
          let queryParams = {};
          if (this.apiClient.isVertexAI()) {
            throw new Error("This method is only supported by the Gemini Developer API.");
          } else {
            const body = createTuningJobParametersPrivateToMldev(params);
            path = formatMap("tunedModels", body["_url"]);
            queryParams = body["_query"];
            delete body["_url"];
            delete body["_query"];
            response = this.apiClient.request({
              path,
              queryParams,
              body: JSON.stringify(body),
              httpMethod: "POST",
              httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,
              abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
            }).then((httpResponse) => {
              return httpResponse.json().then((jsonResponse) => {
                const response2 = jsonResponse;
                response2.sdkHttpResponse = {
                  headers: httpResponse.headers
                };
                return response2;
              });
            });
            return response.then((apiResponse) => {
              const resp = tuningOperationFromMldev(apiResponse);
              return resp;
            });
          }
        }
      };
      BrowserDownloader = class {
        async download(_params, _apiClient) {
          throw new Error("Download to file is not supported in the browser, please use a browser compliant download like an <a> tag.");
        }
      };
      MAX_CHUNK_SIZE = 1024 * 1024 * 8;
      MAX_RETRY_COUNT = 3;
      INITIAL_RETRY_DELAY_MS = 1e3;
      DELAY_MULTIPLIER = 2;
      X_GOOG_UPLOAD_STATUS_HEADER_FIELD = "x-goog-upload-status";
      BrowserUploader = class {
        async upload(file, uploadUrl, apiClient) {
          if (typeof file === "string") {
            throw new Error("File path is not supported in browser uploader.");
          }
          return await uploadBlob(file, uploadUrl, apiClient);
        }
        async uploadToFileSearchStore(file, uploadUrl, apiClient) {
          if (typeof file === "string") {
            throw new Error("File path is not supported in browser uploader.");
          }
          return await uploadBlobToFileSearchStore(file, uploadUrl, apiClient);
        }
        async stat(file) {
          if (typeof file === "string") {
            throw new Error("File path is not supported in browser uploader.");
          } else {
            return await getBlobStat(file);
          }
        }
      };
      BrowserWebSocketFactory = class {
        create(url, headers, callbacks) {
          return new BrowserWebSocket(url, headers, callbacks);
        }
      };
      BrowserWebSocket = class {
        constructor(url, headers, callbacks) {
          this.url = url;
          this.headers = headers;
          this.callbacks = callbacks;
        }
        connect() {
          this.ws = new WebSocket(this.url);
          this.ws.onopen = this.callbacks.onopen;
          this.ws.onerror = this.callbacks.onerror;
          this.ws.onclose = this.callbacks.onclose;
          this.ws.onmessage = this.callbacks.onmessage;
        }
        send(message) {
          if (this.ws === void 0) {
            throw new Error("WebSocket is not connected");
          }
          this.ws.send(message);
        }
        close() {
          if (this.ws === void 0) {
            throw new Error("WebSocket is not connected");
          }
          this.ws.close();
        }
      };
      GOOGLE_API_KEY_HEADER = "x-goog-api-key";
      WebAuth = class {
        constructor(apiKey) {
          this.apiKey = apiKey;
        }
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        async addAuthHeaders(headers, url) {
          if (headers.get(GOOGLE_API_KEY_HEADER) !== null) {
            return;
          }
          if (this.apiKey.startsWith("auth_tokens/")) {
            throw new Error("Ephemeral tokens are only supported by the live API.");
          }
          if (!this.apiKey) {
            throw new Error("API key is missing. Please provide a valid API key.");
          }
          headers.append(GOOGLE_API_KEY_HEADER, this.apiKey);
        }
      };
      LANGUAGE_LABEL_PREFIX = "gl-node/";
      GoogleGenAI = class {
        constructor(options) {
          var _a;
          if (options.apiKey == null) {
            throw new Error("An API Key must be set when running in a browser");
          }
          if (options.project || options.location) {
            throw new Error("Vertex AI project based authentication is not supported on browser runtimes. Please do not provide a project or location.");
          }
          this.vertexai = (_a = options.vertexai) !== null && _a !== void 0 ? _a : false;
          this.apiKey = options.apiKey;
          const baseUrl = getBaseUrl(
            options.httpOptions,
            options.vertexai,
            /*vertexBaseUrlFromEnv*/
            void 0,
            /*geminiBaseUrlFromEnv*/
            void 0
          );
          if (baseUrl) {
            if (options.httpOptions) {
              options.httpOptions.baseUrl = baseUrl;
            } else {
              options.httpOptions = { baseUrl };
            }
          }
          this.apiVersion = options.apiVersion;
          const auth = new WebAuth(this.apiKey);
          this.apiClient = new ApiClient({
            auth,
            apiVersion: this.apiVersion,
            apiKey: this.apiKey,
            vertexai: this.vertexai,
            httpOptions: options.httpOptions,
            userAgentExtra: LANGUAGE_LABEL_PREFIX + "web",
            uploader: new BrowserUploader(),
            downloader: new BrowserDownloader()
          });
          this.models = new Models(this.apiClient);
          this.live = new Live(this.apiClient, auth, new BrowserWebSocketFactory());
          this.batches = new Batches(this.apiClient);
          this.chats = new Chats(this.models, this.apiClient);
          this.caches = new Caches(this.apiClient);
          this.files = new Files(this.apiClient);
          this.operations = new Operations(this.apiClient);
          this.authTokens = new Tokens(this.apiClient);
          this.tunings = new Tunings(this.apiClient);
          this.fileSearchStores = new FileSearchStores(this.apiClient);
        }
      };
    }
  });

  // index.tsx
  var import_react17 = __toESM(require_react());
  var import_client = __toESM(require_client());

  // App.tsx
  var import_react16 = __toESM(require_react());

  // types.ts
  function isMidiExercise(exercise) {
    return "exercise_id" in exercise && "notes" in exercise;
  }

  // constants.ts
  var NOTE_NAMES = ["C", "C#", "D", "D#", "E", "F", "F#", "G", "G#", "A", "A#", "B"];
  var IS_SHARP = [false, true, false, false, true, false, true, false, true, false, true, false];
  var BASE_FREQ = 261.63;
  var EXERCISES = [
    // Warmup
    {
      exercise_id: "FAM_002",
      name: "descendingFiveTone",
      desc: "descendingFiveToneDesc",
      category: "warmup",
      key_center: "C4",
      tempo_bpm: 90,
      time_signature: "4/4",
      notes: [{ type: "note", semitone: 7, duration: 1, lyric: "Mum" }, { type: "note", semitone: 5, duration: 1, lyric: "Mum" }, { type: "note", semitone: 4, duration: 1, lyric: "Mum" }, { type: "note", semitone: 2, duration: 1, lyric: "Mum" }, { type: "note", semitone: 0, duration: 4, lyric: "Mum" }]
    },
    {
      exercise_id: "COOL_001",
      name: "gentleSlideDown",
      desc: "gentleSlideDownDesc",
      category: "warmup",
      key_center: "C4",
      tempo_bpm: 80,
      time_signature: "4/4",
      notes: [{ type: "note", semitone: 7, duration: 2, lyric: "Hum" }, { type: "note", semitone: 4, duration: 2, lyric: "Hum" }, { type: "note", semitone: 0, duration: 4, lyric: "Hum" }]
    },
    // Technique
    {
      exercise_id: "FAM_006",
      name: "staccatoArpeggio",
      desc: "staccatoArpeggioDesc",
      category: "technique",
      key_center: "C4",
      tempo_bpm: 90,
      time_signature: "4/4",
      notes: [{ type: "note", semitone: 0, duration: 0.5, lyric: "Ha" }, { type: "rest", duration: 0.5 }, { type: "note", semitone: 4, duration: 0.5, lyric: "Ha" }, { type: "rest", duration: 0.5 }, { type: "note", semitone: 7, duration: 0.5, lyric: "Ha" }, { type: "rest", duration: 0.5 }, { type: "note", semitone: 12, duration: 0.5, lyric: "Ha" }, { type: "rest", duration: 0.5 }, { type: "note", semitone: 7, duration: 0.5, lyric: "Ha" }, { type: "rest", duration: 0.5 }, { type: "note", semitone: 4, duration: 0.5, lyric: "Ha" }, { type: "rest", duration: 0.5 }, { type: "note", semitone: 0, duration: 2, lyric: "Ha" }]
    },
    // Resonance & Tone
    {
      exercise_id: "EX_012",
      name: "vowelPurityScale",
      desc: "vowelPurityScaleDesc",
      category: "technique",
      key_center: "C4",
      tempo_bpm: 90,
      time_signature: "4/4",
      notes: [{ type: "note", semitone: 0, duration: 1, lyric: "Ah" }, { type: "note", semitone: 2, duration: 1, lyric: "Ah" }, { type: "note", semitone: 4, duration: 1, lyric: "Ah" }, { type: "note", semitone: 5, duration: 1, lyric: "Ah" }, { type: "note", semitone: 7, duration: 1, lyric: "Ah" }, { type: "note", semitone: 5, duration: 1, lyric: "Ah" }, { type: "note", semitone: 4, duration: 1, lyric: "Ah" }, { type: "note", semitone: 2, duration: 1, lyric: "Ah" }, { type: "note", semitone: 0, duration: 2, lyric: "Ah" }]
    },
    {
      exercise_id: "EX_020",
      name: "vowelUniformity",
      desc: "vowelUniformityDesc",
      category: "technique",
      key_center: "C4",
      tempo_bpm: 100,
      time_signature: "4/4",
      notes: [{ type: "note", semitone: 0, duration: 1, lyric: "Ee" }, { type: "note", semitone: 4, duration: 1, lyric: "Ah" }, { type: "note", semitone: 7, duration: 1, lyric: "Oo" }, { type: "note", semitone: 12, duration: 2, lyric: "Ee" }, { type: "note", semitone: 7, duration: 1, lyric: "Ah" }, { type: "note", semitone: 4, duration: 1, lyric: "Oo" }, { type: "note", semitone: 0, duration: 2, lyric: "Ee" }]
    },
    {
      exercise_id: "FAM_007",
      name: "neighOctave",
      desc: "neighOctaveDesc",
      category: "technique",
      key_center: "C4",
      tempo_bpm: 110,
      time_signature: "4/4",
      notes: [{ type: "note", semitone: 0, duration: 1, lyric: "Nay" }, { type: "note", semitone: 4, duration: 1, lyric: "Nay" }, { type: "note", semitone: 7, duration: 1, lyric: "Nay" }, { type: "note", semitone: 12, duration: 0.5, lyric: "Nay" }, { type: "note", semitone: 12, duration: 0.5, lyric: "Nay" }, { type: "note", semitone: 12, duration: 0.5, lyric: "Nay" }, { type: "note", semitone: 12, duration: 0.5, lyric: "Nay" }, { type: "note", semitone: 7, duration: 1, lyric: "Nay" }, { type: "note", semitone: 4, duration: 1, lyric: "Nay" }, { type: "note", semitone: 0, duration: 2, lyric: "Nay" }]
    },
    {
      exercise_id: "EX_030",
      name: "rapidConsonants",
      desc: "rapidConsonantsDesc",
      category: "agility",
      key_center: "C4",
      tempo_bpm: 110,
      time_signature: "4/4",
      notes: [{ type: "note", semitone: 0, duration: 0.5, lyric: "Dig" }, { type: "note", semitone: 2, duration: 0.5, lyric: "Ga" }, { type: "note", semitone: 4, duration: 0.5, lyric: "Dig" }, { type: "note", semitone: 5, duration: 0.5, lyric: "Ga" }, { type: "note", semitone: 7, duration: 0.5, lyric: "Dig" }, { type: "note", semitone: 5, duration: 0.5, lyric: "Ga" }, { type: "note", semitone: 4, duration: 0.5, lyric: "Dig" }, { type: "note", semitone: 2, duration: 0.5, lyric: "Ga" }, { type: "note", semitone: 0, duration: 1, lyric: "Dig" }]
    },
    // Belting
    {
      exercise_id: "EX_026",
      name: "edgyAh",
      desc: "edgyAhDesc",
      category: "technique",
      key_center: "C4",
      tempo_bpm: 100,
      time_signature: "4/4",
      notes: [{ type: "note", semitone: 7, duration: 1, lyric: "AH" }, { type: "note", semitone: 9, duration: 1, lyric: "AH" }, { type: "note", semitone: 12, duration: 2, lyric: "AH" }, { type: "note", semitone: 9, duration: 1, lyric: "AH" }, { type: "note", semitone: 7, duration: 2, lyric: "AH" }]
    },
    // Scales & Agility
    {
      exercise_id: "FAM_004",
      name: "onePointFiveOctaveScale",
      desc: "onePointFiveOctaveScaleDesc",
      category: "technique",
      key_center: "C4",
      tempo_bpm: 120,
      time_signature: "4/4",
      notes: [{ type: "note", semitone: 0, duration: 0.5, lyric: "La" }, { type: "note", semitone: 2, duration: 0.5, lyric: "La" }, { type: "note", semitone: 4, duration: 0.5, lyric: "La" }, { type: "note", semitone: 5, duration: 0.5, lyric: "La" }, { type: "note", semitone: 7, duration: 0.5, lyric: "La" }, { type: "note", semitone: 9, duration: 0.5, lyric: "La" }, { type: "note", semitone: 11, duration: 0.5, lyric: "La" }, { type: "note", semitone: 12, duration: 0.5, lyric: "La" }, { type: "note", semitone: 14, duration: 0.5, lyric: "La" }, { type: "note", semitone: 16, duration: 0.5, lyric: "La" }, { type: "note", semitone: 17, duration: 1, lyric: "La" }, { type: "note", semitone: 16, duration: 0.5, lyric: "La" }, { type: "note", semitone: 14, duration: 0.5, lyric: "La" }, { type: "note", semitone: 12, duration: 0.5, lyric: "La" }, { type: "note", semitone: 11, duration: 0.5, lyric: "La" }, { type: "note", semitone: 9, duration: 0.5, lyric: "La" }, { type: "note", semitone: 7, duration: 0.5, lyric: "La" }, { type: "note", semitone: 5, duration: 0.5, lyric: "La" }, { type: "note", semitone: 4, duration: 0.5, lyric: "La" }, { type: "note", semitone: 2, duration: 0.5, lyric: "La" }, { type: "note", semitone: 0, duration: 2, lyric: "La" }]
    },
    {
      exercise_id: "EX_007",
      name: "majorArpeggio",
      desc: "majorArpeggioDesc",
      category: "agility",
      key_center: "C4",
      tempo_bpm: 100,
      time_signature: "4/4",
      notes: [{ type: "note", semitone: 0, duration: 1, lyric: "La" }, { type: "note", semitone: 4, duration: 1, lyric: "La" }, { type: "note", semitone: 7, duration: 1, lyric: "La" }, { type: "note", semitone: 12, duration: 2, lyric: "La" }, { type: "note", semitone: 7, duration: 1, lyric: "La" }, { type: "note", semitone: 4, duration: 1, lyric: "La" }, { type: "note", semitone: 0, duration: 2, lyric: "La" }]
    },
    {
      exercise_id: "EX_010",
      name: "minorArpeggio",
      desc: "minorArpeggioDesc",
      category: "agility",
      key_center: "C4",
      tempo_bpm: 100,
      time_signature: "4/4",
      notes: [{ type: "note", semitone: 0, duration: 1, lyric: "La" }, { type: "note", semitone: 3, duration: 1, lyric: "La" }, { type: "note", semitone: 7, duration: 1, lyric: "La" }, { type: "note", semitone: 12, duration: 2, lyric: "La" }, { type: "note", semitone: 7, duration: 1, lyric: "La" }, { type: "note", semitone: 3, duration: 1, lyric: "La" }, { type: "note", semitone: 0, duration: 2, lyric: "La" }]
    },
    {
      exercise_id: "FAM_001",
      name: "hanonRun",
      desc: "hanonRunDesc",
      category: "agility",
      key_center: "C4",
      tempo_bpm: 70,
      time_signature: "4/4",
      notes: [{ type: "note", semitone: 0, duration: 0.25, lyric: "Ha" }, { type: "note", semitone: 4, duration: 0.25, lyric: "Ha" }, { type: "note", semitone: 5, duration: 0.25, lyric: "Ha" }, { type: "note", semitone: 7, duration: 0.25, lyric: "Ha" }, { type: "note", semitone: 9, duration: 0.25, lyric: "Ha" }, { type: "note", semitone: 7, duration: 0.25, lyric: "Ha" }, { type: "note", semitone: 5, duration: 0.25, lyric: "Ha" }, { type: "note", semitone: 4, duration: 0.25, lyric: "Ha" }, { type: "note", semitone: 0, duration: 2, lyric: "Ha" }]
    },
    {
      exercise_id: "FAM_005",
      name: "rossiniScale",
      desc: "rossiniScaleDesc",
      category: "agility",
      key_center: "C4",
      tempo_bpm: 115,
      time_signature: "4/4",
      notes: [{ type: "note", semitone: 0, duration: 0.5, lyric: "A" }, { type: "note", semitone: 2, duration: 0.5, lyric: "A" }, { type: "note", semitone: 4, duration: 0.5, lyric: "A" }, { type: "note", semitone: 5, duration: 0.5, lyric: "A" }, { type: "note", semitone: 7, duration: 0.5, lyric: "A" }, { type: "note", semitone: 9, duration: 0.5, lyric: "A" }, { type: "note", semitone: 11, duration: 0.5, lyric: "A" }, { type: "note", semitone: 12, duration: 0.5, lyric: "A" }, { type: "note", semitone: 14, duration: 0.5, lyric: "A" }, { type: "note", semitone: 12, duration: 0.5, lyric: "A" }, { type: "note", semitone: 11, duration: 0.5, lyric: "A" }, { type: "note", semitone: 9, duration: 0.5, lyric: "A" }, { type: "note", semitone: 7, duration: 0.5, lyric: "A" }, { type: "note", semitone: 5, duration: 0.5, lyric: "A" }, { type: "note", semitone: 4, duration: 0.5, lyric: "A" }, { type: "note", semitone: 2, duration: 0.5, lyric: "A" }, { type: "note", semitone: 0, duration: 2, lyric: "A" }]
    },
    {
      exercise_id: "EX_027",
      name: "descendingScale",
      desc: "descendingScaleDesc",
      category: "agility",
      key_center: "C4",
      tempo_bpm: 90,
      time_signature: "4/4",
      notes: [{ type: "note", semitone: 12, duration: 1, lyric: "Ah" }, { type: "note", semitone: 11, duration: 1, lyric: "Ah" }, { type: "note", semitone: 9, duration: 1, lyric: "Ah" }, { type: "note", semitone: 7, duration: 1, lyric: "Ah" }, { type: "note", semitone: 5, duration: 1, lyric: "Ah" }, { type: "note", semitone: 4, duration: 1, lyric: "Ah" }, { type: "note", semitone: 2, duration: 1, lyric: "Ah" }, { type: "note", semitone: 0, duration: 2, lyric: "Ah" }]
    },
    {
      exercise_id: "EX_028",
      name: "descendingArpeggio",
      desc: "descendingArpeggioDesc",
      category: "agility",
      key_center: "C4",
      tempo_bpm: 100,
      time_signature: "4/4",
      notes: [{ type: "note", semitone: 12, duration: 1, lyric: "La" }, { type: "note", semitone: 7, duration: 1, lyric: "La" }, { type: "note", semitone: 4, duration: 1, lyric: "La" }, { type: "note", semitone: 0, duration: 2, lyric: "La" }]
    },
    {
      exercise_id: "ALT_001",
      name: "harmonicMinor",
      desc: "harmonicMinorDesc",
      category: "agility",
      key_center: "C4",
      tempo_bpm: 100,
      time_signature: "4/4",
      notes: [{ type: "note", semitone: 0, duration: 0.5, lyric: "La" }, { type: "note", semitone: 2, duration: 0.5, lyric: "La" }, { type: "note", semitone: 3, duration: 0.5, lyric: "La" }, { type: "note", semitone: 5, duration: 0.5, lyric: "La" }, { type: "note", semitone: 7, duration: 0.5, lyric: "La" }, { type: "note", semitone: 8, duration: 0.5, lyric: "La" }, { type: "note", semitone: 11, duration: 0.5, lyric: "La" }, { type: "note", semitone: 12, duration: 0.5, lyric: "La" }, { type: "note", semitone: 11, duration: 0.5, lyric: "La" }, { type: "note", semitone: 8, duration: 0.5, lyric: "La" }, { type: "note", semitone: 7, duration: 0.5, lyric: "La" }, { type: "note", semitone: 5, duration: 0.5, lyric: "La" }, { type: "note", semitone: 3, duration: 0.5, lyric: "La" }, { type: "note", semitone: 2, duration: 0.5, lyric: "La" }, { type: "note", semitone: 0, duration: 2, lyric: "La" }]
    },
    {
      exercise_id: "ALT_003",
      name: "wholeToneScale",
      desc: "wholeToneScaleDesc",
      category: "agility",
      key_center: "C4",
      tempo_bpm: 90,
      time_signature: "4/4",
      notes: [{ type: "note", semitone: 0, duration: 1, lyric: "Ah" }, { type: "note", semitone: 2, duration: 1, lyric: "Ah" }, { type: "note", semitone: 4, duration: 1, lyric: "Ah" }, { type: "note", semitone: 6, duration: 1, lyric: "Ah" }, { type: "note", semitone: 8, duration: 1, lyric: "Ah" }, { type: "note", semitone: 10, duration: 1, lyric: "Ah" }, { type: "note", semitone: 12, duration: 2, lyric: "Ah" }]
    },
    {
      exercise_id: "ALT_004",
      name: "majorPentatonic",
      desc: "majorPentatonicDesc",
      category: "agility",
      key_center: "C4",
      tempo_bpm: 100,
      time_signature: "4/4",
      notes: [{ type: "note", semitone: 0, duration: 1, lyric: "Oh" }, { type: "note", semitone: 2, duration: 1, lyric: "Oh" }, { type: "note", semitone: 4, duration: 1, lyric: "Oh" }, { type: "note", semitone: 7, duration: 1, lyric: "Oh" }, { type: "note", semitone: 9, duration: 1, lyric: "Oh" }, { type: "note", semitone: 12, duration: 2, lyric: "Oh" }]
    },
    {
      exercise_id: "FAM_003",
      name: "dominantSeventhArp",
      desc: "dominantSeventhArpDesc",
      category: "style",
      key_center: "C4",
      tempo_bpm: 100,
      time_signature: "4/4",
      notes: [{ type: "note", semitone: 0, duration: 1, lyric: "Nay" }, { type: "note", semitone: 4, duration: 1, lyric: "Nay" }, { type: "note", semitone: 7, duration: 1, lyric: "Nay" }, { type: "note", semitone: 10, duration: 1, lyric: "Nay" }, { type: "note", semitone: 12, duration: 1.5, lyric: "Nay" }, { type: "note", semitone: 10, duration: 1, lyric: "Nay" }, { type: "note", semitone: 7, duration: 1, lyric: "Nay" }, { type: "note", semitone: 4, duration: 1, lyric: "Nay" }, { type: "note", semitone: 0, duration: 2, lyric: "Nay" }]
    },
    {
      exercise_id: "ALT_002",
      name: "bluesScale",
      desc: "bluesScaleDesc",
      category: "style",
      key_center: "C4",
      tempo_bpm: 90,
      time_signature: "4/4",
      notes: [{ type: "note", semitone: 0, duration: 1, lyric: "Bah" }, { type: "note", semitone: 3, duration: 1, lyric: "Da" }, { type: "note", semitone: 5, duration: 1, lyric: "Bah" }, { type: "note", semitone: 6, duration: 1, lyric: "Da" }, { type: "note", semitone: 7, duration: 1, lyric: "Bah" }, { type: "note", semitone: 10, duration: 1, lyric: "Da" }, { type: "note", semitone: 12, duration: 3, lyric: "Bah" }]
    },
    {
      exercise_id: "EX_031",
      name: "jazzSixthScat",
      desc: "jazzSixthScatDesc",
      category: "style",
      key_center: "C4",
      tempo_bpm: 100,
      time_signature: "4/4",
      notes: [{ type: "note", semitone: 0, duration: 0.5, lyric: "Doo" }, { type: "note", semitone: 4, duration: 0.5, lyric: "Bah" }, { type: "note", semitone: 7, duration: 0.5, lyric: "Doo" }, { type: "note", semitone: 9, duration: 0.5, lyric: "Bah" }, { type: "note", semitone: 12, duration: 0.5, lyric: "Dat" }, { type: "note", semitone: 9, duration: 0.5, lyric: "Bah" }, { type: "note", semitone: 7, duration: 0.5, lyric: "Doo" }, { type: "note", semitone: 4, duration: 0.5, lyric: "Bah" }, { type: "note", semitone: 0, duration: 2, lyric: "Doo" }]
    },
    // Pitch & Intonation
    {
      exercise_id: "EX_004",
      name: "octaveJumps",
      desc: "octaveJumpsDesc",
      category: "ear",
      key_center: "C4",
      tempo_bpm: 90,
      time_signature: "4/4",
      notes: [{ type: "note", semitone: 0, duration: 1, lyric: "Ah" }, { type: "note", semitone: 12, duration: 1, lyric: "Ah" }, { type: "note", semitone: 0, duration: 1, lyric: "Ah" }, { type: "note", semitone: 12, duration: 1, lyric: "Ah" }, { type: "note", semitone: 0, duration: 2, lyric: "Ah" }]
    },
    {
      exercise_id: "EX_006",
      name: "thirdIntervals",
      desc: "thirdIntervalsDesc",
      category: "ear",
      key_center: "C4",
      tempo_bpm: 100,
      time_signature: "4/4",
      notes: [{ type: "note", semitone: 0, duration: 1, lyric: "La" }, { type: "note", semitone: 4, duration: 1, lyric: "La" }, { type: "note", semitone: 0, duration: 1, lyric: "La" }, { type: "note", semitone: 4, duration: 1, lyric: "La" }, { type: "note", semitone: 0, duration: 1, lyric: "La" }, { type: "note", semitone: 4, duration: 1, lyric: "La" }, { type: "note", semitone: 0, duration: 2, lyric: "La" }]
    },
    {
      exercise_id: "EX_021",
      name: "minorThirdIntervals",
      desc: "minorThirdIntervalsDesc",
      category: "ear",
      key_center: "C4",
      tempo_bpm: 100,
      time_signature: "4/4",
      notes: [{ type: "note", semitone: 0, duration: 1, lyric: "La" }, { type: "note", semitone: 3, duration: 1, lyric: "La" }, { type: "note", semitone: 0, duration: 1, lyric: "La" }, { type: "note", semitone: 3, duration: 1, lyric: "La" }, { type: "note", semitone: 0, duration: 1, lyric: "La" }, { type: "note", semitone: 3, duration: 1, lyric: "La" }, { type: "note", semitone: 0, duration: 2, lyric: "La" }]
    },
    {
      exercise_id: "EX_016",
      name: "sixthIntervals",
      desc: "sixthIntervalsDesc",
      category: "ear",
      key_center: "C4",
      tempo_bpm: 90,
      time_signature: "4/4",
      notes: [{ type: "note", semitone: 0, duration: 1, lyric: "Ah" }, { type: "note", semitone: 9, duration: 1, lyric: "Ah" }, { type: "note", semitone: 0, duration: 1, lyric: "Ah" }, { type: "note", semitone: 9, duration: 1, lyric: "Ah" }, { type: "note", semitone: 0, duration: 2, lyric: "Ah" }]
    },
    {
      exercise_id: "EX_022",
      name: "scaleOfFifths",
      desc: "scaleOfFifthsDesc",
      category: "ear",
      key_center: "C4",
      tempo_bpm: 90,
      time_signature: "4/4",
      notes: [{ type: "note", semitone: 0, duration: 1, lyric: "Ah" }, { type: "note", semitone: 7, duration: 1, lyric: "Ah" }, { type: "note", semitone: 2, duration: 1, lyric: "Ah" }, { type: "note", semitone: 9, duration: 1, lyric: "Ah" }, { type: "note", semitone: 4, duration: 1, lyric: "Ah" }, { type: "note", semitone: 11, duration: 1, lyric: "Ah" }, { type: "note", semitone: 5, duration: 1, lyric: "Ah" }, { type: "note", semitone: 12, duration: 2, lyric: "Ah" }]
    },
    {
      exercise_id: "EX_032",
      name: "tritoneChallenge",
      desc: "tritoneChallengeDesc",
      category: "ear",
      key_center: "C4",
      tempo_bpm: 80,
      time_signature: "4/4",
      notes: [{ type: "note", semitone: 0, duration: 1, lyric: "La" }, { type: "note", semitone: 6, duration: 1, lyric: "La" }, { type: "note", semitone: 0, duration: 1, lyric: "La" }, { type: "note", semitone: 6, duration: 1, lyric: "La" }, { type: "note", semitone: 0, duration: 2, lyric: "La" }]
    },
    {
      exercise_id: "EX_008",
      name: "chromaticScale",
      desc: "chromaticScaleDesc",
      category: "ear",
      key_center: "C4",
      tempo_bpm: 120,
      time_signature: "4/4",
      notes: [{ type: "note", semitone: 0, duration: 0.5, lyric: "La" }, { type: "note", semitone: 1, duration: 0.5, lyric: "La" }, { type: "note", semitone: 2, duration: 0.5, lyric: "La" }, { type: "note", semitone: 3, duration: 0.5, lyric: "La" }, { type: "note", semitone: 4, duration: 0.5, lyric: "La" }, { type: "note", semitone: 5, duration: 0.5, lyric: "La" }, { type: "note", semitone: 6, duration: 0.5, lyric: "La" }, { type: "note", semitone: 7, duration: 0.5, lyric: "La" }, { type: "note", semitone: 8, duration: 0.5, lyric: "La" }, { type: "note", semitone: 9, duration: 0.5, lyric: "La" }, { type: "note", semitone: 10, duration: 0.5, lyric: "La" }, { type: "note", semitone: 11, duration: 0.5, lyric: "La" }, { type: "note", semitone: 12, duration: 2, lyric: "La" }]
    }
  ];
  var MVP_EXERCISES = [
    EXERCISES.find((e) => e.exercise_id === "EX_012"),
    EXERCISES.find((e) => e.exercise_id === "EX_007")
  ];
  var ROUTINES = [
    // Warmup Routines
    {
      id: "warmup-quick",
      name: "warmUpQuick",
      description: "warmUpQuickDesc",
      exerciseIds: ["FAM_002", "COOL_001"],
      benefits: "warmUpQuickBenefits",
      estimatedMinutes: 3
    },
    {
      id: "warmup-complete",
      name: "warmUpComplete",
      description: "warmUpCompleteDesc",
      exerciseIds: ["FAM_002", "COOL_001", "EX_012", "EX_007"],
      benefits: "warmUpCompleteBenefits",
      estimatedMinutes: 8
    },
    // Technique Routines
    {
      id: "resonance-focus",
      name: "resonanceFocus",
      description: "resonanceFocusDesc",
      exerciseIds: ["EX_012", "EX_020", "FAM_007"],
      benefits: "resonanceFocusBenefits",
      estimatedMinutes: 6
    },
    {
      id: "staccato-control",
      name: "staccatoControl",
      description: "staccatoControlDesc",
      exerciseIds: ["FAM_006", "EX_030", "EX_007"],
      benefits: "staccatoControlBenefits",
      estimatedMinutes: 5
    },
    // Agility Routines
    {
      id: "agility-scales",
      name: "agilityScales",
      description: "agilityScalesDesc",
      exerciseIds: ["FAM_005", "FAM_001", "FAM_004"],
      benefits: "agilityScalesBenefits",
      estimatedMinutes: 7
    },
    {
      id: "arpeggios-master",
      name: "arpeggiosMaster",
      description: "arpeggiosMasterDesc",
      exerciseIds: ["EX_007", "EX_010", "EX_028", "ALT_001"],
      benefits: "arpeggiosMasterBenefits",
      estimatedMinutes: 8
    },
    // Ear Training Routines
    {
      id: "interval-training",
      name: "intervalTraining",
      description: "intervalTrainingDesc",
      exerciseIds: ["EX_006", "EX_021", "EX_016", "EX_004"],
      benefits: "intervalTrainingBenefits",
      estimatedMinutes: 7
    },
    {
      id: "pitch-precision",
      name: "pitchPrecision",
      description: "pitchPrecisionDesc",
      exerciseIds: ["EX_022", "EX_032", "EX_008"],
      benefits: "pitchPrecisionBenefits",
      estimatedMinutes: 6
    },
    // Style Routines
    {
      id: "jazz-blues",
      name: "jazzBlues",
      description: "jazzBluesDesc",
      exerciseIds: ["ALT_002", "FAM_003", "EX_031"],
      benefits: "jazzBluesBenefits",
      estimatedMinutes: 6
    },
    {
      id: "belting-power",
      name: "beltingPower",
      description: "beltingPowerDesc",
      exerciseIds: ["EX_026", "FAM_007", "EX_004"],
      benefits: "beltingPowerBenefits",
      estimatedMinutes: 5
    }
  ];
  var WHITE_KEY_SLOT_WIDTH = 60;
  var WHITE_KEY_SIZE = 54;
  var BLACK_KEY_SIZE = 36;
  var V_PADDING = 22;
  var LANGUAGES = [
    { code: "en", name: "English", flag: "\u{1F1FA}\u{1F1F8}" },
    { code: "pt-BR", name: "Portugu\xEAs Brasileiro", flag: "\u{1F1E7}\u{1F1F7}" }
  ];
  var THEMES = [
    {
      id: "violet-wave",
      name: "Violet Wave",
      visualizer: [
        { name: "orb1", gradient: "radial-gradient(circle, #a78bfa, #8b5cf6 80%, transparent 100%)" },
        { name: "orb2", gradient: "radial-gradient(circle, #f0abfc, #d946ef 80%, transparent 100%)" },
        { name: "orb3", gradient: "radial-gradient(circle, #fde047, #facc15 80%, transparent 100%)" },
        { name: "orb4", gradient: "radial-gradient(circle, #a78bfa, #8b5cf6 80%, transparent 100%)" },
        { name: "orb5", gradient: "radial-gradient(circle, #f0abfc, #d946ef 80%, transparent 100%)" },
        { name: "orb6", gradient: "radial-gradient(circle, #fde047, #facc15 80%, transparent 100%)" }
      ],
      button: { from: "from-violet-500", via: "via-fuchsia-500", to: "to-yellow-300", shadow: "shadow-fuchsia-500/40", shadowRgb: "217, 70, 239" },
      gradientText: { from: "from-violet-600", to: "to-fuchsia-600", darkFrom: "dark:from-violet-400", darkTo: "dark:to-fuchsia-400" },
      resultsRange: { from: "from-violet-500", to: "to-fuchsia-500" },
      progress: { from: "from-violet-400", to: "to-fuchsia-500" }
    },
    {
      id: "ocean-blue",
      name: "Ocean Blue",
      visualizer: [
        { name: "orb1", gradient: "radial-gradient(circle, #7dd3fc, #38bdf8 80%, transparent 100%)" },
        { name: "orb2", gradient: "radial-gradient(circle, #67e8f9, #22d3ee 80%, transparent 100%)" },
        { name: "orb3", gradient: "radial-gradient(circle, #60a5fa, #3b82f6 80%, transparent 100%)" },
        { name: "orb4", gradient: "radial-gradient(circle, #7dd3fc, #38bdf8 80%, transparent 100%)" },
        { name: "orb5", gradient: "radial-gradient(circle, #67e8f9, #22d3ee 80%, transparent 100%)" },
        { name: "orb6", gradient: "radial-gradient(circle, #60a5fa, #3b82f6 80%, transparent 100%)" }
      ],
      button: { from: "from-sky-400", via: "via-cyan-400", to: "to-blue-500", shadow: "shadow-cyan-400/40", shadowRgb: "34, 211, 238" },
      gradientText: { from: "from-sky-600", to: "to-blue-600", darkFrom: "dark:from-sky-400", darkTo: "dark:to-blue-400" },
      resultsRange: { from: "from-sky-500", to: "to-blue-500" },
      progress: { from: "from-sky-400", to: "to-blue-500" }
    },
    {
      id: "forest-green",
      name: "Forest Green",
      visualizer: [
        { name: "orb1", gradient: "radial-gradient(circle, #6ee7b7, #34d399 80%, transparent 100%)" },
        { name: "orb2", gradient: "radial-gradient(circle, #5eead4, #14b8a6 80%, transparent 100%)" },
        { name: "orb3", gradient: "radial-gradient(circle, #4ade80, #16a34a 80%, transparent 100%)" },
        { name: "orb4", gradient: "radial-gradient(circle, #6ee7b7, #34d399 80%, transparent 100%)" },
        { name: "orb5", gradient: "radial-gradient(circle, #5eead4, #14b8a6 80%, transparent 100%)" },
        { name: "orb6", gradient: "radial-gradient(circle, #4ade80, #16a34a 80%, transparent 100%)" }
      ],
      button: { from: "from-emerald-400", via: "via-teal-500", to: "to-green-600", shadow: "shadow-teal-500/40", shadowRgb: "20, 184, 166" },
      gradientText: { from: "from-emerald-700", to: "to-teal-600", darkFrom: "dark:from-emerald-400", darkTo: "dark:to-teal-400" },
      resultsRange: { from: "from-emerald-500", to: "to-teal-500" },
      progress: { from: "from-emerald-400", to: "to-teal-500" }
    },
    {
      id: "sunset-orange",
      name: "Sunset Orange",
      visualizer: [
        { name: "orb1", gradient: "radial-gradient(circle, #fcd34d, #facc15 80%, transparent 100%)" },
        { name: "orb2", gradient: "radial-gradient(circle, #fb923c, #f97316 80%, transparent 100%)" },
        { name: "orb3", gradient: "radial-gradient(circle, #f87171, #ef4444 80%, transparent 100%)" },
        { name: "orb4", gradient: "radial-gradient(circle, #fcd34d, #facc15 80%, transparent 100%)" },
        { name: "orb5", gradient: "radial-gradient(circle, #fb923c, #f97316 80%, transparent 100%)" },
        { name: "orb6", gradient: "radial-gradient(circle, #f87171, #ef4444 80%, transparent 100%)" }
      ],
      button: { from: "from-amber-400", via: "via-orange-500", to: "to-red-500", shadow: "shadow-orange-500/40", shadowRgb: "249, 115, 22" },
      gradientText: { from: "from-amber-600", to: "to-orange-600", darkFrom: "dark:from-amber-400", darkTo: "dark:to-orange-400" },
      resultsRange: { from: "from-amber-500", to: "to-orange-500" },
      progress: { from: "from-amber-400", to: "to-orange-500" }
    }
  ];

  // utils.ts
  function generateNotes(startSemitone, endSemitone) {
    const notes = [];
    for (let s = startSemitone; s <= endSemitone; s++) {
      const c4Offset = s;
      const octave = Math.floor(c4Offset / 12) + 4;
      const noteIndex = (c4Offset % 12 + 12) % 12;
      notes.push({
        semitone: s,
        name: NOTE_NAMES[noteIndex] + octave,
        isSharp: IS_SHARP[noteIndex]
      });
    }
    return notes;
  }
  function frequencyToNote(frequency) {
    if (frequency <= 0)
      return null;
    const preciseSemitone = 12 * Math.log2(frequency / BASE_FREQ);
    const roundedSemitone = Math.round(preciseSemitone);
    const detune = (preciseSemitone - roundedSemitone) * 100;
    const noteIndex = (roundedSemitone % 12 + 12) % 12;
    const noteName = NOTE_NAMES[noteIndex];
    const octave = Math.floor(roundedSemitone / 12) + 4;
    return {
      name: noteName + octave,
      semitone: roundedSemitone,
      preciseSemitone,
      detune,
      // Add isSharp to match the Note interface
      isSharp: IS_SHARP[noteIndex]
    };
  }
  function semitoneToNoteName(semitone) {
    const roundedSemitone = Math.round(semitone);
    const noteIndex = (roundedSemitone % 12 + 12) % 12;
    const octave = Math.floor(roundedSemitone / 12) + 4;
    return `${NOTE_NAMES[noteIndex]}${octave}`;
  }
  function noteToFrequency(semitone) {
    return BASE_FREQ * Math.pow(2, semitone / 12);
  }
  var lerp = (start, end, amt) => (1 - amt) * start + amt * end;

  // exerciseUtils.ts
  function parseKeyCenter(keyCenter) {
    const noteMap = {
      "C": 0,
      "C#": 1,
      "Db": 1,
      "D": 2,
      "D#": 3,
      "Eb": 3,
      "E": 4,
      "F": 5,
      "F#": 6,
      "Gb": 6,
      "G": 7,
      "G#": 8,
      "Ab": 8,
      "A": 9,
      "A#": 10,
      "Bb": 10,
      "B": 11
    };
    const noteName = keyCenter.replace(/\d+$/, "");
    return noteMap[noteName] || 0;
  }
  function midiToLegacy(midi) {
    const pattern = [];
    const durations = [];
    const keyOffset = parseKeyCenter(midi.key_center);
    midi.notes.forEach((note) => {
      if (note.type === "note" && note.semitone !== void 0) {
        const totalSemitone = note.semitone + keyOffset;
        pattern.push(totalSemitone);
        durations.push(note.duration);
      } else if (note.type === "rest") {
        pattern.push(-1);
        durations.push(note.duration);
      }
    });
    return {
      id: parseInt(midi.exercise_id.replace(/\D/g, "")) || 9999,
      name: midi.name,
      desc: midi.name,
      pattern,
      bpm: midi.tempo_bpm,
      duration: durations && durations.length > 0 ? durations[0] : 1,
      // First duration as default, fallback to 1
      durations,
      instructions: midi.instructions || "",
      category: midi.category,
      isAIGenerated: midi.isAIGenerated || false
    };
  }
  function getExercisePattern(exercise) {
    if (isMidiExercise(exercise)) {
      const legacy = midiToLegacy(exercise);
      return legacy.pattern;
    }
    return exercise.pattern;
  }
  function getExerciseDurations(exercise) {
    if (isMidiExercise(exercise)) {
      const legacy = midiToLegacy(exercise);
      return legacy.durations || [];
    }
    return exercise.durations || Array(exercise.pattern.length).fill(exercise.duration);
  }
  function getExerciseBPM(exercise) {
    if (isMidiExercise(exercise)) {
      return exercise.tempo_bpm;
    }
    return exercise.bpm || 90;
  }
  function getExerciseId(exercise) {
    if (isMidiExercise(exercise)) {
      return exercise.exercise_id;
    }
    return exercise.id.toString();
  }

  // components/Piano.tsx
  var import_react2 = __toESM(require_react());

  // components/PianoKey.tsx
  var import_react = __toESM(require_react());
  var import_jsx_runtime = __toESM(require_jsx_runtime());
  var PianoKey = (0, import_react.forwardRef)(({ note, onClick, isSelected, isInRange, style, mousePos, centerProximity }, ref) => {
    const keyRef = (0, import_react.useRef)(null);
    const isWhite = !note.isSharp;
    const animatedValues = (0, import_react.useRef)({
      translateY: 0,
      scale: 1,
      shadowY: 2,
      shadowBlur: 12,
      glowOpacity: 0,
      glowSize: 12,
      reflectionX: 60,
      reflectionY: 45,
      reflectionOpacity: 0.7
    });
    const animationFrameRef = (0, import_react.useRef)(null);
    const animate = (0, import_react.useCallback)(() => {
      if (!keyRef.current)
        return;
      let target = {
        translateY: 0,
        scale: 1,
        shadowY: 2,
        shadowBlur: 12,
        glowOpacity: 0,
        glowSize: 12,
        reflectionX: 60,
        reflectionY: 45,
        reflectionOpacity: 0.7
      };
      const baseScale = isSelected ? 1.05 : 0.7;
      const maxScaleIncrease = 0.3;
      const proximityScaleFactor = baseScale + centerProximity * maxScaleIncrease;
      target.scale = proximityScaleFactor;
      const opacityFactor = 1;
      if (isInRange && !isSelected) {
        target.glowOpacity = 0.4;
        target.glowSize = 18;
      }
      if (isSelected) {
        const pulse = (Math.sin(performance.now() / 250) + 1) / 2;
        target.glowOpacity = 0.5 + pulse * 0.5;
        target.glowSize = 25 + pulse * 15;
        target.translateY = 2;
      }
      if (mousePos) {
        const rect = keyRef.current.getBoundingClientRect();
        const keyCenterX = rect.left + rect.width / 2;
        const keyCenterY = rect.top + rect.height / 2;
        const dx = mousePos.x - keyCenterX;
        const dy = mousePos.y - keyCenterY;
        const distance = Math.sqrt(dx * dx + dy * dy);
        const maxDistance = 250;
        if (distance < maxDistance) {
          const proximity = 1 - distance / maxDistance;
          target.translateY = (isSelected ? 2 : 0) + proximity * 4;
          target.scale = target.scale + proximity * 0.08;
          target.reflectionX = 60 + dx * 0.05;
          target.reflectionY = 45 - dy * 0.05;
          target.shadowY = 2 - proximity;
          target.shadowBlur = 12 - proximity * 6;
          target.glowOpacity = (isInRange ? 0.4 : 0) + proximity * 0.8;
          target.glowSize = (isInRange ? 18 : 12) + proximity * 25;
          target.reflectionOpacity = 0.7 + proximity * 0.3;
        }
      }
      const vals = animatedValues.current;
      const smoothness = 0.1;
      vals.translateY = lerp(vals.translateY, target.translateY, smoothness);
      vals.scale = lerp(vals.scale, target.scale, smoothness);
      vals.shadowY = lerp(vals.shadowY, target.shadowY, smoothness);
      vals.shadowBlur = lerp(vals.shadowBlur, target.shadowBlur, smoothness);
      vals.glowOpacity = lerp(vals.glowOpacity, target.glowOpacity, smoothness);
      vals.glowSize = lerp(vals.glowSize, target.glowSize, smoothness);
      vals.reflectionX = lerp(vals.reflectionX, target.reflectionX, smoothness);
      vals.reflectionY = lerp(vals.reflectionY, target.reflectionY, smoothness);
      vals.reflectionOpacity = lerp(vals.reflectionOpacity, target.reflectionOpacity, smoothness);
      const glowColor = isSelected || isInRange ? "139, 92, 246" : "167, 139, 250";
      keyRef.current.style.transform = `translateY(${vals.translateY}px) scale(${vals.scale})`;
      keyRef.current.style.boxShadow = `0px ${vals.shadowY}px ${vals.shadowBlur}px -5px rgba(0, 0, 0, 0.25), 0 0 ${vals.glowSize}px rgba(${glowColor}, ${vals.glowOpacity}), 0 0 10px rgba(255, 255, 255, ${vals.glowOpacity * 0.7})`;
      keyRef.current.style.setProperty("--reflection-x", `${vals.reflectionX}%`);
      keyRef.current.style.setProperty("--reflection-y", `${vals.reflectionY}%`);
      keyRef.current.style.setProperty("--reflection-opacity", `${vals.reflectionOpacity}`);
      keyRef.current.style.opacity = "1";
      animationFrameRef.current = requestAnimationFrame(animate);
    }, [mousePos, isInRange, isSelected, centerProximity, isWhite]);
    (0, import_react.useEffect)(() => {
      animationFrameRef.current = requestAnimationFrame(animate);
      return () => {
        if (animationFrameRef.current) {
          cancelAnimationFrame(animationFrameRef.current);
        }
      };
    }, [animate]);
    const whiteGlassClasses = "bg-gradient-to-b from-white to-white/20";
    const blackGlassClasses = "bg-gradient-to-b from-gray-700/80 to-black/90 border-white/20";
    const glassClasses = isWhite ? whiteGlassClasses : blackGlassClasses;
    const reflectionClass = "before:content-[''] before:absolute before:inset-0 before:rounded-full before:bg-gradient-radial before:from-white/80 before:to-transparent before:to-60% before:opacity-[var(--reflection-opacity,0.7)] before:[background-position:var(--reflection-x,60%)_var(--reflection-y,45%)] before:[background-size:150%_150%]";
    const inRangeClasses = isInRange && !isSelected ? "border-violet-400/30" : "border-transparent";
    return /* @__PURE__ */ (0, import_jsx_runtime.jsxs)("div", { ref, style, className: "absolute cursor-pointer group", children: [
      /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(
        "button",
        {
          ref: keyRef,
          onClick: () => onClick(note),
          className: `relative w-full h-full rounded-full shadow-lg shadow-black/15 backdrop-blur-md border will-change-transform ${glassClasses} ${reflectionClass} ${inRangeClasses} focus:outline-none focus-visible:ring-2 focus-visible:ring-violet-500 focus-visible:ring-offset-2`,
          children: [
            /* @__PURE__ */ (0, import_jsx_runtime.jsx)("div", { className: "absolute inset-0 rounded-full shadow-[inset_0_1px_2px_rgba(255,255,255,0.5),inset_0_-2px_2px_rgba(0,0,0,0.15)]" }),
            isSelected && /* @__PURE__ */ (0, import_jsx_runtime.jsx)("div", { className: "absolute -inset-1 rounded-full border-2 border-violet-500 opacity-80 animate-pulse" }),
            isWhite && /* @__PURE__ */ (0, import_jsx_runtime.jsx)(
              "span",
              {
                className: `absolute inset-0 flex items-center justify-center text-sm font-bold pointer-events-none transition-colors duration-200 ${isInRange ? "text-violet-900" : "text-slate-800"} group-hover:text-violet-700`,
                style: { textShadow: "0 1px 1px rgba(255,255,255,0.7)" },
                children: note.name
              }
            )
          ]
        }
      ),
      !isWhite && /* @__PURE__ */ (0, import_jsx_runtime.jsx)("span", { className: `absolute -bottom-5 left-1/2 -translate-x-1/2 text-xs font-medium pointer-events-none transition-colors duration-200 ${isInRange ? "text-violet-700" : "text-slate-500"} group-hover:text-violet-600`, children: note.name })
    ] });
  });
  var PianoKey_default = import_react.default.memo(PianoKey);

  // components/Piano.tsx
  var import_jsx_runtime2 = __toESM(require_jsx_runtime());
  var Piano = ({ notes, onKeyClick, vocalRange, currentTheme }) => {
    const scrollContainerRef = (0, import_react2.useRef)(null);
    const c4KeyRef = (0, import_react2.useRef)(null);
    const [mousePos, setMousePos] = (0, import_react2.useState)(null);
    const [scrollCenterOffset, setScrollCenterOffset] = (0, import_react2.useState)(0);
    const [viewportWidth, setViewportWidth] = (0, import_react2.useState)(0);
    const whiteKeys = (0, import_react2.useMemo)(() => notes.filter((n) => !n.isSharp), [notes]);
    const pianoWidth = whiteKeys.length * WHITE_KEY_SLOT_WIDTH;
    (0, import_react2.useLayoutEffect)(() => {
      if (c4KeyRef.current && scrollContainerRef.current) {
        const scrollEl = scrollContainerRef.current;
        if (scrollEl.clientWidth > 0) {
          const centerC4 = c4KeyRef.current.offsetLeft + c4KeyRef.current.offsetWidth / 2;
          scrollEl.scrollLeft = centerC4 - scrollEl.clientWidth / 2;
        }
      }
    }, [notes, viewportWidth]);
    (0, import_react2.useEffect)(() => {
      const scrollEl = scrollContainerRef.current;
      if (!scrollEl)
        return;
      const updateState = () => {
        setViewportWidth(scrollEl.clientWidth);
        setScrollCenterOffset(scrollEl.scrollLeft + scrollEl.clientWidth / 2);
      };
      updateState();
      scrollEl.addEventListener("scroll", updateState, { passive: true });
      const resizeObserver = new ResizeObserver(updateState);
      resizeObserver.observe(scrollEl);
      return () => {
        scrollEl.removeEventListener("scroll", updateState);
        resizeObserver.disconnect();
      };
    }, []);
    const handleMouseMove = (0, import_react2.useCallback)((e) => setMousePos({ x: e.clientX, y: e.clientY }), []);
    const handleMouseLeave = (0, import_react2.useCallback)(() => setMousePos(null), []);
    const handleArrowScroll = (0, import_react2.useCallback)((direction) => {
      const container = scrollContainerRef.current;
      if (!container)
        return;
      const scrollAmount = container.clientWidth * 0.7;
      container.scrollBy({
        left: direction === "left" ? -scrollAmount : scrollAmount,
        behavior: "smooth"
      });
    }, []);
    return /* @__PURE__ */ (0, import_jsx_runtime2.jsxs)("div", { className: `relative w-full group my-6 mx-auto`, children: [
      /* @__PURE__ */ (0, import_jsx_runtime2.jsx)(
        "button",
        {
          onClick: () => handleArrowScroll("left"),
          "aria-label": "Scroll left",
          className: "btn-interactive absolute top-1/2 -translate-y-1/2 left-0 z-20 w-10 h-10 flex items-center justify-center rounded-full bg-white/50 dark:bg-black/20 backdrop-blur-md border border-slate-200/50 dark:border-slate-700 shadow-lg hover:bg-white dark:hover:bg-black/40 transition-all duration-300 opacity-0 group-hover:opacity-100",
          children: /* @__PURE__ */ (0, import_jsx_runtime2.jsx)("svg", { className: "w-5 h-5 text-slate-700 dark:text-slate-300", fill: "none", viewBox: "0 0 24 24", stroke: "currentColor", children: /* @__PURE__ */ (0, import_jsx_runtime2.jsx)("path", { strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 2, d: "M15 19l-7-7 7-7" }) })
        }
      ),
      /* @__PURE__ */ (0, import_jsx_runtime2.jsx)(
        "button",
        {
          onClick: () => handleArrowScroll("right"),
          "aria-label": "Scroll right",
          className: "btn-interactive absolute top-1/2 -translate-y-1/2 right-0 z-20 w-10 h-10 flex items-center justify-center rounded-full bg-white/50 dark:bg-black/20 backdrop-blur-md border border-slate-200/50 dark:border-slate-700 shadow-lg hover:bg-white dark:hover:bg-black/40 transition-all duration-300 opacity-0 group-hover:opacity-100",
          children: /* @__PURE__ */ (0, import_jsx_runtime2.jsx)("svg", { className: "w-5 h-5 text-slate-700 dark:text-slate-300", fill: "none", viewBox: "0 0 24 24", stroke: "currentColor", children: /* @__PURE__ */ (0, import_jsx_runtime2.jsx)("path", { strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 2, d: "M9 5l7 7-7 7" }) })
        }
      ),
      /* @__PURE__ */ (0, import_jsx_runtime2.jsx)("div", { className: `relative w-full bg-white/20 dark:bg-black/20 backdrop-blur-lg p-2 sm:p-4 rounded-full shadow-[0_12px_30px_-12px_rgba(0,0,0,0.2),inset_-1px_1px_8px_rgba(0,0,0,0.08),inset_2px_-2px_4px_rgba(255,255,255,0.5)] dark:shadow-[0_12px_30px_-12px_rgba(0,0,0,0.5),inset_-1px_1px_8px_rgba(255,255,255,0.08),inset_2px_-2px_4px_rgba(0,0,0,0.5)] border border-slate-300/60 dark:border-slate-700/60`, children: /* @__PURE__ */ (0, import_jsx_runtime2.jsx)("div", { className: "relative", children: /* @__PURE__ */ (0, import_jsx_runtime2.jsx)(
        "div",
        {
          ref: scrollContainerRef,
          className: "overflow-x-scroll scrollbar-hide rounded-full overflow-y-visible",
          onMouseMove: handleMouseMove,
          onMouseLeave: handleMouseLeave,
          style: {
            maskImage: "linear-gradient(to right, transparent, black 80px, black calc(100% - 80px), transparent)",
            WebkitMaskImage: "linear-gradient(to right, transparent, black 80px, black calc(100% - 80px), transparent)"
          },
          children: /* @__PURE__ */ (0, import_jsx_runtime2.jsx)("div", { className: "relative", style: { width: `${pianoWidth}px`, height: `${WHITE_KEY_SIZE + V_PADDING * 2}px` }, children: notes.map((note) => {
            const isSelected = vocalRange.start?.semitone === note.semitone || vocalRange.end?.semitone === note.semitone;
            const isInRange = vocalRange.start && vocalRange.end && note.semitone >= vocalRange.start.semitone && note.semitone <= vocalRange.end.semitone;
            const isC4 = note.semitone === 0;
            let leftPosition = 0;
            let keyWidth = note.isSharp ? BLACK_KEY_SIZE : WHITE_KEY_SIZE;
            if (note.isSharp) {
              const precedingWhiteKeyIndex = whiteKeys.findIndex((wk) => wk.semitone === note.semitone - 1);
              leftPosition = (precedingWhiteKeyIndex + 1) * WHITE_KEY_SLOT_WIDTH - BLACK_KEY_SIZE / 2;
            } else {
              const whiteKeyIndex = whiteKeys.findIndex((wk) => wk.semitone === note.semitone);
              leftPosition = whiteKeyIndex * WHITE_KEY_SLOT_WIDTH + (WHITE_KEY_SLOT_WIDTH - WHITE_KEY_SIZE) / 2;
            }
            const keyCenter = leftPosition + keyWidth / 2;
            const distanceToCenter = Math.abs(keyCenter - scrollCenterOffset);
            const maxDistance = viewportWidth / 2;
            const normalizedDistance = maxDistance > 0 ? Math.min(1, distanceToCenter / maxDistance) : 0;
            const centerProximity = 1 - Math.pow(normalizedDistance, 1.5);
            return /* @__PURE__ */ (0, import_jsx_runtime2.jsx)(
              PianoKey_default,
              {
                ref: isC4 && !note.isSharp ? c4KeyRef : null,
                note,
                onClick: onKeyClick,
                isSelected,
                isInRange: !!isInRange,
                mousePos,
                centerProximity,
                style: {
                  left: `${leftPosition}px`,
                  width: `${keyWidth}px`,
                  height: `${note.isSharp ? BLACK_KEY_SIZE : WHITE_KEY_SIZE}px`,
                  zIndex: note.isSharp ? 10 : 5,
                  top: `${note.isSharp ? (WHITE_KEY_SIZE - BLACK_KEY_SIZE) / 2 + V_PADDING : V_PADDING}px`
                }
              },
              note.semitone
            );
          }) })
        }
      ) }) })
    ] });
  };
  var Piano_default = import_react2.default.memo(Piano);

  // hooks/useTranslation.tsx
  var import_react3 = __toESM(require_react());

  // i18n.ts
  var translations = {
    en: {
      // General
      home: "Home",
      range: "Range",
      routines: "Routines",
      swipeRoutines: "\u2190 Swipe to see more routines \u2192",
      exercises: "Exercises",
      pitch: "Pitch",
      studies: "Studies",
      tokens: "Tokens",
      voxlabai: "VoxLab AI",
      settings: "Settings",
      cancel: "Cancel",
      nextStep: "Next Step",
      skipStep: "Skip Step",
      comingSoon: "Coming Soon",
      approxDuration: "Approx. Duration",
      benefits: "Benefits",
      beta: "Beta",
      favorites: "Favorites",
      save: "Save",
      saved: "Saved",
      edit: "Edit",
      saveChanges: "Save Changes",
      discardChanges: "Discard Changes",
      aiGenerated: "AI Generated",
      favoriteRoutines: "Favorite Routines",
      favoriteExercises: "Favorite Exercises",
      emptyFavoritesRoutines: "You haven't favorited any routines yet. Tap the star icon on a routine to add it here!",
      emptyFavoritesExercises: "You haven't favorited any exercises yet. Tap the button on an exercise to add it here!",
      tools: "Tools",
      instrumentTuner: "Instrument Tuner",
      tuning: "Tuning",
      chromatic: "Chromatic",
      standardGuitar: "Standard Guitar (EADGBe)",
      flat: "Flat",
      sharp: "Sharp",
      inTune: "In Tune",
      recordVideo: "Record Video Performance",
      accessStudiesPrompt: "Teacher's Assignments",
      recordVideoDesc: "Capture video of your practice sessions to review your technique and stage presence.",
      teacherStudiesDesc: "Access personalized exercises and lesson plans sent directly from your vocal coach.",
      importTokenTitle: "Import Token",
      importTokenDesc: "Add your token here to access the exercise routine created by your professor.",
      interactiveTheoryTitle: "Interactive Music Theory",
      interactiveTheoryDesc: "Learn and practice music theory concepts with engaging, hands-on exercises.",
      masterclassesTitle: "Video Masterclasses",
      masterclassesDesc: "Watch exclusive lessons and tutorials from world-renowned vocal coaches.",
      appVersion: "App Version",
      mvp: "MVP",
      fullFeatures: "Full",
      switchToFull: "Switch to Full Version",
      switchToMVP: "Switch to MVP Version",
      samplesLoaded: "{count} samples loaded successfully!",
      processing: "Processing...",
      loadingAudio: "Loading Audio...",
      greatJob: "Great Job!",
      replay: "Replay",
      backToMenu: "Back to Menu",
      restart: "Restart",
      activeInstrument: "Active Instrument",
      selectInstrument: "Select Instrument",
      noInstrumentsLoaded: "No instruments loaded",
      // Home View
      welcomeTitle: "VoxLab",
      welcomeSubtitle: "Your personal vocal training assistant.",
      helloSinger: "Hello, Singer!",
      betaTestInvite: "You have been invited to test the beta version of this app. Choose a version below. Click the yellow Feedback button at the end to share your suggestions. Try Immersive Mode for fullscreen. Results may vary by device and environment\u2014your testing is essential!",
      feedback: "Feedback",
      sendFeedback: "Send Feedback",
      yourFeedback: "Your Feedback",
      emailOptional: "Email (Optional)",
      feedbackSent: "Feedback sent! Thank you.",
      feedbackError: "Error sending feedback. Please try again.",
      letsPractice: "Select an option below to continue.",
      startPractice: "Start Practice",
      exitFullscreen: "Exit Fullscreen",
      enterFullscreen: "Enter Fullscreen",
      immersiveMode: "Immersive Mode",
      // Range View
      vocalRangeTitle: "Vocal Range",
      findYourRange: "Don't know your vocal range? Let's find it out.",
      startTest: "Start Test",
      iKnowMyRange: "I know my range",
      detectMyRange: "Detect my range",
      vocalRangePrompt: "Set your vocal range manually on the piano or let us detect it for you.",
      selectRangeOnPiano: "Click on the lowest and highest notes of your range.",
      goBack: "Go back",
      rangeNotSet: "Range not set",
      // Range Check Modal
      rangeCheckTitle: "Set Your Vocal Range",
      rangeCheckPrompt: "For the best results, exercises should be tailored to your voice. Would you like to set your vocal range now?",
      defineRange: "Define Range",
      continueAnyway: "Continue Anyway",
      returnToExercise: "Return to Exercise",
      returnToRoutine: "Return to Routine",
      // Routines View
      routinesTitle: "Routines",
      clickForDetails: "Click for details",
      // Warmup Routines
      warmUpQuick: "Quick Warm-up",
      warmUpQuickDesc: "A quick 3-minute routine with gentle descending exercises.",
      warmUpQuickBenefits: "Relaxes vocal cords, improves breath support.",
      warmUpComplete: "Complete Warm-up",
      warmUpCompleteDesc: "A comprehensive 8-minute warm-up for a full session.",
      warmUpCompleteBenefits: "Increases vocal flexibility, activates resonators, prepares for complex passages.",
      // Technique Routines
      resonanceFocus: "Resonance Focus",
      resonanceFocusDesc: "Develop a richer, more resonant vocal tone.",
      resonanceFocusBenefits: "Enhances vocal projection, improves tonal quality, reduces vocal strain.",
      staccatoControl: "Staccato Control",
      staccatoControlDesc: "Improve precision and breath control with articulated exercises.",
      staccatoControlBenefits: "Develops diaphragm control, improves articulation and timing.",
      // Agility Routines
      agilityScales: "Agility Scales",
      agilityScalesDesc: "Build speed and flexibility with progressive scale exercises.",
      agilityScalesBenefits: "Increases vocal speed, improves accuracy in fast passages.",
      arpeggiosMaster: "Arpeggio Master",
      arpeggiosMasterDesc: "Master major, minor and harmonic arpeggios.",
      arpeggiosMasterBenefits: "Strengthens interval recognition, improves pitch accuracy on jumps.",
      // Ear Training Routines
      intervalTraining: "Interval Training",
      intervalTrainingDesc: "Develop your ear with focused interval exercises.",
      intervalTrainingBenefits: "Sharpens pitch recognition, improves intonation accuracy.",
      pitchPrecision: "Pitch Precision",
      pitchPrecisionDesc: "Challenge your ear with chromatic and complex intervals.",
      pitchPrecisionBenefits: "Develops perfect pitch sense, improves chromatic accuracy.",
      // Style Routines
      jazzBlues: "Jazz & Blues",
      jazzBluesDesc: "Explore jazz and blues scales with scat exercises.",
      jazzBluesBenefits: "Develops stylistic flexibility, improves improvisation skills.",
      beltingPower: "Belting Power",
      beltingPowerDesc: "Build healthy and powerful belt technique.",
      beltingPowerBenefits: "Develops forward resonance, strengthens core support for power.",
      startRoutine: "Start Routine",
      // New Sections
      studiesTitle: "Studies",
      studiesDesc: "We encourage you to have a professor accompany your studies. This space is designed for you to interact with them and receive personalized materials.",
      tokensTitle: "Import Token",
      tokensDesc: "Import a custom routine or lesson plan shared with you.",
      importRoutine: "Import Routine",
      addTokenPrompt: "Add your token here",
      accessLessonsPrompt: "Access your teacher lessons here",
      customRoutines: "Custom Routines",
      customizeExercisesPrompt: "Customize your exercises...",
      // AI Studio (now VoxLab AI)
      voxlabaiTitle: "VoxLab AI",
      voxlabaiDesc: "Describe a vocal exercise you need, and our AI assistant will create it for you.",
      voxlabaiBeta: "This feature is experimental. Always prioritize vocal health and stop if you feel any strain.",
      voxlabaiPrompt: 'e.g., "Create an exercise for improving agility with major scales."',
      generate: "Generate",
      practiceThisExercise: "Practice this Exercise",
      refine: "Refine",
      refinePromptPlaceholder: "e.g., Make it faster, higher, or change the vowel...",
      refining: "Refining...",
      // Exercises View
      exercisesTitle: "Vocal Exercises",
      selectExerciseToStart: "Select an exercise to start practicing.",
      exercisesProTitle: "Exercises PRO",
      // Exercise Category Groups (PRO Style)
      warmup: "Warmup",
      technique: "Technique",
      agility: "Agility",
      ear: "Ear Training",
      style: "Style",
      // Legacy categories (kept for compatibility)
      warmupsAndBasics: "Warm-ups & Basics",
      breathAndSupport: "Breath & Support",
      resonanceAndTone: "Resonance & Tone",
      pitchAndIntonation: "Pitch & Intonation",
      scalesAndAgility: "Scales & Agility",
      belting: "Belting",
      cooldowns: "Cooldowns",
      aiGeneratedExercises: "AI Generated",
      // Exercise Names & Descriptions
      lipTrills: "Lip Trills",
      lipTrillsDesc: "Gently blow air through closed lips",
      sirens: "Sirenes",
      sirensDesc: "Slide from low to high notes smoothly",
      staccatoExercise: "Staccato Exercise",
      staccatoExerciseDesc: "Quick bursts of sound",
      messaDiVoce: "Messa di Voce",
      messaDiVoceDesc: "Swell on a single note (crescendo/decrescendo)",
      pulsedHas: 'Pulsed "Ha"s',
      pulsedHasDesc: 'Engage the diaphragm with pulsed "ha" sounds',
      sustainedHiss: "Sustained Hiss",
      sustainedHissDesc: 'Exhale on a long, steady "sss" sound',
      hummingScale: "Humming Scale",
      hummingScaleDesc: 'Hum a 5-tone scale on "mmm"',
      vowelPurityScale: "Vowel Purity Scale",
      vowelPurityScaleDesc: 'Sing a 5-tone scale on "ee-eh-ah-oh-oo"',
      ngResonance: '"NG" Resonance',
      ngResonanceDesc: 'Feel forward resonance on an "ng" sound',
      forwardNee: 'Forward "Nee"',
      forwardNeeDesc: 'A 5-tone scale on "nee" for forward placement',
      vowelUniformity: "Vowel Uniformity",
      vowelUniformityDesc: "Sing a major arpeggio on a single vowel",
      octaveJumps: "Octave Jumps",
      octaveJumpsDesc: "Jump between low and high notes",
      thirdIntervals: "Third Intervals",
      thirdIntervalsDesc: "Practice jumps of thirds",
      chromaticScale: "Chromatic Scale",
      chromaticScaleDesc: "Ascending and descending half-step scale",
      sixthIntervals: "Sixth Intervals",
      sixthIntervalsDesc: "Practice larger jumps of sixths",
      minorThirdIntervals: "Minor Third Intervals",
      minorThirdIntervalsDesc: "Practice jumps of minor thirds",
      scaleOfFifths: "Scale of Fifths",
      scaleOfFifthsDesc: "Ascend and descend in fifths",
      fiveToneScale: "5-Tone Scale",
      fiveToneScaleDesc: "Sing: Do-Re-Mi-Fa-Sol-Fa-Mi-Re-Do",
      majorArpeggio: "Major Arpeggio",
      majorArpeggioDesc: "Do-Mi-Sol-Do-Sol-Mi-Do",
      minorArpeggio: "Minor Arpeggio",
      minorArpeggioDesc: "Do-Mib-Sol-Do-Sol-Mib-D\xF3",
      solfegeMajorScale: "Solfege Major Scale",
      solfegeMajorScaleDesc: "Ascending and descending major scale",
      brattyNae: 'Bratty "Nae"',
      brattyNaeDesc: "Develop a bright, forward tone for belting",
      octaveGug: 'Octave "Gug"',
      octaveGugDesc: "Build power and connection across your break",
      edgyAh: 'Edgy "Ah"',
      edgyAhDesc: "Practice a powerful, open-throated belt",
      descendingScale: "Descending Scale",
      descendingScaleDesc: "Practice going down smoothly",
      descendingArpeggio: "Descending Arpeggio",
      descendingArpeggioDesc: "Maintain tone quality descending",
      descendingVooScale: 'Descending "Voo" Scale',
      descendingVooScaleDesc: "A gentle descending 5-tone scale",
      gentleSighs: "Gentle Sighs",
      gentleSighsDesc: 'Descend on a relaxed "hah" sigh',
      descendingFiveTone: "Descending 5-Tone",
      descendingFiveToneDesc: "Sing 'Mum' on each note going down (5-4-3-2-1). Great warmup!",
      gentleSlideDown: "Gentle Slide Down",
      gentleSlideDownDesc: "Hum gently on 5-3-1. Relax your voice.",
      staccatoArpeggio: "Staccato Arpeggio",
      staccatoArpeggioDesc: "Sing short 'Ha' on each note, like a laugh. Engages your diaphragm.",
      neighOctave: "The 'Neigh' Octave",
      neighOctaveDesc: "Pharyngeal sound to connect chest/head.",
      onePointFiveOctaveScale: "1.5 Octave Scale",
      onePointFiveOctaveScaleDesc: "Extends to the 11th. Great for range.",
      hanonRun: "Hanon Run (No. 1)",
      hanonRunDesc: "Piano dexterity adapted for voice. 16th notes.",
      rossiniScale: "The Rossini Scale",
      rossiniScaleDesc: "Gold standard 9-tone scale.",
      rapidConsonants: "Rapid Consonants",
      rapidConsonantsDesc: "Tongue coordination. Sing crisp 'Dig-Ga'.",
      harmonicMinor: "Harmonic Minor",
      harmonicMinorDesc: "Raised 7th (Classical Minor).",
      wholeToneScale: "Whole Tone Scale",
      wholeToneScaleDesc: "Dreamy (Whole steps).",
      majorPentatonic: "Major Pentatonic",
      majorPentatonicDesc: "1-2-3-5-6.",
      tritoneChallenge: "Tritone Challenge",
      tritoneChallengeDesc: "The 'Simpsons' interval.",
      dominantSeventhArp: "Dominant 7th Arp",
      dominantSeventhArpDesc: "Essential for Jazz. Adds the flat 7.",
      bluesScale: "Blues Scale",
      bluesScaleDesc: "1-b3-4-#4-5-b7.",
      jazzSixthScat: "Jazz 6th Scat",
      jazzSixthScatDesc: "Classic Swing sound (1-3-5-6-8).",
      // Pitch View
      livePitchDetector: "Live Pitch Detector",
      note: "Note",
      frequency: "Frequency",
      inputVolume: "Input Volume",
      micStatusListening: "Listening...",
      micStatusActivate: "Click to activate microphone",
      micStatusPermissionDenied: "Permission denied",
      micStatusError: "Audio Error",
      pitchFooter: "For best results, use headphones in a quiet environment.",
      // Pitch View Controls
      autoFit: "Auto-Fit",
      centerNote: "Center Note",
      rangeOctaves: "Range",
      octavesUnit: "Octaves",
      gain: "Gain",
      noiseGate: "Noise Gate",
      compressor: "Compressor",
      autoGain: "Auto Gain",
      clippingWarning: "Clipping!",
      compressorRatio: "Ratio",
      release: "Release",
      equalizer: "Equalizer",
      low: "Low",
      mid: "Mid",
      high: "High",
      // Exercise Game View
      exerciseComplete: "Exercise Complete!",
      noteVolume: "Note Volume",
      metronomeVolume: "Metronome Volume",
      upNext: "Up Next",
      nextExercise: "Next Exercise",
      routineComplete: "Routine Complete!",
      drinkWaterSuggestion: "Great job! Drink some water and rest your voice.",
      finish: "Finish",
      preview: "Preview",
      stopPreview: "Stop",
      routineLabel: "ROUTINE",
      exerciseProgress: "Exercise {current} of {total}",
      // Settings Overlay
      language: "Language",
      colorPalette: "Color Palette",
      faq: "FAQ",
      support: "Support",
      // Vocal Range Test
      vocalRangeTestTitle: "Vocal Range Test",
      lowestNoteInstructions: "Sing your lowest comfortable note.",
      recordingLowestNote: "Recording lowest note...",
      lowestNoteDetected: "Lowest Note Detected",
      speakNaturallyInstructions: "Speak naturally for a few moments.",
      speakingNow: "Speaking now...",
      sirenSoundInstructions: "Glide smoothly from your lowest to highest note and back.",
      listeningInstruction: "Start singing now!",
      listeningMessage: "Listening...",
      goAheadInstruction: "Go ahead.",
      analysisMessage: "Analyzing your voice...",
      resultsTitle: "Detection Complete!",
      resultsSubtitle: "We've estimated your vocal range as:",
      tryAgain: "Try Again",
      confirmRange: "Confirm Range",
      notHearingGoAhead: "I'm not hearing you. Go ahead.",
      // Mobile Audio Unlock
      enableAudio: "Enable Audio",
      tapToEnableSound: "Tap the button below to enable sound on your device.",
      enableSound: "Enable Sound"
    },
    "pt-BR": {
      // General
      home: "In\xEDcio",
      range: "Extens\xE3o",
      routines: "Rotinas",
      swipeRoutines: "\u2190 Deslize para ver mais rotinas \u2192",
      exercises: "Exerc\xEDcios",
      pitch: "Afina\xE7\xE3o",
      studies: "Estudos",
      tokens: "Tokens",
      voxlabai: "VoxLab IA",
      settings: "Ajustes",
      cancel: "Cancelar",
      nextStep: "Pr\xF3ximo",
      skipStep: "Pular",
      comingSoon: "Em Breve",
      approxDuration: "Dura\xE7\xE3o Aprox.",
      benefits: "Benef\xEDcios",
      beta: "Beta",
      favorites: "Favoritos",
      save: "Salvar",
      saved: "Salvo",
      edit: "Editar",
      saveChanges: "Salvar Altera\xE7\xF5es",
      discardChanges: "Descartar",
      aiGenerated: "Gerado por IA",
      favoriteRoutines: "Rotinas Favoritas",
      favoriteExercises: "Exerc\xEDcios Favoritos",
      emptyFavoritesRoutines: "Voc\xEA ainda n\xE3o favoritou nenhuma rotina. Toque na estrela em uma rotina para adicion\xE1-la aqui!",
      emptyFavoritesExercises: "Voc\xEA ainda n\xE3o favoritou nenhum exerc\xEDcio. Toque no bot\xE3o em um exerc\xEDcio para adicion\xE1-lo aqui!",
      tools: "Ferramentas",
      instrumentTuner: "Afinador de Instrumentos",
      tuning: "Afina\xE7\xE3o",
      chromatic: "Crom\xE1tico",
      standardGuitar: "Viol\xE3o Padr\xE3o (EADGBe)",
      flat: "Abaixo",
      sharp: "Acima",
      inTune: "Afinado",
      recordVideo: "Gravar Performance em V\xEDdeo",
      accessStudiesPrompt: "Li\xE7\xF5es do Professor",
      recordVideoDesc: "Capture v\xEDdeos das suas sess\xF5es de pr\xE1tica para analisar sua t\xE9cnica e presen\xE7a de palco.",
      teacherStudiesDesc: "Acesse exerc\xEDcios personalizados e planos de aula enviados diretamente pelo seu professor de canto.",
      importTokenTitle: "Importar Token",
      importTokenDesc: "Adicione aqui seu token para acessar a rotina de exerc\xEDcios criada por seu professor.",
      interactiveTheoryTitle: "Teoria Musical Interativa",
      interactiveTheoryDesc: "Aprenda e pratique conceitos de teoria musical com exerc\xEDcios pr\xE1ticos e envolventes.",
      masterclassesTitle: "Masterclasses em V\xEDdeo",
      masterclassesDesc: "Assista a aulas e tutoriais exclusivos com preparadores vocais de renome mundial.",
      appVersion: "Vers\xE3o do App",
      mvp: "MVP",
      fullFeatures: "Completo",
      switchToFull: "Mudar para Vers\xE3o Completa",
      switchToMVP: "Mudar para Vers\xE3o MVP",
      samplesLoaded: "{count} amostras carregadas com sucesso!",
      processing: "Processando...",
      loadingAudio: "Carregando \xC1udio...",
      greatJob: "\xD3timo Trabalho!",
      replay: "Repetir",
      backToMenu: "Menu Principal",
      restart: "Reiniciar",
      activeInstrument: "Instrumento Ativo",
      selectInstrument: "Selecionar Instrumento",
      noInstrumentsLoaded: "Nenhum instrumento carregado",
      // Home View
      welcomeTitle: "VoxLab",
      welcomeSubtitle: "Seu assistente pessoal de treino vocal.",
      helloSinger: "Ol\xE1, Cantor!",
      betaTestInvite: "Voc\xEA foi convidado para testar a vers\xE3o beta deste app! Recomendamos experimentar o Modo Imersivo para tela cheia. Como os resultados podem variar de acordo com o dispositivo, seus testes s\xE3o essenciais! Use o bot\xE3o amarelo de Feedback para enviar suas sugest\xF5es.\n\nEscolha uma vers\xE3o abaixo para come\xE7ar.",
      feedback: "Feedback",
      sendFeedback: "Enviar Feedback",
      yourFeedback: "Seu Feedback",
      emailOptional: "E-mail (Opcional)",
      feedbackSent: "Feedback enviado! Obrigado.",
      feedbackError: "Erro ao enviar feedback. Tente novamente.",
      letsPractice: "Selecione uma das op\xE7\xF5es abaixo para continuar.",
      startPractice: "Come\xE7ar",
      exitFullscreen: "Sair da Tela Cheia",
      enterFullscreen: "Tela Cheia",
      immersiveMode: "Modo Imersivo",
      // Range View
      vocalRangeTitle: "Extens\xE3o Vocal",
      findYourRange: "N\xE3o sabe sua extens\xE3o vocal? Vamos descobrir.",
      startTest: "Iniciar Teste",
      iKnowMyRange: "Eu sei minha extens\xE3o",
      detectMyRange: "Detectar minha extens\xE3o",
      vocalRangePrompt: "Defina sua extens\xE3o vocal manualmente no piano ou deixe que a gente detecte para voc\xEA.",
      selectRangeOnPiano: "Clique nas notas mais grave e mais aguda da sua extens\xE3o.",
      goBack: "Voltar",
      rangeNotSet: "Extens\xE3o n\xE3o definida",
      // Range Check Modal
      rangeCheckTitle: "Defina Sua Extens\xE3o Vocal",
      rangeCheckPrompt: "Para melhores resultados, os exerc\xEDcios devem ser adaptados \xE0 sua voz. Gostaria de definir sua extens\xE3o vocal agora?",
      defineRange: "Definir Extens\xE3o",
      continueAnyway: "Continuar",
      returnToExercise: "Voltar para o Exerc\xEDcio",
      returnToRoutine: "Voltar para a Rotina",
      // Routines View
      routinesTitle: "Rotinas",
      clickForDetails: "Clique para detalhes",
      // Warmup Routines
      warmUpQuick: "Aquecimento R\xE1pido",
      warmUpQuickDesc: "Uma rotina de 3 minutos com exerc\xEDcios descendentes suaves.",
      warmUpQuickBenefits: "Relaxa as cordas vocais, melhora o apoio respirat\xF3rio.",
      warmUpComplete: "Aquecimento Completo",
      warmUpCompleteDesc: "Um aquecimento de 8 minutos para uma sess\xE3o intensa.",
      warmUpCompleteBenefits: "Aumenta a flexibilidade vocal, ativa os ressonadores.",
      // Technique Routines
      resonanceFocus: "Foco em Resson\xE2ncia",
      resonanceFocusDesc: "Desenvolva um timbre vocal mais rico e ressonante.",
      resonanceFocusBenefits: "Melhora a proje\xE7\xE3o vocal, aprimora a qualidade tonal.",
      staccatoControl: "Controle Staccato",
      staccatoControlDesc: "Melhore a precis\xE3o e controle com exerc\xEDcios articulados.",
      staccatoControlBenefits: "Desenvolve controle do diafragma, melhora articula\xE7\xE3o.",
      // Agility Routines
      agilityScales: "Escalas de Agilidade",
      agilityScalesDesc: "Construa velocidade e flexibilidade com escalas progressivas.",
      agilityScalesBenefits: "Aumenta a velocidade vocal, melhora a precis\xE3o.",
      arpeggiosMaster: "Mestre dos Arpejos",
      arpeggiosMasterDesc: "Domine arpejos maiores, menores e harm\xF4nicos.",
      arpeggiosMasterBenefits: "Fortalece reconhecimento de intervalos.",
      // Ear Training Routines
      intervalTraining: "Treino de Intervalos",
      intervalTrainingDesc: "Desenvolva seu ouvido com exerc\xEDcios focados em intervalos.",
      intervalTrainingBenefits: "Agudiza o reconhecimento de tom.",
      pitchPrecision: "Precis\xE3o de Afina\xE7\xE3o",
      pitchPrecisionDesc: "Desafie seu ouvido com intervalos crom\xE1ticos e complexos.",
      pitchPrecisionBenefits: "Desenvolve senso de afina\xE7\xE3o absoluta.",
      // Style Routines
      jazzBlues: "Jazz & Blues",
      jazzBluesDesc: "Explore escalas de jazz e blues com exerc\xEDcios de scat.",
      jazzBluesBenefits: "Desenvolve flexibilidade estil\xEDstica e improvisa\xE7\xE3o.",
      beltingPower: "Pot\xEAncia Belting",
      beltingPowerDesc: "Construa t\xE9cnica de belting saud\xE1vel e potente.",
      beltingPowerBenefits: "Desenvolve resson\xE2ncia frontal, fortalece o apoio.",
      startRoutine: "Iniciar Rotina",
      // New Sections
      studiesTitle: "Estudos",
      studiesDesc: "Incentivamos que um professor acompanhe seus estudos. Este espa\xE7o \xE9 projetado para voc\xEA interagir com ele e receber materiais personalizados.",
      tokensTitle: "Importar Token",
      tokensDesc: "Importe uma rotina personalizada ou plano de aula compartilhado com voc\xEA.",
      importRoutine: "Importar Rotina",
      addTokenPrompt: "Adicione seu token aqui",
      accessLessonsPrompt: "Acesse as li\xE7\xF5es do seu professor",
      customRoutines: "Rotinas Personalizadas",
      customizeExercisesPrompt: "Personalize seus exerc\xEDcios...",
      // AI Studio (now VoxLab AI)
      voxlabaiTitle: "VoxLab IA",
      voxlabaiDesc: "Descreva um exerc\xEDcio vocal que voc\xEA precisa, e nosso assistente de IA ir\xE1 cri\xE1-lo para voc\xEA.",
      voxlabaiBeta: "Este recurso \xE9 experimental. Sempre priorize a sa\xFAde vocal e pare se sentir qualquer tens\xE3o.",
      voxlabaiPrompt: 'ex: "Crie um exerc\xEDcio para melhorar a agilidade com escalas maiores."',
      generate: "Gerar",
      practiceThisExercise: "Praticar este Exerc\xEDcio",
      refine: "Refinar",
      refinePromptPlaceholder: "ex: Fa\xE7a mais r\xE1pido, mais agudo, ou mude a vogal...",
      refining: "Refinando...",
      // Exercises View
      exercisesTitle: "Exerc\xEDcios Vocais",
      selectExerciseToStart: "Selecione um exerc\xEDcio para come\xE7ar a praticar.",
      exercisesProTitle: "Exerc\xEDcios PRO",
      // Exercise Category Groups (PRO Style)
      warmup: "Aquecimento",
      technique: "T\xE9cnica",
      agility: "Agilidade",
      ear: "Treinamento Auditivo",
      style: "Estilo",
      // Legacy categories (kept for compatibility)
      warmupsAndBasics: "Aquecimentos & B\xE1sicos",
      breathAndSupport: "Respira\xE7\xE3o & Apoio",
      resonanceAndTone: "Resson\xE2ncia & Timbre",
      pitchAndIntonation: "Afina\xE7\xE3o & Entona\xE7\xE3o",
      scalesAndAgility: "Escalas & Agilidade",
      belting: "Belting",
      cooldowns: "Desaquecimento",
      aiGeneratedExercises: "Gerados por IA",
      // Exercise Names & Descriptions (pt-BR)
      lipTrills: "Lip Trills",
      lipTrillsDesc: "Sopre ar suavemente atrav\xE9s dos l\xE1bios fechados",
      sirens: "Sirenes",
      sirensDesc: "Deslize suavemente de notas graves para agudas",
      staccatoExercise: "Exerc\xEDcio de Staccato",
      staccatoExerciseDesc: "Rajadas r\xE1pidas de som",
      messaDiVoce: "Messa di Voce",
      messaDiVoceDesc: "Aumente e diminua o volume em uma \xFAnica nota",
      pulsedHas: '"Ha"s Pulsados',
      pulsedHasDesc: 'Engaje o diafragma com sons pulsados de "ha"',
      sustainedHiss: "Assobio Sustentado",
      sustainedHissDesc: 'Expire em um som de "sss" longo e constante',
      hummingScale: "Escala em Humming",
      hummingScaleDesc: 'Cantarole uma escala de 5 tons em "mmm"',
      vowelPurityScale: "Escala de Pureza das Vogais",
      vowelPurityScaleDesc: 'Cante uma escala de 5 tons em "i-\xE9-\xE1-\xF3-u"',
      ngResonance: 'Resson\xE2ncia "NG"',
      ngResonanceDesc: 'Sinta a resson\xE2ncia frontal em um som de "ng"',
      forwardNee: '"Nee" Frontal',
      forwardNeeDesc: 'Uma escala de 5 tons em "nee" para proje\xE7\xE3o frontal',
      vowelUniformity: "Uniformidade das Vogais",
      vowelUniformityDesc: "Cante um arpejo maior em uma \xFAnica vogal",
      octaveJumps: "Saltos de Oitava",
      octaveJumpsDesc: "Salte entre notas graves e agudas",
      thirdIntervals: "Intervalos de Ter\xE7a",
      thirdIntervalsDesc: "Pratique saltos de ter\xE7as",
      chromaticScale: "Escala Crom\xE1tica",
      chromaticScaleDesc: "Escala de semitons ascendente e descendente",
      sixthIntervals: "Intervalos de Sexta",
      sixthIntervalsDesc: "Pratique saltos maiores de sextas",
      minorThirdIntervals: "Intervalos de Ter\xE7a Menor",
      minorThirdIntervalsDesc: "Ou\xE7a atentamente o salto de intervalo menor",
      scaleOfFifths: "Escala de Quintas",
      scaleOfFifthsDesc: "Suba e des\xE7a em quintas",
      fiveToneScale: "Escala de 5 Tons",
      fiveToneScaleDesc: "Cante: D\xF3-R\xE9-Mi-F\xE1-Sol-F\xE1-Mi-R\xE9-D\xF3",
      majorArpeggio: "Arpejo Maior",
      majorArpeggioDesc: "D\xF3-Mi-Sol-D\xF3-Sol-Mi-D\xF3",
      minorArpeggio: "Arpejo Menor",
      minorArpeggioDesc: "D\xF3-Mib-Sol-D\xF3-Sol-Mib-D\xF3",
      solfegeMajorScale: "Escala Maior em Solfejo",
      solfegeMajorScaleDesc: "Escala maior ascendente e descendente",
      brattyNae: '"Nae" Anasalado',
      brattyNaeDesc: "Desenvolva um tom brilhante e frontal para belting",
      octaveGug: '"Gug" na Oitava',
      octaveGugDesc: "Construa pot\xEAncia e conex\xE3o atrav\xE9s da sua passagem",
      edgyAh: '"Ah" com Brilho',
      edgyAhDesc: "Pratique um belting potente de garganta aberta",
      descendingScale: "Escala Descendente",
      descendingScaleDesc: "Pratique descendo suavemente",
      descendingArpeggio: "Arpejo Descendente",
      descendingArpeggioDesc: "Mantenha a qualidade do tom ao descer",
      descendingVooScale: 'Escala Descendente em "Voo"',
      descendingVooScaleDesc: "Uma escala descendente suave de 5 tons",
      gentleSighs: "Suspiros Suaves",
      gentleSighsDesc: 'Des\xE7a em um suspiro relaxado de "hah"',
      descendingFiveTone: "Escala de 5 Tons Descendente",
      descendingFiveToneDesc: "Cante 'Mum' em cada nota descendo (5-4-3-2-1). \xD3timo aquecimento!",
      gentleSlideDown: "Deslize Suave Descendente",
      gentleSlideDownDesc: "Hum suavemente em 5-3-1. Relaxe sua voz.",
      staccatoArpeggio: "Arpejo em Staccato",
      staccatoArpeggioDesc: "Cante 'Ha' curto em cada nota. Engaja seu diafragma.",
      neighOctave: "Oitava em 'Neigh'",
      neighOctaveDesc: "Som far\xEDngeo para conectar peito/cabe\xE7a.",
      onePointFiveOctaveScale: "Escala de 1.5 Oitava",
      onePointFiveOctaveScaleDesc: "Estende at\xE9 a 11\xAA. \xD3timo para extens\xE3o.",
      hanonRun: "Corrida Hanon (No. 1)",
      hanonRunDesc: "Destreza de piano adaptada para voz. Semicolcheias.",
      rossiniScale: "Escala Rossini",
      rossiniScaleDesc: "Escala de 9 tons padr\xE3o ouro.",
      rapidConsonants: "Consoantes R\xE1pidas",
      rapidConsonantsDesc: "Coordena\xE7\xE3o da l\xEDngua. Cante 'Dig-Ga' n\xEDtido.",
      harmonicMinor: "Menor Harm\xF4nica",
      harmonicMinorDesc: "7\xAA aumentada (Menor Cl\xE1ssica).",
      wholeToneScale: "Escala de Tons Inteiros",
      wholeToneScaleDesc: "Sonhador (Tons inteiros).",
      majorPentatonic: "Pentat\xF4nica Maior",
      majorPentatonicDesc: "1-2-3-5-6.",
      tritoneChallenge: "Desafio do Tr\xEDtono",
      tritoneChallengeDesc: "O intervalo dos 'Simpsons'.",
      dominantSeventhArp: "Arpejo Dominante com 7\xAA",
      dominantSeventhArpDesc: "Essencial para Jazz. Adiciona a 7\xAA menor.",
      bluesScale: "Escala de Blues",
      bluesScaleDesc: "1-b3-4-#4-5-b7.",
      jazzSixthScat: "Scat Jazz com 6\xAA",
      jazzSixthScatDesc: "Som cl\xE1ssico de Swing (1-3-5-6-8).",
      // Pitch View
      livePitchDetector: "Detector de Afina\xE7\xE3o",
      note: "Nota",
      frequency: "Frequ\xEAncia",
      inputVolume: "Volume de Entrada",
      micStatusListening: "Ouvindo...",
      micStatusActivate: "Clique para ativar o microfone",
      micStatusPermissionDenied: "Permiss\xE3o negada",
      micStatusError: "Erro de \xE1udio",
      pitchFooter: "Para melhores resultados, use fones de ouvido em um ambiente silencioso.",
      // Pitch View Controls
      autoFit: "Ajuste Autom\xE1tico",
      centerNote: "Nota Central",
      rangeOctaves: "Extens\xE3o",
      octavesUnit: "Oitavas",
      gain: "Ganho",
      noiseGate: "Redutor de Ru\xEDdo",
      compressor: "Compressor",
      autoGain: "Ganho Autom\xE1tico",
      clippingWarning: "Saturando!",
      compressorRatio: "Taxa (Ratio)",
      release: "Libera\xE7\xE3o (Release)",
      equalizer: "Equalizador",
      low: "Graves",
      mid: "M\xE9dios",
      high: "Agudos",
      // Exercise Game View
      exerciseComplete: "Exerc\xEDcio Completo!",
      noteVolume: "Volume da Nota",
      metronomeVolume: "Volume do Metr\xF4nomo",
      upNext: "A Seguir",
      nextExercise: "Pr\xF3ximo Exerc\xEDcio",
      routineComplete: "Rotina Completa!",
      drinkWaterSuggestion: "\xD3timo trabalho! Beba um pouco de \xE1gua e descanse a voz.",
      finish: "Finalizar",
      preview: "Pr\xE9via",
      stopPreview: "Parar",
      routineLabel: "ROTINA",
      exerciseProgress: "Exerc\xEDcio {current} de {total}",
      // Settings Overlay
      language: "Idioma",
      colorPalette: "Paleta de Cores",
      faq: "D\xFAvidas",
      support: "Suporte",
      // Vocal Range Test
      vocalRangeTestTitle: "Teste de Extens\xE3o Vocal",
      lowestNoteInstructions: "Cante sua nota mais grave e confort\xE1vel.",
      recordingLowestNote: "Gravando nota mais grave...",
      lowestNoteDetected: "Nota Mais Grave Detectada",
      speakNaturallyInstructions: "Fale naturalmente por alguns momentos.",
      speakingNow: "Falando agora...",
      sirenSoundInstructions: "Deslize suavemente da sua nota mais grave para a mais aguda e vice-versa.",
      listeningInstruction: "Comece a cantar agora!",
      listeningMessage: "Ouvindo...",
      goAheadInstruction: "V\xE1 em frente.",
      analysisMessage: "Analisando sua voz...",
      resultsTitle: "Detec\xE7\xE3o Conclu\xEDda!",
      resultsSubtitle: "Estimamos sua extens\xE3o vocal como:",
      tryAgain: "Tentar Novamente",
      confirmRange: "Confirmar Extens\xE3o",
      notHearingGoAhead: "N\xE3o estou te ouvindo. V\xE1 em frente.",
      // Mobile Audio Unlock
      enableAudio: "Ativar \xC1udio",
      tapToEnableSound: "Toque no bot\xE3o abaixo para ativar o som no seu dispositivo.",
      enableSound: "Ativar Som"
    }
  };

  // hooks/useTranslation.tsx
  var import_jsx_runtime3 = __toESM(require_jsx_runtime());
  var LanguageContext = (0, import_react3.createContext)(void 0);
  var LanguageProvider = ({ children }) => {
    const [language, setLanguage] = (0, import_react3.useState)(LANGUAGES[1]);
    const t = (0, import_react3.useCallback)((key, replacements) => {
      const langCode = language.code;
      const typedKey = key;
      let translation = translations[langCode] && translations[langCode][typedKey] || translations.en[typedKey] || key;
      if (replacements) {
        Object.entries(replacements).forEach(([k, v]) => {
          translation = translation.replace(`{${k}}`, String(v));
        });
      }
      return translation;
    }, [language]);
    return /* @__PURE__ */ (0, import_jsx_runtime3.jsx)(LanguageContext.Provider, { value: { language, setLanguage, t }, children });
  };
  var useTranslation = () => {
    const context = (0, import_react3.useContext)(LanguageContext);
    if (context === void 0) {
      throw new Error("useTranslation must be used within a LanguageProvider");
    }
    return context;
  };

  // node_modules/lucide-react/dist/esm/createLucideIcon.js
  var import_react5 = __toESM(require_react());

  // node_modules/lucide-react/dist/esm/shared/src/utils.js
  var toKebabCase = (string) => string.replace(/([a-z0-9])([A-Z])/g, "$1-$2").toLowerCase();
  var toCamelCase = (string) => string.replace(
    /^([A-Z])|[\s-_]+(\w)/g,
    (match, p1, p2) => p2 ? p2.toUpperCase() : p1.toLowerCase()
  );
  var toPascalCase = (string) => {
    const camelCase = toCamelCase(string);
    return camelCase.charAt(0).toUpperCase() + camelCase.slice(1);
  };
  var mergeClasses = (...classes) => classes.filter((className, index, array) => {
    return Boolean(className) && className.trim() !== "" && array.indexOf(className) === index;
  }).join(" ").trim();
  var hasA11yProp = (props) => {
    for (const prop in props) {
      if (prop.startsWith("aria-") || prop === "role" || prop === "title") {
        return true;
      }
    }
  };

  // node_modules/lucide-react/dist/esm/Icon.js
  var import_react4 = __toESM(require_react());

  // node_modules/lucide-react/dist/esm/defaultAttributes.js
  var defaultAttributes = {
    xmlns: "http://www.w3.org/2000/svg",
    width: 24,
    height: 24,
    viewBox: "0 0 24 24",
    fill: "none",
    stroke: "currentColor",
    strokeWidth: 2,
    strokeLinecap: "round",
    strokeLinejoin: "round"
  };

  // node_modules/lucide-react/dist/esm/Icon.js
  var Icon = (0, import_react4.forwardRef)(
    ({
      color = "currentColor",
      size = 24,
      strokeWidth = 2,
      absoluteStrokeWidth,
      className = "",
      children,
      iconNode,
      ...rest
    }, ref) => (0, import_react4.createElement)(
      "svg",
      {
        ref,
        ...defaultAttributes,
        width: size,
        height: size,
        stroke: color,
        strokeWidth: absoluteStrokeWidth ? Number(strokeWidth) * 24 / Number(size) : strokeWidth,
        className: mergeClasses("lucide", className),
        ...!children && !hasA11yProp(rest) && { "aria-hidden": "true" },
        ...rest
      },
      [
        ...iconNode.map(([tag, attrs]) => (0, import_react4.createElement)(tag, attrs)),
        ...Array.isArray(children) ? children : [children]
      ]
    )
  );

  // node_modules/lucide-react/dist/esm/createLucideIcon.js
  var createLucideIcon = (iconName, iconNode) => {
    const Component = (0, import_react5.forwardRef)(
      ({ className, ...props }, ref) => (0, import_react5.createElement)(Icon, {
        ref,
        iconNode,
        className: mergeClasses(
          `lucide-${toKebabCase(toPascalCase(iconName))}`,
          `lucide-${iconName}`,
          className
        ),
        ...props
      })
    );
    Component.displayName = toPascalCase(iconName);
    return Component;
  };

  // node_modules/lucide-react/dist/esm/icons/activity.js
  var __iconNode = [
    [
      "path",
      {
        d: "M22 12h-2.48a2 2 0 0 0-1.93 1.46l-2.35 8.36a.25.25 0 0 1-.48 0L9.24 2.18a.25.25 0 0 0-.48 0l-2.35 8.36A2 2 0 0 1 4.49 12H2",
        key: "169zse"
      }
    ]
  ];
  var Activity = createLucideIcon("activity", __iconNode);

  // node_modules/lucide-react/dist/esm/icons/chevron-down.js
  var __iconNode2 = [["path", { d: "m6 9 6 6 6-6", key: "qrunsl" }]];
  var ChevronDown = createLucideIcon("chevron-down", __iconNode2);

  // node_modules/lucide-react/dist/esm/icons/chevron-left.js
  var __iconNode3 = [["path", { d: "m15 18-6-6 6-6", key: "1wnfg3" }]];
  var ChevronLeft = createLucideIcon("chevron-left", __iconNode3);

  // node_modules/lucide-react/dist/esm/icons/clock.js
  var __iconNode4 = [
    ["path", { d: "M12 6v6l4 2", key: "mmk7yg" }],
    ["circle", { cx: "12", cy: "12", r: "10", key: "1mglay" }]
  ];
  var Clock = createLucideIcon("clock", __iconNode4);

  // node_modules/lucide-react/dist/esm/icons/list-music.js
  var __iconNode5 = [
    ["path", { d: "M16 5H3", key: "m91uny" }],
    ["path", { d: "M11 12H3", key: "51ecnj" }],
    ["path", { d: "M11 19H3", key: "zflm78" }],
    ["path", { d: "M21 16V5", key: "yxg4q8" }],
    ["circle", { cx: "18", cy: "16", r: "3", key: "1hluhg" }]
  ];
  var ListMusic = createLucideIcon("list-music", __iconNode5);

  // node_modules/lucide-react/dist/esm/icons/mic.js
  var __iconNode6 = [
    ["path", { d: "M12 19v3", key: "npa21l" }],
    ["path", { d: "M19 10v2a7 7 0 0 1-14 0v-2", key: "1vc78b" }],
    ["rect", { x: "9", y: "2", width: "6", height: "13", rx: "3", key: "s6n7sd" }]
  ];
  var Mic = createLucideIcon("mic", __iconNode6);

  // node_modules/lucide-react/dist/esm/icons/music.js
  var __iconNode7 = [
    ["path", { d: "M9 18V5l12-2v13", key: "1jmyc2" }],
    ["circle", { cx: "6", cy: "18", r: "3", key: "fqmcym" }],
    ["circle", { cx: "18", cy: "16", r: "3", key: "1hluhg" }]
  ];
  var Music = createLucideIcon("music", __iconNode7);

  // node_modules/lucide-react/dist/esm/icons/pause.js
  var __iconNode8 = [
    ["rect", { x: "14", y: "3", width: "5", height: "18", rx: "1", key: "kaeet6" }],
    ["rect", { x: "5", y: "3", width: "5", height: "18", rx: "1", key: "1wsw3u" }]
  ];
  var Pause = createLucideIcon("pause", __iconNode8);

  // node_modules/lucide-react/dist/esm/icons/play.js
  var __iconNode9 = [
    [
      "path",
      {
        d: "M5 5a2 2 0 0 1 3.008-1.728l11.997 6.998a2 2 0 0 1 .003 3.458l-12 7A2 2 0 0 1 5 19z",
        key: "10ikf1"
      }
    ]
  ];
  var Play = createLucideIcon("play", __iconNode9);

  // node_modules/lucide-react/dist/esm/icons/rotate-ccw.js
  var __iconNode10 = [
    ["path", { d: "M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 8", key: "1357e3" }],
    ["path", { d: "M3 3v5h5", key: "1xhq8a" }]
  ];
  var RotateCcw = createLucideIcon("rotate-ccw", __iconNode10);

  // node_modules/lucide-react/dist/esm/icons/settings.js
  var __iconNode11 = [
    [
      "path",
      {
        d: "M9.671 4.136a2.34 2.34 0 0 1 4.659 0 2.34 2.34 0 0 0 3.319 1.915 2.34 2.34 0 0 1 2.33 4.033 2.34 2.34 0 0 0 0 3.831 2.34 2.34 0 0 1-2.33 4.033 2.34 2.34 0 0 0-3.319 1.915 2.34 2.34 0 0 1-4.659 0 2.34 2.34 0 0 0-3.32-1.915 2.34 2.34 0 0 1-2.33-4.033 2.34 2.34 0 0 0 0-3.831A2.34 2.34 0 0 1 6.35 6.051a2.34 2.34 0 0 0 3.319-1.915",
        key: "1i5ecw"
      }
    ],
    ["circle", { cx: "12", cy: "12", r: "3", key: "1v7zrd" }]
  ];
  var Settings = createLucideIcon("settings", __iconNode11);

  // node_modules/lucide-react/dist/esm/icons/sliders-vertical.js
  var __iconNode12 = [
    ["path", { d: "M10 8h4", key: "1sr2af" }],
    ["path", { d: "M12 21v-9", key: "17s77i" }],
    ["path", { d: "M12 8V3", key: "13r4qs" }],
    ["path", { d: "M17 16h4", key: "h1uq16" }],
    ["path", { d: "M19 12V3", key: "o1uvq1" }],
    ["path", { d: "M19 21v-5", key: "qua636" }],
    ["path", { d: "M3 14h4", key: "bcjad9" }],
    ["path", { d: "M5 10V3", key: "cb8scm" }],
    ["path", { d: "M5 21v-7", key: "1w1uti" }]
  ];
  var SlidersVertical = createLucideIcon("sliders-vertical", __iconNode12);

  // node_modules/lucide-react/dist/esm/icons/sparkles.js
  var __iconNode13 = [
    [
      "path",
      {
        d: "M11.017 2.814a1 1 0 0 1 1.966 0l1.051 5.558a2 2 0 0 0 1.594 1.594l5.558 1.051a1 1 0 0 1 0 1.966l-5.558 1.051a2 2 0 0 0-1.594 1.594l-1.051 5.558a1 1 0 0 1-1.966 0l-1.051-5.558a2 2 0 0 0-1.594-1.594l-5.558-1.051a1 1 0 0 1 0-1.966l5.558-1.051a2 2 0 0 0 1.594-1.594z",
        key: "1s2grr"
      }
    ],
    ["path", { d: "M20 2v4", key: "1rf3ol" }],
    ["path", { d: "M22 4h-4", key: "gwowj6" }],
    ["circle", { cx: "4", cy: "20", r: "2", key: "6kqj1y" }]
  ];
  var Sparkles = createLucideIcon("sparkles", __iconNode13);

  // node_modules/lucide-react/dist/esm/icons/square.js
  var __iconNode14 = [
    ["rect", { width: "18", height: "18", x: "3", y: "3", rx: "2", key: "afitv7" }]
  ];
  var Square = createLucideIcon("square", __iconNode14);

  // node_modules/lucide-react/dist/esm/icons/star.js
  var __iconNode15 = [
    [
      "path",
      {
        d: "M11.525 2.295a.53.53 0 0 1 .95 0l2.31 4.679a2.123 2.123 0 0 0 1.595 1.16l5.166.756a.53.53 0 0 1 .294.904l-3.736 3.638a2.123 2.123 0 0 0-.611 1.878l.882 5.14a.53.53 0 0 1-.771.56l-4.618-2.428a2.122 2.122 0 0 0-1.973 0L6.396 21.01a.53.53 0 0 1-.77-.56l.881-5.139a2.122 2.122 0 0 0-.611-1.879L2.16 9.795a.53.53 0 0 1 .294-.906l5.165-.755a2.122 2.122 0 0 0 1.597-1.16z",
        key: "r04s7s"
      }
    ]
  ];
  var Star = createLucideIcon("star", __iconNode15);

  // node_modules/lucide-react/dist/esm/icons/volume-2.js
  var __iconNode16 = [
    [
      "path",
      {
        d: "M11 4.702a.705.705 0 0 0-1.203-.498L6.413 7.587A1.4 1.4 0 0 1 5.416 8H3a1 1 0 0 0-1 1v6a1 1 0 0 0 1 1h2.416a1.4 1.4 0 0 1 .997.413l3.383 3.384A.705.705 0 0 0 11 19.298z",
        key: "uqj9uw"
      }
    ],
    ["path", { d: "M16 9a5 5 0 0 1 0 6", key: "1q6k2b" }],
    ["path", { d: "M19.364 18.364a9 9 0 0 0 0-12.728", key: "ijwkga" }]
  ];
  var Volume2 = createLucideIcon("volume-2", __iconNode16);

  // node_modules/lucide-react/dist/esm/icons/zap.js
  var __iconNode17 = [
    [
      "path",
      {
        d: "M4 14a1 1 0 0 1-.78-1.63l9.9-10.2a.5.5 0 0 1 .86.46l-1.92 6.02A1 1 0 0 0 13 10h7a1 1 0 0 1 .78 1.63l-9.9 10.2a.5.5 0 0 1-.86-.46l1.92-6.02A1 1 0 0 0 11 14z",
        key: "1xq2db"
      }
    ]
  ];
  var Zap = createLucideIcon("zap", __iconNode17);

  // components/ExerciseView.tsx
  var import_jsx_runtime4 = __toESM(require_jsx_runtime());
  var GROUP_COLORS = {
    "warmup": { text: "text-amber-600", bg: "bg-amber-100", border: "hover:border-amber-400", hoverText: "group-hover:text-amber-700" },
    "technique": { text: "text-sky-600", bg: "bg-sky-100", border: "hover:border-sky-400", hoverText: "group-hover:text-sky-700" },
    "agility": { text: "text-emerald-600", bg: "bg-emerald-100", border: "hover:border-emerald-400", hoverText: "group-hover:text-emerald-700" },
    "ear": { text: "text-fuchsia-600", bg: "bg-fuchsia-100", border: "hover:border-fuchsia-400", hoverText: "group-hover:text-fuchsia-700" },
    "style": { text: "text-rose-600", bg: "bg-rose-100", border: "hover:border-rose-400", hoverText: "group-hover:text-rose-700" },
    "Default": { text: "text-slate-600", bg: "bg-slate-100", border: "hover:border-violet-300", hoverText: "group-hover:text-violet-700" }
  };
  var ExerciseView = ({ onSelectExercise, currentTheme, savedAIExercises, favoriteExerciseIds, onToggleFavorite }) => {
    const { t } = useTranslation();
    const allExercises = [...EXERCISES, ...savedAIExercises];
    const orderedCategories = [
      "warmup",
      "technique",
      "agility",
      "ear",
      "style"
    ];
    const presentCategories = Array.from(new Set(allExercises.map((ex) => ex.category)));
    const categories = [
      ...orderedCategories.filter((c) => presentCategories.includes(c)),
      ...presentCategories.filter((c) => !orderedCategories.includes(c))
    ];
    return /* @__PURE__ */ (0, import_jsx_runtime4.jsx)("div", { className: "flex-grow overflow-y-auto px-4 py-6 font-sans", children: /* @__PURE__ */ (0, import_jsx_runtime4.jsx)("div", { className: "max-w-4xl mx-auto space-y-8 pb-32", children: categories.map((category) => {
      const categoryExercises = allExercises.filter((ex) => ex.category === category);
      const colors = GROUP_COLORS[category] || GROUP_COLORS.Default;
      return /* @__PURE__ */ (0, import_jsx_runtime4.jsxs)("section", { children: [
        /* @__PURE__ */ (0, import_jsx_runtime4.jsxs)("h2", { className: "text-base font-bold mb-2 flex items-center gap-2 text-slate-800 dark:text-slate-200", children: [
          /* @__PURE__ */ (0, import_jsx_runtime4.jsx)(Music, { size: 18 }),
          " ",
          t(category)
        ] }),
        /* @__PURE__ */ (0, import_jsx_runtime4.jsx)("div", { className: "grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-3", children: categoryExercises.map((exercise) => {
          const isFavorite = favoriteExerciseIds.includes(exercise.exercise_id);
          const isAI = exercise.isAIGenerated;
          return /* @__PURE__ */ (0, import_jsx_runtime4.jsxs)(
            "button",
            {
              onClick: () => onSelectExercise(exercise),
              className: `text-left p-3 rounded-xl border-2 transition-all duration-200 relative overflow-hidden hover:scale-[1.02] hover:shadow-lg ${colors.border} bg-white dark:bg-slate-800 border-slate-200 dark:border-slate-700`,
              children: [
                /* @__PURE__ */ (0, import_jsx_runtime4.jsx)(
                  "button",
                  {
                    type: "button",
                    onClick: (e) => {
                      e.preventDefault();
                      e.stopPropagation();
                      onToggleFavorite(exercise.exercise_id);
                    },
                    className: "absolute top-2 right-2 p-1.5 rounded-full bg-white/40 dark:bg-slate-700/40 backdrop-blur-sm text-slate-400 hover:text-amber-500 transition-all hover:scale-110 z-20 cursor-pointer",
                    children: /* @__PURE__ */ (0, import_jsx_runtime4.jsx)(Star, { size: 16, className: isFavorite ? "fill-amber-400 text-amber-400" : "" })
                  }
                ),
                isAI && /* @__PURE__ */ (0, import_jsx_runtime4.jsx)("div", { className: "absolute top-2 right-10 p-1.5", children: /* @__PURE__ */ (0, import_jsx_runtime4.jsx)(Sparkles, { size: 16, className: "text-violet-500" }) }),
                /* @__PURE__ */ (0, import_jsx_runtime4.jsxs)("div", { className: "relative z-10 pr-8", children: [
                  /* @__PURE__ */ (0, import_jsx_runtime4.jsx)("h3", { className: `font-bold text-base mb-1.5 transition-colors ${colors.hoverText} text-slate-800 dark:text-slate-200`, children: exercise.isAIGenerated ? exercise.name : t(exercise.name) }),
                  /* @__PURE__ */ (0, import_jsx_runtime4.jsx)("p", { className: "text-xs line-clamp-2 pb-6 text-slate-500 dark:text-slate-400", children: exercise.isAIGenerated ? exercise.desc : t(exercise.desc) })
                ] }),
                /* @__PURE__ */ (0, import_jsx_runtime4.jsx)("span", { className: `absolute bottom-2 right-2 text-[9px] uppercase font-bold px-1.5 py-0.5 rounded-full ${colors.bg} ${colors.text} z-20`, children: t(category) })
              ]
            },
            exercise.exercise_id
          );
        }) })
      ] }, category);
    }) }) });
  };
  var ExerciseView_default = ExerciseView;

  // components/ExerciseGameViewALTWrapper.tsx
  var import_react7 = __toESM(require_react());

  // utils/pitchDetection.ts
  var pYinHistory = null;
  var smoothRms = 0;
  var detectPitchPYIN = (buffer, sampleRate, params) => {
    const { bias, tolerance, gateThreshold, gateMode } = params;
    const bufferSize = buffer.length;
    let instantRms = 0;
    for (let i = 0; i < bufferSize; i++) {
      instantRms += buffer[i] * buffer[i];
    }
    instantRms = Math.sqrt(instantRms / bufferSize);
    const SMOOTHING_FACTOR = 0.95;
    smoothRms = instantRms * (1 - SMOOTHING_FACTOR) + smoothRms * SMOOTHING_FACTOR;
    let rmsToUse = gateMode === "smooth" ? smoothRms : instantRms;
    if (gateThreshold > 0 && rmsToUse < gateThreshold) {
      pYinHistory = null;
      return -1;
    }
    const yinBufferLength = bufferSize / 2;
    const yinBuffer = new Float32Array(yinBufferLength);
    for (let t = 0; t < yinBufferLength; t++) {
      yinBuffer[t] = 0;
      for (let i = 0; i < yinBufferLength; i++) {
        const delta = buffer[i] - buffer[i + t];
        yinBuffer[t] += delta * delta;
      }
    }
    yinBuffer[0] = 1;
    let runningSum = 0;
    for (let t = 1; t < yinBufferLength; t++) {
      runningSum += yinBuffer[t];
      if (runningSum === 0) {
        yinBuffer[t] = 1;
      } else {
        yinBuffer[t] *= t / runningSum;
      }
    }
    let candidates = [];
    for (let t = 2; t < yinBufferLength - 1; t++) {
      if (yinBuffer[t] < yinBuffer[t - 1] && yinBuffer[t] < yinBuffer[t + 1]) {
        if (yinBuffer[t] < 1) {
          candidates.push({ tau: t, error: yinBuffer[t] });
        }
      }
    }
    if (candidates.length === 0) {
      pYinHistory = null;
      return -1;
    }
    let bestScore = -1;
    let bestTau = -1;
    candidates.forEach((cand) => {
      let prob = Math.pow(1 - cand.error, 4);
      if (pYinHistory && pYinHistory > 0 && bias > 0) {
        const prevTau = sampleRate / pYinHistory;
        const ratio = Math.abs(cand.tau - prevTau) / prevTau;
        if (ratio < tolerance) {
          prob *= 1 + bias * 2;
        } else if (Math.abs(ratio - 0.5) < 0.05)
          prob *= 0.5;
      }
      if (prob > bestScore) {
        bestScore = prob;
        bestTau = cand.tau;
      }
    });
    if (bestScore < 0.01) {
      pYinHistory = null;
      return -1;
    }
    if (bestTau <= 0 || bestTau >= yinBufferLength - 1) {
      pYinHistory = null;
      return -1;
    }
    let s0 = yinBuffer[bestTau - 1];
    let s1 = yinBuffer[bestTau];
    let s2 = yinBuffer[bestTau + 1];
    let adjustment = (s2 - s0) / (2 * (2 * s1 - s2 - s0));
    const finalTau = bestTau + adjustment;
    const pitch = sampleRate / finalTau;
    pYinHistory = pitch;
    return pitch;
  };
  var resetPYINHistory = () => {
    pYinHistory = null;
    smoothRms = 0;
  };

  // components/ExerciseGameViewALT.tsx
  var import_react6 = __toESM(require_react());
  var import_jsx_runtime5 = __toESM(require_jsx_runtime());
  var noteStrings = ["C", "C#", "D", "D#", "E", "F", "F#", "G", "G#", "A", "A#", "B"];
  function getNote(frequency) {
    if (!frequency || frequency === -1)
      return { note: "-", cents: 0, octave: 0, midi: -1 };
    const noteNum = 12 * (Math.log(frequency / 440) / Math.log(2));
    const midi = Math.round(noteNum) + 69;
    const note = noteStrings[midi % 12];
    const octave = Math.floor(midi / 12) - 1;
    const cents = Math.floor((noteNum - Math.round(noteNum)) * 100);
    return { note, octave, cents, midi };
  }
  function getFrequency(midi) {
    return 440 * Math.pow(2, (midi - 69) / 12);
  }
  var getCanvasTheme = (currentTheme) => {
    const isDark = document.documentElement.classList.contains("dark");
    let primary = isDark ? "#a78bfa" : "#7c3aed";
    let secondary = isDark ? "#f0abfc" : "#c026d3";
    if (currentTheme) {
      if (currentTheme.visualizer && currentTheme.visualizer.length > 0) {
      }
    }
    if (isDark) {
      return {
        background: "#0f172a",
        // slate-900
        surface: "#1e293b",
        // slate-800
        gridLines: "#334155",
        // slate-700
        gridLabels: "#64748b",
        // slate-500
        primary,
        secondary,
        success: "#6ee7b7",
        // emerald-400
        text: "#f1f5f9",
        // slate-100
        textSubtle: "#94a3b8",
        // slate-400
        notePreview: "rgba(255, 255, 255, 0.05)",
        pitchLine: "#a78bfa"
        // violet-400
      };
    }
    return {
      background: "#f1f5f9",
      // slate-100
      surface: "#e2e8f0",
      // slate-200
      gridLines: "#cbd5e1",
      // slate-300
      gridLabels: "#94a3b8",
      // slate-400
      primary: "#8b5cf6",
      // violet-600
      secondary: "#d946ef",
      // fuchsia-500
      success: "#34d399",
      // emerald-400
      text: "#0f172a",
      // slate-900
      textSubtle: "#64748b",
      // slate-500
      notePreview: "rgba(0, 0, 0, 0.05)",
      pitchLine: "#8b5cf6"
      // violet-600
    };
  };
  function ExerciseGameViewALT(props) {
    const { t } = useTranslation();
    const {
      exercise,
      vocalRange,
      userPitch,
      visibleOctaves,
      isPlaying,
      micGain,
      playNote,
      onPlayPause,
      onStop,
      onBack,
      onRefine,
      currentRoutine,
      isExerciseFavorite,
      isRoutineFavorite,
      onToggleFavoriteExercise,
      onToggleFavoriteRoutine
    } = props;
    if (!exercise) {
      console.error("ExerciseGameViewALT: No exercise provided!");
      return /* @__PURE__ */ (0, import_jsx_runtime5.jsx)("div", { className: "flex items-center justify-center h-screen text-white", children: "No exercise data" });
    }
    const canvasTheme = getCanvasTheme(props.currentTheme);
    const canvasRef = (0, import_react6.useRef)(null);
    const containerRef = (0, import_react6.useRef)(null);
    const historyRef = (0, import_react6.useRef)([]);
    const userPitchRef = (0, import_react6.useRef)(null);
    const lastPitchPositionRef = (0, import_react6.useRef)(null);
    const [showSettings, setShowSettings] = (0, import_react6.useState)(false);
    const [showEngineSettings, setShowEngineSettings] = (0, import_react6.useState)(false);
    const [showControls, setShowControls] = (0, import_react6.useState)(true);
    const [dimensions, setDimensions] = (0, import_react6.useState)({ width: 800, height: 400 });
    const [cursorRatio, setCursorRatio] = (0, import_react6.useState)(0.2);
    const isDraggingRef = (0, import_react6.useRef)(false);
    const [isMetronomeOn, setIsMetronomeOn] = (0, import_react6.useState)(true);
    const [showMicPermissionDialog, setShowMicPermissionDialog] = (0, import_react6.useState)(false);
    const [showRefineInput, setShowRefineInput] = (0, import_react6.useState)(false);
    const [refinePrompt, setRefinePrompt] = (0, import_react6.useState)("");
    const [localParams, setLocalParams] = (0, import_react6.useState)({
      historyScale: 1,
      verticalZoom: 1.5,
      // Default 1.5 octaves visible (closer zoom)
      horizontalZoom: 3,
      // 3 seconds visible
      tempoMultiplier: 1
      // 1.0 = normal speed, 0.5 = half speed, 2.0 = double speed
    });
    const [currentKeyMidi, setCurrentKeyMidi] = (0, import_react6.useState)(() => {
      const semitone = vocalRange.start?.semitone ?? -9;
      return 60 + semitone;
    });
    const notesRef = (0, import_react6.useRef)([]);
    const timeoutsRef = (0, import_react6.useRef)([]);
    const particlesRef = (0, import_react6.useRef)([]);
    const lastHitTimeRef = (0, import_react6.useRef)(0);
    const visualPitchRef = (0, import_react6.useRef)(0);
    (0, import_react6.useEffect)(() => {
      return () => {
        timeoutsRef.current.forEach(clearTimeout);
        timeoutsRef.current = [];
      };
    }, []);
    const initialCameraRange = (0, import_react6.useMemo)(() => {
      let startMidi = vocalRange.start?.semitone;
      let endMidi = vocalRange.end?.semitone;
      if (startMidi == null || startMidi <= 0 || startMidi > 127) {
        startMidi = 48;
      }
      if (endMidi == null || endMidi <= 0 || endMidi > 127) {
        endMidi = 72;
      }
      const centerMidi = Math.floor((startMidi + endMidi) / 2);
      const octavesVisible = 2;
      const freqRatio = Math.pow(2, octavesVisible / 2);
      const centerFreq = getFrequency(centerMidi);
      return {
        minF: centerFreq / freqRatio,
        maxF: centerFreq * freqRatio
      };
    }, [vocalRange.start?.semitone, vocalRange.end?.semitone, visibleOctaves]);
    const cameraRef = (0, import_react6.useRef)(initialCameraRange);
    const startTimeRef = (0, import_react6.useRef)(0);
    const stopAllLocalEvents = (0, import_react6.useCallback)(() => {
      timeoutsRef.current.forEach((id) => clearTimeout(id));
      timeoutsRef.current = [];
    }, []);
    const pausedTimeRef = (0, import_react6.useRef)(0);
    const totalPausedTimeRef = (0, import_react6.useRef)(0);
    const pauseStartTimeRef = (0, import_react6.useRef)(0);
    (0, import_react6.useEffect)(() => {
      if (!isPlaying) {
        pauseStartTimeRef.current = performance.now();
        stopAllLocalEvents();
        setShowControls(true);
      } else {
        if (pauseStartTimeRef.current > 0 && notesRef.current.length > 0) {
          const pauseDuration = performance.now() - pauseStartTimeRef.current;
          totalPausedTimeRef.current += pauseDuration;
          pauseStartTimeRef.current = 0;
        } else {
          pauseStartTimeRef.current = 0;
          startGame();
        }
      }
      return () => stopAllLocalEvents();
    }, [isPlaying]);
    (0, import_react6.useEffect)(() => {
      cameraRef.current = initialCameraRange;
    }, [initialCameraRange]);
    (0, import_react6.useEffect)(() => {
      const container = containerRef.current;
      if (!container)
        return;
      const updateDimensions = () => {
        const dpr = window.devicePixelRatio || 1;
        const rect = container.getBoundingClientRect();
        if (rect.width > 0 && rect.height > 0) {
          setDimensions({
            width: rect.width * dpr,
            height: rect.height * dpr
          });
        }
      };
      const resizeObserver = new ResizeObserver(() => {
        updateDimensions();
      });
      resizeObserver.observe(container);
      requestAnimationFrame(() => {
        updateDimensions();
      });
      return () => resizeObserver.disconnect();
    }, []);
    const getCanvasCoords = (e) => {
      const canvas = canvasRef.current;
      if (!canvas)
        return { x: 0, y: 0 };
      const rect = canvas.getBoundingClientRect();
      let clientX, clientY;
      if (e.touches && e.touches.length > 0) {
        clientX = e.touches[0].clientX;
        clientY = e.touches[0].clientY;
      } else {
        clientX = e.clientX;
        clientY = e.clientY;
      }
      return {
        x: clientX - rect.left,
        y: clientY - rect.top
      };
    };
    const controlsTimeoutRef = (0, import_react6.useRef)(null);
    const toggleControls = (0, import_react6.useCallback)(() => {
      setShowControls(true);
      if (controlsTimeoutRef.current)
        clearTimeout(controlsTimeoutRef.current);
      if (isPlaying) {
        controlsTimeoutRef.current = setTimeout(() => setShowControls(false), 3e3);
      }
    }, [isPlaying]);
    (0, import_react6.useEffect)(() => {
      const handleInteraction = (e) => {
        const target = e.target;
        const isControlBtn = target.closest(".btn-interactive");
        if (e.target === canvasRef.current || isControlBtn)
          toggleControls();
      };
      window.addEventListener("click", handleInteraction);
      window.addEventListener("touchstart", handleInteraction, { passive: true });
      toggleControls();
      return () => {
        window.removeEventListener("click", handleInteraction);
        window.removeEventListener("touchstart", handleInteraction);
        if (controlsTimeoutRef.current)
          clearTimeout(controlsTimeoutRef.current);
      };
    }, [toggleControls]);
    (0, import_react6.useEffect)(() => {
      const isTouchDevice = "ontouchstart" in window || navigator.maxTouchPoints > 0;
      if (isTouchDevice) {
        return;
      }
      const handleKeyDown = (e) => {
        if (e.code === "Space") {
          e.preventDefault();
          props.onPlayPause();
          toggleControls();
        }
      };
      window.addEventListener("keydown", handleKeyDown);
      return () => window.removeEventListener("keydown", handleKeyDown);
    }, [props.onPlayPause, toggleControls]);
    const getGameTime = () => {
      let currentTotalPaused = totalPausedTimeRef.current;
      if (!isPlaying && pauseStartTimeRef.current > 0) {
        currentTotalPaused += performance.now() - pauseStartTimeRef.current;
      }
      return (performance.now() - startTimeRef.current - currentTotalPaused) / 1e3;
    };
    const getNoteStreamLeadTime = (0, import_react6.useCallback)(() => {
      const timeWindow = 5 * localParams.historyScale;
      return timeWindow * (1 - cursorRatio);
    }, [localParams.historyScale, cursorRatio]);
    const createNotes = (0, import_react6.useCallback)((rootMidi, anchorTime, type) => {
      const pattern = getExercisePattern(exercise);
      const bpm = getExerciseBPM(exercise);
      const secondsPerBeat = 60 / bpm;
      const beatDur = secondsPerBeat / localParams.tempoMultiplier;
      const durations = getExerciseDurations(exercise);
      const hasDurationsArray = durations && durations.length === pattern.length && durations.length > 0;
      let defaultDurationBeats = 1;
      if (durations && durations.length > 0) {
        defaultDurationBeats = durations[0];
      }
      if (defaultDurationBeats > 10) {
        defaultDurationBeats = defaultDurationBeats / 1e3 / (60 / 90);
      }
      const effectiveSecondsPerBeat = secondsPerBeat / localParams.tempoMultiplier;
      const notes = [];
      let currentTime = 0;
      const audioCtx = props.getAudioContext?.();
      const currentGameTime = getGameTime();
      const delayUntilSequenceStarts = anchorTime - currentGameTime;
      const safeDelay = Math.max(0, delayUntilSequenceStarts);
      const audioStartTime = audioCtx ? audioCtx.currentTime + safeDelay : 0;
      pattern.forEach((semitoneOffset, i) => {
        const midi = rootMidi + semitoneOffset;
        const freq = getFrequency(midi);
        let durationBeats = defaultDurationBeats;
        if (hasDurationsArray) {
          durationBeats = durations[i];
          if (durationBeats > 10) {
            durationBeats = durationBeats / 1e3 / (60 / 90);
          }
        }
        const noteDurationSeconds = durationBeats * effectiveSecondsPerBeat;
        const absoluteHitTime = anchorTime + currentTime;
        const AUDIO_LATENCY_COMPENSATION = 0.05;
        const audioScheduleTime = audioStartTime + currentTime + AUDIO_LATENCY_COMPENSATION;
        const waveType = type === "preview" ? "triangle" : "sine";
        const volume = 1;
        const playDuration = noteDurationSeconds * 0.95;
        if (audioCtx) {
          playNote(freq, audioScheduleTime, playDuration, waveType, volume);
        }
        notes.push({
          id: Math.random(),
          midi,
          freq,
          startTime: absoluteHitTime,
          duration: noteDurationSeconds,
          // Visual duration = full beat duration
          type,
          hit: false
        });
        currentTime += noteDurationSeconds;
      });
      return { notes, totalDuration: currentTime };
    }, [exercise, playNote, props, localParams.tempoMultiplier]);
    const scheduleEvent = (callback, delayMs) => {
      if (!isPlaying)
        return;
      const timeoutId = setTimeout(callback, delayMs);
      timeoutsRef.current.push(timeoutId);
    };
    const sanitizeMidiRange = (0, import_react6.useCallback)((startMidi, endMidi) => {
      let start = startMidi || 48;
      let end = endMidi || 72;
      if (start < 36) {
        start = 48;
      }
      if (start > 84) {
        start = 60;
      }
      if (end < 48) {
        end = 72;
      }
      if (end > 96) {
        end = 84;
      }
      if (end <= start) {
        start = 48;
        end = 72;
      }
      return { start, end };
    }, []);
    const playChord = (0, import_react6.useCallback)((rootMidi, startTime, duration, pattern) => {
      const hasMinorThird = pattern.some((semitone) => semitone === 3);
      const thirdInterval = hasMinorThird ? 3 : 4;
      playNote(getFrequency(rootMidi), startTime, duration, "sine", 0.35);
      playNote(getFrequency(rootMidi + thirdInterval), startTime, duration, "sine", 0.35);
      playNote(getFrequency(rootMidi + 7), startTime, duration, "sine", 0.35);
    }, [playNote]);
    const directionRef = (0, import_react6.useRef)(1);
    const isLastSequenceScheduledRef = (0, import_react6.useRef)(false);
    const currentChordNodesRef = (0, import_react6.useRef)([]);
    const scheduleNextSequence = (0, import_react6.useCallback)((rootMidi, sequenceStartTime) => {
      if (!isPlaying)
        return;
      const audioCtx = props.getAudioContext?.();
      if (!audioCtx)
        return;
      const now = getGameTime();
      const bpm = getExerciseBPM(exercise);
      const beatDur = 60 / bpm / localParams.tempoMultiplier;
      const pattern = getExercisePattern(exercise);
      const noteSemitones = pattern.filter((s) => s > 0);
      const hasMinorThird = noteSemitones.includes(3);
      const thirdInterval = hasMinorThird ? 3 : 4;
      const { notes, totalDuration } = createNotes(rootMidi, sequenceStartTime, "target");
      notesRef.current = [...notesRef.current, ...notes];
      const sequenceBeats = totalDuration / beatDur;
      let beatsToNextMeasure = Math.ceil(sequenceBeats / 4) * 4;
      let paddingBeats = beatsToNextMeasure - sequenceBeats;
      if (paddingBeats < 2) {
        beatsToNextMeasure += 4;
        paddingBeats = beatsToNextMeasure - sequenceBeats;
      }
      const currentChordBeats = Math.min(2, Math.floor(paddingBeats / 2));
      const nextChordBeats = paddingBeats - currentChordBeats;
      if (currentChordBeats > 0) {
        const currentChordTime = audioCtx.currentTime + sequenceStartTime + totalDuration - now;
        const currentChordDur = currentChordBeats * beatDur;
        playNote(getFrequency(rootMidi), currentChordTime, currentChordDur, "sine", 0.35);
        playNote(getFrequency(rootMidi + thirdInterval), currentChordTime, currentChordDur, "sine", 0.35);
        playNote(getFrequency(rootMidi + 7), currentChordTime, currentChordDur, "sine", 0.35);
      }
      const nextSequenceAnchorTime = sequenceStartTime + beatsToNextMeasure * beatDur;
      const maxPatternInterval = Math.max(...noteSemitones);
      const { start: minMidi, end: maxMidi } = sanitizeMidiRange(
        vocalRange.start?.semitone,
        vocalRange.end?.semitone
      );
      let nextRootMidi = rootMidi + directionRef.current;
      let shouldStop = false;
      if (directionRef.current === 1) {
        const projectedPeak = nextRootMidi + maxPatternInterval;
        if (projectedPeak > maxMidi) {
          directionRef.current = -1;
          nextRootMidi = rootMidi - 1;
        }
      }
      if (directionRef.current === -1) {
        if (nextRootMidi < minMidi) {
          shouldStop = true;
        }
      }
      const willBeLastSequence = shouldStop;
      if (willBeLastSequence && !isLastSequenceScheduledRef.current) {
        isLastSequenceScheduledRef.current = true;
        const completionDelay = (nextSequenceAnchorTime - now) * 1e3;
        scheduleEvent(() => {
          if (!isPlaying)
            return;
          stopAllLocalEvents();
          props.onComplete();
        }, Math.max(0, completionDelay));
        return;
      } else if (isLastSequenceScheduledRef.current) {
        return;
      }
      if (nextChordBeats > 0) {
        const nextChordTime = audioCtx.currentTime + sequenceStartTime + totalDuration + currentChordBeats * beatDur - now;
        const nextChordDur = nextChordBeats * beatDur + 1 * beatDur;
        const nextThirdInterval = hasMinorThird ? 3 : 4;
        playNote(getFrequency(nextRootMidi), nextChordTime, nextChordDur, "sine", 0.35);
        playNote(getFrequency(nextRootMidi + nextThirdInterval), nextChordTime, nextChordDur, "sine", 0.35);
        playNote(getFrequency(nextRootMidi + 7), nextChordTime, nextChordDur, "sine", 0.35);
      }
      const timeToNextGenMs = (nextSequenceAnchorTime - getNoteStreamLeadTime() - now) * 1e3;
      const safeDelayMs = Math.max(0, timeToNextGenMs);
      scheduleEvent(() => {
        if (!isPlaying)
          return;
        setCurrentKeyMidi(nextRootMidi);
        scheduleNextSequence(nextRootMidi, nextSequenceAnchorTime);
      }, safeDelayMs);
    }, [isPlaying, vocalRange, exercise, getNoteStreamLeadTime, createNotes, props, sanitizeMidiRange, localParams.tempoMultiplier, playNote, stopAllLocalEvents]);
    (0, import_react6.useEffect)(() => {
      if (!isPlaying || !isMetronomeOn || !props.playMetronomeClick)
        return;
      const bpm = getExerciseBPM(exercise);
      const secondsPerBeat = 60 / bpm;
      const beatDur = secondsPerBeat / localParams.tempoMultiplier;
      const clickInterval = beatDur;
      const timeWindow = 5 * localParams.historyScale;
      const leadTime = timeWindow * (1 - cursorRatio);
      const anchorTime = Math.max(leadTime, 4 * beatDur);
      const audioCtx = props.getAudioContext?.();
      if (!audioCtx)
        return;
      const firstClickTime = anchorTime - 4 * beatDur;
      let nextClickIndex = 0;
      let isCancelled = false;
      let timeoutId;
      const scheduleClick = () => {
        if (isCancelled)
          return;
        const gameTime = (performance.now() - startTimeRef.current) / 1e3;
        const nextClickTime = firstClickTime + nextClickIndex * clickInterval;
        if (nextClickTime < gameTime - 0.1) {
          nextClickIndex++;
          scheduleClick();
          return;
        }
        const delayMs = (nextClickTime - gameTime) * 1e3;
        timeoutId = setTimeout(() => {
          if (isCancelled)
            return;
          const audioTime = audioCtx.currentTime;
          props.playMetronomeClick?.(audioTime);
          nextClickIndex++;
          scheduleClick();
        }, Math.max(0, delayMs));
      };
      scheduleClick();
      return () => {
        isCancelled = true;
        clearTimeout(timeoutId);
      };
    }, [isPlaying, isMetronomeOn]);
    const startGame = () => {
      notesRef.current = [];
      stopAllLocalEvents();
      isLastSequenceScheduledRef.current = false;
      directionRef.current = 1;
      startTimeRef.current = performance.now();
      const now = 0;
      const leadTime = getNoteStreamLeadTime();
      const bpm = getExerciseBPM(exercise);
      const secondsPerBeat = 60 / bpm;
      const beatDur = secondsPerBeat / localParams.tempoMultiplier;
      const { start: startKey, end: endKey } = sanitizeMidiRange(
        vocalRange.start?.semitone,
        vocalRange.end?.semitone
      );
      setCurrentKeyMidi(startKey);
      const anchorTime = Math.max(leadTime, 4 * beatDur);
      const pattern = getExercisePattern(exercise);
      const audioCtx = props.getAudioContext?.();
      if (audioCtx) {
        const introChordTime = audioCtx.currentTime + anchorTime - 4 * beatDur;
        const introChordDur = 4 * beatDur;
        playChord(startKey, introChordTime, introChordDur, pattern);
      }
      const previewData = createNotes(startKey, anchorTime, "preview");
      notesRef.current = [...notesRef.current, ...previewData.notes];
      const initialGapDuration = 2 * beatDur;
      const firstTargetHitTime = anchorTime + previewData.totalDuration + initialGapDuration;
      if (audioCtx) {
        const firstTargetChordTime = audioCtx.currentTime + firstTargetHitTime - 4 * beatDur;
        const firstTargetChordDur = 4 * beatDur;
        playChord(startKey, firstTargetChordTime, firstTargetChordDur, pattern);
      }
      scheduleNextSequence(startKey, firstTargetHitTime);
      toggleControls();
    };
    (0, import_react6.useEffect)(() => {
      if (!isPlaying) {
        stopAllLocalEvents();
      }
    }, [isPlaying, stopAllLocalEvents]);
    (0, import_react6.useEffect)(() => {
      if (userPitch && userPitch > 100) {
        userPitchRef.current = { frequency: userPitch, confidence: 1 };
      } else {
        userPitchRef.current = null;
      }
    }, [userPitch]);
    (0, import_react6.useEffect)(() => {
      const canvas = canvasRef.current;
      if (!canvas)
        return;
      const ctx = canvas.getContext("2d");
      if (!ctx)
        return;
      const width = canvas.width;
      const height = canvas.height;
      const extendedGrid = [];
      for (let m = 36; m <= 96; m++) {
        const midiIndex = m % 12;
        const isNatural = [0, 2, 4, 5, 7, 9, 11].includes(midiIndex);
        extendedGrid.push({ midi: m, freq: getFrequency(m), isNatural });
      }
      let animationFrameId;
      const pixelsPerSecond = width / localParams.horizontalZoom / localParams.historyScale;
      const loop = () => {
        try {
          const currentPitchFreq = userPitchRef.current?.frequency || -1;
          const hasSignalNow = currentPitchFreq > 50 && currentPitchFreq < 2e3;
          if (hasSignalNow) {
            if (visualPitchRef.current <= 0) {
              visualPitchRef.current = currentPitchFreq;
            } else {
              const diff = currentPitchFreq - visualPitchRef.current;
              const maxChangeRatio = 0.03;
              const maxChange = visualPitchRef.current * maxChangeRatio;
              const clampedDiff = Math.max(-maxChange, Math.min(maxChange, diff));
              visualPitchRef.current += clampedDiff * 0.5;
            }
          }
          const currentPitch = currentPitchFreq;
          const hasUserSignal = hasSignalNow;
          const cursorX = width * cursorRatio;
          let dynamicCenterMidi = currentKeyMidi + 5;
          const targetCenterFreq = getFrequency(dynamicCenterMidi);
          const octavesVisible = localParams.verticalZoom;
          const freqRatio = Math.pow(2, octavesVisible / 2);
          const targetMinF = targetCenterFreq / freqRatio;
          const targetMaxF = targetCenterFreq * freqRatio;
          cameraRef.current.minF += (targetMinF - cameraRef.current.minF) * 0.05;
          cameraRef.current.maxF += (targetMaxF - cameraRef.current.maxF) * 0.05;
          const { minF, maxF } = cameraRef.current;
          const getLogY = (f) => {
            const safeF = Math.max(1, f);
            const safeMin = Math.max(1, minF);
            const safeMax = Math.max(1, maxF);
            if (safeMax === safeMin)
              return height / 2;
            const normalized = (Math.log(safeF) - Math.log(safeMin)) / (Math.log(safeMax) - Math.log(safeMin));
            return height - normalized * height;
          };
          const y1 = getLogY(440);
          const y2 = getLogY(440 * Math.pow(2, 1 / 12));
          const laneHeight = Math.abs(y1 - y2);
          const VISUAL_LATENCY = 0.08;
          const rawTime = getGameTime();
          const now = rawTime - VISUAL_LATENCY;
          const visualNow = performance.now() / 1e3;
          ctx.clearRect(0, 0, width, height);
          extendedGrid.forEach((item) => {
            const y = getLogY(item.freq);
            ctx.strokeStyle = canvasTheme.gridLines;
            ctx.lineWidth = 1.5;
            ctx.beginPath();
            ctx.moveTo(0, y);
            ctx.lineTo(width, y);
            ctx.stroke();
            if (item.isNatural) {
              const { note: gridNote, octave: gridOctave } = getNote(item.freq);
              ctx.fillStyle = canvasTheme.gridLabels;
              ctx.font = "12px monospace";
              ctx.fillText(`${gridNote}${gridOctave}`, 5, y - 2);
            }
          });
          if (hasSignalNow && currentPitchFreq) {
            historyRef.current.push({ frequency: visualPitchRef.current, time: visualNow });
            const cutoffTime = visualNow - 2;
            while (historyRef.current.length > 0 && historyRef.current[0].time < cutoffTime) {
              historyRef.current.shift();
            }
          }
          if (isPlaying || notesRef.current.length > 0) {
            if (isPlaying) {
              notesRef.current = notesRef.current.filter((note2) => {
                const deltaT = note2.startTime - now;
                const noteWidth = note2.duration * pixelsPerSecond;
                const noteX = cursorX + deltaT * pixelsPerSecond;
                return noteX + noteWidth > -100;
              });
            }
            notesRef.current.forEach((note2) => {
              const deltaT = note2.startTime - now;
              const noteWidth = note2.duration * pixelsPerSecond;
              const noteX = cursorX + deltaT * pixelsPerSecond;
              const noteY = getLogY(note2.freq);
              if (noteX > width)
                return;
              const isCrossingCursor = noteX <= cursorX && noteX + noteWidth >= cursorX;
              const isPast = noteX + noteWidth < cursorX;
              if (isPlaying && note2.type === "target" && isCrossingCursor && hasUserSignal) {
                const { midi } = getNote(currentPitch);
                if (Math.abs(midi - note2.midi) < 0.6) {
                  note2.hit = true;
                }
              }
              const distanceToCursor = noteX - cursorX;
              const maxDistance = width - cursorX;
              const progress = Math.max(0, Math.min(1, 1 - distanceToCursor / maxDistance));
              let crossProgress = 0;
              if (isCrossingCursor) {
                const crossedAmount = cursorX - noteX;
                crossProgress = Math.max(0, Math.min(1, crossedAmount / noteWidth));
              } else if (isPast) {
                crossProgress = 1;
              }
              let fillColor = canvasTheme.primary;
              let strokeColor = canvasTheme.primary;
              let glowColor = null;
              let label = null;
              let useGradient = false;
              let gradientColors = null;
              if (note2.type === "preview") {
                fillColor = "rgba(150, 160, 180, 0.2)";
                strokeColor = "rgba(150, 160, 180, 0.4)";
                ctx.setLineDash([4, 4]);
              } else if (note2.type === "target") {
                ctx.setLineDash([]);
                if (note2.hit) {
                  useGradient = true;
                  gradientColors = { start: "#34D399", end: "#10B981" };
                  strokeColor = "#059669";
                  glowColor = "#34D399";
                } else if (isCrossingCursor) {
                  useGradient = true;
                  const violetStart = "#8B5CF6";
                  const violetEnd = "#C4B5FD";
                  gradientColors = { start: violetStart, end: violetEnd, crossProgress };
                } else if (isPast) {
                  useGradient = true;
                  gradientColors = { start: "#DC2626", end: "#EF4444" };
                  strokeColor = "#DC2626";
                } else {
                  useGradient = true;
                  const getThemeColor = (p) => {
                    let r, g, b;
                    if (p < 0.5) {
                      const localP = p * 2;
                      r = 139 + (217 - 139) * localP;
                      g = 92 + (70 - 92) * localP;
                      b = 246 + (239 - 246) * localP;
                    } else {
                      const localP = (p - 0.5) * 2;
                      r = 217 + (250 - 217) * localP;
                      g = 70 + (204 - 70) * localP;
                      b = 239 + (21 - 239) * localP;
                    }
                    return `rgb(${Math.round(r)}, ${Math.round(g)}, ${Math.round(b)})`;
                  };
                  const leftDist = Math.max(0, noteX - cursorX);
                  const rightDist = Math.max(0, noteX + noteWidth - cursorX);
                  const maxDist = width - cursorX;
                  const pLeft = Math.min(1, leftDist / maxDist);
                  const pRight = Math.min(1, rightDist / maxDist);
                  gradientColors = { start: getThemeColor(pLeft), end: getThemeColor(pRight) };
                  strokeColor = getThemeColor(pRight);
                }
              }
              if (noteY < -50 || noteY > height + 50)
                return;
              if (glowColor) {
                ctx.shadowBlur = 20;
                ctx.shadowColor = glowColor;
              } else {
                ctx.shadowBlur = 0;
              }
              const rectHeight = Math.max(10, laneHeight * 0.8);
              const radius = rectHeight / 2;
              if (useGradient && gradientColors) {
                const gradient2 = ctx.createLinearGradient(noteX, 0, noteX + noteWidth, 0);
                if (gradientColors.crossProgress !== void 0) {
                  gradient2.addColorStop(0, gradientColors.start);
                  gradient2.addColorStop(gradientColors.crossProgress, gradientColors.end);
                  gradient2.addColorStop(1, gradientColors.end);
                } else {
                  gradient2.addColorStop(0, gradientColors.start);
                  gradient2.addColorStop(1, gradientColors.end);
                }
                ctx.fillStyle = gradient2;
              } else {
                ctx.fillStyle = fillColor;
              }
              ctx.strokeStyle = strokeColor;
              ctx.lineWidth = 2;
              ctx.beginPath();
              ctx.roundRect(noteX, noteY - rectHeight / 2, Math.max(4, noteWidth - 2), rectHeight, radius);
              ctx.fill();
              if (note2.type === "target") {
                const shineGrad = ctx.createLinearGradient(noteX, noteY - rectHeight / 2, noteX, noteY);
                shineGrad.addColorStop(0, "rgba(255,255,255,0.5)");
                shineGrad.addColorStop(0.5, "rgba(255,255,255,0.1)");
                shineGrad.addColorStop(1, "rgba(255,255,255,0.0)");
                ctx.fillStyle = shineGrad;
                ctx.fill();
              }
              ctx.stroke();
              ctx.setLineDash([]);
              ctx.shadowBlur = 0;
              if (noteWidth > 20) {
                ctx.fillStyle = note2.type === "preview" ? "rgba(0,0,0,0.6)" : "#000000";
                ctx.font = "bold 32px system-ui, -apple-system, sans-serif";
                ctx.textAlign = "center";
                ctx.fillText(getNote(note2.freq).note, noteX + noteWidth / 2, noteY + 10);
                ctx.textAlign = "left";
              }
            });
            const previewNotes = notesRef.current.filter((n) => n.type === "preview");
            let previewAlpha = 0;
            previewNotes.forEach((n) => {
              const deltaT = n.startTime - now;
              const endTime = n.startTime + n.duration;
              const deltaEnd = endTime - now;
              if (deltaT > -0.5 && deltaEnd > -1) {
                if (deltaT > 2) {
                  previewAlpha = Math.max(previewAlpha, 1 - (deltaT - 2));
                } else if (deltaEnd < 0.5 && deltaEnd > -1) {
                  previewAlpha = Math.max(previewAlpha, (deltaEnd + 1) / 1.5);
                } else {
                  previewAlpha = Math.max(previewAlpha, 0.9);
                }
              }
            });
            if (previewAlpha > 0.05) {
              ctx.save();
              ctx.font = "800 56px system-ui, -apple-system, sans-serif";
              ctx.textAlign = "center";
              const gradient2 = ctx.createLinearGradient(width / 2 - 100, 0, width / 2 + 100, 0);
              gradient2.addColorStop(0, `rgba(139, 92, 246, ${previewAlpha})`);
              gradient2.addColorStop(1, `rgba(217, 70, 239, ${previewAlpha})`);
              ctx.fillStyle = gradient2;
              ctx.fillText("PR\xC9VIA", width / 2, 120);
              ctx.restore();
            }
          }
          const history = historyRef.current;
          const historyPoints = Math.min(history.length, Math.ceil(cursorX / (1 / 60 * pixelsPerSecond)));
          ctx.lineWidth = 3;
          ctx.lineCap = "round";
          ctx.lineJoin = "round";
          const gradient = ctx.createLinearGradient(0, 0, cursorX, 0);
          gradient.addColorStop(0, "rgba(255, 255, 255, 0)");
          gradient.addColorStop(0.8, canvasTheme.pitchLine);
          gradient.addColorStop(1, "#ffffff");
          ctx.strokeStyle = gradient;
          const cycleSpeed = 2;
          const t2 = visualNow % cycleSpeed / cycleSpeed;
          const phase = Math.sin(t2 * Math.PI * 2) * 0.5 + 0.5;
          const lerpColor = (c1, c2, factor) => {
            const r = Math.round(c1[0] + (c2[0] - c1[0]) * factor);
            const g = Math.round(c1[1] + (c2[1] - c1[1]) * factor);
            const b = Math.round(c1[2] + (c2[2] - c1[2]) * factor);
            return `rgba(${r}, ${g}, ${b}`;
          };
          const violet = [139, 92, 246];
          const fuchsia = [217, 70, 239];
          const pink = [236, 72, 153];
          const color1Base = lerpColor(violet, fuchsia, phase);
          const color2Base = lerpColor(fuchsia, pink, phase);
          const getDynamicColor = (base, alpha) => {
            return `${base}, ${alpha})`;
          };
          if (hasSignalNow && historyPoints > 1) {
            const maxTrailPoints = 30;
            const pointsToDraw = Math.min(historyPoints, maxTrailPoints);
            if (pointsToDraw > 2) {
              ctx.beginPath();
              const newestPoint = history[history.length - 1];
              const oldestPoint = history[history.length - pointsToDraw];
              if (newestPoint && oldestPoint) {
                const startX = cursorX;
                const endX = cursorX - (visualNow - oldestPoint.time) * pixelsPerSecond;
                const trailGradient = ctx.createLinearGradient(startX, 0, endX, 0);
                trailGradient.addColorStop(0, getDynamicColor(color1Base, 1));
                trailGradient.addColorStop(0.4, getDynamicColor(color2Base, 0.8));
                trailGradient.addColorStop(1, getDynamicColor(color2Base, 0));
                ctx.strokeStyle = trailGradient;
                ctx.lineWidth = 12;
                ctx.lineCap = "round";
                ctx.lineJoin = "round";
                ctx.shadowBlur = 8;
                ctx.shadowColor = getDynamicColor(color1Base, 0.5);
                const cursorY = getLogY(visualPitchRef.current);
                ctx.moveTo(cursorX, cursorY);
                for (let i = 0; i < pointsToDraw; i++) {
                  const index = history.length - 1 - i;
                  const point = history[index];
                  if (!point || point.frequency <= 0) {
                    ctx.stroke();
                    ctx.beginPath();
                    continue;
                  }
                  const y = getLogY(point.frequency);
                  const x = cursorX - (visualNow - point.time) * pixelsPerSecond;
                  if (i === 0) {
                    const cpX = (cursorX + x) / 2;
                    const cpY = (cursorY + y) / 2;
                    ctx.quadraticCurveTo(cpX, cpY, x, y);
                  } else {
                    const prevIndex = history.length - i;
                    const prevPoint = history[prevIndex];
                    if (prevPoint) {
                      const prevY = getLogY(prevPoint.frequency);
                      const prevX = cursorX - (visualNow - prevPoint.time) * pixelsPerSecond;
                      const midX = (x + prevX) / 2;
                      const midY = (y + prevY) / 2;
                      const cpX = x;
                      const cpY = y;
                      const endX2 = (x + prevX) / 2;
                      const endY = (y + prevY) / 2;
                      ctx.quadraticCurveTo(cpX, cpY, endX2, endY);
                    } else {
                      ctx.lineTo(x, y);
                    }
                  }
                }
                ctx.stroke();
                ctx.shadowBlur = 0;
              }
            }
          }
          let isHitting = false;
          if (hasSignalNow) {
            const { midi: userMidi } = getNote(visualPitchRef.current);
            const targetNotes = notesRef.current.filter(
              (n) => n.type === "target" && n.startTime <= now && n.startTime + n.duration >= now
            );
            for (const target of targetNotes) {
              const { midi: targetMidi } = getNote(target.freq);
              if (Math.abs(userMidi - targetMidi) < 0.8) {
                isHitting = true;
                break;
              }
            }
          }
          if (isHitting && hasSignalNow) {
            if (now - lastHitTimeRef.current > 0.05) {
              lastHitTimeRef.current = now;
              const y = getLogY(currentPitchFreq);
              for (let k = 0; k < 10; k++) {
                particlesRef.current.push({
                  x: cursorX,
                  y,
                  vx: -80 - Math.random() * 100,
                  // Move BACKWARDS (negative = left) as if hit reaction
                  vy: (Math.random() - 0.5) * 120,
                  // Slight vertical spread
                  life: 1.2,
                  // Longer life
                  color: k % 2 === 0 ? "#34d399" : "#22c55e",
                  // Emerald Green variations
                  size: Math.random() * 6 + 3
                  // Larger particles
                });
              }
            }
          }
          for (let i = particlesRef.current.length - 1; i >= 0; i--) {
            const p = particlesRef.current[i];
            p.life -= 0.02;
            p.x += p.vx * 0.016;
            p.y += p.vy * 0.016;
            if (p.life <= 0) {
              particlesRef.current.splice(i, 1);
              continue;
            }
            ctx.beginPath();
            ctx.arc(p.x, p.y, p.size * p.life, 0, Math.PI * 2);
            ctx.fillStyle = p.color;
            ctx.globalAlpha = p.life;
            ctx.fill();
            ctx.globalAlpha = 1;
          }
          ctx.shadowBlur = 0;
          ctx.strokeStyle = canvasTheme.primary;
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.moveTo(cursorX, 0);
          ctx.lineTo(cursorX, height);
          ctx.stroke();
          let circleY;
          if (hasSignalNow) {
            circleY = getLogY(visualPitchRef.current);
            lastPitchPositionRef.current = { x: cursorX, y: circleY };
          } else if (lastPitchPositionRef.current) {
            circleY = lastPitchPositionRef.current.y;
          } else {
            circleY = height / 2;
          }
          if (circleY >= 0 && circleY <= height) {
            const radius = width < 768 ? 28 : 22;
            const isActive = hasSignalNow;
            const baseColor = isHitting ? "251, 191, 36" : isActive ? "139, 92, 246" : "150, 160, 180";
            const pulse = isHitting ? 1.5 + Math.sin(now * 20) * 0.5 : 1;
            ctx.beginPath();
            ctx.arc(cursorX, circleY, (radius + 8) * (isHitting ? 1.2 : 1), 0, Math.PI * 2);
            ctx.fillStyle = `rgba(${baseColor}, ${isHitting ? 0.4 : 0.15})`;
            ctx.fill();
            ctx.beginPath();
            ctx.arc(cursorX, circleY, radius + 4, 0, Math.PI * 2);
            ctx.strokeStyle = `rgba(${baseColor}, 0.4)`;
            ctx.lineWidth = 3;
            ctx.stroke();
            const gradient2 = ctx.createRadialGradient(cursorX, circleY, 0, cursorX, circleY, radius);
            if (isActive) {
              gradient2.addColorStop(0, "#C4B5FD");
              gradient2.addColorStop(1, "#8B5CF6");
            } else {
              gradient2.addColorStop(0, "#D1D5DB");
              gradient2.addColorStop(1, "#9CA3AF");
            }
            ctx.beginPath();
            ctx.arc(cursorX, circleY, radius, 0, Math.PI * 2);
            ctx.fillStyle = gradient2;
            ctx.fill();
            ctx.beginPath();
            ctx.arc(cursorX - radius / 3, circleY - radius / 3, radius / 3, 0, Math.PI * 2);
            ctx.fillStyle = "rgba(255, 255, 255, 0.4)";
            ctx.fill();
          }
          animationFrameId = requestAnimationFrame(loop);
        } catch (error) {
          console.error("Error in draw loop:", error);
        }
      };
      loop();
      return () => {
        cancelAnimationFrame(animationFrameId);
      };
    }, [isPlaying, localParams, getNoteStreamLeadTime, currentKeyMidi, exercise, vocalRange, createNotes, props.onComplete, scheduleNextSequence]);
    const { note, octave, cents } = getNote(userPitch);
    const hasSignal = (userPitch || 0) > 50 && (userPitch || 0) < 2e3;
    return /* @__PURE__ */ (0, import_jsx_runtime5.jsxs)("div", { className: "h-full w-full flex flex-col font-sans overflow-hidden", style: { backgroundColor: canvasTheme.background, color: canvasTheme.text }, children: [
      /* @__PURE__ */ (0, import_jsx_runtime5.jsx)("style", { children: `
                @keyframes shine {
                    0% { transform: translateX(-100%); }
                    100% { transform: translateX(100%); }
                }
                ` }),
      currentRoutine && /* @__PURE__ */ (0, import_jsx_runtime5.jsx)("div", { className: "absolute top-0 left-0 right-0 z-50 p-4 bg-gradient-to-b from-black/40 to-transparent backdrop-blur-sm", children: /* @__PURE__ */ (0, import_jsx_runtime5.jsxs)("div", { className: "text-center", children: [
        /* @__PURE__ */ (0, import_jsx_runtime5.jsx)("div", { className: "text-white/80 text-sm font-medium mb-1", children: currentRoutine.routine.name }),
        /* @__PURE__ */ (0, import_jsx_runtime5.jsxs)("div", { className: "text-white text-lg font-bold", children: [
          "Exercise ",
          currentRoutine.exerciseIndex + 1,
          " of ",
          currentRoutine.routine.exerciseIds.length
        ] })
      ] }) }),
      currentRoutine && /* @__PURE__ */ (0, import_jsx_runtime5.jsx)("div", { className: "absolute top-2 left-2 md:top-4 md:left-4 z-50", children: /* @__PURE__ */ (0, import_jsx_runtime5.jsx)("div", { className: "bg-white/40 backdrop-blur-xl border border-slate-200/50 rounded-2xl p-2 md:p-3 shadow-xl", children: /* @__PURE__ */ (0, import_jsx_runtime5.jsxs)("div", { className: "flex flex-col gap-0.5", children: [
        /* @__PURE__ */ (0, import_jsx_runtime5.jsx)("div", { className: "text-[9px] md:text-[10px] font-mono text-slate-500 uppercase tracking-widest", children: t("routineLabel") }),
        /* @__PURE__ */ (0, import_jsx_runtime5.jsx)("div", { className: "text-xs md:text-sm font-bold text-slate-900", children: t(currentRoutine.routine.name) }),
        /* @__PURE__ */ (0, import_jsx_runtime5.jsx)("div", { className: "text-[10px] md:text-xs font-mono text-slate-600", children: t("exerciseProgress", {
          current: currentRoutine.exerciseIndex + 1,
          total: currentRoutine.routine.exerciseIds.length
        }) })
      ] }) }) }),
      /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(
        "button",
        {
          onClick: () => {
            if (currentRoutine) {
              onToggleFavoriteRoutine(currentRoutine.routine.id);
            } else {
              onToggleFavoriteExercise(getExerciseId(exercise));
            }
          },
          className: "absolute top-3 right-3 md:top-5 md:right-5 z-50 p-2 transition-all btn-interactive hover:scale-110 active:scale-95",
          title: currentRoutine ? "Favorite Routine" : "Favorite Exercise",
          children: /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(
            Star,
            {
              size: 32,
              strokeWidth: 2,
              className: `transition-all ${(currentRoutine ? isRoutineFavorite : isExerciseFavorite) ? "fill-amber-400 text-amber-400" : "fill-transparent text-amber-400"}`
            }
          )
        }
      ),
      exercise.isAIGenerated && showRefineInput && /* @__PURE__ */ (0, import_jsx_runtime5.jsx)("div", { className: "absolute inset-0 z-50 flex items-center justify-center p-4 bg-black/20 backdrop-blur-sm", children: /* @__PURE__ */ (0, import_jsx_runtime5.jsxs)("div", { className: "w-full max-w-md bg-white dark:bg-slate-900 rounded-2xl shadow-2xl border border-violet-200 dark:border-violet-700 p-4 animate-in zoom-in-95 duration-200", children: [
        /* @__PURE__ */ (0, import_jsx_runtime5.jsxs)("div", { className: "flex items-center gap-2 mb-3", children: [
          /* @__PURE__ */ (0, import_jsx_runtime5.jsx)("svg", { className: "w-5 h-5 text-violet-600", fill: "none", viewBox: "0 0 24 24", stroke: "currentColor", children: /* @__PURE__ */ (0, import_jsx_runtime5.jsx)("path", { strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 2, d: "M11 5H6a2 2 0 00-2 2v11a2 2 0 002 2h11a2 2 0 002-2v-5m-1.414-9.414a2 2 0 112.828 2.828L11.828 15H9v-2.828l8.586-8.586z" }) }),
          /* @__PURE__ */ (0, import_jsx_runtime5.jsx)("h3", { className: "font-bold text-slate-900 dark:text-slate-100", children: "Refinar" }),
          /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(
            "button",
            {
              onClick: () => setShowRefineInput(false),
              className: "ml-auto w-7 h-7 rounded-full bg-slate-200 dark:bg-slate-700 hover:bg-slate-300 dark:hover:bg-slate-600 flex items-center justify-center transition-colors",
              children: /* @__PURE__ */ (0, import_jsx_runtime5.jsx)("svg", { className: "w-4 h-4", fill: "none", viewBox: "0 0 24 24", stroke: "currentColor", children: /* @__PURE__ */ (0, import_jsx_runtime5.jsx)("path", { strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 2, d: "M6 18L18 6M6 6l12 12" }) })
            }
          )
        ] }),
        /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(
          "input",
          {
            type: "text",
            value: refinePrompt,
            onChange: (e) => setRefinePrompt(e.target.value),
            placeholder: "ex: Fa\xE7a mais r\xE1pido, mais agudo, ou mude a vogal...",
            className: "w-full px-4 py-2.5 rounded-lg bg-slate-100 dark:bg-slate-800 border border-slate-300 dark:border-slate-600 text-slate-900 dark:text-slate-100 placeholder-slate-500 dark:placeholder-slate-400 focus:outline-none focus:ring-2 focus:ring-violet-500 text-sm",
            autoFocus: true,
            onKeyDown: async (e) => {
              if (e.key === "Enter" && refinePrompt.trim() && onRefine) {
                const prompt = refinePrompt.trim();
                setRefinePrompt("");
                setShowRefineInput(false);
                await onRefine(exercise, prompt);
              } else if (e.key === "Escape") {
                setShowRefineInput(false);
              }
            }
          }
        ),
        /* @__PURE__ */ (0, import_jsx_runtime5.jsxs)("div", { className: "mt-2 text-xs text-slate-500 dark:text-slate-400 text-center", children: [
          "Press ",
          /* @__PURE__ */ (0, import_jsx_runtime5.jsx)("kbd", { className: "px-1.5 py-0.5 bg-slate-200 dark:bg-slate-700 rounded text-xs font-mono", children: "Enter" }),
          " to refine \u2022 ",
          /* @__PURE__ */ (0, import_jsx_runtime5.jsx)("kbd", { className: "px-1.5 py-0.5 bg-slate-200 dark:bg-slate-700 rounded text-xs font-mono", children: "ESC" }),
          " to cancel"
        ] })
      ] }) }),
      /* @__PURE__ */ (0, import_jsx_runtime5.jsxs)("div", { className: "flex-grow relative min-h-0", ref: containerRef, children: [
        /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(
          "canvas",
          {
            ref: canvasRef,
            width: dimensions.width,
            height: dimensions.height,
            className: "block w-full h-full relative z-10",
            style: {
              width: "100%",
              height: "100%"
            }
          }
        ),
        currentRoutine && /* @__PURE__ */ (0, import_jsx_runtime5.jsx)("div", { className: "absolute top-2 left-2 md:top-4 md:left-4 z-50", children: /* @__PURE__ */ (0, import_jsx_runtime5.jsx)("div", { className: "bg-white/40 dark:bg-slate-800/40 backdrop-blur-xl border border-slate-200/50 dark:border-slate-600/50 rounded-2xl p-2 md:p-3 shadow-xl", children: /* @__PURE__ */ (0, import_jsx_runtime5.jsxs)("div", { className: "flex flex-col gap-0.5", children: [
          /* @__PURE__ */ (0, import_jsx_runtime5.jsx)("div", { className: "text-[9px] md:text-[10px] font-mono text-slate-500 dark:text-slate-400 uppercase tracking-widest", children: t("routineLabel") }),
          /* @__PURE__ */ (0, import_jsx_runtime5.jsx)("div", { className: "text-xs md:text-sm font-bold text-slate-900 dark:text-slate-100", children: t(currentRoutine.routine.name) }),
          /* @__PURE__ */ (0, import_jsx_runtime5.jsx)("div", { className: "text-[10px] md:text-xs font-mono text-slate-600 dark:text-slate-400", children: t("exerciseProgress", {
            current: currentRoutine.exerciseIndex + 1,
            total: currentRoutine.routine.exerciseIds.length
          }) })
        ] }) }) }),
        /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(
          "button",
          {
            onClick: () => {
              if (currentRoutine) {
                onToggleFavoriteRoutine(currentRoutine.routine.id);
              } else {
                onToggleFavoriteExercise(getExerciseId(exercise));
              }
            },
            className: "absolute top-3 right-3 md:top-5 md:right-5 z-50 p-2 transition-all btn-interactive hover:scale-110 active:scale-95",
            title: currentRoutine ? "Favorite Routine" : "Favorite Exercise",
            children: /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(
              Star,
              {
                size: 32,
                strokeWidth: 2,
                className: `transition-all ${(currentRoutine ? isRoutineFavorite : isExerciseFavorite) ? "fill-amber-400 text-amber-400" : "fill-transparent text-amber-400"}`
              }
            )
          }
        ),
        /* @__PURE__ */ (0, import_jsx_runtime5.jsx)("div", { className: "absolute left-0 right-0 z-50", style: { bottom: 0 }, children: /* @__PURE__ */ (0, import_jsx_runtime5.jsx)("div", { className: `w-full p-3 md:p-6 flex items-end justify-center pointer-events-auto transition-opacity duration-300`, children: /* @__PURE__ */ (0, import_jsx_runtime5.jsxs)("div", { className: "flex items-center gap-2 md:gap-3", children: [
          /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(
            "button",
            {
              onClick: onBack || onStop,
              className: `w-8 h-8 md:w-10 md:h-10 rounded-full ${isPlaying ? "bg-white/40 backdrop-blur-md border border-white/50 text-slate-700" : "bg-gradient-to-br from-yellow-400 to-yellow-500 border-2 border-yellow-300 text-slate-900"} flex items-center justify-center shadow-lg hover:scale-105 transition-all duration-300 ease-out btn-interactive`,
              children: /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(ChevronLeft, { size: 20, strokeWidth: 3 })
            }
          ),
          exercise.isAIGenerated && /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(
            "button",
            {
              onClick: () => setShowRefineInput(!showRefineInput),
              className: `w-8 h-8 md:w-10 md:h-10 rounded-full ${showRefineInput ? "bg-gradient-to-br from-violet-600 to-violet-700 border-2 border-violet-400 text-white" : isPlaying ? "bg-white/40 backdrop-blur-md border border-white/50 text-slate-700" : "bg-gradient-to-br from-violet-400 to-violet-500 border-2 border-violet-300 text-white"} flex items-center justify-center shadow-lg hover:scale-105 transition-all duration-300 ease-out btn-interactive`,
              children: /* @__PURE__ */ (0, import_jsx_runtime5.jsx)("svg", { className: "w-4 h-4 md:w-5 md:h-5", fill: "none", viewBox: "0 0 24 24", stroke: "currentColor", strokeWidth: 2.5, children: /* @__PURE__ */ (0, import_jsx_runtime5.jsx)("path", { strokeLinecap: "round", strokeLinejoin: "round", d: "M11 5H6a2 2 0 00-2 2v11a2 2 0 002 2h11a2 2 0 002-2v-5m-1.414-9.414a2 2 0 112.828 2.828L11.828 15H9v-2.828l8.586-8.586z" }) })
            }
          ),
          /* @__PURE__ */ (0, import_jsx_runtime5.jsxs)(
            "button",
            {
              onClick: onPlayPause,
              className: `w-12 h-12 md:w-14 md:h-14 rounded-full group transition-all duration-300 ease-out transform hover:scale-105 active:scale-95 text-white shadow-xl overflow-hidden opacity-100`,
              style: {
                backgroundImage: `linear-gradient(to bottom right, #8b5cf6, #d946ef, #facc15)`,
                boxShadow: `0 8px 32px rgba(217, 70, 239, 0.4), inset 0 1px 0 rgba(255, 255, 255, 0.2)`,
                transitionDelay: showControls ? "100ms" : "100ms"
              },
              children: [
                /* @__PURE__ */ (0, import_jsx_runtime5.jsx)("div", { className: "absolute inset-0 bg-gradient-to-br from-white/30 via-transparent to-transparent opacity-50" }),
                /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(
                  "div",
                  {
                    className: "absolute inset-0 bg-gradient-to-r from-transparent via-white/20 to-transparent animate-shine",
                    style: { animationName: "shine", animationDuration: "0.7s", animationDelay: "0s", animationTimingFunction: "linear", animationIterationCount: "infinite", animationPlayState: "running" }
                  }
                ),
                /* @__PURE__ */ (0, import_jsx_runtime5.jsx)("div", { className: "relative z-10 flex items-center justify-center h-full w-full", children: isPlaying ? /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(Pause, { size: 28, fill: "currentColor" }) : /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(Play, { size: 28, fill: "currentColor", className: "ml-1" }) })
              ]
            }
          ),
          props.onRestart && /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(
            "button",
            {
              onClick: () => {
                props.onRestart();
              },
              className: `w-10 h-10 md:w-12 md:h-12 rounded-full ${isPlaying ? "bg-white/40 backdrop-blur-md border border-white/50 text-slate-700" : "bg-white/60 backdrop-blur-md border border-slate-200/50 text-slate-800"} flex items-center justify-center shadow-xl hover:scale-105 transition-all duration-300 ease-out btn-interactive`,
              children: /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(RotateCcw, { size: 20 })
            }
          ),
          /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(
            "button",
            {
              onClick: props.onToggleFullscreen,
              className: `w-8 h-8 md:w-10 md:h-10 rounded-full ${isPlaying ? "bg-white/40 backdrop-blur-md border border-white/50 text-slate-700" : "bg-white/60 backdrop-blur-md border border-slate-200/50 text-slate-800"} flex items-center justify-center shadow-lg hover:scale-105 transition-all duration-300 ease-out btn-interactive`,
              title: props.isFullscreen ? "Exit Fullscreen" : "Enter Fullscreen",
              children: props.isFullscreen ? /* @__PURE__ */ (0, import_jsx_runtime5.jsx)("svg", { className: "w-4 h-4 md:w-5 md:h-5", fill: "none", viewBox: "0 0 24 24", stroke: "currentColor", strokeWidth: 2.5, children: /* @__PURE__ */ (0, import_jsx_runtime5.jsx)("path", { strokeLinecap: "round", strokeLinejoin: "round", d: "M8 4H4v4m12 4h4v-4M8 20H4v-4m12 4h4v-4" }) }) : /* @__PURE__ */ (0, import_jsx_runtime5.jsx)("svg", { className: "w-4 h-4 md:w-5 md:h-5", fill: "none", viewBox: "0 0 24 24", stroke: "currentColor", strokeWidth: 2.5, children: /* @__PURE__ */ (0, import_jsx_runtime5.jsx)("path", { strokeLinecap: "round", strokeLinejoin: "round", d: "M4 8V4h4m12 4V4h-4M4 16v4h4m12-4v4h-4" }) })
            }
          )
        ] }) }) }),
        showSettings && /* @__PURE__ */ (0, import_jsx_runtime5.jsxs)("div", { className: "fixed inset-x-0 bottom-0 max-h-[70vh] w-full rounded-t-2xl md:absolute md:top-20 md:right-4 md:w-72 md:rounded-2xl bg-white/40 backdrop-blur-xl p-4 md:p-5 border border-slate-200/50 shadow-2xl z-50 overflow-y-auto", children: [
          /* @__PURE__ */ (0, import_jsx_runtime5.jsxs)("h4", { className: "text-lg font-bold text-slate-900 mb-4 flex items-center justify-between gap-2 border-b border-slate-300/50 pb-2", children: [
            /* @__PURE__ */ (0, import_jsx_runtime5.jsxs)("div", { className: "flex items-center gap-2", children: [
              /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(Settings, { size: 18, className: "text-violet-600" }),
              " Range Settings"
            ] }),
            /* @__PURE__ */ (0, import_jsx_runtime5.jsx)("button", { onClick: () => setShowSettings(false), className: "w-7 h-7 rounded-full text-slate-500 hover:text-slate-800 btn-interactive flex items-center justify-center", children: /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(ChevronDown, { size: 18 }) })
          ] }),
          /* @__PURE__ */ (0, import_jsx_runtime5.jsxs)("div", { className: "space-y-4", children: [
            /* @__PURE__ */ (0, import_jsx_runtime5.jsxs)("div", { className: "bg-slate-100/50 rounded-lg p-3", children: [
              /* @__PURE__ */ (0, import_jsx_runtime5.jsx)("div", { className: "text-xs text-slate-600 mb-2 font-semibold", children: "Current Range" }),
              /* @__PURE__ */ (0, import_jsx_runtime5.jsxs)("div", { className: "text-sm font-mono text-slate-800", children: [
                vocalRange.start?.name || "C3",
                " - ",
                vocalRange.end?.name || "C5"
              ] })
            ] }),
            /* @__PURE__ */ (0, import_jsx_runtime5.jsxs)("div", { children: [
              /* @__PURE__ */ (0, import_jsx_runtime5.jsx)("div", { className: "text-xs text-slate-600 mb-2", children: "Shift Range (Semitones)" }),
              /* @__PURE__ */ (0, import_jsx_runtime5.jsxs)("div", { className: "flex items-center gap-2", children: [
                /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(
                  "button",
                  {
                    onClick: () => setCurrentKeyMidi((k) => Math.max(24, k - 1)),
                    className: "flex-1 px-3 py-2 rounded-lg bg-slate-200 hover:bg-slate-300 text-slate-800 font-semibold text-sm transition-colors",
                    children: "\u2193 Down"
                  }
                ),
                /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(
                  "button",
                  {
                    onClick: () => setCurrentKeyMidi((k) => Math.min(96, k + 1)),
                    className: "flex-1 px-3 py-2 rounded-lg bg-slate-200 hover:bg-slate-300 text-slate-800 font-semibold text-sm transition-colors",
                    children: "\u2191 Up"
                  }
                )
              ] })
            ] }),
            /* @__PURE__ */ (0, import_jsx_runtime5.jsxs)("div", { children: [
              /* @__PURE__ */ (0, import_jsx_runtime5.jsx)("div", { className: "text-xs text-slate-600 mb-2", children: "Quick Shift" }),
              /* @__PURE__ */ (0, import_jsx_runtime5.jsxs)("div", { className: "grid grid-cols-2 gap-2", children: [
                /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(
                  "button",
                  {
                    onClick: () => setCurrentKeyMidi((k) => Math.max(24, k - 12)),
                    className: "px-3 py-2 rounded-lg bg-violet-100 hover:bg-violet-200 text-violet-800 font-semibold text-xs transition-colors",
                    children: "-1 Octave"
                  }
                ),
                /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(
                  "button",
                  {
                    onClick: () => setCurrentKeyMidi((k) => Math.min(96, k + 12)),
                    className: "px-3 py-2 rounded-lg bg-violet-100 hover:bg-violet-200 text-violet-800 font-semibold text-xs transition-colors",
                    children: "+1 Octave"
                  }
                )
              ] })
            ] }),
            /* @__PURE__ */ (0, import_jsx_runtime5.jsx)("div", { className: "text-xs text-slate-500 italic pt-2 border-t border-slate-200", children: "Tip: Adjust if exercises feel too high or too low for your voice." })
          ] })
        ] }),
        showEngineSettings && /* @__PURE__ */ (0, import_jsx_runtime5.jsxs)("div", { className: "fixed inset-x-0 bottom-0 max-h-[70vh] w-full rounded-t-2xl md:absolute md:top-20 md:right-4 md:w-72 md:rounded-2xl bg-white/40 backdrop-blur-xl p-4 md:p-5 border border-slate-200/50 shadow-2xl z-50 overflow-y-auto", children: [
          /* @__PURE__ */ (0, import_jsx_runtime5.jsxs)("h4", { className: "text-lg font-bold text-slate-900 mb-4 flex items-center justify-between gap-2 border-b border-slate-300/50 pb-2", children: [
            /* @__PURE__ */ (0, import_jsx_runtime5.jsxs)("div", { className: "flex items-center gap-2", children: [
              /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(Zap, { size: 18, className: "text-indigo-600" }),
              " Engine Settings"
            ] }),
            /* @__PURE__ */ (0, import_jsx_runtime5.jsx)("button", { onClick: () => setShowEngineSettings(false), className: "w-7 h-7 rounded-full text-slate-500 hover:text-slate-800 btn-interactive flex items-center justify-center", children: /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(ChevronDown, { size: 18 }) })
          ] }),
          /* @__PURE__ */ (0, import_jsx_runtime5.jsxs)("div", { className: "mb-4", children: [
            /* @__PURE__ */ (0, import_jsx_runtime5.jsxs)("div", { className: "flex justify-between text-xs text-slate-500 mb-1", children: [
              /* @__PURE__ */ (0, import_jsx_runtime5.jsx)("span", { children: "Vertical Zoom (Octaves)" }),
              /* @__PURE__ */ (0, import_jsx_runtime5.jsx)("span", { className: "font-mono text-violet-600", children: localParams.verticalZoom.toFixed(1) })
            ] }),
            /* @__PURE__ */ (0, import_jsx_runtime5.jsx)("input", { type: "range", min: "1", max: "4", step: "0.5", value: localParams.verticalZoom, onChange: (e) => setLocalParams((p) => ({ ...p, verticalZoom: parseFloat(e.target.value) })), className: "w-full h-1 bg-slate-200 rounded-lg appearance-none cursor-pointer accent-violet-600" })
          ] }),
          /* @__PURE__ */ (0, import_jsx_runtime5.jsxs)("div", { className: "mb-4", children: [
            /* @__PURE__ */ (0, import_jsx_runtime5.jsxs)("div", { className: "flex justify-between text-xs text-slate-500 mb-1", children: [
              /* @__PURE__ */ (0, import_jsx_runtime5.jsx)("span", { children: "Horizontal Zoom (Seconds)" }),
              /* @__PURE__ */ (0, import_jsx_runtime5.jsx)("span", { className: "font-mono text-violet-600", children: localParams.horizontalZoom.toFixed(1) })
            ] }),
            /* @__PURE__ */ (0, import_jsx_runtime5.jsx)("input", { type: "range", min: "1", max: "5", step: "0.5", value: localParams.horizontalZoom, onChange: (e) => setLocalParams((p) => ({ ...p, horizontalZoom: parseFloat(e.target.value) })), className: "w-full h-1 bg-slate-200 rounded-lg appearance-none cursor-pointer accent-violet-600" })
          ] }),
          /* @__PURE__ */ (0, import_jsx_runtime5.jsxs)("div", { className: "border-t border-slate-300/50 pt-4 mb-5", children: [
            /* @__PURE__ */ (0, import_jsx_runtime5.jsxs)("div", { className: "flex justify-between text-xs text-slate-500 mb-1", children: [
              /* @__PURE__ */ (0, import_jsx_runtime5.jsx)("span", { children: "Tempo Speed" }),
              /* @__PURE__ */ (0, import_jsx_runtime5.jsx)("span", { className: "font-mono text-violet-600", children: localParams.tempoMultiplier === 0.5 ? "50%" : localParams.tempoMultiplier === 0.75 ? "75%" : localParams.tempoMultiplier === 1 ? "100%" : localParams.tempoMultiplier === 1.25 ? "125%" : "150%" })
            ] }),
            /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(
              "input",
              {
                type: "range",
                min: "0.5",
                max: "1.5",
                step: "0.25",
                value: localParams.tempoMultiplier,
                onChange: (e) => setLocalParams((p) => ({ ...p, tempoMultiplier: parseFloat(e.target.value) })),
                className: "w-full h-2 bg-slate-200 rounded-lg appearance-none cursor-pointer accent-indigo-600"
              }
            ),
            /* @__PURE__ */ (0, import_jsx_runtime5.jsxs)("div", { className: "flex justify-between text-[10px] text-slate-400 mt-1", children: [
              /* @__PURE__ */ (0, import_jsx_runtime5.jsx)("span", { children: "Slower" }),
              /* @__PURE__ */ (0, import_jsx_runtime5.jsx)("span", { children: "Normal" }),
              /* @__PURE__ */ (0, import_jsx_runtime5.jsx)("span", { children: "Faster" })
            ] })
          ] })
        ] }),
        showMicPermissionDialog && /* @__PURE__ */ (0, import_jsx_runtime5.jsx)("div", { className: "fixed inset-0 z-[100] flex items-center justify-center bg-black/50 backdrop-blur-sm", children: /* @__PURE__ */ (0, import_jsx_runtime5.jsx)("div", { className: "bg-white/95 dark:bg-slate-900/95 backdrop-blur-xl rounded-3xl p-6 md:p-8 max-w-md mx-4 shadow-2xl border border-slate-200/50 dark:border-slate-700/50", children: /* @__PURE__ */ (0, import_jsx_runtime5.jsxs)("div", { className: "flex flex-col items-center text-center", children: [
          /* @__PURE__ */ (0, import_jsx_runtime5.jsx)("div", { className: "w-16 h-16 md:w-20 md:h-20 rounded-full bg-gradient-to-br from-violet-500 to-fuchsia-500 flex items-center justify-center mb-4 shadow-lg", children: /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(Mic, { size: 32, className: "text-white" }) }),
          /* @__PURE__ */ (0, import_jsx_runtime5.jsx)("h3", { className: "text-xl md:text-2xl font-bold text-slate-900 dark:text-slate-100 mb-2", children: "Usar Microfone?" }),
          /* @__PURE__ */ (0, import_jsx_runtime5.jsx)("p", { className: "text-sm md:text-base text-slate-600 dark:text-slate-400 mb-6", children: "Gostaria de usar seu microfone para detec\xE7\xE3o de altura durante este exerc\xEDcio?" }),
          /* @__PURE__ */ (0, import_jsx_runtime5.jsxs)("div", { className: "flex flex-col gap-3 w-full", children: [
            /* @__PURE__ */ (0, import_jsx_runtime5.jsxs)(
              "button",
              {
                onClick: () => {
                  setShowMicPermissionDialog(false);
                  if (props.onToggleMic && !props.micActive) {
                    props.onToggleMic();
                  }
                },
                className: "relative overflow-hidden px-6 py-4 rounded-2xl font-semibold text-white transition-all shadow-lg hover:shadow-xl transform hover:scale-[1.02] active:scale-[0.98]",
                style: {
                  backgroundImage: "linear-gradient(to bottom right, #8b5cf6, #d946ef, #facc15)",
                  boxShadow: "0 8px 24px rgba(217, 70, 239, 0.4)"
                },
                children: [
                  /* @__PURE__ */ (0, import_jsx_runtime5.jsx)("div", { className: "absolute inset-0 bg-gradient-to-br from-white/30 via-transparent to-transparent opacity-50" }),
                  /* @__PURE__ */ (0, import_jsx_runtime5.jsx)("div", { className: "relative z-10", children: "Sim, Usar Microfone" })
                ]
              }
            ),
            /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(
              "button",
              {
                onClick: () => {
                  setShowMicPermissionDialog(false);
                },
                className: "px-6 py-4 rounded-2xl bg-white/60 dark:bg-slate-800/60 backdrop-blur-md border border-slate-200/50 dark:border-slate-600/50 text-slate-800 dark:text-slate-100 font-semibold transition-all shadow-md hover:bg-white/80 dark:hover:bg-slate-700/80 hover:shadow-lg transform hover:scale-[1.02] active:scale-[0.98]",
                children: "N\xE3o, Continuar Sem"
              }
            )
          ] })
        ] }) }) })
      ] })
    ] });
  }

  // components/ExerciseGameViewALTWrapper.tsx
  var import_jsx_runtime6 = __toESM(require_jsx_runtime());
  var ExerciseGameViewALTWrapper = (props) => {
    const audioContextRef = (0, import_react7.useRef)(null);
    const analyserRef = (0, import_react7.useRef)(null);
    const micSourceRef = (0, import_react7.useRef)(null);
    const streamRef = (0, import_react7.useRef)(null);
    const [pitch, setPitch] = (0, import_react7.useState)(null);
    const [micActive, setMicActive] = (0, import_react7.useState)(false);
    const [internalIsPlaying, setInternalIsPlaying] = (0, import_react7.useState)(false);
    const animationFrameRef = (0, import_react7.useRef)();
    const pianoBuffersRef = (0, import_react7.useRef)(/* @__PURE__ */ new Map());
    const pianoSamplesLoaded = (0, import_react7.useRef)(false);
    const audioSettingsRef = (0, import_react7.useRef)({
      bias: props.pyinBias ?? 0.1,
      tolerance: props.pyinTolerance ?? 0.3,
      gateThreshold: props.noiseGateThreshold ?? 0.01,
      gateMode: props.pyinGateMode ?? "smooth"
    });
    const PIANO_SAMPLES = [];
    const notes = ["C", "Ds", "Fs", "A"];
    const noteOffsets = { "C": 0, "Ds": 3, "Fs": 6, "A": 9 };
    for (let octave = 1; octave <= 7; octave++) {
      for (const note of notes) {
        const noteOffset = noteOffsets[note];
        const midi = (octave + 1) * 12 + noteOffset;
        PIANO_SAMPLES.push({ midi, file: `/sounds/Salamander_Piano/${note}${octave}.mp3` });
      }
    }
    (0, import_react7.useEffect)(() => {
      const autoStartMic = async () => {
        try {
          await new Promise((resolve) => setTimeout(resolve, 500));
          const stream = await navigator.mediaDevices.getUserMedia({
            audio: { echoCancellation: false, autoGainControl: false, noiseSuppression: false }
          });
          streamRef.current = stream;
          if (!audioContextRef.current || audioContextRef.current.state === "closed") {
            const ctx = new AudioContext();
            audioContextRef.current = ctx;
            const analyser = ctx.createAnalyser();
            analyser.fftSize = 4096;
            analyser.smoothingTimeConstant = 0.8;
            analyserRef.current = analyser;
            await loadPianoSamples(ctx);
          }
          if (audioContextRef.current.state === "suspended") {
            await audioContextRef.current.resume();
          }
          const source = audioContextRef.current.createMediaStreamSource(stream);
          micSourceRef.current = source;
          const highPassFilter = audioContextRef.current.createBiquadFilter();
          highPassFilter.type = "highpass";
          highPassFilter.frequency.value = 750;
          highPassFilter.Q.value = 1;
          const compressor = audioContextRef.current.createDynamicsCompressor();
          compressor.threshold.value = -50;
          compressor.knee.value = 40;
          compressor.ratio.value = 12;
          compressor.attack.value = 0;
          compressor.release.value = 0.25;
          source.connect(highPassFilter);
          highPassFilter.connect(compressor);
          compressor.connect(analyserRef.current);
          setMicActive(true);
          const updatePitchLoop = () => {
            if (!analyserRef.current || !audioContextRef.current)
              return;
            const buffer = new Float32Array(analyserRef.current.fftSize);
            analyserRef.current.getFloatTimeDomainData(buffer);
            const frequency = detectPitchPYIN(buffer, audioContextRef.current.sampleRate, {
              bias: audioSettingsRef.current.bias,
              tolerance: audioSettingsRef.current.tolerance,
              gateThreshold: audioSettingsRef.current.gateThreshold,
              gateMode: audioSettingsRef.current.gateMode
            });
            if (frequency > 0) {
              const noteStrings2 = ["C", "C#", "D", "D#", "E", "F", "F#", "G", "G#", "A", "A#", "B"];
              const pitch2 = 69 + 12 * Math.log2(frequency / 440);
              const midi = Math.round(pitch2);
              const note = noteStrings2[midi % 12];
              const octave = Math.floor(midi / 12) - 1;
              const cents = Math.floor((pitch2 - midi) * 100);
              setPitch({ frequency, note: `${note}${octave}`, cents });
            } else {
              setPitch(null);
            }
            animationFrameRef.current = requestAnimationFrame(updatePitchLoop);
          };
          updatePitchLoop();
        } catch (err) {
          console.log("Microphone not available - continuing without pitch feedback");
        }
      };
      autoStartMic();
      return () => {
        if (animationFrameRef.current) {
          cancelAnimationFrame(animationFrameRef.current);
        }
        if (micSourceRef.current) {
          micSourceRef.current.disconnect();
        }
        if (streamRef.current) {
          streamRef.current.getTracks().forEach((track) => track.stop());
        }
      };
    }, []);
    (0, import_react7.useEffect)(() => {
      setInternalIsPlaying(props.isPlaying);
    }, [props.isPlaying]);
    (0, import_react7.useEffect)(() => {
      const initAudio = async () => {
        if (!audioContextRef.current || audioContextRef.current.state === "closed") {
          const ctx = new AudioContext();
          audioContextRef.current = ctx;
          const analyser = ctx.createAnalyser();
          analyser.fftSize = 4096;
          analyser.smoothingTimeConstant = 0.8;
          analyserRef.current = analyser;
          await loadPianoSamples(ctx);
        }
        if (audioContextRef.current && audioContextRef.current.state === "suspended") {
          audioContextRef.current.resume().catch((e) => {
          });
        }
      };
      initAudio();
      return () => {
        if (animationFrameRef.current) {
          cancelAnimationFrame(animationFrameRef.current);
        }
        if (audioContextRef.current && audioContextRef.current.state !== "closed") {
          audioContextRef.current.close();
          audioContextRef.current = null;
        }
      };
    }, []);
    const loadPianoSamples = async (ctx) => {
      if (pianoSamplesLoaded.current)
        return;
      try {
        const loadPromises = PIANO_SAMPLES.map(async (sample) => {
          const response = await fetch(sample.file);
          const arrayBuffer = await response.arrayBuffer();
          const audioBuffer = await ctx.decodeAudioData(arrayBuffer);
          pianoBuffersRef.current.set(sample.midi, audioBuffer);
        });
        await Promise.all(loadPromises);
        pianoSamplesLoaded.current = true;
      } catch (error) {
        console.error("\u274C Error loading piano samples:", error);
      }
    };
    const freqToMidi = (freq) => {
      return Math.round(12 * Math.log2(freq / 440) + 69);
    };
    const findNearestSample = (targetMidi) => {
      if (!PIANO_SAMPLES || PIANO_SAMPLES.length === 0) {
        console.error("PIANO_SAMPLES is empty or undefined!");
        return 60;
      }
      let nearest = PIANO_SAMPLES[0].midi;
      let minDistance = Math.abs(targetMidi - nearest);
      for (const sample of PIANO_SAMPLES) {
        const distance = Math.abs(targetMidi - sample.midi);
        if (distance < minDistance) {
          minDistance = distance;
          nearest = sample.midi;
        }
      }
      return nearest;
    };
    const startMicrophone = async () => {
      try {
        if (!audioContextRef.current || audioContextRef.current.state === "closed") {
          const ctx = new AudioContext();
          audioContextRef.current = ctx;
          const analyser = ctx.createAnalyser();
          analyser.fftSize = 4096;
          analyser.smoothingTimeConstant = 0.8;
          analyserRef.current = analyser;
          await loadPianoSamples(ctx);
        }
        if (audioContextRef.current.state === "suspended") {
          await audioContextRef.current.resume();
        }
        const stream = await navigator.mediaDevices.getUserMedia({
          audio: { echoCancellation: false, autoGainControl: false, noiseSuppression: false }
        });
        streamRef.current = stream;
        const source = audioContextRef.current.createMediaStreamSource(stream);
        micSourceRef.current = source;
        source.connect(analyserRef.current);
        const highPassFilter = audioContextRef.current.createBiquadFilter();
        highPassFilter.type = "highpass";
        highPassFilter.frequency.value = 750;
        highPassFilter.Q.value = 1;
        const compressor = audioContextRef.current.createDynamicsCompressor();
        compressor.threshold.value = -50;
        compressor.knee.value = 40;
        compressor.ratio.value = 12;
        compressor.attack.value = 0;
        compressor.release.value = 0.25;
        source.disconnect();
        source.connect(highPassFilter);
        highPassFilter.connect(compressor);
        compressor.connect(analyserRef.current);
        setMicActive(true);
        updatePitch();
      } catch (err) {
        console.error("Error accessing microphone:", err);
      }
    };
    const stopMicrophone = () => {
      if (animationFrameRef.current) {
        cancelAnimationFrame(animationFrameRef.current);
      }
      if (micSourceRef.current) {
        micSourceRef.current.disconnect();
      }
      if (streamRef.current) {
        streamRef.current.getTracks().forEach((track) => track.stop());
      }
      setMicActive(false);
      setPitch(null);
      resetPYINHistory();
    };
    const getNote2 = (frequency) => {
      const noteStrings2 = ["C", "C#", "D", "D#", "E", "F", "F#", "G", "G#", "A", "A#", "B"];
      const pitch2 = 69 + 12 * Math.log2(frequency / 440);
      const midi = Math.round(pitch2);
      const note = noteStrings2[midi % 12];
      const octave = Math.floor(midi / 12) - 1;
      const cents = Math.floor((pitch2 - midi) * 100);
      return { note, octave, cents, midi, frequency };
    };
    (0, import_react7.useEffect)(() => {
      audioSettingsRef.current = {
        bias: props.pyinBias ?? 0.1,
        tolerance: props.pyinTolerance ?? 0.3,
        gateThreshold: props.noiseGateThreshold ?? 0.01,
        gateMode: props.pyinGateMode ?? "smooth"
      };
    }, [props.pyinBias, props.pyinTolerance, props.noiseGateThreshold, props.pyinGateMode]);
    const updatePitch = () => {
      if (!analyserRef.current || !audioContextRef.current)
        return;
      const buffer = new Float32Array(analyserRef.current.fftSize);
      analyserRef.current.getFloatTimeDomainData(buffer);
      const frequency = detectPitchPYIN(buffer, audioContextRef.current.sampleRate, {
        bias: audioSettingsRef.current.bias,
        tolerance: audioSettingsRef.current.tolerance,
        gateThreshold: audioSettingsRef.current.gateThreshold,
        gateMode: audioSettingsRef.current.gateMode
      });
      if (frequency > 0) {
        const pitchData = getNote2(frequency);
        setPitch({ frequency, note: `${pitchData.note}${pitchData.octave}`, cents: pitchData.cents });
      } else {
        setPitch(null);
      }
      animationFrameRef.current = requestAnimationFrame(updatePitch);
    };
    const activeSourcesRef = (0, import_react7.useRef)([]);
    const stopAllAudio = () => {
      activeSourcesRef.current.forEach((source) => {
        try {
          source.stop();
        } catch (e) {
        }
      });
      activeSourcesRef.current = [];
    };
    (0, import_react7.useEffect)(() => {
      if (!props.isPlaying) {
        stopAllAudio();
        if (audioContextRef.current?.state === "running") {
          audioContextRef.current.suspend();
        }
      } else {
        if (audioContextRef.current?.state === "suspended") {
          audioContextRef.current.resume();
        }
      }
    }, [props.isPlaying]);
    const playNoteMock = (0, import_react7.useCallback)((freq, startTime, duration, type, volume) => {
      if (!audioContextRef.current || !pianoSamplesLoaded.current)
        return;
      const ctx = audioContextRef.current;
      if (ctx.state === "suspended")
        ctx.resume();
      const targetMidi = freqToMidi(freq);
      const nearestSampleMidi = findNearestSample(targetMidi);
      const sampleBuffer = pianoBuffersRef.current.get(nearestSampleMidi);
      if (!sampleBuffer)
        return;
      const semitoneDiff = targetMidi - nearestSampleMidi;
      const playbackRate = Math.pow(2, semitoneDiff / 12);
      const source = ctx.createBufferSource();
      source.buffer = sampleBuffer;
      source.playbackRate.value = playbackRate;
      const gainNode = ctx.createGain();
      gainNode.gain.value = volume * 2.5;
      source.connect(gainNode);
      const lowPassFilter = ctx.createBiquadFilter();
      lowPassFilter.type = "lowpass";
      lowPassFilter.frequency.value = 600;
      lowPassFilter.Q.value = 1;
      gainNode.connect(lowPassFilter);
      lowPassFilter.connect(ctx.destination);
      source.start(startTime);
      source.stop(startTime + duration);
      activeSourcesRef.current.push(source);
      source.onended = () => {
        activeSourcesRef.current = activeSourcesRef.current.filter((s) => s !== source);
      };
    }, []);
    const playMetronomeClick = (0, import_react7.useCallback)((startTime) => {
      if (!audioContextRef.current)
        return;
      const ctx = audioContextRef.current;
      if (ctx.state === "suspended")
        ctx.resume();
      const now = startTime || ctx.currentTime;
      const osc = ctx.createOscillator();
      const gain = ctx.createGain();
      osc.type = "sine";
      osc.frequency.setValueAtTime(1e3, now);
      gain.gain.setValueAtTime(0, now);
      gain.gain.linearRampToValueAtTime(0.5, now + 2e-3);
      gain.gain.exponentialRampToValueAtTime(1e-3, now + 0.05);
      osc.connect(gain);
      gain.connect(ctx.destination);
      osc.start(now);
      osc.stop(now + 0.06);
      activeSourcesRef.current.push(osc);
      osc.onended = () => {
        activeSourcesRef.current = activeSourcesRef.current.filter((s) => s !== osc);
      };
    }, []);
    const handlePlayPause = () => {
      if (audioContextRef.current?.state === "suspended") {
        audioContextRef.current.resume();
      }
      props.onPlayPause();
    };
    const getAudioContext = () => audioContextRef.current;
    const [restartKey, setRestartKey] = (0, import_react7.useState)(0);
    const handleRestart = () => {
      stopAllAudio();
      setRestartKey((prev) => prev + 1);
      if (!internalIsPlaying) {
        props.onPlayPause();
      }
    };
    return /* @__PURE__ */ (0, import_jsx_runtime6.jsx)("div", { className: "fixed inset-0 z-50", children: /* @__PURE__ */ (0, import_jsx_runtime6.jsx)(
      ExerciseGameViewALT,
      {
        exercise: props.exercise,
        vocalRange: props.vocalRange,
        userPitch: pitch?.frequency || null,
        centerSemitone: props.centerSemitone,
        visibleOctaves: props.visibleOctaves,
        isPlaying: internalIsPlaying,
        isPreviewing: props.isPreviewing,
        isExerciseComplete: props.isExerciseComplete,
        playNote: playNoteMock,
        playMetronomeClick,
        onPlayPause: handlePlayPause,
        onStop: () => {
          stopMicrophone();
          props.onStop();
        },
        ...props.onRestart ? { onRestart: handleRestart } : {},
        onPreview: props.onPreview,
        onComplete: props.onComplete,
        onNotePositionUpdate: props.onNotePositionUpdate || (() => {
        }),
        onBack: props.onBack,
        onEdit: props.onEdit,
        onRefine: props.onRefine,
        currentRoutine: props.currentRoutine,
        onNextInRoutine: props.onNextInRoutine,
        isFullscreen: props.isFullscreen,
        onToggleFullscreen: props.onToggleFullscreen,
        isExerciseFavorite: props.isExerciseFavorite,
        isRoutineFavorite: props.isRoutineFavorite,
        onToggleFavoriteExercise: props.onToggleFavoriteExercise,
        onToggleFavoriteRoutine: props.onToggleFavoriteRoutine,
        checkAudioBuffers: props.checkAudioBuffers,
        micGain: 0,
        micActive,
        onToggleMic: micActive ? stopMicrophone : startMicrophone,
        getAudioContext,
        currentTheme: props.currentTheme
      },
      restartKey
    ) });
  };
  var ExerciseGameViewALTWrapper_default = ExerciseGameViewALTWrapper;

  // components/FloatingMenu.tsx
  var import_jsx_runtime7 = __toESM(require_jsx_runtime());
  var HomeIcon = ({ isActive, activeClassName }) => /* @__PURE__ */ (0, import_jsx_runtime7.jsx)("svg", { viewBox: "0 0 24 24", strokeWidth: "1.5", stroke: "currentColor", fill: "none", strokeLinecap: "round", strokeLinejoin: "round", className: `h-5 w-5 ${isActive ? activeClassName : ""}`, children: /* @__PURE__ */ (0, import_jsx_runtime7.jsx)("path", { d: "M3 9l9-7 9 7v11a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2z" }) });
  var PianoIcon = ({ isActive, activeClassName }) => /* @__PURE__ */ (0, import_jsx_runtime7.jsxs)("svg", { viewBox: "0 0 24 24", strokeWidth: "1.5", stroke: "currentColor", fill: "none", strokeLinecap: "round", strokeLinejoin: "round", className: `w-5 h-5 ${isActive ? activeClassName : ""}`, children: [
    /* @__PURE__ */ (0, import_jsx_runtime7.jsx)("rect", { x: "4", y: "4", width: "16", height: "16", rx: "2" }),
    /* @__PURE__ */ (0, import_jsx_runtime7.jsx)("line", { x1: "4", y1: "12", x2: "20", y2: "12" }),
    /* @__PURE__ */ (0, import_jsx_runtime7.jsx)("line", { x1: "8", y1: "4", x2: "8", y2: "12" }),
    /* @__PURE__ */ (0, import_jsx_runtime7.jsx)("line", { x1: "12", y1: "4", x2: "12", y2: "12" }),
    /* @__PURE__ */ (0, import_jsx_runtime7.jsx)("line", { x1: "16", y1: "4", x2: "16", y2: "12" })
  ] });
  var RoutinesIcon = ({ isActive, activeClassName }) => /* @__PURE__ */ (0, import_jsx_runtime7.jsxs)("svg", { viewBox: "0 0 24 24", strokeWidth: "1.5", stroke: "currentColor", fill: "none", strokeLinecap: "round", strokeLinejoin: "round", className: `h-5 w-5 ${isActive ? activeClassName : ""}`, children: [
    /* @__PURE__ */ (0, import_jsx_runtime7.jsx)("path", { d: "M21 15V6" }),
    /* @__PURE__ */ (0, import_jsx_runtime7.jsx)("path", { d: "M18.5 18a2.5 2.5 0 1 0 0-5 2.5 2.5 0 0 0 0 5Z" }),
    /* @__PURE__ */ (0, import_jsx_runtime7.jsx)("path", { d: "M12 12H3" }),
    /* @__PURE__ */ (0, import_jsx_runtime7.jsx)("path", { d: "M16 6H3" }),
    /* @__PURE__ */ (0, import_jsx_runtime7.jsx)("path", { d: "M12 18H3" })
  ] });
  var ExercisesIcon = ({ isActive, activeClassName }) => /* @__PURE__ */ (0, import_jsx_runtime7.jsx)("svg", { viewBox: "0 0 24 24", strokeWidth: "1.5", stroke: "currentColor", fill: "none", strokeLinecap: "round", strokeLinejoin: "round", className: `h-5 w-5 ${isActive ? activeClassName : ""}`, children: /* @__PURE__ */ (0, import_jsx_runtime7.jsx)("path", { d: "M4 12h16M4 6h16M4 18h7" }) });
  var StudiesIcon = ({ isActive, activeClassName }) => /* @__PURE__ */ (0, import_jsx_runtime7.jsxs)("svg", { viewBox: "0 0 24 24", strokeWidth: "1.5", stroke: "currentColor", fill: "none", strokeLinecap: "round", strokeLinejoin: "round", className: `h-5 w-5 ${isActive ? activeClassName : ""}`, children: [
    /* @__PURE__ */ (0, import_jsx_runtime7.jsx)("path", { d: "M22 10v6M2 10l10-5 10 5-10 5z" }),
    /* @__PURE__ */ (0, import_jsx_runtime7.jsx)("path", { d: "M6 12v5c0 1.66 4 3 10 0v-5" })
  ] });
  var VoxLabAIIcon = ({ isActive, activeClassName }) => /* @__PURE__ */ (0, import_jsx_runtime7.jsxs)("svg", { viewBox: "0 0 24 24", strokeWidth: "1.5", stroke: "currentColor", fill: "none", strokeLinecap: "round", strokeLinejoin: "round", className: `h-5 w-5 ${isActive ? activeClassName : ""}`, children: [
    /* @__PURE__ */ (0, import_jsx_runtime7.jsx)("path", { d: "M12 3a9 9 0 0 1 9 9 9 9 0 0 1-9 9 9 9 0 0 1-9-9 9 9 0 0 1 9-9z" }),
    /* @__PURE__ */ (0, import_jsx_runtime7.jsx)("path", { d: "M9 12l2 2 4-4" })
  ] });
  var FavoritesIcon = ({ isActive, activeClassName }) => /* @__PURE__ */ (0, import_jsx_runtime7.jsx)("svg", { viewBox: "0 0 24 24", strokeWidth: "1.5", stroke: "currentColor", fill: isActive ? "currentColor" : "none", strokeLinecap: "round", strokeLinejoin: "round", className: `h-5 w-5 ${isActive ? activeClassName : ""}`, children: /* @__PURE__ */ (0, import_jsx_runtime7.jsx)("path", { d: "M12 2l3.09 6.26L22 9.27l-5 4.87 1.18 6.88L12 17.77l-6.18 3.25L7 14.14 2 9.27l6.91-1.01L12 2z" }) });
  var SettingsIcon = () => /* @__PURE__ */ (0, import_jsx_runtime7.jsx)("svg", { viewBox: "0 0 24 24", strokeWidth: "1.5", stroke: "currentColor", fill: "none", strokeLinecap: "round", strokeLinejoin: "round", className: "h-5 w-5", children: /* @__PURE__ */ (0, import_jsx_runtime7.jsx)("path", { d: "M4 6h16M4 12h16M4 18h16" }) });
  var NavItem = ({ label, icon, isActive, onClick, theme, className = "w-1/6", isCompact }) => {
    const activeIconLightClass = theme.gradientText.from.replace("from-", "text-");
    const activeIconDarkClass = theme.gradientText.darkFrom.replace("dark:from-", "dark:text-");
    return /* @__PURE__ */ (0, import_jsx_runtime7.jsxs)(
      "button",
      {
        onClick,
        className: `btn-interactive relative flex flex-col items-center justify-center h-full text-center px-1 rounded-full focus-visible:ring-offset-2 ${isActive ? "" : "text-slate-500 dark:text-slate-400 hover:text-slate-700 dark:hover:text-slate-200"} ${className}`,
        "aria-label": label,
        children: [
          /* @__PURE__ */ (0, import_jsx_runtime7.jsx)("div", { className: `relative transition-colors duration-300 ease-in-out ${!isCompact && "mb-0.5"} ${isActive ? `${activeIconLightClass} ${activeIconDarkClass}` : ""}`, children: icon }),
          !isCompact && /* @__PURE__ */ (0, import_jsx_runtime7.jsx)("span", { className: `relative text-[0.6rem] transition-colors duration-300 ease-in-out ${isActive ? `font-bold bg-clip-text text-transparent bg-gradient-to-br ${theme.gradientText.from} ${theme.gradientText.to} ${theme.gradientText.darkFrom} ${theme.gradientText.darkTo}` : "font-normal"}`, children: label })
        ]
      }
    );
  };
  var FloatingMenu = ({ activeView, setActiveView, setIsSettingsOpen, currentTheme, uiView, isVisible }) => {
    const { t } = useTranslation();
    const isCompact = uiView === "exercise";
    const menuItems = [
      { id: "home", label: t("home"), icon: HomeIcon },
      { id: "exercises", label: t("exercises"), icon: ExercisesIcon },
      { id: "routines", label: t("routines"), icon: RoutinesIcon },
      { id: "favorites", label: t("favorites"), icon: FavoritesIcon },
      { id: "range", label: t("range"), icon: PianoIcon },
      { id: "voxlabai", label: t("voxlabai"), icon: VoxLabAIIcon },
      { id: "studies", label: t("studies"), icon: StudiesIcon }
    ];
    const glassBg = `bg-white/50 dark:bg-slate-900/50 backdrop-blur-lg shadow-[0_12px_30px_-12px_rgba(0,0,0,0.2),inset_-1px_1px_8px_rgba(0,0,0,0.08),inset_2px_-2px_4px_rgba(255,255,255,0.5)] dark:shadow-[0_12px_30px_-12px_rgba(0,0,0,0.5),inset_-1px_1px_8px_rgba(255,255,255,0.08),inset_2px_-2px_4px_rgba(0,0,0,0.5)] border border-slate-300/60 dark:border-slate-700/60`;
    return /* @__PURE__ */ (0, import_jsx_runtime7.jsxs)("div", { className: `fixed bottom-4 left-1/2 -translate-x-1/2 w-[calc(100%-2rem)] max-w-lg md:max-w-3xl flex items-center gap-2 z-50 transition-all duration-500 ease-in-out ${isCompact ? "h-14" : "h-16"} ${isVisible ? "translate-y-0 opacity-100" : "translate-y-24 opacity-0 pointer-events-none"}`, children: [
      /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(
        "nav",
        {
          className: `flex-grow h-full rounded-full min-w-0 relative ${glassBg}`,
          children: /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(
            "div",
            {
              className: "flex items-center h-full px-2 md:justify-around md:px-4 space-x-1 md:space-x-0 overflow-x-auto scrollbar-hide md:overflow-visible",
              style: {
                maskImage: "linear-gradient(to right, transparent, black 20px, black calc(100% - 20px), transparent)",
                WebkitMaskImage: "linear-gradient(to right, transparent, black 20px, black calc(100% - 20px), transparent)"
              },
              children: menuItems.map((item) => /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(
                NavItem,
                {
                  label: item.label,
                  icon: /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(item.icon, { isActive: activeView === item.id, activeClassName: "active-icon" }),
                  isActive: activeView === item.id,
                  onClick: () => setActiveView(item.id),
                  theme: currentTheme,
                  className: "w-14 flex-shrink-0 md:w-auto md:px-2",
                  isCompact
                },
                item.id
              ))
            }
          )
        }
      ),
      /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(
        "button",
        {
          onClick: () => setIsSettingsOpen(true),
          "aria-label": t("settings"),
          className: `btn-interactive flex-shrink-0 flex items-center justify-center rounded-full text-slate-500 dark:text-slate-400 hover:text-slate-700 dark:hover:text-slate-200 transition-all duration-500 ease-in-out ${isCompact ? "w-14 h-14" : "w-16 h-16"} ${glassBg}`,
          children: /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(SettingsIcon, {})
        }
      )
    ] });
  };
  var FloatingMenu_default = FloatingMenu;

  // components/VocalRangeTestScreen.tsx
  var import_react8 = __toESM(require_react());
  init_web();
  var import_jsx_runtime8 = __toESM(require_jsx_runtime());
  function average(arr) {
    if (!arr || arr.length === 0)
      return null;
    return arr.reduce((a, b) => a + b, 0) / arr.length;
  }
  function min(arr) {
    if (!arr || arr.length === 0)
      return null;
    return arr.reduce((a, b) => a < b ? a : b);
  }
  function max(arr) {
    if (!arr || arr.length === 0)
      return null;
    return arr.reduce((a, b) => a > b ? a : b);
  }
  function calculateRMS(arr) {
    if (!arr || arr.length === 0)
      return 0;
    let sum = 0;
    for (let i = 0; i < arr.length; i++) {
      sum += arr[i] * arr[i];
    }
    return Math.sqrt(sum / arr.length);
  }
  function midiToNoteName(m) {
    const names = ["C", "C#", "D", "D#", "E", "F", "F#", "G", "G#", "A", "A#", "B"];
    const octave = Math.floor(m / 12) - 1;
    const name = names[(m % 12 + 12) % 12];
    return `${name}${octave}`;
  }
  function freqToNote(freq) {
    if (!freq)
      return null;
    const midi = 69 + 12 * Math.log2(freq / 440);
    const rounded = Math.round(midi);
    return midiToNoteName(rounded);
  }
  var YIN_MIN_FREQ = 50;
  var YIN_MAX_FREQ = 2e3;
  var LOW_VOLUME_RMS_THRESHOLD = 2e-3;
  var LOW_VOLUME_FRAME_COUNT_THRESHOLD = 120;
  var translations2 = {
    en: {
      title1: "Vocal Range",
      selectMode: "Select an analysis mode",
      simpleMode: "Simple Mode",
      advancedMode: "Advanced Mode",
      simpleModeDesc: "A quick 1-step test using a vocal siren.",
      advancedModeDesc: "A detailed 3-step analysis of your voice.",
      startDetection: "Start Analysis",
      micDenied: "Microphone access denied. Please allow microphone access in your browser settings.",
      advancedStepHeader: "STEP {step} OF 3",
      simpleStepHeader: "STEP 1 OF 1",
      step1Title: "Lowest Note",
      step2Title: "Speaking Voice",
      step3Title: "Siren",
      simpleStep1Title: "Vocal Siren",
      step1Instruction: "Sing your LOWEST note.\nHold it steady.",
      step2Instruction: "Speak NATURALLY.\nTalk or read aloud.",
      step3Instruction: "Perform a SIREN.\nLow to high, then back down.",
      simpleStep1Instruction: "Sing a smooth siren from low to high in one breath.",
      countdownGo: "GO!",
      notHearingYou: "I'm not hearing you...",
      noInputTitle: "No Input Heard",
      noInputDescription: "Couldn't hear you. Try again?",
      tryAgain: "Try Again",
      continueAnyway: "Continue Anyway",
      resultsTitle: "Your Vocal Analysis",
      simpleResultsTitle: "Your Vocal Range",
      resultsRange: "Analysis Complete",
      resultsLowestSung: "Lowest Sung Note",
      resultsHighestSung: "Highest Sung Note",
      resultsAvgSpeaking: "Avg. Speaking Voice",
      startNew: "Start New Analysis",
      switchToLight: "Switch to light mode",
      switchToDark: "Switch to dark mode",
      feedbackTitle: "Your Vocal Analysis",
      generatingFeedback: "Generating feedback...",
      goBack: "Go Back",
      saveAndContinue: "Save & Continue",
      voiceClassification: "Suggested Classification:",
      classificationDisclaimer: "Voice classifications are traditional references. Modern vocal science recognizes that range is flexible and can be developed over time with proper training. These categories are guides, not limitations.",
      bass: "Bass",
      baritone: "Baritone",
      tenor: "Tenor",
      alto: "Alto / Contralto",
      mezzo: "Mezzo-Soprano",
      soprano: "Soprano"
    },
    "pt-BR": {
      title1: "Extens\xE3o Vocal",
      selectMode: "Selecione um modo de an\xE1lise",
      simpleMode: "Modo Simples",
      advancedMode: "Modo Avan\xE7ado",
      simpleModeDesc: "Um teste r\xE1pido de 1 etapa usando uma sirene vocal.",
      advancedModeDesc: "Uma an\xE1lise detalhada de 3 etapas da sua voz.",
      startDetection: "Iniciar An\xE1lise",
      micDenied: "Acesso ao microfone negado. Por favor, permita o acesso ao microfone nas configura\xE7\xF5es do seu navegador.",
      advancedStepHeader: "ETAPA {step} DE 3",
      simpleStepHeader: "ETAPA 1 DE 1",
      step1Title: "Nota Mais Grave",
      step2Title: "Voz Falada",
      step3Title: "Sirene",
      simpleStep1Title: "Sirene Vocal",
      step1Instruction: "Cante sua nota mais GRAVE.\nMantenha-a est\xE1vel.",
      step2Instruction: "Fale NATURALMENTE.\nConverse ou leia em voz alta.",
      step3Instruction: "Fa\xE7a uma SIRENE.\nDo grave ao agudo, e de volta.",
      simpleStep1Instruction: "Cante uma sirene suave, do grave ao agudo, em um s\xF3 f\xF4lego.",
      countdownGo: "VAI!",
      notHearingYou: "N\xE3o estou te ouvindo...",
      noInputTitle: "Nenhum Som Captado",
      noInputDescription: "N\xE3o consegui te ouvir. Tentar novamente?",
      tryAgain: "Tentar Novamente",
      continueAnyway: "Continuar Mesmo Assim",
      resultsTitle: "Sua An\xE1lise Vocal",
      simpleResultsTitle: "Sua Extens\xE3o Vocal",
      resultsRange: "An\xE1lise Conclu\xEDda",
      resultsLowestSung: "Nota Mais Grave Cantada",
      resultsHighestSung: "Nota Mais Aguda Cantada",
      resultsAvgSpeaking: "Voz Falada M\xE9dia",
      startNew: "Iniciar Nova An\xE1lise",
      switchToLight: "Mudar para o modo claro",
      switchToDark: "Mudar para o modo escuro",
      feedbackTitle: "Sua An\xE1lise Vocal",
      generatingFeedback: "Gerando feedback...",
      goBack: "Voltar",
      saveAndContinue: "Salvar e Continuar",
      voiceClassification: "Classifica\xE7\xE3o Sugerida:",
      classificationDisclaimer: "Classifica\xE7\xF5es vocais s\xE3o refer\xEAncias tradicionais. A ci\xEAncia vocal moderna reconhece que a extens\xE3o \xE9 flex\xEDvel e pode ser desenvolvida ao longo do tempo com treinamento adequado. Estas categorias s\xE3o guias, n\xE3o limita\xE7\xF5es.",
      bass: "Baixo",
      baritone: "Bar\xEDtono",
      tenor: "Tenor",
      alto: "Contralto",
      mezzo: "Meio-Soprano",
      soprano: "Soprano"
    }
  };
  var VOICE_CLASSIFICATIONS = {
    bass: {
      typical: { min: 40, max: 64 },
      // E2 - E4
      color: "#1e3a8a"
    },
    baritone: {
      typical: { min: 45, max: 69 },
      // A2 - A4
      color: "#1e40af"
    },
    tenor: {
      typical: { min: 48, max: 72 },
      // C3 - C5
      color: "#2563eb"
    },
    alto: {
      typical: { min: 53, max: 77 },
      // F3 - F5
      color: "#7c3aed"
    },
    mezzo: {
      typical: { min: 57, max: 81 },
      // A3 - A5
      color: "#a855f7"
    },
    soprano: {
      typical: { min: 60, max: 84 },
      // C4 - C6
      color: "#c084fc"
    }
  };
  function getVoiceClassification(minHz, maxHz) {
    if (!minHz || !maxHz)
      return null;
    const minMidi = Math.round(12 * Math.log2(minHz / 440) + 69);
    const maxMidi = Math.round(12 * Math.log2(maxHz / 440) + 69);
    const midpoint = (minMidi + maxMidi) / 2;
    let bestMatch = null;
    let smallestDiff = Infinity;
    Object.entries(VOICE_CLASSIFICATIONS).forEach(([key, voice]) => {
      const voiceMid = (voice.typical.min + voice.typical.max) / 2;
      const diff = Math.abs(midpoint - voiceMid);
      if (diff < smallestDiff) {
        smallestDiff = diff;
        bestMatch = key;
      }
    });
    return bestMatch;
  }
  var ThemeToggle = ({ theme, toggleTheme, "aria-label": ariaLabel }) => /* @__PURE__ */ (0, import_jsx_runtime8.jsx)(
    "button",
    {
      onClick: toggleTheme,
      className: "p-2 rounded-full bg-black/5 dark:bg-black/20 backdrop-blur-sm text-gray-500 dark:text-gray-400 hover:text-black dark:hover:text-white transition-all duration-200 ease-in-out transform origin-center hover:scale-110 active:scale-90 active:translate-y-px hover:brightness-95 dark:hover:brightness-125 active:brightness-110",
      "aria-label": ariaLabel,
      children: theme === "dark" ? /* @__PURE__ */ (0, import_jsx_runtime8.jsx)("svg", { xmlns: "http://www.w3.org/2000/svg", className: "h-6 w-6", fill: "none", viewBox: "0 0 24 24", stroke: "currentColor", strokeWidth: 2, children: /* @__PURE__ */ (0, import_jsx_runtime8.jsx)("path", { strokeLinecap: "round", strokeLinejoin: "round", d: "M12 3v1m0 16v1m9-9h-1M4 12H3m15.364 6.364l-.707-.707M6.343 6.343l-.707-.707m12.728 0l-.707.707M6.343 17.657l-.707.707M16 12a4 4 0 11-8 0 4 4 0 018 0z" }) }) : /* @__PURE__ */ (0, import_jsx_runtime8.jsx)("svg", { xmlns: "http://www.w3.org/2000/svg", className: "h-6 w-6", fill: "none", viewBox: "0 0 24 24", stroke: "currentColor", strokeWidth: 2, children: /* @__PURE__ */ (0, import_jsx_runtime8.jsx)("path", { strokeLinecap: "round", strokeLinejoin: "round", d: "M20.354 15.354A9 9 0 018.646 3.646 9.003 9.003 0 0012 21a9.003 9.003 0 008.354-5.646z" }) })
    }
  );
  var LanguageToggle = ({ language, toggleLanguage }) => /* @__PURE__ */ (0, import_jsx_runtime8.jsx)(
    "button",
    {
      onClick: toggleLanguage,
      className: "p-2 rounded-full bg-black/5 dark:bg-black/20 backdrop-blur-sm text-gray-500 dark:text-gray-400 hover:text-black dark:hover:text-white transition-all duration-200 ease-in-out font-normal text-sm w-10 h-10 flex items-center justify-center transform origin-center hover:scale-110 active:scale-90 active:translate-y-px hover:brightness-95 dark:hover:brightness-125 active:brightness-110",
      "aria-label": `Switch language to ${language === "en" ? "Portuguese" : "English"}`,
      children: language === "en" ? "PT" : "EN"
    }
  );
  var VocalRangeTestScreen = (0, import_react8.memo)(({ onCancel, onComplete, currentTheme, pyinBias, pyinTolerance, pyinGateMode, noiseGateThreshold }) => {
    console.log("VocalRangeTestScreen Props:", { onCancel: !!onCancel, onComplete: !!onComplete, currentTheme: !!currentTheme });
    const [permission, setPermission] = (0, import_react8.useState)(null);
    const [status, setStatus] = (0, import_react8.useState)("modeSelection");
    const [mode, setMode] = (0, import_react8.useState)(null);
    const [step, setStep] = (0, import_react8.useState)(0);
    const [instructionMessage, setInstructionMessage] = (0, import_react8.useState)("");
    const [instructionOpacityClass, setInstructionOpacityClass] = (0, import_react8.useState)("opacity-100");
    const [countdownDisplay, setCountdownDisplay] = (0, import_react8.useState)(null);
    const [countdownOpacity, setCountdownOpacity] = (0, import_react8.useState)(0);
    const [rmsVolume, setRmsVolume] = (0, import_react8.useState)(0);
    const [isNotHearingYou, setIsNotHearingYou] = (0, import_react8.useState)(false);
    const [showNotHearingYouMessage, setShowNotHearingYou] = (0, import_react8.useState)(false);
    const [progressPercentage, setProgressPercentage] = (0, import_react8.useState)(0);
    const [theme, setTheme] = (0, import_react8.useState)(() => {
      return document.documentElement.classList.contains("dark") ? "dark" : "light";
    });
    const [language, setLanguage] = (0, import_react8.useState)("pt-BR");
    const [isAnimatingOut, setIsAnimatingOut] = (0, import_react8.useState)(false);
    const [isSaving, setIsSaving] = (0, import_react8.useState)(false);
    const [isInitializing, setIsInitializing] = (0, import_react8.useState)(false);
    const [isGeneratingFeedback, setIsGeneratingFeedback] = (0, import_react8.useState)(false);
    const [generatedFeedback, setGeneratedFeedback] = (0, import_react8.useState)(null);
    const audioCtxRef = (0, import_react8.useRef)(null);
    const analyserRef = (0, import_react8.useRef)(null);
    const mediaStreamRef = (0, import_react8.useRef)(null);
    const rafRef = (0, import_react8.useRef)(null);
    const dataArrayRef = (0, import_react8.useRef)(null);
    const bufferLengthRef = (0, import_react8.useRef)(0);
    const sourceNodeRef = (0, import_react8.useRef)(null);
    const gainNodeRef = (0, import_react8.useRef)(null);
    const metronomeAudioCtxRef = (0, import_react8.useRef)(null);
    const lowVolumeFrameCountRef = (0, import_react8.useRef)(0);
    const currentStepRecordedPitchesRef = (0, import_react8.useRef)([]);
    const lastAttemptedStepRef = (0, import_react8.useRef)(null);
    const lastAttemptedDurationRef = (0, import_react8.useRef)(null);
    const notHearingYouFadeOutTimerRef = (0, import_react8.useRef)(null);
    const lastProgressRef = (0, import_react8.useRef)(0);
    const [lowNotePitches, setLowNotePitches] = (0, import_react8.useState)([]);
    const [speakingPitches, setSpeakingPitches] = (0, import_react8.useState)([]);
    const [sirenPitches, setSirenPitches] = (0, import_react8.useState)([]);
    const [advancedResult, setAdvancedResult] = (0, import_react8.useState)(null);
    const [simpleSirenPitches, setSimpleSirenPitches] = (0, import_react8.useState)([]);
    const [simpleResult, setSimpleResult] = (0, import_react8.useState)(null);
    const activeTheme = currentTheme;
    const changeStatus = (0, import_react8.useCallback)((newStatus, stateUpdateFn) => {
      setIsAnimatingOut(true);
      setTimeout(() => {
        if (stateUpdateFn)
          stateUpdateFn();
        setStatus(newStatus);
        setIsAnimatingOut(false);
      }, 300);
    }, []);
    const toggleTheme = (0, import_react8.useCallback)(() => {
      setTheme((prevTheme) => prevTheme === "dark" ? "light" : "dark");
    }, []);
    const toggleLanguage = (0, import_react8.useCallback)(() => {
      setLanguage((prev) => prev === "en" ? "pt-BR" : "en");
    }, []);
    const t = (0, import_react8.useCallback)((key, replacements) => {
      let text = translations2[language][key] || translations2.en[key];
      if (replacements) {
        Object.keys(replacements).forEach((rKey) => {
          text = text.replace(`{${rKey}}`, String(replacements[rKey]));
        });
      }
      return text;
    }, [language]);
    (0, import_react8.useEffect)(() => {
      const root2 = window.document.documentElement;
      if (theme === "dark") {
        root2.classList.add("dark");
      } else {
        root2.classList.remove("dark");
      }
    }, [theme]);
    const playMetronomeSound = (0, import_react8.useCallback)(() => {
      if (!metronomeAudioCtxRef.current) {
        metronomeAudioCtxRef.current = new (window.AudioContext || window.webkitAudioContext)();
      }
      const ctx = metronomeAudioCtxRef.current;
      const oscillator = ctx.createOscillator();
      const gainNode = ctx.createGain();
      oscillator.type = "triangle";
      oscillator.frequency.setValueAtTime(220, ctx.currentTime);
      gainNode.gain.setValueAtTime(0.2, ctx.currentTime);
      oscillator.connect(gainNode);
      gainNode.connect(ctx.destination);
      oscillator.start();
      gainNode.gain.exponentialRampToValueAtTime(1e-3, ctx.currentTime + 0.3);
      oscillator.stop(ctx.currentTime + 0.3);
    }, []);
    const stopAll = (0, import_react8.useCallback)(() => {
      if (rafRef.current)
        cancelAnimationFrame(rafRef.current);
      rafRef.current = null;
      mediaStreamRef.current?.getTracks().forEach((t2) => t2.stop());
      mediaStreamRef.current = null;
      if (audioCtxRef.current && audioCtxRef.current.state !== "closed") {
        audioCtxRef.current.close().catch((e) => console.error("Error closing audio context:", e));
      }
      audioCtxRef.current = null;
      if (notHearingYouFadeOutTimerRef.current)
        clearTimeout(notHearingYouFadeOutTimerRef.current);
      onCancel();
      changeStatus("modeSelection", () => {
        setMode(null);
        setStep(0);
        setInstructionMessage("");
        setRmsVolume(0);
        setProgressPercentage(0);
        setLowNotePitches([]);
        setSpeakingPitches([]);
        setSirenPitches([]);
        setSimpleSirenPitches([]);
        setAdvancedResult(null);
        setSimpleResult(null);
        setGeneratedFeedback(null);
        setIsGeneratingFeedback(false);
      });
    }, [changeStatus, onCancel]);
    (0, import_react8.useEffect)(() => {
      return () => {
        if (rafRef.current)
          cancelAnimationFrame(rafRef.current);
        mediaStreamRef.current?.getTracks().forEach((t2) => t2.stop());
        if (audioCtxRef.current && audioCtxRef.current.state !== "closed") {
          audioCtxRef.current.close().catch((e) => console.error("Error closing audio context on unmount:", e));
        }
      };
    }, []);
    const initAudio = (0, import_react8.useCallback)(async () => {
      try {
        if (audioCtxRef.current && audioCtxRef.current.state !== "closed") {
          await audioCtxRef.current.close();
        }
        const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
        mediaStreamRef.current = stream;
        const AudioContext2 = window.AudioContext || window.webkitAudioContext;
        audioCtxRef.current = new AudioContext2();
        if (audioCtxRef.current.state === "suspended") {
          await audioCtxRef.current.resume();
        }
        sourceNodeRef.current = audioCtxRef.current.createMediaStreamSource(stream);
        gainNodeRef.current = audioCtxRef.current.createGain();
        analyserRef.current = audioCtxRef.current.createAnalyser();
        sourceNodeRef.current.connect(gainNodeRef.current);
        gainNodeRef.current.connect(analyserRef.current);
        gainNodeRef.current.gain.setValueAtTime(5, audioCtxRef.current.currentTime);
        analyserRef.current.fftSize = 2048;
        bufferLengthRef.current = analyserRef.current.fftSize;
        dataArrayRef.current = new Float32Array(bufferLengthRef.current);
        setPermission(true);
        return true;
      } catch (err) {
        console.error("Error accessing microphone:", err);
        setPermission(false);
        changeStatus("modeSelection", () => {
          setInstructionMessage(t("micDenied"));
        });
        return false;
      }
    }, [changeStatus, t]);
    const getInstructionForStep = (0, import_react8.useCallback)((currentMode, stepNumber) => {
      if (currentMode === "advanced") {
        if (stepNumber === 1)
          return t("step1Instruction");
        if (stepNumber === 2)
          return t("step2Instruction");
        if (stepNumber === 3)
          return t("step3Instruction");
      } else if (currentMode === "simple") {
        if (stepNumber === 1)
          return t("simpleStep1Instruction");
      }
      return "";
    }, [t]);
    const computeAdvancedResults = (0, import_react8.useCallback)((finalSirenPitches) => {
      const filteredLow = lowNotePitches.filter((f) => f >= YIN_MIN_FREQ && f <= YIN_MAX_FREQ);
      const filteredSpeaking = speakingPitches.filter((f) => f >= YIN_MIN_FREQ && f <= YIN_MAX_FREQ);
      const filteredSiren = finalSirenPitches.filter((f) => f >= YIN_MIN_FREQ && f <= YIN_MAX_FREQ);
      const avgLowest = min(filteredLow);
      const avgSpeaking = average(filteredSpeaking);
      const minSiren = min(filteredSiren);
      const maxSiren = max(filteredSiren);
      const allMin = [
        ...avgLowest !== null ? [avgLowest] : [],
        ...minSiren !== null ? [minSiren] : []
      ].filter((f) => f > 0);
      const overallMin = min(allMin);
      const allMax = [
        ...avgSpeaking !== null ? [avgSpeaking] : [],
        ...maxSiren !== null ? [maxSiren] : []
      ].filter((f) => f > 0);
      const overallMax = max(allMax);
      changeStatus("results", () => {
        setAdvancedResult({
          lowestNoteHz: avgLowest,
          speakingHz: avgSpeaking,
          overallMinHz: overallMin,
          overallMaxHz: overallMax,
          lowestNoteNote: freqToNote(avgLowest),
          speakingNote: freqToNote(avgSpeaking),
          overallMinNote: freqToNote(overallMin),
          overallMaxNote: freqToNote(overallMax)
        });
      });
    }, [lowNotePitches, speakingPitches, changeStatus]);
    const computeSimpleResults = (0, import_react8.useCallback)((pitches) => {
      const filteredPitches = pitches.filter((f) => f >= YIN_MIN_FREQ && f <= YIN_MAX_FREQ);
      const lowHz = min(filteredPitches);
      const highHz = max(filteredPitches);
      changeStatus("results", () => {
        setSimpleResult({
          lowestNoteHz: lowHz,
          highestNoteHz: highHz,
          lowestNoteNote: freqToNote(lowHz),
          highestNoteNote: freqToNote(highHz)
        });
      });
    }, [changeStatus]);
    const showInstructionsWithFadeRef = (0, import_react8.useRef)(null);
    const startProcessStep = (0, import_react8.useCallback)(async (currentMode, targetStep, durationMs) => {
      setStatus("recording");
      setCountdownDisplay(null);
      setInstructionOpacityClass("opacity-100 text-black dark:text-white");
      if (notHearingYouFadeOutTimerRef.current)
        clearTimeout(notHearingYouFadeOutTimerRef.current);
      setIsNotHearingYou(false);
      setShowNotHearingYou(false);
      lowVolumeFrameCountRef.current = 0;
      currentStepRecordedPitchesRef.current = [];
      setProgressPercentage(0);
      lastAttemptedStepRef.current = targetStep;
      const validDuration = !durationMs || durationMs <= 0 ? 1e4 : durationMs;
      lastAttemptedDurationRef.current = validDuration;
      const startTime = performance.now();
      const analyser = analyserRef.current;
      const dataArray = dataArrayRef.current;
      const audioCtx = audioCtxRef.current;
      const recentPitches = [];
      const PITCH_BUFFER_SIZE = 3;
      const PITCH_FILTER_RATIO = 2.5;
      const tick = async () => {
        if (!analyser || !dataArray || !audioCtx) {
          console.warn("Tick skipped: missing audio context or analyser", { analyser: !!analyser, dataArray: !!dataArray, audioCtx: !!audioCtx });
          return;
        }
        const elapsedTime = performance.now() - startTime;
        const newProgress = Math.min(100, elapsedTime / validDuration * 100);
        if (Math.abs(newProgress - lastProgressRef.current) > 0.5 || newProgress >= 100 || newProgress === 0) {
          setProgressPercentage(newProgress);
          lastProgressRef.current = newProgress;
        }
        analyser.getFloatTimeDomainData(dataArray);
        const freq = detectPitchPYIN(dataArray, audioCtx.sampleRate, {
          bias: pyinBias ?? 0.1,
          tolerance: pyinTolerance ?? 0.3,
          gateThreshold: noiseGateThreshold ?? 8e-3,
          gateMode: pyinGateMode ?? "smooth"
        });
        const validFreq = freq > 70 && freq < 2e3 ? freq : null;
        const rms = calculateRMS(dataArray);
        setRmsVolume((prev) => prev * 0.95 + rms * 0.05);
        if (rms < LOW_VOLUME_RMS_THRESHOLD) {
          lowVolumeFrameCountRef.current++;
          if (lowVolumeFrameCountRef.current >= LOW_VOLUME_FRAME_COUNT_THRESHOLD && !isNotHearingYou) {
            setIsNotHearingYou(true);
            setShowNotHearingYou(true);
            if (notHearingYouFadeOutTimerRef.current)
              clearTimeout(notHearingYouFadeOutTimerRef.current);
          }
        } else {
          lowVolumeFrameCountRef.current = 0;
          if (isNotHearingYou) {
            setIsNotHearingYou(false);
            if (notHearingYouFadeOutTimerRef.current)
              clearTimeout(notHearingYouFadeOutTimerRef.current);
            notHearingYouFadeOutTimerRef.current = window.setTimeout(() => setShowNotHearingYou(false), 300);
          }
        }
        if (validFreq !== null && validFreq > 0) {
          let acceptPitch = true;
          if (recentPitches.length >= PITCH_BUFFER_SIZE) {
            const sortedRecent = [...recentPitches].sort((a, b) => a - b);
            const median = sortedRecent[Math.floor(PITCH_BUFFER_SIZE / 2)];
            const ratio = freq / median;
            if (ratio > PITCH_FILTER_RATIO || ratio < 1 / PITCH_FILTER_RATIO) {
              acceptPitch = false;
            }
          }
          if (acceptPitch) {
            currentStepRecordedPitchesRef.current.push(validFreq);
            recentPitches.push(validFreq);
            if (recentPitches.length > PITCH_BUFFER_SIZE) {
              recentPitches.shift();
            }
          }
        }
        if (elapsedTime < validDuration) {
          rafRef.current = requestAnimationFrame(tick);
        } else {
          if (rafRef.current)
            cancelAnimationFrame(rafRef.current);
          rafRef.current = null;
          setRmsVolume(0);
          const recordedPitches = currentStepRecordedPitchesRef.current;
          if (currentMode === "advanced") {
            if (targetStep === 1)
              setLowNotePitches(recordedPitches);
            else if (targetStep === 2)
              setSpeakingPitches(recordedPitches);
            else if (targetStep === 3)
              setSirenPitches(recordedPitches);
          } else if (currentMode === "simple") {
            if (targetStep === 1)
              setSimpleSirenPitches(recordedPitches);
          }
          await new Promise((resolve) => setTimeout(resolve, 700));
          if (recordedPitches.length === 0) {
            changeStatus("waitingForInputRetry", () => {
              setInstructionMessage(t("noInputDescription"));
            });
            return;
          }
          if (currentMode === "advanced") {
            if (targetStep === 1)
              await showInstructionsWithFadeRef.current?.(currentMode, 2, 12e3);
            else if (targetStep === 2)
              await showInstructionsWithFadeRef.current?.(currentMode, 3, 15e3);
            else if (targetStep === 3)
              computeAdvancedResults(recordedPitches);
          } else if (currentMode === "simple") {
            if (targetStep === 1)
              computeSimpleResults(recordedPitches);
          }
        }
      };
      if (rafRef.current)
        cancelAnimationFrame(rafRef.current);
      rafRef.current = requestAnimationFrame(tick);
    }, [isNotHearingYou, t, computeAdvancedResults, computeSimpleResults, changeStatus]);
    const startRecordingCountdown = (0, import_react8.useCallback)(async (currentMode, targetStep, durationMs, instruction) => {
      setInstructionMessage(instruction);
      setInstructionOpacityClass("opacity-100");
      setStatus("countdown");
      setRmsVolume(0);
      for (let i = 3; i > 0; i--) {
        setCountdownDisplay(String(i));
        setCountdownOpacity(1);
        playMetronomeSound();
        await new Promise((resolve) => setTimeout(resolve, 800));
        setCountdownOpacity(0);
        await new Promise((resolve) => setTimeout(resolve, 200));
      }
      setCountdownDisplay(t("countdownGo"));
      setCountdownOpacity(1);
      playMetronomeSound();
      await new Promise((resolve) => setTimeout(resolve, 500));
      setCountdownOpacity(0);
      await new Promise((resolve) => setTimeout(resolve, 200));
      setCountdownDisplay(null);
      await startProcessStep(currentMode, targetStep, durationMs);
    }, [playMetronomeSound, startProcessStep, t]);
    const showInstructionsWithFade = (0, import_react8.useCallback)(async (currentMode, targetStep, durationMs) => {
      const instructionText = getInstructionForStep(currentMode, targetStep);
      changeStatus("instructions", () => {
        setInstructionMessage(instructionText);
        setStep(targetStep);
      });
      await new Promise((resolve) => setTimeout(resolve, 400));
      await startRecordingCountdown(currentMode, targetStep, durationMs, instructionText);
    }, [getInstructionForStep, startRecordingCountdown, changeStatus]);
    (0, import_react8.useEffect)(() => {
      showInstructionsWithFadeRef.current = showInstructionsWithFade;
    }, [showInstructionsWithFade]);
    const startDetection = (0, import_react8.useCallback)(async (selectedMode) => {
      if (isInitializing)
        return;
      setIsInitializing(true);
      setMode(selectedMode);
      if (!audioCtxRef.current || audioCtxRef.current.state === "closed") {
        const success = await initAudio();
        if (!success) {
          setIsInitializing(false);
          setMode(null);
          return;
        }
      }
      setLowNotePitches([]);
      setSpeakingPitches([]);
      setSirenPitches([]);
      setSimpleSirenPitches([]);
      setAdvancedResult(null);
      setSimpleResult(null);
      setGeneratedFeedback(null);
      setIsGeneratingFeedback(false);
      const duration = selectedMode === "advanced" ? 1e4 : 9e3;
      await showInstructionsWithFade(selectedMode, 1, duration);
      setTimeout(() => setIsInitializing(false), 500);
    }, [isInitializing, initAudio, showInstructionsWithFade]);
    const handleTryAgain = (0, import_react8.useCallback)(async () => {
      if (mode && lastAttemptedStepRef.current !== null && lastAttemptedDurationRef.current !== null) {
        if (showInstructionsWithFadeRef.current) {
          await showInstructionsWithFadeRef.current(mode, lastAttemptedStepRef.current, lastAttemptedDurationRef.current);
        }
      }
    }, [mode]);
    const handleContinueAnyway = (0, import_react8.useCallback)(async () => {
      if (mode === "advanced" && lastAttemptedStepRef.current !== null && showInstructionsWithFadeRef.current) {
        if (lastAttemptedStepRef.current === 1)
          await showInstructionsWithFadeRef.current?.(mode, 2, 12e3);
        else if (lastAttemptedStepRef.current === 2)
          await showInstructionsWithFadeRef.current?.(mode, 3, 15e3);
        else if (lastAttemptedStepRef.current === 3)
          computeAdvancedResults([]);
      } else if (mode === "simple" && lastAttemptedStepRef.current !== null) {
        if (lastAttemptedStepRef.current === 1)
          computeSimpleResults([]);
      }
    }, [mode, computeAdvancedResults, computeSimpleResults]);
    const handleSave = (0, import_react8.useCallback)(() => {
      console.log("handleSave called");
      setIsSaving(true);
      let minHz = null;
      let maxHz = null;
      if (mode === "advanced" && advancedResult) {
        minHz = advancedResult.overallMinHz;
        maxHz = advancedResult.overallMaxHz;
      } else if (mode === "simple" && simpleResult) {
        minHz = simpleResult.lowestNoteHz;
        maxHz = simpleResult.highestNoteHz;
      }
      if (minHz && maxHz) {
        console.log("Saving results:", minHz, maxHz);
        const minMidi = Math.round(12 * Math.log2(minHz / 440) + 69);
        const maxMidi = Math.round(12 * Math.log2(maxHz / 440) + 69);
        const minSemitone = minMidi - 60;
        const maxSemitone = maxMidi - 60;
        if (onComplete) {
          onComplete(
            { semitone: minSemitone, name: freqToNote(minHz) || "C3", isSharp: (freqToNote(minHz) || "").includes("#") },
            { semitone: maxSemitone, name: freqToNote(maxHz) || "C5", isSharp: (freqToNote(maxHz) || "").includes("#") }
          );
          onCancel();
        } else {
          console.error("onComplete prop is missing!");
          alert("Error: Could not save results (missing callback).");
          setIsSaving(false);
        }
      } else {
        console.warn("No results to save, cancelling");
        setIsSaving(false);
        onCancel();
      }
    }, [mode, advancedResult, simpleResult, onComplete, onCancel]);
    const getStepTitle = (0, import_react8.useCallback)(() => {
      if (mode === "advanced") {
        if (step === 1)
          return t("step1Title");
        if (step === 2)
          return t("step2Title");
        if (step === 3)
          return t("step3Title");
      } else if (mode === "simple") {
        if (step === 1)
          return t("simpleStep1Title");
      }
      return "";
    }, [mode, step, t]);
    const generateVocalFeedback = (0, import_react8.useCallback)(async () => {
      if (!advancedResult && !simpleResult)
        return;
      setIsGeneratingFeedback(true);
      setGeneratedFeedback(null);
      let vocalData;
      if (mode === "advanced" && advancedResult) {
        vocalData = {
          testMode: "Advanced Analysis",
          vocalRangeDetected: `${advancedResult.overallMinNote || "?"} to ${advancedResult.overallMaxNote || "?"}`,
          lowestNote: `${advancedResult.lowestNoteNote || "?"}`,
          averageSpeakingPitch: `${advancedResult.speakingNote || "?"}`
        };
      } else if (mode === "simple" && simpleResult) {
        vocalData = {
          testMode: "Simple Siren Test",
          vocalRangeDetected: `${simpleResult.lowestNoteNote || "?"} to ${simpleResult.highestNoteNote || "?"}`
        };
      } else {
        setIsGeneratingFeedback(false);
        return;
      }
      const lang = language === "pt-BR" ? "Brazilian Portuguese" : "English";
      const prompt = `
        You are a vocal analysis assistant. Provide brief, synthesized feedback on a vocal range test. Your response must be in ${lang}.

        Vocal test data:
        ${JSON.stringify(vocalData, null, 2)}

        Based on the data, provide a very concise analysis (1-2 sentences). Keep the tone positive and direct.

        IMPORTANT: For the "singers" field, provide 3-4 well-known professional singers with similar vocal ranges. 
        - Include a balanced mix of genders (at least 1-2 male and 1-2 female artists)
        - Choose internationally recognized artists known for their vocal ability
        - Ensure the singers actually have similar ranges to the detected range
        - Do NOT segregate by gender in the display - mix them naturally
        - Prioritize vocal quality and range similarity over other factors

        Your response MUST be a valid JSON object with short, synthesized values.

        Example in English:
        {
          "analysis": "Your voice showed a well-defined lower range with a smooth transition. The recorded vocal extension is quite interesting.",
          "singers": ["Adele", "Sam Smith", "Christina Aguilera", "John Legend"],
          "tip": "Stay hydrated before singing exercises.",
          "disclaimer": "Vocal performance can vary naturally. This is a snapshot of your voice right now."
        }
    `;
      try {
        const ai = new GoogleGenAI({ apiKey: "AIzaSyD0JEm3fqse7TQZ1ri2UWMmdtJigyX3fpo" });
        const responseSchema = {
          type: Type.OBJECT,
          properties: {
            analysis: { type: Type.STRING },
            singers: { type: Type.ARRAY, items: { type: Type.STRING } },
            tip: { type: Type.STRING },
            disclaimer: { type: Type.STRING }
          },
          required: ["analysis", "singers", "tip", "disclaimer"]
        };
        const response = await ai.models.generateContent({
          model: "gemini-2.5-flash",
          contents: prompt,
          config: {
            responseMimeType: "application/json",
            responseSchema
          }
        });
        const feedbackObject = JSON.parse(response.text);
        setGeneratedFeedback(feedbackObject);
      } catch (error) {
        console.error("Error generating vocal feedback:", error);
      } finally {
        setIsGeneratingFeedback(false);
      }
    }, [advancedResult, simpleResult, mode, language]);
    (0, import_react8.useEffect)(() => {
      if (status === "results" && (advancedResult || simpleResult) && !generatedFeedback && !isGeneratingFeedback) {
        generateVocalFeedback();
      }
    }, [status, advancedResult, simpleResult, generatedFeedback, isGeneratingFeedback, generateVocalFeedback]);
    const mainContent = () => {
      if (status === "modeSelection") {
        return /* @__PURE__ */ (0, import_jsx_runtime8.jsxs)(import_jsx_runtime8.Fragment, { children: [
          /* @__PURE__ */ (0, import_jsx_runtime8.jsx)("h1", { className: "text-4xl sm:text-5xl font-black text-transparent bg-clip-text bg-gradient-to-r from-gray-800 to-gray-600 dark:from-white dark:to-gray-400 mb-4", children: t("title1") }),
          /* @__PURE__ */ (0, import_jsx_runtime8.jsx)("p", { className: "text-lg text-gray-600 dark:text-gray-300 mb-10 max-w-md", children: t("selectMode") }),
          permission === false && instructionMessage && /* @__PURE__ */ (0, import_jsx_runtime8.jsx)("p", { className: "text-lg text-red-500 dark:text-red-400 mb-10 max-w-md", children: instructionMessage }),
          /* @__PURE__ */ (0, import_jsx_runtime8.jsxs)("div", { className: "flex flex-col sm:flex-row gap-8", children: [
            /* @__PURE__ */ (0, import_jsx_runtime8.jsxs)("div", { className: "flex flex-col items-center gap-3", children: [
              /* @__PURE__ */ (0, import_jsx_runtime8.jsxs)(
                "button",
                {
                  onClick: () => startDetection("simple"),
                  disabled: isInitializing,
                  className: `
                                px-8 py-3 rounded-full font-medium text-base text-white
                                flex items-center justify-center gap-2
                                relative overflow-hidden group 
                                transition-all transform hover:scale-105 active:scale-95
                                bg-gradient-to-br ${activeTheme.button.from} ${activeTheme.button.via} ${activeTheme.button.to}
                                shadow-2xl ${activeTheme.button.shadow} 
                                backdrop-blur-sm
                            `,
                  style: {
                    boxShadow: `0 8px 32px rgba(${activeTheme.button.shadowRgb}, 0.4), inset 0 1px 0 rgba(255, 255, 255, 0.2)`
                  },
                  children: [
                    /* @__PURE__ */ (0, import_jsx_runtime8.jsx)("div", { className: "absolute inset-0 bg-gradient-to-br from-white/30 via-transparent to-transparent opacity-50" }),
                    /* @__PURE__ */ (0, import_jsx_runtime8.jsx)("div", { className: "absolute inset-0 bg-gradient-to-r from-transparent via-white/20 to-transparent translate-x-[-100%] group-hover:translate-x-[100%] transition-transform duration-700" }),
                    /* @__PURE__ */ (0, import_jsx_runtime8.jsx)("span", { className: "relative z-10 flex items-center gap-2", children: /* @__PURE__ */ (0, import_jsx_runtime8.jsx)("span", { children: t("simpleMode") }) })
                  ]
                }
              ),
              /* @__PURE__ */ (0, import_jsx_runtime8.jsx)("p", { className: "font-light text-sm text-gray-600 dark:text-gray-400", children: t("simpleModeDesc") })
            ] }),
            /* @__PURE__ */ (0, import_jsx_runtime8.jsxs)("div", { className: "flex flex-col items-center gap-3", children: [
              /* @__PURE__ */ (0, import_jsx_runtime8.jsxs)(
                "button",
                {
                  onClick: () => startDetection("advanced"),
                  disabled: isInitializing,
                  className: `
                                px-8 py-3 rounded-full font-medium text-base text-white
                                flex items-center justify-center gap-2
                                relative overflow-hidden group 
                                transition-all transform hover:scale-105 active:scale-95
                                bg-gradient-to-br ${activeTheme.button.from} ${activeTheme.button.via} ${activeTheme.button.to}
                                shadow-2xl ${activeTheme.button.shadow} 
                                backdrop-blur-sm
                            `,
                  style: {
                    boxShadow: `0 8px 32px rgba(${activeTheme.button.shadowRgb}, 0.4), inset 0 1px 0 rgba(255, 255, 255, 0.2)`
                  },
                  children: [
                    /* @__PURE__ */ (0, import_jsx_runtime8.jsx)("div", { className: "absolute inset-0 bg-gradient-to-br from-white/30 via-transparent to-transparent opacity-50" }),
                    /* @__PURE__ */ (0, import_jsx_runtime8.jsx)("div", { className: "absolute inset-0 bg-gradient-to-r from-transparent via-white/20 to-transparent translate-x-[-100%] group-hover:translate-x-[100%] transition-transform duration-700" }),
                    /* @__PURE__ */ (0, import_jsx_runtime8.jsx)("span", { className: "relative z-10 flex items-center gap-2", children: /* @__PURE__ */ (0, import_jsx_runtime8.jsx)("span", { children: t("advancedMode") }) })
                  ]
                }
              ),
              /* @__PURE__ */ (0, import_jsx_runtime8.jsx)("p", { className: "font-light text-sm text-gray-600 dark:text-gray-400", children: t("advancedModeDesc") })
            ] })
          ] })
        ] });
      }
      if (["instructions", "countdown", "recording"].includes(status)) {
        const gradientTextClasses = `text-transparent bg-clip-text bg-gradient-to-r ${activeTheme.gradientText.from} ${activeTheme.gradientText.to} ${activeTheme.gradientText.darkFrom} ${activeTheme.gradientText.darkTo}`;
        return /* @__PURE__ */ (0, import_jsx_runtime8.jsxs)("div", { className: "flex flex-col items-center justify-center transition-all duration-500 min-h-[32rem]", children: [
          /* @__PURE__ */ (0, import_jsx_runtime8.jsx)("div", { className: `absolute top-6 text-lg font-bold ${gradientTextClasses} tracking-widest`, children: mode === "advanced" ? t("advancedStepHeader", { step }) : t("simpleStepHeader") }),
          /* @__PURE__ */ (0, import_jsx_runtime8.jsx)("div", { className: "text-3xl font-extrabold text-black dark:text-white mb-6 mt-12", children: getStepTitle() }),
          /* @__PURE__ */ (0, import_jsx_runtime8.jsx)("div", { className: "relative w-full h-40 flex items-center justify-center mb-6", children: status === "countdown" && countdownDisplay ? /* @__PURE__ */ (0, import_jsx_runtime8.jsx)("div", { className: "absolute text-9xl font-black text-black dark:text-white transition-opacity duration-300", style: { opacity: countdownOpacity }, children: countdownDisplay }) : /* @__PURE__ */ (0, import_jsx_runtime8.jsx)("div", { className: `text-4xl font-bold text-gray-700 dark:text-gray-200 whitespace-pre-wrap transition-opacity duration-700 px-4 ${instructionOpacityClass}`, children: status === "recording" && instructionMessage }) }),
          status === "recording" && /* @__PURE__ */ (0, import_jsx_runtime8.jsxs)("div", { className: "w-full max-w-md flex flex-col items-center mt-4 space-y-4", children: [
            /* @__PURE__ */ (0, import_jsx_runtime8.jsx)("div", { className: "w-full h-3 bg-black/10 dark:bg-white/10 rounded-full overflow-hidden", children: /* @__PURE__ */ (0, import_jsx_runtime8.jsx)("div", { className: `h-full bg-gradient-to-r ${activeTheme.progress.from} ${activeTheme.progress.to} transition-all duration-100 ease-linear`, style: { width: `${progressPercentage}%` } }) }),
            showNotHearingYouMessage && /* @__PURE__ */ (0, import_jsx_runtime8.jsx)("div", { className: `text-xl font-bold ${gradientTextClasses} transition-opacity duration-300 ease-in-out animate-pulse text-center w-full`, children: t("notHearingYou") })
          ] })
        ] });
      }
      if (status === "waitingForInputRetry") {
        return /* @__PURE__ */ (0, import_jsx_runtime8.jsxs)("div", { className: "flex flex-col items-center justify-center transition-all duration-500 min-h-[32rem]", children: [
          /* @__PURE__ */ (0, import_jsx_runtime8.jsx)("h3", { className: "text-3xl font-bold text-black dark:text-white mb-4", children: t("noInputTitle") }),
          /* @__PURE__ */ (0, import_jsx_runtime8.jsx)("p", { className: "text-gray-600 dark:text-gray-300 text-lg mb-8 max-w-md", children: instructionMessage }),
          /* @__PURE__ */ (0, import_jsx_runtime8.jsxs)("div", { className: "flex flex-col sm:flex-row space-y-4 sm:space-y-0 sm:space-x-4", children: [
            /* @__PURE__ */ (0, import_jsx_runtime8.jsxs)(
              "button",
              {
                onClick: handleTryAgain,
                className: `
                      px-8 py-3 rounded-full font-medium text-base text-white
                      flex items-center justify-center gap-2
                      relative overflow-hidden group 
                      transition-all transform hover:scale-105 active:scale-95
                      bg-gradient-to-br ${activeTheme.button.from} ${activeTheme.button.via} ${activeTheme.button.to}
                      shadow-2xl ${activeTheme.button.shadow} 
                      backdrop-blur-sm
                  `,
                style: {
                  boxShadow: `0 8px 32px rgba(${activeTheme.button.shadowRgb}, 0.4), inset 0 1px 0 rgba(255, 255, 255, 0.2)`
                },
                children: [
                  /* @__PURE__ */ (0, import_jsx_runtime8.jsx)("div", { className: "absolute inset-0 bg-gradient-to-br from-white/30 via-transparent to-transparent opacity-50" }),
                  /* @__PURE__ */ (0, import_jsx_runtime8.jsx)("div", { className: "absolute inset-0 bg-gradient-to-r from-transparent via-white/20 to-transparent translate-x-[-100%] group-hover:translate-x-[100%] transition-transform duration-700" }),
                  /* @__PURE__ */ (0, import_jsx_runtime8.jsx)("span", { className: "relative z-10 flex items-center gap-2", children: /* @__PURE__ */ (0, import_jsx_runtime8.jsx)("span", { children: t("tryAgain") }) })
                ]
              }
            ),
            /* @__PURE__ */ (0, import_jsx_runtime8.jsxs)(
              "button",
              {
                onClick: handleContinueAnyway,
                className: `
                      px-8 py-3 rounded-full font-medium text-base text-white
                      flex items-center justify-center gap-2
                      relative overflow-hidden group 
                      transition-all transform hover:scale-105 active:scale-95
                      bg-gradient-to-br from-gray-500 via-gray-600 to-gray-700
                      shadow-2xl shadow-gray-600/40
                      backdrop-blur-sm
                  `,
                style: {
                  boxShadow: "0 8px 32px rgba(75, 85, 99, 0.4), inset 0 1px 0 rgba(255, 255, 255, 0.2)"
                },
                children: [
                  /* @__PURE__ */ (0, import_jsx_runtime8.jsx)("div", { className: "absolute inset-0 bg-gradient-to-br from-white/30 via-transparent to-transparent opacity-50" }),
                  /* @__PURE__ */ (0, import_jsx_runtime8.jsx)("div", { className: "absolute inset-0 bg-gradient-to-r from-transparent via-white/20 to-transparent translate-x-[-100%] group-hover:translate-x-[100%] transition-transform duration-700" }),
                  /* @__PURE__ */ (0, import_jsx_runtime8.jsx)("span", { className: "relative z-10 flex items-center gap-2", children: /* @__PURE__ */ (0, import_jsx_runtime8.jsx)("span", { children: t("continueAnyway") }) })
                ]
              }
            )
          ] })
        ] });
      }
      if (status === "results") {
        const resultsTitleClasses = `text-4xl font-bold text-transparent bg-clip-text bg-gradient-to-r ${activeTheme.gradientText.from} ${activeTheme.gradientText.to} ${activeTheme.gradientText.darkFrom} ${activeTheme.gradientText.darkTo} mb-8`;
        const resultsRangeClasses = `flex-grow h-1 bg-gradient-to-r ${activeTheme.resultsRange.from} ${activeTheme.resultsRange.to} mx-4 rounded-full`;
        return mode === "advanced" && advancedResult ? /* @__PURE__ */ (0, import_jsx_runtime8.jsxs)("div", { className: "w-full max-w-lg text-center bg-white/30 dark:bg-black/20 backdrop-blur-lg border border-black/10 dark:border-white/10 rounded-3xl p-6 sm:p-8 shadow-2xl flex flex-col items-center justify-center transition-all duration-500 min-h-[32rem]", children: [
          /* @__PURE__ */ (0, import_jsx_runtime8.jsx)("h2", { className: resultsTitleClasses, children: t("resultsTitle") }),
          /* @__PURE__ */ (0, import_jsx_runtime8.jsxs)("div", { className: "w-full mb-8", children: [
            /* @__PURE__ */ (0, import_jsx_runtime8.jsx)("p", { className: "text-lg font-semibold text-green-600 dark:text-green-500 mb-4", children: t("resultsRange") }),
            /* @__PURE__ */ (0, import_jsx_runtime8.jsxs)("div", { className: "flex items-center justify-between", children: [
              /* @__PURE__ */ (0, import_jsx_runtime8.jsxs)("div", { className: "text-center", children: [
                /* @__PURE__ */ (0, import_jsx_runtime8.jsx)("p", { className: "text-5xl font-black text-black dark:text-white", children: advancedResult.overallMinNote || "N/A" }),
                /* @__PURE__ */ (0, import_jsx_runtime8.jsxs)("p", { className: "text-md text-gray-500 dark:text-gray-400", children: [
                  "(",
                  advancedResult.overallMinHz?.toFixed(1) || "--",
                  " Hz)"
                ] })
              ] }),
              /* @__PURE__ */ (0, import_jsx_runtime8.jsx)("div", { className: resultsRangeClasses }),
              /* @__PURE__ */ (0, import_jsx_runtime8.jsxs)("div", { className: "text-center", children: [
                /* @__PURE__ */ (0, import_jsx_runtime8.jsx)("p", { className: "text-5xl font-black text-black dark:text-white", children: advancedResult.overallMaxNote || "N/A" }),
                /* @__PURE__ */ (0, import_jsx_runtime8.jsxs)("p", { className: "text-md text-gray-500 dark:text-gray-400", children: [
                  "(",
                  advancedResult.overallMaxHz?.toFixed(1) || "--",
                  " Hz)"
                ] })
              ] })
            ] }),
            advancedResult.overallMinHz && advancedResult.overallMaxHz && (() => {
              const minMidi = Math.round(12 * Math.log2(advancedResult.overallMinHz / 440) + 69);
              const maxMidi = Math.round(12 * Math.log2(advancedResult.overallMaxHz / 440) + 69);
              const semitones = maxMidi - minMidi;
              const octaves = (semitones / 12).toFixed(1);
              return /* @__PURE__ */ (0, import_jsx_runtime8.jsxs)("p", { className: "text-sm text-gray-600 dark:text-gray-400 mt-3 font-medium", children: [
                "Range: ",
                semitones,
                " semitones (",
                octaves,
                " octaves)"
              ] });
            })(),
            (() => {
              const classification = getVoiceClassification(advancedResult.overallMinHz, advancedResult.overallMaxHz);
              if (!classification)
                return null;
              return /* @__PURE__ */ (0, import_jsx_runtime8.jsxs)("div", { className: "mt-6 p-4 rounded-xl bg-gradient-to-br from-purple-100/50 to-blue-100/50 dark:from-purple-900/20 dark:to-blue-900/20 border border-purple-200/50 dark:border-purple-700/50 backdrop-blur-sm animate-slide-up", children: [
                /* @__PURE__ */ (0, import_jsx_runtime8.jsxs)("div", { className: "flex items-center gap-3 mb-2", children: [
                  /* @__PURE__ */ (0, import_jsx_runtime8.jsx)(
                    "div",
                    {
                      className: "w-3 h-3 rounded-full shadow-lg",
                      style: { backgroundColor: VOICE_CLASSIFICATIONS[classification].color }
                    }
                  ),
                  /* @__PURE__ */ (0, import_jsx_runtime8.jsx)("p", { className: "text-sm font-semibold text-gray-700 dark:text-gray-300", children: t("voiceClassification") })
                ] }),
                /* @__PURE__ */ (0, import_jsx_runtime8.jsx)("p", { className: "text-xl font-bold text-gray-900 dark:text-white mb-3", children: t(classification) }),
                /* @__PURE__ */ (0, import_jsx_runtime8.jsx)("p", { className: "text-xs text-gray-600 dark:text-gray-400 leading-relaxed", children: t("classificationDisclaimer") })
              ] });
            })()
          ] }),
          /* @__PURE__ */ (0, import_jsx_runtime8.jsx)("div", { className: "w-3/4 h-px bg-black/10 dark:bg-white/10 my-4" }),
          /* @__PURE__ */ (0, import_jsx_runtime8.jsxs)("div", { className: "grid grid-cols-1 sm:grid-cols-2 gap-x-8 gap-y-6 w-full pt-4 text-center sm:text-left", children: [
            /* @__PURE__ */ (0, import_jsx_runtime8.jsxs)("div", { children: [
              /* @__PURE__ */ (0, import_jsx_runtime8.jsx)("p", { className: "text-sm font-medium text-gray-500 dark:text-gray-400", children: t("resultsLowestSung") }),
              /* @__PURE__ */ (0, import_jsx_runtime8.jsxs)("p", { className: "text-xl font-bold text-black dark:text-white", children: [
                advancedResult.lowestNoteNote || "N/A",
                " ",
                /* @__PURE__ */ (0, import_jsx_runtime8.jsxs)("span", { className: "text-base text-gray-600 dark:text-gray-400", children: [
                  "(",
                  advancedResult.lowestNoteHz?.toFixed(1) || "--",
                  " Hz)"
                ] })
              ] })
            ] }),
            /* @__PURE__ */ (0, import_jsx_runtime8.jsxs)("div", { children: [
              /* @__PURE__ */ (0, import_jsx_runtime8.jsx)("p", { className: "text-sm font-medium text-gray-500 dark:text-gray-400", children: t("resultsAvgSpeaking") }),
              /* @__PURE__ */ (0, import_jsx_runtime8.jsxs)("p", { className: "text-xl font-bold text-black dark:text-white", children: [
                advancedResult.speakingNote || "N/A",
                " ",
                /* @__PURE__ */ (0, import_jsx_runtime8.jsxs)("span", { className: "text-base text-gray-600 dark:text-gray-400", children: [
                  "(",
                  advancedResult.speakingHz?.toFixed(1) || "--",
                  " Hz)"
                ] })
              ] })
            ] })
          ] }),
          /* @__PURE__ */ (0, import_jsx_runtime8.jsx)("div", { className: "w-3/4 h-px bg-black/10 dark:bg-white/10 my-4" }),
          /* @__PURE__ */ (0, import_jsx_runtime8.jsxs)("div", { className: "w-full px-2 sm:px-4 text-left mt-2", children: [
            /* @__PURE__ */ (0, import_jsx_runtime8.jsx)("h3", { className: "text-lg font-bold text-black dark:text-white mb-2", children: t("feedbackTitle") }),
            isGeneratingFeedback && /* @__PURE__ */ (0, import_jsx_runtime8.jsx)("p", { className: "text-gray-500 dark:text-gray-400 animate-pulse", children: t("generatingFeedback") }),
            generatedFeedback && /* @__PURE__ */ (0, import_jsx_runtime8.jsxs)("div", { className: "text-gray-700 dark:text-gray-300 space-y-3 text-sm", children: [
              /* @__PURE__ */ (0, import_jsx_runtime8.jsx)("p", { children: generatedFeedback.analysis }),
              generatedFeedback.singers.length > 0 && /* @__PURE__ */ (0, import_jsx_runtime8.jsxs)("p", { children: [
                /* @__PURE__ */ (0, import_jsx_runtime8.jsx)("span", { className: "font-semibold text-black dark:text-white", children: "Similar Range:" }),
                " ",
                generatedFeedback.singers.join(", ")
              ] }),
              /* @__PURE__ */ (0, import_jsx_runtime8.jsxs)("p", { children: [
                /* @__PURE__ */ (0, import_jsx_runtime8.jsx)("span", { className: `font-semibold text-transparent bg-clip-text bg-gradient-to-r ${activeTheme.gradientText.from} ${activeTheme.gradientText.to} ${activeTheme.gradientText.darkFrom} ${activeTheme.gradientText.darkTo}`, children: "Pro Tip:" }),
                " ",
                generatedFeedback.tip
              ] }),
              /* @__PURE__ */ (0, import_jsx_runtime8.jsx)("p", { className: "text-xs italic text-gray-500 dark:text-gray-400 pt-2", children: generatedFeedback.disclaimer })
            ] })
          ] }),
          /* @__PURE__ */ (0, import_jsx_runtime8.jsxs)("div", { className: "pt-10 flex flex-col sm:flex-row gap-4", children: [
            /* @__PURE__ */ (0, import_jsx_runtime8.jsx)(
              "button",
              {
                onClick: handleSave,
                disabled: isSaving,
                className: `
                      px-8 py-3 rounded-full font-medium text-base text-white
                      flex items-center justify-center gap-2
                      relative overflow-hidden group
                      transition-all transform hover:scale-105 active:scale-95
                      bg-gradient-to-br from-green-500 to-emerald-600
                      shadow-2xl shadow-green-500/30
                      backdrop-blur-sm
                      ${isSaving ? "opacity-70 cursor-not-allowed" : ""}
                  `,
                children: /* @__PURE__ */ (0, import_jsx_runtime8.jsx)("span", { className: "relative z-10 flex items-center gap-2", children: /* @__PURE__ */ (0, import_jsx_runtime8.jsx)("span", { children: isSaving ? "Saving..." : t("saveAndContinue") || "Save & Continue" }) })
              }
            ),
            /* @__PURE__ */ (0, import_jsx_runtime8.jsxs)(
              "button",
              {
                onClick: stopAll,
                className: `
                      px-8 py-3 rounded-full font-medium text-base text-white
                      flex items-center justify-center gap-2
                      relative overflow-hidden group 
                      transition-all transform hover:scale-105 active:scale-95
                      bg-gradient-to-br ${activeTheme.button.from} ${activeTheme.button.via} ${activeTheme.button.to}
                      shadow-2xl ${activeTheme.button.shadow} 
                      backdrop-blur-sm
                  `,
                style: {
                  boxShadow: `0 8px 32px rgba(${activeTheme.button.shadowRgb}, 0.4), inset 0 1px 0 rgba(255, 255, 255, 0.2)`
                },
                children: [
                  /* @__PURE__ */ (0, import_jsx_runtime8.jsx)("div", { className: "absolute inset-0 bg-gradient-to-br from-white/30 via-transparent to-transparent opacity-50" }),
                  /* @__PURE__ */ (0, import_jsx_runtime8.jsx)("div", { className: "absolute inset-0 bg-gradient-to-r from-transparent via-white/20 to-transparent translate-x-[-100%] group-hover:translate-x-[100%] transition-transform duration-700" }),
                  /* @__PURE__ */ (0, import_jsx_runtime8.jsx)("span", { className: "relative z-10 flex items-center gap-2", children: /* @__PURE__ */ (0, import_jsx_runtime8.jsx)("span", { children: t("startNew") }) })
                ]
              }
            )
          ] })
        ] }) : mode === "simple" && simpleResult ? /* @__PURE__ */ (0, import_jsx_runtime8.jsxs)("div", { className: "w-full max-w-md text-center bg-white/30 dark:bg-black/20 backdrop-blur-lg border border-black/10 dark:border-white/10 rounded-2xl p-4 sm:p-6 shadow-2xl flex flex-col items-center justify-center transition-all duration-500", children: [
          /* @__PURE__ */ (0, import_jsx_runtime8.jsx)("h2", { className: `text-2xl sm:text-3xl font-bold text-transparent bg-clip-text bg-gradient-to-r ${activeTheme.gradientText.from} ${activeTheme.gradientText.to} ${activeTheme.gradientText.darkFrom} ${activeTheme.gradientText.darkTo} mb-4`, children: t("simpleResultsTitle") }),
          /* @__PURE__ */ (0, import_jsx_runtime8.jsxs)("div", { className: "w-full mb-4", children: [
            /* @__PURE__ */ (0, import_jsx_runtime8.jsx)("p", { className: "text-sm font-semibold text-green-600 dark:text-green-500 mb-2", children: t("resultsRange") }),
            /* @__PURE__ */ (0, import_jsx_runtime8.jsxs)("div", { className: "flex items-center justify-between", children: [
              /* @__PURE__ */ (0, import_jsx_runtime8.jsxs)("div", { className: "text-center", children: [
                /* @__PURE__ */ (0, import_jsx_runtime8.jsx)("p", { className: "text-4xl font-black text-black dark:text-white", children: simpleResult.lowestNoteNote || "N/A" }),
                /* @__PURE__ */ (0, import_jsx_runtime8.jsxs)("p", { className: "text-xs text-gray-500 dark:text-gray-400", children: [
                  "(",
                  simpleResult.lowestNoteHz?.toFixed(1) || "--",
                  " Hz)"
                ] })
              ] }),
              /* @__PURE__ */ (0, import_jsx_runtime8.jsx)("div", { className: resultsRangeClasses }),
              /* @__PURE__ */ (0, import_jsx_runtime8.jsxs)("div", { className: "text-center", children: [
                /* @__PURE__ */ (0, import_jsx_runtime8.jsx)("p", { className: "text-4xl font-black text-black dark:text-white", children: simpleResult.highestNoteNote || "N/A" }),
                /* @__PURE__ */ (0, import_jsx_runtime8.jsxs)("p", { className: "text-xs text-gray-500 dark:text-gray-400", children: [
                  "(",
                  simpleResult.highestNoteHz?.toFixed(1) || "--",
                  " Hz)"
                ] })
              ] })
            ] }),
            simpleResult.lowestNoteHz && simpleResult.highestNoteHz && (() => {
              const minMidi = Math.round(12 * Math.log2(simpleResult.lowestNoteHz / 440) + 69);
              const maxMidi = Math.round(12 * Math.log2(simpleResult.highestNoteHz / 440) + 69);
              const semitones = maxMidi - minMidi;
              const octaves = (semitones / 12).toFixed(1);
              return /* @__PURE__ */ (0, import_jsx_runtime8.jsxs)("p", { className: "text-xs text-gray-600 dark:text-gray-400 mt-2 font-medium", children: [
                "Range: ",
                semitones,
                " semitones (",
                octaves,
                " octaves)"
              ] });
            })(),
            (() => {
              const classification = getVoiceClassification(simpleResult.lowestNoteHz, simpleResult.highestNoteHz);
              if (!classification)
                return null;
              return /* @__PURE__ */ (0, import_jsx_runtime8.jsxs)("div", { className: "mt-4 p-3 rounded-xl bg-gradient-to-br from-purple-100/50 to-blue-100/50 dark:from-purple-900/20 dark:to-blue-900/20 border border-purple-200/50 dark:border-purple-700/50 backdrop-blur-sm animate-slide-up", children: [
                /* @__PURE__ */ (0, import_jsx_runtime8.jsxs)("div", { className: "flex items-center gap-2 mb-1", children: [
                  /* @__PURE__ */ (0, import_jsx_runtime8.jsx)(
                    "div",
                    {
                      className: "w-2.5 h-2.5 rounded-full shadow-lg",
                      style: { backgroundColor: VOICE_CLASSIFICATIONS[classification].color }
                    }
                  ),
                  /* @__PURE__ */ (0, import_jsx_runtime8.jsx)("p", { className: "text-xs font-semibold text-gray-700 dark:text-gray-300", children: t("voiceClassification") })
                ] }),
                /* @__PURE__ */ (0, import_jsx_runtime8.jsx)("p", { className: "text-lg font-bold text-gray-900 dark:text-white mb-1", children: t(classification) }),
                /* @__PURE__ */ (0, import_jsx_runtime8.jsx)("p", { className: "text-[10px] text-gray-600 dark:text-gray-400 leading-relaxed", children: t("classificationDisclaimer") })
              ] });
            })()
          ] }),
          /* @__PURE__ */ (0, import_jsx_runtime8.jsx)("div", { className: "w-full h-px bg-black/10 dark:bg-white/10 my-2" }),
          /* @__PURE__ */ (0, import_jsx_runtime8.jsxs)("div", { className: "w-full px-1 text-left", children: [
            /* @__PURE__ */ (0, import_jsx_runtime8.jsx)("h3", { className: "text-sm font-bold text-black dark:text-white mb-1", children: t("feedbackTitle") }),
            isGeneratingFeedback && /* @__PURE__ */ (0, import_jsx_runtime8.jsx)("p", { className: "text-gray-500 dark:text-gray-400 animate-pulse text-xs", children: t("generatingFeedback") }),
            generatedFeedback && /* @__PURE__ */ (0, import_jsx_runtime8.jsxs)("div", { className: "text-gray-700 dark:text-gray-300 space-y-1.5 text-xs", children: [
              /* @__PURE__ */ (0, import_jsx_runtime8.jsx)("p", { children: generatedFeedback.analysis }),
              generatedFeedback.singers.length > 0 && /* @__PURE__ */ (0, import_jsx_runtime8.jsxs)("p", { children: [
                /* @__PURE__ */ (0, import_jsx_runtime8.jsx)("span", { className: "font-semibold text-black dark:text-white", children: "Similar Range:" }),
                " ",
                generatedFeedback.singers.join(", ")
              ] }),
              /* @__PURE__ */ (0, import_jsx_runtime8.jsxs)("p", { children: [
                /* @__PURE__ */ (0, import_jsx_runtime8.jsx)("span", { className: `font-semibold text-transparent bg-clip-text bg-gradient-to-r ${activeTheme.gradientText.from} ${activeTheme.gradientText.to} ${activeTheme.gradientText.darkFrom} ${activeTheme.gradientText.darkTo}`, children: "Pro Tip:" }),
                " ",
                generatedFeedback.tip
              ] }),
              /* @__PURE__ */ (0, import_jsx_runtime8.jsx)("p", { className: "text-[10px] italic text-gray-500 dark:text-gray-400 pt-1", children: generatedFeedback.disclaimer })
            ] })
          ] }),
          /* @__PURE__ */ (0, import_jsx_runtime8.jsxs)("div", { className: "pt-4 pb-16 flex flex-row gap-3 w-full justify-center", children: [
            /* @__PURE__ */ (0, import_jsx_runtime8.jsx)(
              "button",
              {
                onClick: handleSave,
                className: `
                          px-5 py-2.5 rounded-full font-medium text-sm text-white
                          flex items-center justify-center gap-2
                          relative overflow-hidden group
                          transition-all transform hover:scale-105 active:scale-95
                          bg-gradient-to-br from-green-500 to-emerald-600
                          shadow-xl shadow-green-500/30
                          backdrop-blur-sm
                      `,
                children: /* @__PURE__ */ (0, import_jsx_runtime8.jsx)("span", { className: "relative z-10 flex items-center gap-2", children: /* @__PURE__ */ (0, import_jsx_runtime8.jsx)("span", { children: t("saveAndContinue") || "Save & Continue" }) })
              }
            ),
            /* @__PURE__ */ (0, import_jsx_runtime8.jsxs)(
              "button",
              {
                onClick: stopAll,
                className: `
                          px-5 py-2.5 rounded-full font-medium text-sm text-white
                          flex items-center justify-center gap-2
                          relative overflow-hidden group 
                          transition-all transform hover:scale-105 active:scale-95
                          bg-gradient-to-br ${activeTheme.button.from} ${activeTheme.button.via} ${activeTheme.button.to}
                          shadow-xl ${activeTheme.button.shadow} 
                          backdrop-blur-sm
                      `,
                style: {
                  boxShadow: `0 6px 24px rgba(${activeTheme.button.shadowRgb}, 0.4), inset 0 1px 0 rgba(255, 255, 255, 0.2)`
                },
                children: [
                  /* @__PURE__ */ (0, import_jsx_runtime8.jsx)("div", { className: "absolute inset-0 bg-gradient-to-br from-white/30 via-transparent to-transparent opacity-50" }),
                  /* @__PURE__ */ (0, import_jsx_runtime8.jsx)("div", { className: "absolute inset-0 bg-gradient-to-r from-transparent via-white/20 to-transparent translate-x-[-100%] group-hover:translate-x-[100%] transition-transform duration-700" }),
                  /* @__PURE__ */ (0, import_jsx_runtime8.jsx)("span", { className: "relative z-10 flex items-center gap-2", children: /* @__PURE__ */ (0, import_jsx_runtime8.jsx)("span", { children: t("startNew") }) })
                ]
              }
            )
          ] })
        ] }) : null;
      }
      return null;
    };
    const BackIcon = () => /* @__PURE__ */ (0, import_jsx_runtime8.jsx)("svg", { viewBox: "0 0 24 24", fill: "currentColor", className: "w-6 h-6", children: /* @__PURE__ */ (0, import_jsx_runtime8.jsx)("path", { d: "M20 11H7.83l5.59-5.59L12 4l-8 8 8 8 1.41-1.41L7.83 13H20v-2z" }) });
    return /* @__PURE__ */ (0, import_jsx_runtime8.jsxs)("div", { className: "fixed inset-0 z-40 bg-gray-100 dark:bg-gray-900 text-gray-800 dark:text-white font-sans flex flex-col items-center justify-center p-4 overflow-hidden transition-colors duration-300", children: [
      /* @__PURE__ */ (0, import_jsx_runtime8.jsx)(
        "div",
        {
          className: "absolute top-0 left-0 w-full h-full overflow-hidden",
          style: { transform: "translateZ(0)" },
          children: activeTheme.visualizer.map((color, index) => {
            const baseSize = 200;
            const scale = 1 + rmsVolume * 8;
            const positionType = index % 3;
            let dynamicStyle = {
              width: `${baseSize}px`,
              height: `${baseSize}px`,
              opacity: Math.min(0.7, 0.35 + rmsVolume * 25),
              background: color.gradient,
              willChange: "transform, opacity",
              filter: "blur(50px)"
            };
            switch (positionType) {
              case 0:
                dynamicStyle = {
                  ...dynamicStyle,
                  bottom: "-100px",
                  left: `calc(50% + ${Math.sin(performance.now() / (4e3 + index * 500)) * 35}vw)`,
                  transform: `translate(-50%, 50%) scale(${scale})`
                };
                break;
              case 1:
                dynamicStyle = {
                  ...dynamicStyle,
                  left: "-100px",
                  top: `calc(50% + ${Math.cos(performance.now() / (4500 + index * 500)) * 35}vh)`,
                  transform: `translate(-50%, -50%) scale(${scale})`
                };
                break;
              case 2:
              default:
                dynamicStyle = {
                  ...dynamicStyle,
                  right: "-100px",
                  top: `calc(50% + ${Math.sin(performance.now() / (5e3 + index * 500)) * 35}vh)`,
                  transform: `translate(50%, -50%) scale(${scale})`
                };
                break;
            }
            return /* @__PURE__ */ (0, import_jsx_runtime8.jsx)(
              "div",
              {
                className: "absolute rounded-full mix-blend-hard-light",
                style: dynamicStyle
              },
              color.name
            );
          })
        }
      ),
      /* @__PURE__ */ (0, import_jsx_runtime8.jsx)("div", { className: `relative z-10 w-full max-w-2xl mx-auto flex flex-col items-center justify-center text-center transition-all duration-300 ease-in-out ${isAnimatingOut ? "opacity-0 scale-95" : "opacity-100 scale-100"}`, children: mainContent() }),
      /* @__PURE__ */ (0, import_jsx_runtime8.jsxs)("div", { className: "absolute bottom-8 left-0 right-0 flex items-center justify-center space-x-4 z-20", children: [
        /* @__PURE__ */ (0, import_jsx_runtime8.jsx)(LanguageToggle, { language, toggleLanguage }),
        /* @__PURE__ */ (0, import_jsx_runtime8.jsx)(ThemeToggle, { theme, toggleTheme, "aria-label": t(theme === "dark" ? "switchToLight" : "switchToDark") })
      ] })
    ] });
  });
  var VocalRangeTestScreen_default = VocalRangeTestScreen;

  // components/SettingsOverlay.tsx
  var import_react9 = __toESM(require_react());
  var import_jsx_runtime9 = __toESM(require_jsx_runtime());
  var SettingsOverlay = ({
    setIsSettingsOpen,
    setActiveView,
    language,
    setLanguage,
    activeTheme,
    setThemeId,
    themeMode,
    setThemeMode,
    onLoadSamples,
    availableInstruments,
    activeInstrument,
    setActiveInstrument,
    compressorEnabled,
    setCompressorEnabled,
    frequencySeparationEnabled,
    setFrequencySeparationEnabled,
    pyinBias,
    setPyinBias,
    pyinGateMode,
    setPyinGateMode,
    noiseGateThreshold,
    setNoiseGateThreshold
  }) => {
    const { t } = useTranslation();
    const [show, setShow] = (0, import_react9.useState)(false);
    const [isLoadingSamples, setIsLoadingSamples] = (0, import_react9.useState)(false);
    const [sampleStatus, setSampleStatus] = (0, import_react9.useState)(null);
    const fileInputRef = (0, import_react9.useRef)(null);
    (0, import_react9.useEffect)(() => {
      const timer = requestAnimationFrame(() => setShow(true));
      return () => cancelAnimationFrame(timer);
    }, []);
    const handleClose = () => {
      setShow(false);
      setTimeout(() => setIsSettingsOpen(false), 300);
    };
    const handleFileChange = async (e) => {
      if (e.target.files && e.target.files.length > 0 && onLoadSamples) {
        setIsLoadingSamples(true);
        setSampleStatus(null);
        await new Promise((resolve) => setTimeout(resolve, 50));
        const result = await onLoadSamples(e.target.files);
        setIsLoadingSamples(false);
        if (result) {
          let msg = t("samplesLoaded", { count: result.loaded });
          if (result.errors > 0)
            msg += ` (${result.errors} failed)`;
          if (result.loaded === 0 && result.errors === 0)
            msg = "No recognized samples found.";
          if (result.loaded > 0 && result.loaded < 4) {
            msg += " (Smart Pitch Shifting Active)";
          }
          setSampleStatus(msg);
        }
        e.target.value = "";
      }
    };
    const SunIcon = () => /* @__PURE__ */ (0, import_jsx_runtime9.jsx)("svg", { className: "w-4 h-4", fill: "none", viewBox: "0 0 24 24", stroke: "currentColor", children: /* @__PURE__ */ (0, import_jsx_runtime9.jsx)("path", { strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 2, d: "M12 3v1m0 16v1m9-9h-1M4 12H3m15.364 6.364l-.707-.707M6.343 6.343l-.707-.707m12.728 0l-.707.707M6.343 17.657l-.707.707M16 12a4 4 0 11-8 0 4 4 0 018 0z" }) });
    const MoonIcon = () => /* @__PURE__ */ (0, import_jsx_runtime9.jsx)("svg", { className: "w-4 h-4", fill: "none", viewBox: "0 0 24 24", stroke: "currentColor", children: /* @__PURE__ */ (0, import_jsx_runtime9.jsx)("path", { strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 2, d: "M20.354 15.354A9 9 0 018.646 3.646 9.003 9.003 0 0012 21a9.003 9.003 0 008.354-5.646z" }) });
    return /* @__PURE__ */ (0, import_jsx_runtime9.jsx)("div", { className: `fixed inset-0 bg-black/10 backdrop-blur-md z-[120] flex items-center justify-center p-4 transition-opacity duration-300 ease-out ${show ? "opacity-100" : "opacity-0"}`, onClick: handleClose, children: /* @__PURE__ */ (0, import_jsx_runtime9.jsxs)(
      "div",
      {
        className: `relative w-full max-w-xs max-h-[85vh] overflow-y-auto scrollbar-hide bg-white/95 dark:bg-slate-900/90 backdrop-blur-3xl rounded-3xl shadow-lg border border-white/50 dark:border-slate-700 p-4 text-slate-800 dark:text-slate-200 shadow-[inset_0_1px_1px_rgba(255,255,255,0.5)] dark:shadow-[inset_0_1px_1px_rgba(255,255,255,0.1)] transition-all duration-300 ease-out ${show ? "opacity-100 scale-100" : "opacity-0 scale-95"}`,
        onClick: (e) => e.stopPropagation(),
        children: [
          /* @__PURE__ */ (0, import_jsx_runtime9.jsxs)("div", { className: "flex justify-between items-center mb-3 sticky top-0 bg-white/95 dark:bg-slate-900/90 backdrop-blur-xl z-10 -mx-4 px-4 py-2", children: [
            /* @__PURE__ */ (0, import_jsx_runtime9.jsx)("h2", { className: "text-2xl font-black bg-gradient-to-r from-gray-600 to-gray-900 dark:from-gray-400 dark:to-gray-100 bg-clip-text text-transparent", children: t("settings") }),
            /* @__PURE__ */ (0, import_jsx_runtime9.jsx)(
              "button",
              {
                onClick: handleClose,
                className: "btn-interactive p-1 rounded-full text-slate-500 hover:bg-slate-400/20",
                children: /* @__PURE__ */ (0, import_jsx_runtime9.jsx)("svg", { className: "w-5 h-5", fill: "none", viewBox: "0 0 24 24", stroke: "currentColor", children: /* @__PURE__ */ (0, import_jsx_runtime9.jsx)("path", { strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 2, d: "M6 18L18 6M6 6l12 12" }) })
              }
            )
          ] }),
          /* @__PURE__ */ (0, import_jsx_runtime9.jsxs)("div", { className: "space-y-3", children: [
            /* @__PURE__ */ (0, import_jsx_runtime9.jsxs)("div", { className: "grid grid-cols-2 gap-2", children: [
              /* @__PURE__ */ (0, import_jsx_runtime9.jsxs)("div", { children: [
                /* @__PURE__ */ (0, import_jsx_runtime9.jsx)("h3", { className: "text-xs font-semibold text-slate-800 dark:text-slate-200 mb-1.5", children: t("language") }),
                /* @__PURE__ */ (0, import_jsx_runtime9.jsx)("div", { className: "flex space-x-2", children: LANGUAGES.map((lang) => /* @__PURE__ */ (0, import_jsx_runtime9.jsx)(
                  "button",
                  {
                    onClick: () => setLanguage(lang),
                    className: `btn-interactive flex items-center space-x-2 px-2.5 py-1 rounded-full border text-xs ${language.code === lang.code ? "border-violet-500/50 bg-violet-500/10 text-violet-800 dark:text-violet-300 dark:bg-violet-500/20 font-semibold" : "border-slate-300/70 dark:border-slate-600 hover:border-violet-400/70 hover:bg-slate-400/10 dark:hover:bg-slate-700/50 text-slate-700 dark:text-slate-300"}`,
                    children: /* @__PURE__ */ (0, import_jsx_runtime9.jsx)("span", { children: lang.flag })
                  },
                  lang.code
                )) })
              ] }),
              /* @__PURE__ */ (0, import_jsx_runtime9.jsxs)("div", { children: [
                /* @__PURE__ */ (0, import_jsx_runtime9.jsx)("h3", { className: "text-xs font-semibold text-slate-800 dark:text-slate-200 mb-1.5", children: "Mode" }),
                /* @__PURE__ */ (0, import_jsx_runtime9.jsxs)("div", { className: "p-1 rounded-full bg-slate-200 dark:bg-slate-800 flex", children: [
                  /* @__PURE__ */ (0, import_jsx_runtime9.jsx)("button", { onClick: () => setThemeMode("light"), className: `flex-1 flex justify-center items-center py-0.5 rounded-full text-xs font-semibold transition-colors ${themeMode === "light" ? "bg-white shadow-sm text-violet-700" : "text-slate-500"}`, children: /* @__PURE__ */ (0, import_jsx_runtime9.jsx)(SunIcon, {}) }),
                  /* @__PURE__ */ (0, import_jsx_runtime9.jsx)("button", { onClick: () => setThemeMode("dark"), className: `flex-1 flex justify-center items-center py-0.5 rounded-full text-xs font-semibold transition-colors ${themeMode === "dark" ? "bg-slate-700 shadow-sm text-violet-400" : "text-slate-500"}`, children: /* @__PURE__ */ (0, import_jsx_runtime9.jsx)(MoonIcon, {}) })
                ] })
              ] })
            ] }),
            /* @__PURE__ */ (0, import_jsx_runtime9.jsxs)("div", { children: [
              /* @__PURE__ */ (0, import_jsx_runtime9.jsx)("h3", { className: "text-xs font-semibold text-slate-800 dark:text-slate-200 mb-1.5", children: t("colorPalette") }),
              /* @__PURE__ */ (0, import_jsx_runtime9.jsx)("div", { className: "grid grid-cols-2 gap-2", children: THEMES.map((palette) => /* @__PURE__ */ (0, import_jsx_runtime9.jsxs)(
                "button",
                {
                  onClick: () => setThemeId(palette.id),
                  className: `btn-interactive flex items-center space-x-2 p-1.5 rounded-lg border ${activeTheme.id === palette.id ? "border-violet-500/50 bg-violet-500/10 text-violet-800 dark:text-violet-300 dark:bg-violet-500/20 font-semibold" : "border-slate-300/70 dark:border-slate-600 hover:border-violet-400/70 hover:bg-slate-400/10 dark:hover:bg-slate-700/50 text-slate-700 dark:text-slate-300"}`,
                  children: [
                    /* @__PURE__ */ (0, import_jsx_runtime9.jsx)("div", { className: `w-5 h-5 rounded-full bg-gradient-to-br ${palette.button.from} ${palette.button.to}` }),
                    /* @__PURE__ */ (0, import_jsx_runtime9.jsx)("span", { className: "text-xs font-medium", children: palette.name })
                  ]
                },
                palette.id
              )) })
            ] }),
            /* @__PURE__ */ (0, import_jsx_runtime9.jsx)("div", { className: "border-t border-slate-300/50 dark:border-slate-700 my-1.5" }),
            /* @__PURE__ */ (0, import_jsx_runtime9.jsxs)("div", { children: [
              /* @__PURE__ */ (0, import_jsx_runtime9.jsx)("h3", { className: "text-xs font-semibold text-slate-800 dark:text-slate-200 mb-1.5", children: "Custom Audio" }),
              availableInstruments && availableInstruments.length > 0 && setActiveInstrument && /* @__PURE__ */ (0, import_jsx_runtime9.jsxs)("div", { className: "mb-2", children: [
                /* @__PURE__ */ (0, import_jsx_runtime9.jsx)("label", { className: "block text-[10px] text-slate-500 dark:text-slate-400 mb-1", children: t("activeInstrument") }),
                /* @__PURE__ */ (0, import_jsx_runtime9.jsx)(
                  "select",
                  {
                    value: activeInstrument,
                    onChange: (e) => setActiveInstrument(e.target.value),
                    className: "w-full p-1.5 rounded-lg text-xs border border-slate-300/70 dark:border-slate-600 bg-white/50 dark:bg-slate-800/50 text-slate-700 dark:text-slate-300 focus:ring-1 focus:ring-violet-500",
                    children: availableInstruments.map((inst) => /* @__PURE__ */ (0, import_jsx_runtime9.jsx)("option", { value: inst, children: inst }, inst))
                  }
                )
              ] }),
              /* @__PURE__ */ (0, import_jsx_runtime9.jsx)(
                "input",
                {
                  type: "file",
                  ref: fileInputRef,
                  className: "hidden",
                  multiple: true,
                  onChange: handleFileChange,
                  accept: "audio/*,.flac,.mp3,.wav"
                }
              ),
              /* @__PURE__ */ (0, import_jsx_runtime9.jsx)(
                "button",
                {
                  onClick: () => !isLoadingSamples && fileInputRef.current?.click(),
                  disabled: isLoadingSamples,
                  className: `btn-interactive w-full text-left flex items-center space-x-2 p-1.5 rounded-lg border border-slate-300/70 dark:border-slate-600 hover:border-violet-400/70 hover:bg-slate-400/10 dark:hover:bg-slate-700/50 text-slate-700 dark:text-slate-300 ${isLoadingSamples ? "opacity-75 cursor-wait" : ""}`,
                  children: isLoadingSamples ? /* @__PURE__ */ (0, import_jsx_runtime9.jsxs)("div", { className: "flex items-center space-x-2 w-full justify-center py-1", children: [
                    /* @__PURE__ */ (0, import_jsx_runtime9.jsx)("div", { className: "animate-spin h-4 w-4 border-2 border-violet-500 rounded-full border-t-transparent" }),
                    /* @__PURE__ */ (0, import_jsx_runtime9.jsx)("span", { className: "text-xs font-medium", children: t("processing") })
                  ] }) : /* @__PURE__ */ (0, import_jsx_runtime9.jsxs)(import_jsx_runtime9.Fragment, { children: [
                    /* @__PURE__ */ (0, import_jsx_runtime9.jsx)("svg", { xmlns: "http://www.w3.org/2000/svg", className: "h-5 w-5 text-violet-600 dark:text-violet-400", fill: "none", viewBox: "0 0 24 24", stroke: "currentColor", strokeWidth: "1.5", children: /* @__PURE__ */ (0, import_jsx_runtime9.jsx)("path", { strokeLinecap: "round", strokeLinejoin: "round", d: "M9 19V6l12-3v13M9 19l-6 3V9l6-3m0 13V6m12 6l-12-4" }) }),
                    /* @__PURE__ */ (0, import_jsx_runtime9.jsxs)("div", { className: "flex flex-col", children: [
                      /* @__PURE__ */ (0, import_jsx_runtime9.jsx)("span", { className: "text-xs font-medium", children: "Load Local Samples" }),
                      /* @__PURE__ */ (0, import_jsx_runtime9.jsx)("span", { className: "text-[10px] text-slate-500", children: "Select audio files (mp3/wav/flac)" })
                    ] })
                  ] })
                }
              ),
              sampleStatus && /* @__PURE__ */ (0, import_jsx_runtime9.jsxs)("div", { className: "mt-2 p-2 bg-green-100 dark:bg-green-900/30 text-green-800 dark:text-green-200 text-xs rounded-lg border border-green-200 dark:border-green-800 flex items-center animate-fade-in", children: [
                /* @__PURE__ */ (0, import_jsx_runtime9.jsx)("svg", { className: "w-4 h-4 mr-1.5 flex-shrink-0", fill: "none", viewBox: "0 0 24 24", stroke: "currentColor", children: /* @__PURE__ */ (0, import_jsx_runtime9.jsx)("path", { strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 2, d: "M5 13l4 4L19 7" }) }),
                /* @__PURE__ */ (0, import_jsx_runtime9.jsx)("span", { children: sampleStatus })
              ] })
            ] }),
            /* @__PURE__ */ (0, import_jsx_runtime9.jsxs)("div", { className: "flex space-x-2", children: [
              /* @__PURE__ */ (0, import_jsx_runtime9.jsx)("button", { className: "btn-interactive flex-1 text-center py-1.5 rounded-lg bg-slate-400/10 dark:bg-slate-700/50 hover:bg-slate-400/20 dark:hover:bg-slate-700 text-slate-800 dark:text-slate-200 font-medium text-xs", children: t("faq") }),
              /* @__PURE__ */ (0, import_jsx_runtime9.jsx)("button", { className: "btn-interactive flex-1 text-center py-1.5 rounded-lg bg-slate-400/10 dark:bg-slate-700/50 hover:bg-slate-400/20 dark:hover:bg-slate-700 text-slate-800 dark:text-slate-200 font-medium text-xs", children: t("support") })
            ] }),
            /* @__PURE__ */ (0, import_jsx_runtime9.jsx)("div", { className: "mt-2 text-center", children: /* @__PURE__ */ (0, import_jsx_runtime9.jsx)("span", { className: "text-[10px] text-slate-400 dark:text-slate-500 font-mono", children: "v0.9.0 Beta" }) })
          ] })
        ]
      }
    ) });
  };
  var SettingsOverlay_default = SettingsOverlay;

  // components/RoutineView.tsx
  var import_react11 = __toESM(require_react());

  // components/ThemedButton.tsx
  var import_react10 = __toESM(require_react());
  var import_jsx_runtime10 = __toESM(require_jsx_runtime());
  var ThemedButton = import_react10.default.memo(({ onClick, disabled, children, theme, className }) => {
    return /* @__PURE__ */ (0, import_jsx_runtime10.jsxs)(
      "button",
      {
        onClick,
        disabled,
        className: `
        px-6 py-2.5 rounded-full font-semibold text-sm text-white
        flex items-center justify-center gap-2
        relative overflow-hidden group 
        transition-all transform hover:scale-105 active:scale-95
        bg-gradient-to-br ${theme.button.from} ${theme.button.via} ${theme.button.to}
        shadow-2xl ${theme.button.shadow} 
        backdrop-blur-sm
        disabled:opacity-50 disabled:cursor-not-allowed
        ${className || ""}
      `,
        style: {
          boxShadow: `0 8px 32px rgba(${theme.button.shadowRgb}, 0.4), inset 0 1px 0 rgba(255, 255, 255, 0.2)`
        },
        children: [
          /* @__PURE__ */ (0, import_jsx_runtime10.jsx)("div", { className: "absolute inset-0 bg-gradient-to-br from-white/30 via-transparent to-transparent opacity-50" }),
          /* @__PURE__ */ (0, import_jsx_runtime10.jsx)("div", { className: "absolute inset-0 bg-gradient-to-r from-transparent via-white/20 to-transparent translate-x-[-100%] group-hover:translate-x-[100%] transition-transform duration-700" }),
          /* @__PURE__ */ (0, import_jsx_runtime10.jsx)("span", { className: "relative z-10 flex items-center gap-2", children })
        ]
      }
    );
  });
  ThemedButton.displayName = "ThemedButton";
  var ThemedButton_default = ThemedButton;

  // components/RoutineView.tsx
  var import_jsx_runtime11 = __toESM(require_jsx_runtime());
  var StarIcon = ({ isFavorite }) => /* @__PURE__ */ (0, import_jsx_runtime11.jsx)("svg", { className: `w-6 h-6 transition-all duration-200 ${isFavorite ? "text-amber-400 scale-110" : "text-slate-400 group-hover:text-amber-300"}`, fill: "currentColor", viewBox: "0 0 20 20", children: /* @__PURE__ */ (0, import_jsx_runtime11.jsx)("path", { d: "M9.049 2.927c.3-.921 1.603-.921 1.902 0l1.07 3.292a1 1 0 00.95.69h3.462c.969 0 1.371 1.24.588 1.81l-2.8 2.034a1 1 0 00-.364 1.118l1.07 3.292c.3.921-.755 1.688-1.54 1.118l-2.8-2.034a1 1 0 00-1.175 0l-2.8 2.034c-.784.57-1.838-.197-1.539-1.118l1.07-3.292a1 1 0 00-.364-1.118L2.98 8.72c-.783-.57-.38-1.81.588-1.81h3.461a1 1 0 00.951-.69l1.07-3.292z" }) });
  var RoutineCard = ({ routine, onStart, currentTheme, isFavorite, onToggleFavorite }) => {
    const { t } = useTranslation();
    const [isFlipped, setIsFlipped] = (0, import_react11.useState)(false);
    const exercisesById = (0, import_react11.useMemo)(() => new Map(EXERCISES.map((ex) => [getExerciseId(ex), ex])), []);
    const totalDurationMs = (0, import_react11.useMemo)(() => {
      return routine.exerciseIds.reduce((sum, id) => {
        const exercise = exercisesById.get(id);
        if (!exercise)
          return sum;
        let exerciseTime = 0;
        const MAX_TRANSPOSE = 24;
        const mockRange = { start: { semitone: -12 }, end: { semitone: 12 } };
        for (let t2 = 0; t2 <= MAX_TRANSPOSE; t2++) {
          const pattern = getExercisePattern(exercise);
          const durations = getExerciseDurations(exercise);
          const maxOffset = Math.max(...pattern, 0);
          if (mockRange.start.semitone + maxOffset + t2 > mockRange.end.semitone)
            break;
          const totalDuration = durations.reduce((sum2, d) => sum2 + d, 0);
          exerciseTime += totalDuration * 1e3 + 500;
        }
        return sum + exerciseTime;
      }, 0);
    }, [routine.exerciseIds, exercisesById]);
    const totalDurationMinutes = Math.round(totalDurationMs / (1e3 * 60));
    const TimeIcon = () => /* @__PURE__ */ (0, import_jsx_runtime11.jsx)("svg", { className: "w-5 h-5 mr-1 text-sky-500", fill: "none", viewBox: "0 0 24 24", stroke: "currentColor", children: /* @__PURE__ */ (0, import_jsx_runtime11.jsx)("path", { strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 2, d: "M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z" }) });
    const cardRef = (0, import_react11.useRef)(null);
    const handleCardClick = () => {
      if (!cardRef.current)
        return;
      const container = cardRef.current.closest(".overflow-x-auto");
      if (!container) {
        setIsFlipped(!isFlipped);
        return;
      }
      const containerRect = container.getBoundingClientRect();
      const cardRect = cardRef.current.getBoundingClientRect();
      const containerCenter = containerRect.left + containerRect.width / 2;
      const cardCenter = cardRect.left + cardRect.width / 2;
      const distanceFromCenter = Math.abs(containerCenter - cardCenter);
      if (distanceFromCenter > 50) {
        cardRef.current.scrollIntoView({ behavior: "smooth", inline: "center", block: "nearest" });
      } else {
        setIsFlipped(!isFlipped);
      }
    };
    return /* @__PURE__ */ (0, import_jsx_runtime11.jsx)("div", { ref: cardRef, className: "w-full h-full cursor-pointer", style: { perspective: "1000px" }, onClick: handleCardClick, children: /* @__PURE__ */ (0, import_jsx_runtime11.jsxs)(
      "div",
      {
        className: `relative w-full h-full transition-transform duration-700 ease-in-out`,
        style: { transformStyle: "preserve-3d", transform: isFlipped ? "rotateY(180deg)" : "rotateY(0deg)" },
        children: [
          /* @__PURE__ */ (0, import_jsx_runtime11.jsxs)("div", { className: "select-none absolute w-full h-full p-6 flex flex-col justify-between bg-white/60 dark:bg-slate-800/30 backdrop-blur-2xl rounded-3xl shadow-lg border border-white/50 dark:border-slate-700/50 overflow-hidden", style: { backfaceVisibility: "hidden", WebkitBackfaceVisibility: "hidden" }, children: [
            /* @__PURE__ */ (0, import_jsx_runtime11.jsx)(
              "button",
              {
                onClick: (e) => {
                  e.stopPropagation();
                  onToggleFavorite(routine.id);
                },
                className: "btn-interactive group absolute top-4 right-4 z-20 p-2 rounded-full bg-white/30 dark:bg-slate-700/30 backdrop-blur-sm",
                "aria-label": t("favorites"),
                children: /* @__PURE__ */ (0, import_jsx_runtime11.jsx)(StarIcon, { isFavorite })
              }
            ),
            /* @__PURE__ */ (0, import_jsx_runtime11.jsxs)("div", { children: [
              /* @__PURE__ */ (0, import_jsx_runtime11.jsxs)("div", { className: "flex items-center text-sm text-slate-600 dark:text-slate-300 bg-slate-100/70 dark:bg-slate-900/50 rounded-full px-3 py-1 mb-3 w-fit", children: [
                /* @__PURE__ */ (0, import_jsx_runtime11.jsx)(TimeIcon, {}),
                /* @__PURE__ */ (0, import_jsx_runtime11.jsxs)("span", { className: "font-semibold", children: [
                  "~",
                  totalDurationMinutes,
                  " min"
                ] })
              ] }),
              /* @__PURE__ */ (0, import_jsx_runtime11.jsx)("h3", { className: `text-2xl font-extrabold bg-clip-text text-transparent bg-gradient-to-br ${currentTheme.gradientText.from} ${currentTheme.gradientText.to} ${currentTheme.gradientText.darkFrom} ${currentTheme.gradientText.darkTo} mb-2`, children: t(routine.name) }),
              /* @__PURE__ */ (0, import_jsx_runtime11.jsx)("p", { className: "text-slate-600 dark:text-slate-400 text-sm", children: t(routine.description) })
            ] }),
            /* @__PURE__ */ (0, import_jsx_runtime11.jsx)(
              "button",
              {
                onClick: () => setIsFlipped(true),
                className: "btn-interactive w-full py-2 text-center text-xs font-semibold text-slate-600 dark:text-slate-400 hover:text-slate-800 dark:hover:text-slate-200 transition-colors",
                children: t("clickForDetails")
              }
            )
          ] }),
          /* @__PURE__ */ (0, import_jsx_runtime11.jsxs)("div", { className: "select-none absolute w-full h-full p-6 flex flex-col justify-between bg-white/80 dark:bg-slate-800/60 backdrop-blur-3xl rounded-3xl shadow-lg border border-white/50 dark:border-slate-700/50 overflow-hidden", style: { backfaceVisibility: "hidden", WebkitBackfaceVisibility: "hidden", transform: "rotateY(180deg)" }, children: [
            /* @__PURE__ */ (0, import_jsx_runtime11.jsxs)("div", { className: "flex-grow flex flex-col min-h-0", children: [
              /* @__PURE__ */ (0, import_jsx_runtime11.jsx)("h4", { className: `text-lg font-bold bg-clip-text text-transparent bg-gradient-to-br ${currentTheme.gradientText.from} ${currentTheme.gradientText.to} ${currentTheme.gradientText.darkFrom} ${currentTheme.gradientText.darkTo} mb-2`, children: t("benefits") }),
              /* @__PURE__ */ (0, import_jsx_runtime11.jsx)("p", { className: "text-slate-600 dark:text-slate-400 text-sm mb-4", children: t(routine.benefits) }),
              /* @__PURE__ */ (0, import_jsx_runtime11.jsx)("h4", { className: `text-lg font-bold bg-clip-text text-transparent bg-gradient-to-br ${currentTheme.gradientText.from} ${currentTheme.gradientText.to} ${currentTheme.gradientText.darkFrom} ${currentTheme.gradientText.darkTo} mb-2`, children: t("exercises") }),
              /* @__PURE__ */ (0, import_jsx_runtime11.jsx)("div", { className: "flex-grow overflow-y-auto scrollbar-hide", children: /* @__PURE__ */ (0, import_jsx_runtime11.jsx)("div", { className: "flex flex-wrap gap-2", children: routine.exerciseIds.map((id) => {
                const ex = exercisesById.get(id);
                return ex ? /* @__PURE__ */ (0, import_jsx_runtime11.jsx)("span", { className: "text-slate-700 dark:text-slate-300 text-xs font-medium bg-slate-100/80 dark:bg-slate-900/50 rounded-full px-3 py-1 border border-slate-200/80 dark:border-slate-700/80", children: t(ex.name) }, id) : null;
              }) }) })
            ] }),
            /* @__PURE__ */ (0, import_jsx_runtime11.jsx)(ThemedButton_default, { onClick: (e) => {
              e.stopPropagation();
              onStart(routine);
            }, theme: currentTheme, className: "w-full mt-4", children: t("startRoutine") })
          ] })
        ]
      }
    ) });
  };
  var RoutineView = ({ onStartRoutine, currentTheme, favoriteRoutineIds, onToggleFavorite }) => {
    const { t } = useTranslation();
    const scrollContainerRef = (0, import_react11.useRef)(null);
    const handleArrowScroll = (direction) => {
      const container = scrollContainerRef.current;
      if (!container)
        return;
      const firstCard = container.querySelector(".snap-center.px-3");
      if (!firstCard)
        return;
      const scrollAmount = firstCard.offsetWidth;
      container.scrollBy({
        left: direction === "left" ? -scrollAmount : scrollAmount,
        behavior: "smooth"
      });
    };
    const handleScroll = () => {
      const container = scrollContainerRef.current;
      if (!container)
        return;
      const scrollCenter = container.scrollLeft + container.offsetWidth / 2;
      const cards = Array.from(container.children);
      cards.forEach((cardWrapper) => {
        const transformWrapper = cardWrapper.firstElementChild;
        if (!transformWrapper || !transformWrapper.firstElementChild)
          return;
        const cardCenter = cardWrapper.offsetLeft + cardWrapper.offsetWidth / 2;
        const distance = scrollCenter - cardCenter;
        const maxDistance = container.offsetWidth * 0.8;
        const distanceRatio = Math.max(-1, Math.min(1, distance / maxDistance));
        const rotateY = -distanceRatio * 65;
        const translateX = -distanceRatio * 40;
        const translateZ = -Math.abs(distanceRatio) * 120;
        const scale = 1 - Math.abs(distanceRatio) * 0.15;
        const opacity = 1 - Math.pow(Math.abs(distanceRatio), 1.5);
        const zIndex = 100 - Math.abs(Math.round(distanceRatio * 100));
        const blur = Math.abs(distanceRatio) * 3;
        transformWrapper.style.transform = `translateX(${translateX}px) translateZ(${translateZ}px) rotateY(${rotateY}deg) scale(${scale})`;
        transformWrapper.style.opacity = `${opacity}`;
        transformWrapper.style.zIndex = `${zIndex}`;
        transformWrapper.style.filter = `blur(${blur}px)`;
      });
    };
    (0, import_react11.useEffect)(() => {
      const container = scrollContainerRef.current;
      if (container) {
        container.addEventListener("scroll", handleScroll, { passive: true });
        const initTimeout = setTimeout(() => {
          handleScroll();
          const firstCard = container.querySelector(".snap-center.px-3");
          if (firstCard) {
            const scrollPos = firstCard.offsetLeft + firstCard.offsetWidth / 2 - container.offsetWidth / 2;
            container.scrollTo({ left: scrollPos, behavior: "auto" });
          }
        }, 100);
        const resizeObserver = new ResizeObserver(handleScroll);
        resizeObserver.observe(container);
        return () => {
          clearTimeout(initTimeout);
          container.removeEventListener("scroll", handleScroll);
          resizeObserver.disconnect();
        };
      }
    }, []);
    return /* @__PURE__ */ (0, import_jsx_runtime11.jsxs)("section", { className: "flex-grow flex flex-col items-center justify-center w-full -mt-24 md:mt-0", children: [
      /* @__PURE__ */ (0, import_jsx_runtime11.jsxs)("div", { className: "relative w-full h-[450px] md:h-[400px]", style: { perspective: "2000px" }, children: [
        /* @__PURE__ */ (0, import_jsx_runtime11.jsx)(
          "button",
          {
            onClick: () => handleArrowScroll("left"),
            "aria-label": "Scroll left",
            className: "btn-interactive hidden md:flex absolute top-1/2 -translate-y-1/2 left-4 z-[101] w-12 h-12 items-center justify-center rounded-full bg-white/60 dark:bg-black/30 backdrop-blur-md border border-slate-200/50 dark:border-slate-700 shadow-lg hover:bg-white",
            children: /* @__PURE__ */ (0, import_jsx_runtime11.jsx)("svg", { className: "w-6 h-6 text-slate-700 dark:text-slate-300", fill: "none", viewBox: "0 0 24 24", stroke: "currentColor", children: /* @__PURE__ */ (0, import_jsx_runtime11.jsx)("path", { strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 2, d: "M15 19l-7-7 7-7" }) })
          }
        ),
        /* @__PURE__ */ (0, import_jsx_runtime11.jsxs)(
          "div",
          {
            ref: scrollContainerRef,
            className: "flex overflow-x-auto snap-x snap-mandatory scrollbar-hide items-center absolute inset-0 py-4",
            children: [
              /* @__PURE__ */ (0, import_jsx_runtime11.jsx)("div", { className: "flex-shrink-0 w-[calc(50%-144px)] sm:w-[calc(50%-160px)] snap-center" }),
              ROUTINES.map((routine) => /* @__PURE__ */ (0, import_jsx_runtime11.jsx)("div", { className: "flex-shrink-0 w-72 sm:w-80 snap-center px-3", style: { height: "380px" }, children: /* @__PURE__ */ (0, import_jsx_runtime11.jsx)("div", { className: "w-full h-full", style: { transformStyle: "preserve-3d" }, children: /* @__PURE__ */ (0, import_jsx_runtime11.jsx)(
                RoutineCard,
                {
                  routine,
                  onStart: onStartRoutine,
                  currentTheme,
                  isFavorite: favoriteRoutineIds.includes(routine.id),
                  onToggleFavorite
                }
              ) }) }, routine.id)),
              /* @__PURE__ */ (0, import_jsx_runtime11.jsx)("div", { className: "flex-shrink-0 w-[calc(50%-144px)] sm:w-[calc(50%-160px)] snap-center" })
            ]
          }
        ),
        /* @__PURE__ */ (0, import_jsx_runtime11.jsx)(
          "button",
          {
            onClick: () => handleArrowScroll("right"),
            "aria-label": "Scroll right",
            className: "btn-interactive hidden md:flex absolute top-1/2 -translate-y-1/2 right-4 z-[101] w-12 h-12 items-center justify-center rounded-full bg-white/60 dark:bg-black/30 backdrop-blur-md border border-slate-200/50 dark:border-slate-700 shadow-lg hover:bg-white",
            children: /* @__PURE__ */ (0, import_jsx_runtime11.jsx)("svg", { className: "w-6 h-6 text-slate-700 dark:text-slate-300", fill: "none", viewBox: "0 0 24 24", stroke: "currentColor", children: /* @__PURE__ */ (0, import_jsx_runtime11.jsx)("path", { strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 2, d: "M9 5l7 7-7 7" }) })
          }
        )
      ] }),
      /* @__PURE__ */ (0, import_jsx_runtime11.jsx)("div", { className: "flex md:hidden justify-center gap-2 mt-4", children: ROUTINES.map((_, index) => /* @__PURE__ */ (0, import_jsx_runtime11.jsx)(
        "div",
        {
          className: "w-2 h-2 rounded-full bg-slate-300 dark:bg-slate-600",
          style: {
            opacity: index === 0 ? 1 : 0.4,
            transition: "opacity 0.3s ease"
          }
        },
        index
      )) }),
      /* @__PURE__ */ (0, import_jsx_runtime11.jsx)("p", { className: "text-center text-xs text-slate-400 dark:text-slate-500 mt-2 md:hidden", children: t("swipeRoutines") })
    ] });
  };
  var RoutineView_default = import_react11.default.memo(RoutineView);

  // components/ComingSoonCard.tsx
  var import_jsx_runtime12 = __toESM(require_jsx_runtime());
  var ComingSoonCard = ({ title, description, children, theme }) => {
    const { t } = useTranslation();
    return /* @__PURE__ */ (0, import_jsx_runtime12.jsxs)("div", { className: "relative opacity-50 cursor-not-allowed", children: [
      /* @__PURE__ */ (0, import_jsx_runtime12.jsx)("div", { className: "absolute -top-2 -right-2 bg-amber-400 text-white text-xs font-bold px-2 py-0.5 rounded-full shadow-md z-10", children: t("comingSoon") }),
      /* @__PURE__ */ (0, import_jsx_runtime12.jsxs)("div", { className: "relative border border-slate-200 dark:border-slate-700 rounded-2xl p-5 bg-slate-50/50 dark:bg-slate-800/30 overflow-hidden", children: [
        /* @__PURE__ */ (0, import_jsx_runtime12.jsx)("h3", { className: `text-xl font-bold bg-clip-text text-transparent bg-gradient-to-br ${theme.gradientText.from} ${theme.gradientText.to} ${theme.gradientText.darkFrom} ${theme.gradientText.darkTo} mb-1`, children: title }),
        /* @__PURE__ */ (0, import_jsx_runtime12.jsx)("p", { className: "text-slate-500 dark:text-slate-400 text-sm mb-4", children: description }),
        /* @__PURE__ */ (0, import_jsx_runtime12.jsx)("div", { className: "pointer-events-none", children })
      ] })
    ] });
  };
  var ComingSoonCard_default = ComingSoonCard;

  // components/ComingSoonView.tsx
  var import_jsx_runtime13 = __toESM(require_jsx_runtime());
  var TokenIcon = () => /* @__PURE__ */ (0, import_jsx_runtime13.jsx)("svg", { xmlns: "http://www.w3.org/2000/svg", className: "h-8 w-8 text-slate-400", fill: "none", viewBox: "0 0 24 24", stroke: "currentColor", strokeWidth: 1.5, children: /* @__PURE__ */ (0, import_jsx_runtime13.jsx)("path", { strokeLinecap: "round", strokeLinejoin: "round", d: "M15.75 5.25a3 3 0 013 3m3 0a6 6 0 01-7.029 5.912c-.563-.097-1.159.026-1.563.43L10.5 17.25H8.25v2.25H6v2.25H2.25v-2.818c0-.597.237-1.17.659-1.591l6.499-6.499c.404-.404.527-1 .43-1.563A6 6 0 1121.75 8.25z" }) });
  var RecordVideoIcon = () => /* @__PURE__ */ (0, import_jsx_runtime13.jsx)("svg", { xmlns: "http://www.w3.org/2000/svg", className: "h-8 w-8 text-slate-400", fill: "none", viewBox: "0 0 24 24", stroke: "currentColor", strokeWidth: 1.5, children: /* @__PURE__ */ (0, import_jsx_runtime13.jsx)("path", { strokeLinecap: "round", strokeLinejoin: "round", d: "M15 10l4.553-2.276A1 1 0 0121 8.618v6.764a1 1 0 01-1.447.894L15 14M5 18h8a2 2 0 002-2V8a2 2 0 00-2-2H5a2 2 0 00-2 2v8a2 2 0 002 2z" }) });
  var TeacherIcon = () => /* @__PURE__ */ (0, import_jsx_runtime13.jsx)("svg", { xmlns: "http://www.w3.org/2000/svg", className: "h-8 w-8 text-slate-400", fill: "none", viewBox: "0 0 24 24", stroke: "currentColor", strokeWidth: 1.5, children: /* @__PURE__ */ (0, import_jsx_runtime13.jsx)("path", { strokeLinecap: "round", strokeLinejoin: "round", d: "M12 4.354a4 4 0 110 5.292M15 21H3v-1a6 6 0 0112 0v1zm0 0h6v-1a6 6 0 00-9-5.197M15 21v-1a6 6 0 00-5.176-5.97M15 21h6v-1a6 6 0 00-9-5.197" }) });
  var MusicTheoryIcon = () => /* @__PURE__ */ (0, import_jsx_runtime13.jsx)("svg", { xmlns: "http://www.w3.org/2000/svg", className: "h-8 w-8 text-slate-400", fill: "none", viewBox: "0 0 24 24", stroke: "currentColor", strokeWidth: 1.5, children: /* @__PURE__ */ (0, import_jsx_runtime13.jsx)("path", { strokeLinecap: "round", strokeLinejoin: "round", d: "M9 19V6l12-3v13M9 19l-6 3V9l6-3m0 13V6m12 6l-12-4" }) });
  var MasterclassIcon = () => /* @__PURE__ */ (0, import_jsx_runtime13.jsxs)("svg", { xmlns: "http://www.w3.org/2000/svg", className: "h-8 w-8 text-slate-400", fill: "none", viewBox: "0 0 24 24", stroke: "currentColor", strokeWidth: 1.5, children: [
    /* @__PURE__ */ (0, import_jsx_runtime13.jsx)("path", { strokeLinecap: "round", strokeLinejoin: "round", d: "M14.752 11.168l-3.197-2.132A1 1 0 0010 9.87v4.263a1 1 0 001.555.832l3.197-2.132a1 1 0 000-1.664z" }),
    /* @__PURE__ */ (0, import_jsx_runtime13.jsx)("path", { strokeLinecap: "round", strokeLinejoin: "round", d: "M21 12a9 9 0 11-18 0 9 9 0 0118 0z" })
  ] });
  var ComingSoonView = ({ title, description, currentTheme, isStudies }) => {
    const { t } = useTranslation();
    if (isStudies) {
      const futureFeatures = [
        { icon: /* @__PURE__ */ (0, import_jsx_runtime13.jsx)(TokenIcon, {}), titleKey: "importTokenTitle", descKey: "importTokenDesc" },
        { icon: /* @__PURE__ */ (0, import_jsx_runtime13.jsx)(RecordVideoIcon, {}), titleKey: "recordVideo", descKey: "recordVideoDesc" },
        { icon: /* @__PURE__ */ (0, import_jsx_runtime13.jsx)(TeacherIcon, {}), titleKey: "accessStudiesPrompt", descKey: "teacherStudiesDesc" },
        { icon: /* @__PURE__ */ (0, import_jsx_runtime13.jsx)(MusicTheoryIcon, {}), titleKey: "interactiveTheoryTitle", descKey: "interactiveTheoryDesc" },
        { icon: /* @__PURE__ */ (0, import_jsx_runtime13.jsx)(MasterclassIcon, {}), titleKey: "masterclassesTitle", descKey: "masterclassesDesc" }
      ];
      return /* @__PURE__ */ (0, import_jsx_runtime13.jsxs)("section", { className: "flex-grow flex flex-col justify-center animate-fade-in w-full -mt-36 md:mt-0", children: [
        /* @__PURE__ */ (0, import_jsx_runtime13.jsx)("div", { className: "text-center mb-6", children: /* @__PURE__ */ (0, import_jsx_runtime13.jsx)("p", { className: "text-slate-500 dark:text-slate-400", children: t("studiesDesc") }) }),
        /* @__PURE__ */ (0, import_jsx_runtime13.jsx)("div", { className: "grid grid-cols-1 md:grid-cols-2 gap-4", children: futureFeatures.map((feature) => /* @__PURE__ */ (0, import_jsx_runtime13.jsx)(
          ComingSoonCard_default,
          {
            title: t(feature.titleKey),
            description: t(feature.descKey),
            theme: currentTheme,
            children: /* @__PURE__ */ (0, import_jsx_runtime13.jsx)("div", { className: "flex items-center justify-center h-16", children: feature.icon })
          },
          feature.titleKey
        )) })
      ] });
    }
    return /* @__PURE__ */ (0, import_jsx_runtime13.jsx)("section", { className: "flex-grow flex flex-col justify-center items-center w-full animate-fade-in", children: /* @__PURE__ */ (0, import_jsx_runtime13.jsx)("div", { className: "w-full max-w-md", children: /* @__PURE__ */ (0, import_jsx_runtime13.jsx)(ComingSoonCard_default, { title, description, theme: currentTheme, children: /* @__PURE__ */ (0, import_jsx_runtime13.jsx)("div", { className: "h-24 w-full flex items-center justify-center rounded-lg border-2 border-dashed border-slate-300 dark:border-slate-600 bg-slate-100/50 dark:bg-slate-800/30", children: /* @__PURE__ */ (0, import_jsx_runtime13.jsxs)("p", { className: "text-slate-400 dark:text-slate-500 font-medium", children: [
      t("comingSoon"),
      "..."
    ] }) }) }) }) });
  };
  var ComingSoonView_default = ComingSoonView;

  // components/AIStudioView.tsx
  var import_react12 = __toESM(require_react());
  init_web();
  var import_jsx_runtime14 = __toESM(require_jsx_runtime());
  var LoadingSpinner = () => /* @__PURE__ */ (0, import_jsx_runtime14.jsx)("div", { className: "flex justify-center items-center", children: /* @__PURE__ */ (0, import_jsx_runtime14.jsx)("div", { className: "animate-spin rounded-full h-8 w-8 border-b-2 border-violet-600" }) });
  var StarIcon2 = ({ isFavorite }) => /* @__PURE__ */ (0, import_jsx_runtime14.jsx)("svg", { className: `w-6 h-6 transition-all duration-200 ${isFavorite ? "text-amber-400 scale-110" : "text-slate-400 group-hover:text-amber-300"}`, fill: "currentColor", viewBox: "0 0 20 20", children: /* @__PURE__ */ (0, import_jsx_runtime14.jsx)("path", { d: "M9.049 2.927c.3-.921 1.603-.921 1.902 0l1.07 3.292a1 1 0 00.95.69h3.462c.969 0 1.371 1.24.588 1.81l-2.8 2.034a1 1 0 00-.364 1.118l1.07 3.292c.3.921-.755 1.688-1.54 1.118l-2.8-2.034a1 1 0 00-1.175 0l-2.8 2.034c-.784.57-1.838-.197-1.539-1.118l1.07-3.292a1 1 0 00-.364-1.118L2.98 8.72c-.783-.57-.38-1.81.588-1.81h3.461a1 1 0 00.951-.69l1.07-3.292z" }) });
  var MagicIcon = () => /* @__PURE__ */ (0, import_jsx_runtime14.jsx)("svg", { xmlns: "http://www.w3.org/2000/svg", className: "h-5 w-5 text-violet-500 hover:text-violet-700 dark:text-violet-400 dark:hover:text-violet-200", fill: "none", viewBox: "0 0 24 24", stroke: "currentColor", strokeWidth: 2, children: /* @__PURE__ */ (0, import_jsx_runtime14.jsx)("path", { strokeLinecap: "round", strokeLinejoin: "round", d: "M5 3v4M3 5h4M6 17v4m-2-2h4m5-16l2.286 6.857L21 12l-5.714 2.143L13 21l-2.286-6.857L5 12l5.714-2.143L13 3z" }) });
  var beatsToMusicalNotation = (beats) => {
    if (beats >= 3.5)
      return { notation: "Whole Note", symbol: "\u{1D15D}" };
    if (beats >= 1.75)
      return { notation: "Half Note", symbol: "\u{1D157}\u{1D165}" };
    if (beats >= 0.875)
      return { notation: "Quarter Note", symbol: "\u2669" };
    if (beats >= 0.4375)
      return { notation: "Eighth Note", symbol: "\u266A" };
    if (beats >= 0.21875)
      return { notation: "Sixteenth Note", symbol: "\u{1D158}\u{1D165}\u{1D16F}" };
    return { notation: "Very Short", symbol: "\u{1D158}\u{1D165}\u{1D170}" };
  };
  var VoxLabAIView = ({ currentTheme, onStartExercise, onSave, onToggleFavorite, savedAIExercises, favoriteExerciseIds, playNote, aiResult, setAiResult }) => {
    const { t, language } = useTranslation();
    const [prompt, setPrompt] = (0, import_react12.useState)("");
    const [isLoading, setIsLoading] = (0, import_react12.useState)(false);
    const result = aiResult;
    const setResult = setAiResult;
    const [error, setError] = (0, import_react12.useState)("");
    const [isRefining, setIsRefining] = (0, import_react12.useState)(false);
    const [refinePrompt, setRefinePrompt] = (0, import_react12.useState)("");
    const [isRefineLoading, setIsRefineLoading] = (0, import_react12.useState)(false);
    const [isPreviewing, setIsPreviewing] = (0, import_react12.useState)(false);
    const [previewTimeoutId, setPreviewTimeoutId] = (0, import_react12.useState)(null);
    const previewClickedRef = (0, import_react12.useRef)(false);
    const [userApiKey, setUserApiKey] = (0, import_react12.useState)("");
    const [showApiKeyInput, setShowApiKeyInput] = (0, import_react12.useState)(false);
    import_react12.default.useEffect(() => {
      const envKey = "AIzaSyD0JEm3fqse7TQZ1ri2UWMmdtJigyX3fpo";
      const storedKey = localStorage.getItem("voxlab_api_key");
      if (envKey && envKey.length > 0 && envKey !== "undefined") {
        setShowApiKeyInput(false);
      } else if (storedKey) {
        setUserApiKey(storedKey);
        setShowApiKeyInput(false);
      } else {
        setShowApiKeyInput(true);
      }
    }, []);
    const handleSaveApiKey = (key) => {
      setUserApiKey(key);
      localStorage.setItem("voxlab_api_key", key);
      setShowApiKeyInput(false);
    };
    const isSaved = (0, import_react12.useMemo)(() => {
      if (!result)
        return false;
      return savedAIExercises.some((ex) => ex.id === result.id);
    }, [result, savedAIExercises]);
    const isFavorite = (0, import_react12.useMemo)(() => {
      if (!result)
        return false;
      return favoriteExerciseIds.includes(result.id);
    }, [result, favoriteExerciseIds]);
    const handleGenerate = async () => {
      if (!prompt || isLoading)
        return;
      const envKey = "AIzaSyD0JEm3fqse7TQZ1ri2UWMmdtJigyX3fpo";
      const apiKeyToUse = envKey && envKey.length > 0 && envKey !== "undefined" ? envKey : userApiKey;
      if (!apiKeyToUse) {
        setShowApiKeyInput(true);
        setError("Please enter a valid Google AI API Key to continue.");
        return;
      }
      setIsLoading(true);
      setError("");
      setResult(null);
      setIsRefining(false);
      try {
        const ai = new GoogleGenAI({ apiKey: apiKeyToUse });
        const fullPrompt = `Create a custom vocal exercise based on the following user request: "${prompt}". 
            
The response MUST be a valid JSON object matching the provided schema (VoxLab Exercise Format v1.5).
All user-facing text in the JSON response (like name, instructions) must be in ${language.name}.
The category must be one of the exact strings provided in the schema enum.

IMPORTANT PEDAGOGICAL RULE:
- Unless specifically asked for a continuous run (like "agility" or "speed"), ALWAYS insert a rest (duration 1.0 or more) at the end of the pattern.
- This allows the app to play the reference chord for the NEXT key before the user starts singing.
- The pattern structure should generally be: [Notes...] -> [Rest].

UNDERSTANDING USER REQUESTS:
- Recognize musical terms in multiple languages (English, Portuguese, Spanish, Italian, etc.)
- Examples: "scale" = "escala" = "scala", "arpeggio" = "arpejo" = "arpeggio"
- Understand abbreviations: "maj" = "major", "min" = "minor", "dim" = "diminished"
- Recognize note names: Do, Re, Mi, Fa, Sol, La, Si (solf\xE8ge) = C, D, E, F, G, A, B
- Common requests: "warm-up", "aquecimento", "sirene", "siren", "lip trill", "tongue trill"
- Interval requests: "thirds", "ter\xE7as", "fifths", "quintas", "octaves", "oitavas"

MUSICIAN-FRIENDLY INPUT (IMPORTANT!):
Musicians think in 1-based scale degrees: "1-3-5" means root, third, fifth.
But the JSON format uses 0-based semitones: 0=root, 4=major 3rd, 7=perfect 5th.

When users say:
- "1" or "root" \u2192 use semitone: 0
- "2" or "major 2nd" \u2192 use semitone: 2
- "3" or "major 3rd" \u2192 use semitone: 4
- "b3" or "minor 3rd" \u2192 use semitone: 3
- "4" or "perfect 4th" \u2192 use semitone: 5
- "5" or "perfect 5th" \u2192 use semitone: 7
- "6" or "major 6th" \u2192 use semitone: 9
- "b7" or "minor 7th" \u2192 use semitone: 10
- "7" or "major 7th" \u2192 use semitone: 11
- "8" or "octave" \u2192 use semitone: 12

EXERCISE FORMAT v1.5:
- Use "notes" array (not "pattern")
- Each note has: type ("note" or "rest"), semitone (0-12), duration (in beats), lyric (optional)
- Semitones are 0-based: 0=root, 1=minor 2nd, 2=major 2nd, 3=minor 3rd, 4=major 3rd, etc.
- Durations are in BEATS: 4.0=whole, 2.0=half, 1.0=quarter, 0.5=eighth, 0.25=sixteenth
- You can use dotted notes: 3.0=dotted half, 1.5=dotted quarter, 0.75=dotted eighth
- You can add rests for breathing: { "type": "rest", "duration": 1.0 }

BPM (Beats Per Minute):
- Slow: 60-80 BPM (warm-ups, breath work)
- Moderate: 80-120 BPM (scales, basic exercises)
- Fast: 120-180 BPM (agility, runs, coloratura)

EXAMPLES:

Major Arpeggio (1-3-5-8):
{
  "notes": [
    { "type": "note", "semitone": 0, "duration": 1.0, "lyric": "La" },
    { "type": "note", "semitone": 4, "duration": 1.0, "lyric": "La" },
    { "type": "note", "semitone": 7, "duration": 1.0, "lyric": "La" },
    { "type": "note", "semitone": 12, "duration": 2.0, "lyric": "La" }
  ]
}

Blues Scale with Rest:
{
  "notes": [
    { "type": "note", "semitone": 0, "duration": 1.0, "lyric": "Ah" },
    { "type": "note", "semitone": 3, "duration": 1.0, "lyric": "Ah" },
    { "type": "note", "semitone": 5, "duration": 1.0, "lyric": "Ah" },
    { "type": "rest", "duration": 0.5 },
    { "type": "note", "semitone": 6, "duration": 1.0, "lyric": "Ah" },
    { "type": "note", "semitone": 7, "duration": 1.0, "lyric": "Ah" },
    { "type": "note", "semitone": 10, "duration": 1.0, "lyric": "Ah" }
  ]
}`;
        const noteSchema = {
          type: Type.OBJECT,
          properties: {
            type: {
              type: Type.STRING,
              description: "Either 'note' (sing a pitch) or 'rest' (silence/breathing pause)"
            },
            semitone: {
              type: Type.INTEGER,
              description: "Semitones from root (0-12+). 0=root, 4=major 3rd, 7=perfect 5th, 12=octave. Required for 'note' type."
            },
            duration: {
              type: Type.NUMBER,
              description: "Duration in BEATS. 4.0=whole, 2.0=half, 1.0=quarter, 0.5=eighth, 0.25=sixteenth. Can use dotted: 1.5=dotted quarter."
            },
            lyric: {
              type: Type.STRING,
              description: "Optional syllable to sing (e.g., 'Ah', 'La', 'Do'). Only for 'note' type."
            }
          },
          required: ["type", "duration"]
        };
        const schema = {
          type: Type.OBJECT,
          properties: {
            exercise_id: {
              type: Type.STRING,
              description: "Unique ID like 'AI_GEN_001'. Use 'AI_GEN_' prefix + timestamp or random number."
            },
            name: {
              type: Type.STRING,
              description: "A creative name for the exercise in the user's language."
            },
            category: {
              type: Type.STRING,
              description: "Choose one: 'warmUpsAndBasics', 'breathAndSupport', 'resonanceAndTone', 'pitchAndIntonation', 'scalesAndAgility', 'belting', 'cooldowns'"
            },
            key_center: {
              type: Type.STRING,
              description: "Starting pitch like 'C4', 'D4', 'A3'. Default to 'C4' if not specified."
            },
            tempo_bpm: {
              type: Type.INTEGER,
              description: "Tempo in BPM. Slow=60-80, Moderate=90-110, Fast=120-160."
            },
            time_signature: {
              type: Type.STRING,
              description: "Time signature like '4/4', '3/4', '6/8'. Default to '4/4'."
            },
            notes: {
              type: Type.ARRAY,
              description: "Array of note/rest objects. Each has type, semitone (for notes), duration, and optional lyric.",
              items: noteSchema
            },
            instructions: {
              type: Type.STRING,
              description: "Detailed, encouraging instructions in the user's language."
            }
          },
          required: ["exercise_id", "name", "category", "key_center", "tempo_bpm", "time_signature", "notes", "instructions"]
        };
        const response = await ai.models.generateContent({
          model: "gemini-2.0-flash",
          contents: fullPrompt,
          config: {
            responseMimeType: "application/json",
            responseSchema: schema
          }
        });
        const jsonResult = JSON.parse(response.text);
        const exerciseResult = {
          ...jsonResult,
          isAIGenerated: true
        };
        setResult(exerciseResult);
      } catch (e) {
        console.error("Error calling Gemini API:", e);
        setError("An error occurred while generating the exercise. Please check your API key and try again.");
        if (String(e).includes("401") || String(e).includes("API key")) {
          setShowApiKeyInput(true);
        }
      } finally {
        setIsLoading(false);
      }
    };
    const handleRefine = async () => {
      if (!refinePrompt || isRefineLoading || !result)
        return;
      const envKey = "AIzaSyD0JEm3fqse7TQZ1ri2UWMmdtJigyX3fpo";
      const apiKeyToUse = envKey && envKey.length > 0 && envKey !== "undefined" ? envKey : userApiKey;
      if (!apiKeyToUse) {
        setShowApiKeyInput(true);
        setError("Please enter a valid Google AI API Key to continue.");
        return;
      }
      setIsRefineLoading(true);
      setError("");
      try {
        const ai = new GoogleGenAI({ apiKey: apiKeyToUse });
        const fullPrompt = `
                I have a vocal exercise defined in JSON: ${JSON.stringify(result)}.
                Please modify this exercise based on this request: "${refinePrompt}".
                The response MUST be a valid JSON object matching the provided schema.
                All user-facing text (name, desc, instructions) must be in ${language.name}.
                The category must be one of the exact strings provided in the schema enum.
                Keep the general structure but apply the requested changes.
                
                IMPORTANT MUSICAL TIMING GUIDELINES:
                This is a MUSIC application. All timing must be based on musical tempo (BPM) and beat subdivisions.
                
                BPM (Beats Per Minute):
                - Slow: 60-80 BPM
                - Moderate: 80-120 BPM  
                - Fast: 120-180 BPM
                
                Note Durations (in BEATS, not milliseconds):
                - Whole note = 4 beats
                - Half note = 2 beats
                - Quarter note = 1 beat
                - Eighth note = 0.5 beats
                - Sixteenth note = 0.25 beats
                
                If the user specifies a note duration (like "half note", "quarter note", etc.), you MUST use the corresponding BEAT value.
                If the user wants VARIED note durations within the exercise, provide a "durations" array with one beat value per note in the pattern.
            `;
        const schema = {
          type: Type.OBJECT,
          properties: {
            name: { type: Type.STRING, description: "A creative name for the exercise." },
            desc: { type: Type.STRING, description: "A short, one-sentence description of the exercise's purpose." },
            instructions: { type: Type.STRING, description: "Detailed, step-by-step instructions on how to perform the exercise. Use clear and encouraging language." },
            pattern: {
              type: Type.ARRAY,
              description: "A sequence of semitone offsets from a starting note. E.g., a simple 5-tone scale is [0, 2, 4, 5, 7, 5, 4, 2, 0]. Keep it melodic and logical.",
              items: { type: Type.INTEGER }
            },
            bpm: {
              type: Type.INTEGER,
              description: "Tempo in beats per minute. Choose based on exercise type: slow warm-ups (60-80), moderate scales (90-110), fast agility (120-160)."
            },
            duration: {
              type: Type.NUMBER,
              description: "Default duration for all notes in BEATS. Use: whole=4, half=2, quarter=1, eighth=0.5, sixteenth=0.25."
            },
            durations: {
              type: Type.ARRAY,
              description: "Optional: Array of durations in BEATS for each note in the pattern. If provided, this overrides 'duration'. Must have the same length as 'pattern'.",
              items: { type: Type.NUMBER }
            },
            category: {
              type: Type.STRING,
              description: "The most fitting category for this exercise. Choose one of: 'Warm-ups & Basics', 'Breath & Support', 'Resonance & Tone', 'Pitch & Intonation', 'Scales & Agility', 'Belting', 'Cooldowns'."
            }
          },
          required: ["name", "desc", "instructions", "pattern", "bpm", "duration", "category"]
        };
        const response = await ai.models.generateContent({
          model: "gemini-2.0-flash",
          contents: fullPrompt,
          config: {
            responseMimeType: "application/json",
            responseSchema: schema
          }
        });
        const jsonResult = JSON.parse(response.text);
        const exerciseResult = {
          ...jsonResult,
          id: result.id,
          // Keep ID to maintain identity if possible, or generate new one
          isAIGenerated: true
        };
        setResult(exerciseResult);
        setIsRefining(false);
        setRefinePrompt("");
      } catch (e) {
        console.error("Error calling Gemini API:", e);
        setError("An error occurred while refining the exercise. Please try again.");
      } finally {
        setIsRefineLoading(false);
      }
    };
    const handleFavoriteClick = () => {
      if (!result)
        return;
      if (!isSaved) {
        onSave(result);
      }
      onToggleFavorite(result.id);
    };
    return /* @__PURE__ */ (0, import_jsx_runtime14.jsxs)("section", { className: "flex-grow flex flex-col justify-center pb-24", children: [
      /* @__PURE__ */ (0, import_jsx_runtime14.jsx)("p", { className: "text-slate-600 dark:text-slate-300 mb-6 text-center", children: t("voxlabaiDesc") }),
      /* @__PURE__ */ (0, import_jsx_runtime14.jsxs)("div", { className: "relative border border-amber-400/50 bg-amber-50/50 dark:bg-amber-900/20 rounded-lg p-4 text-sm text-amber-800 dark:text-amber-300 mb-6", children: [
        /* @__PURE__ */ (0, import_jsx_runtime14.jsxs)("span", { className: "font-bold", children: [
          t("beta"),
          ":"
        ] }),
        " ",
        t("voxlabaiBeta")
      ] }),
      showApiKeyInput && /* @__PURE__ */ (0, import_jsx_runtime14.jsxs)("div", { className: "mb-6 p-4 border border-violet-200 dark:border-violet-800 bg-violet-50 dark:bg-violet-900/20 rounded-lg", children: [
        /* @__PURE__ */ (0, import_jsx_runtime14.jsx)("label", { className: "block text-sm font-bold text-violet-800 dark:text-violet-300 mb-2", children: "Google AI API Key Required" }),
        /* @__PURE__ */ (0, import_jsx_runtime14.jsxs)("p", { className: "text-xs text-slate-600 dark:text-slate-400 mb-3", children: [
          "To use this feature, you need a Google AI API key. Get one for free at ",
          /* @__PURE__ */ (0, import_jsx_runtime14.jsx)("a", { href: "https://aistudio.google.com/app/apikey", target: "_blank", rel: "noreferrer", className: "text-violet-600 underline", children: "aistudio.google.com" }),
          "."
        ] }),
        /* @__PURE__ */ (0, import_jsx_runtime14.jsxs)("div", { className: "flex gap-2", children: [
          /* @__PURE__ */ (0, import_jsx_runtime14.jsx)(
            "input",
            {
              type: "password",
              value: userApiKey,
              onChange: (e) => setUserApiKey(e.target.value),
              placeholder: "Paste your API key here",
              className: "flex-1 p-2 text-sm rounded border border-slate-300 dark:border-slate-600 bg-white dark:bg-slate-800 focus:ring-2 focus:ring-violet-500"
            }
          ),
          /* @__PURE__ */ (0, import_jsx_runtime14.jsx)(
            "button",
            {
              onClick: () => handleSaveApiKey(userApiKey),
              className: "px-4 py-2 bg-violet-600 text-white text-sm font-bold rounded hover:bg-violet-700 transition-colors",
              children: "Save Key"
            }
          )
        ] })
      ] }),
      /* @__PURE__ */ (0, import_jsx_runtime14.jsxs)("div", { className: "space-y-4", children: [
        /* @__PURE__ */ (0, import_jsx_runtime14.jsx)(
          "textarea",
          {
            value: prompt,
            onChange: (e) => setPrompt(e.target.value),
            placeholder: t("voxlabaiPrompt"),
            className: "relative z-10 w-full h-28 p-3 border border-slate-300 dark:border-slate-600 bg-white dark:bg-slate-800 text-slate-900 dark:text-slate-100 placeholder:text-slate-400 dark:placeholder:text-slate-500 rounded-lg focus:ring-2 focus:ring-violet-500 focus:border-violet-500 transition-shadow resize-none",
            disabled: isLoading
          }
        ),
        /* @__PURE__ */ (0, import_jsx_runtime14.jsx)("div", { className: "flex justify-center", children: /* @__PURE__ */ (0, import_jsx_runtime14.jsx)(
          ThemedButton_default,
          {
            onClick: handleGenerate,
            disabled: isLoading || !prompt,
            theme: currentTheme,
            children: isLoading ? t("generate") + "..." : t("generate")
          }
        ) })
      ] }),
      error && /* @__PURE__ */ (0, import_jsx_runtime14.jsx)("p", { className: "text-red-500 mt-4", children: error }),
      (isLoading || result) && /* @__PURE__ */ (0, import_jsx_runtime14.jsx)("div", { className: "mt-8 p-5 border border-slate-200 dark:border-slate-700 rounded-2xl bg-white/60 dark:bg-slate-800/30 backdrop-blur-md shadow-sm", children: isLoading ? /* @__PURE__ */ (0, import_jsx_runtime14.jsx)(LoadingSpinner, {}) : result && // VIEW MODE
      /* @__PURE__ */ (0, import_jsx_runtime14.jsxs)("div", { className: "space-y-4", children: [
        /* @__PURE__ */ (0, import_jsx_runtime14.jsxs)("div", { children: [
          /* @__PURE__ */ (0, import_jsx_runtime14.jsxs)("div", { className: "flex justify-between items-start", children: [
            /* @__PURE__ */ (0, import_jsx_runtime14.jsx)("span", { className: `text-xs font-bold uppercase bg-clip-text text-transparent bg-gradient-to-br ${currentTheme.gradientText.from} ${currentTheme.gradientText.to} ${currentTheme.gradientText.darkFrom} ${currentTheme.gradientText.darkTo}`, children: result.category }),
            /* @__PURE__ */ (0, import_jsx_runtime14.jsxs)("div", { className: "flex items-center gap-2", children: [
              /* @__PURE__ */ (0, import_jsx_runtime14.jsx)("span", { className: "text-xs font-semibold text-green-700 dark:text-green-300 bg-green-100 dark:bg-green-900/50 px-2 py-0.5 rounded-full", children: t("aiGenerated") }),
              /* @__PURE__ */ (0, import_jsx_runtime14.jsx)(
                "button",
                {
                  onClick: () => setIsRefining(!isRefining),
                  className: `btn-interactive p-1.5 rounded-full backdrop-blur-sm transition-colors ${isRefining ? "bg-violet-100 dark:bg-violet-900/50" : "bg-white/30 dark:bg-slate-700/30"}`,
                  "aria-label": t("refine"),
                  title: t("refine"),
                  children: /* @__PURE__ */ (0, import_jsx_runtime14.jsx)(MagicIcon, {})
                }
              ),
              /* @__PURE__ */ (0, import_jsx_runtime14.jsx)(
                "button",
                {
                  onClick: handleFavoriteClick,
                  className: "btn-interactive p-1.5 rounded-full bg-white/30 dark:bg-slate-700/30 backdrop-blur-sm",
                  "aria-label": t("favorites"),
                  children: /* @__PURE__ */ (0, import_jsx_runtime14.jsx)(StarIcon2, { isFavorite })
                }
              )
            ] })
          ] }),
          isRefining && /* @__PURE__ */ (0, import_jsx_runtime14.jsxs)("div", { className: "mt-3 mb-4 p-3 rounded-xl bg-violet-50/80 dark:bg-violet-900/20 border border-violet-200 dark:border-violet-800 animate-fade-in", children: [
            /* @__PURE__ */ (0, import_jsx_runtime14.jsx)("label", { className: "block text-xs font-bold text-violet-800 dark:text-violet-300 mb-2", children: t("refine") }),
            /* @__PURE__ */ (0, import_jsx_runtime14.jsxs)("div", { className: "flex gap-2", children: [
              /* @__PURE__ */ (0, import_jsx_runtime14.jsx)(
                "input",
                {
                  type: "text",
                  value: refinePrompt,
                  onChange: (e) => setRefinePrompt(e.target.value),
                  placeholder: t("refinePromptPlaceholder"),
                  className: "flex-1 p-2 text-sm rounded-lg border border-violet-200 dark:border-violet-700 bg-white dark:bg-slate-800 focus:ring-2 focus:ring-violet-500",
                  onKeyDown: (e) => e.key === "Enter" && handleRefine()
                }
              ),
              /* @__PURE__ */ (0, import_jsx_runtime14.jsx)(
                "button",
                {
                  onClick: handleRefine,
                  disabled: isRefineLoading || !refinePrompt,
                  className: "px-3 py-2 bg-violet-600 text-white rounded-lg hover:bg-violet-700 disabled:opacity-50 disabled:cursor-not-allowed transition-colors",
                  children: isRefineLoading ? /* @__PURE__ */ (0, import_jsx_runtime14.jsx)("div", { className: "animate-spin h-4 w-4 border-2 border-white rounded-full border-t-transparent" }) : /* @__PURE__ */ (0, import_jsx_runtime14.jsx)("svg", { xmlns: "http://www.w3.org/2000/svg", className: "h-4 w-4", fill: "none", viewBox: "0 0 24 24", stroke: "currentColor", children: /* @__PURE__ */ (0, import_jsx_runtime14.jsx)("path", { strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 2, d: "M13 10V3L4 14h7v7l9-11h-7z" }) })
                }
              )
            ] })
          ] }),
          /* @__PURE__ */ (0, import_jsx_runtime14.jsx)("h3", { className: `text-2xl font-bold bg-clip-text text-transparent bg-gradient-to-br ${currentTheme.gradientText.from} ${currentTheme.gradientText.to} ${currentTheme.gradientText.darkFrom} ${currentTheme.gradientText.darkTo}`, children: result.name }),
          /* @__PURE__ */ (0, import_jsx_runtime14.jsxs)("p", { className: "text-slate-600 dark:text-slate-300 italic", children: [
            '"',
            result.desc,
            '"'
          ] })
        ] }),
        /* @__PURE__ */ (0, import_jsx_runtime14.jsx)("div", { className: "border-t border-slate-200/80 dark:border-slate-700/80 my-2" }),
        /* @__PURE__ */ (0, import_jsx_runtime14.jsxs)("div", { children: [
          /* @__PURE__ */ (0, import_jsx_runtime14.jsx)("h4", { className: "font-semibold text-violet-700 dark:text-violet-400", children: "Instructions" }),
          /* @__PURE__ */ (0, import_jsx_runtime14.jsx)("p", { className: "text-slate-600 dark:text-slate-300 whitespace-pre-wrap", children: result.instructions })
        ] }),
        /* @__PURE__ */ (0, import_jsx_runtime14.jsxs)("div", { children: [
          /* @__PURE__ */ (0, import_jsx_runtime14.jsx)("h4", { className: "font-semibold text-violet-700 dark:text-violet-400", children: result.notes ? "Notes" : "Pattern" }),
          /* @__PURE__ */ (0, import_jsx_runtime14.jsx)("p", { className: "font-mono text-sm text-slate-500 dark:text-slate-400 bg-slate-100 dark:bg-slate-900/50 rounded p-2", children: result.notes ? `${result.notes.length} notes` : result.pattern?.join(", ") || "No pattern defined" })
        ] }),
        /* @__PURE__ */ (0, import_jsx_runtime14.jsxs)("div", { className: "grid grid-cols-2 gap-4", children: [
          result.duration && /* @__PURE__ */ (0, import_jsx_runtime14.jsxs)("div", { children: [
            /* @__PURE__ */ (0, import_jsx_runtime14.jsx)("h4", { className: "font-semibold text-violet-700 dark:text-violet-400", children: "Note Duration" }),
            /* @__PURE__ */ (0, import_jsx_runtime14.jsxs)("p", { className: "text-slate-600 dark:text-slate-300", children: [
              /* @__PURE__ */ (0, import_jsx_runtime14.jsx)("span", { className: "text-2xl mr-2", children: beatsToMusicalNotation(result.duration).symbol }),
              beatsToMusicalNotation(result.duration).notation
            ] }),
            /* @__PURE__ */ (0, import_jsx_runtime14.jsxs)("p", { className: "text-xs text-slate-400 dark:text-slate-500 mt-1", children: [
              "(",
              result.duration,
              " beats)"
            ] })
          ] }),
          /* @__PURE__ */ (0, import_jsx_runtime14.jsxs)("div", { children: [
            /* @__PURE__ */ (0, import_jsx_runtime14.jsx)("h4", { className: "font-semibold text-violet-700 dark:text-violet-400", children: "Tempo" }),
            /* @__PURE__ */ (0, import_jsx_runtime14.jsxs)("p", { className: "text-slate-600 dark:text-slate-300", children: [
              /* @__PURE__ */ (0, import_jsx_runtime14.jsx)("span", { className: "text-2xl mr-2", children: "\u2669" }),
              result.tempo_bpm || result.bpm || 90,
              " BPM"
            ] }),
            /* @__PURE__ */ (0, import_jsx_runtime14.jsx)("p", { className: "text-xs text-slate-400 dark:text-slate-500 mt-1", children: "Beats per minute" })
          ] })
        ] }),
        /* @__PURE__ */ (0, import_jsx_runtime14.jsx)("div", { className: "border-t border-slate-200/80 dark:border-slate-700/80 my-2" }),
        /* @__PURE__ */ (0, import_jsx_runtime14.jsxs)("div", { className: "flex gap-2 mt-2 justify-center", children: [
          /* @__PURE__ */ (0, import_jsx_runtime14.jsxs)(
            "button",
            {
              type: "button",
              onClick: () => {
                console.log("Preview button clicked!", { isPreviewing });
                if (isPreviewing) {
                  if (previewTimeoutId)
                    clearTimeout(previewTimeoutId);
                  setIsPreviewing(false);
                  setPreviewTimeoutId(null);
                } else {
                  setIsPreviewing(true);
                  const bpm = result.tempo_bpm || result.bpm || 90;
                  const secondsPerBeat = 60 / bpm;
                  if (result.notes) {
                    const notes = result.notes;
                    let currentTime = 0;
                    notes.forEach((note, index) => {
                      if (note.type === "note") {
                        const durationSec = note.duration * secondsPerBeat;
                        setTimeout(() => {
                          playNote(note.semitone, durationSec * 1e3, false);
                        }, currentTime * 1e3);
                        currentTime += note.duration;
                      } else {
                        currentTime += note.duration;
                      }
                    });
                    const finalTimeoutId = setTimeout(() => {
                      setIsPreviewing(false);
                      setPreviewTimeoutId(null);
                    }, currentTime * 1e3);
                    setPreviewTimeoutId(finalTimeoutId);
                  } else if (result.pattern && result.pattern.length > 0) {
                    const noteDuration = result.duration * secondsPerBeat;
                    playNote(result.pattern[0], noteDuration, false);
                    let currentTime = noteDuration;
                    for (let i = 1; i < result.pattern.length; i++) {
                      const semitone = result.pattern[i];
                      setTimeout(() => {
                        playNote(semitone, noteDuration, false);
                      }, currentTime * 1e3);
                      currentTime += noteDuration;
                    }
                    const totalDuration = result.pattern.length * noteDuration;
                    const finalTimeoutId = setTimeout(() => {
                      setIsPreviewing(false);
                      setPreviewTimeoutId(null);
                    }, totalDuration * 1e3);
                    setPreviewTimeoutId(finalTimeoutId);
                  }
                }
              },
              className: "flex items-center justify-center gap-2 px-6 py-2.5 rounded-lg bg-slate-100 dark:bg-slate-800 text-slate-700 dark:text-slate-300 hover:bg-slate-200 dark:hover:bg-slate-700 active:bg-slate-300 dark:active:bg-slate-600 transition-all text-sm font-semibold cursor-pointer select-none",
              children: [
                isPreviewing ? /* @__PURE__ */ (0, import_jsx_runtime14.jsx)(Square, { size: 16 }) : /* @__PURE__ */ (0, import_jsx_runtime14.jsx)(Play, { size: 16 }),
                isPreviewing ? "Stop Preview" : "Preview"
              ]
            }
          ),
          /* @__PURE__ */ (0, import_jsx_runtime14.jsx)(
            ThemedButton_default,
            {
              onClick: () => onStartExercise(result),
              theme: currentTheme,
              children: t("practiceThisExercise")
            }
          )
        ] })
      ] }) })
    ] });
  };
  var AIStudioView_default = VoxLabAIView;

  // components/TestModeView.tsx
  var import_jsx_runtime15 = __toESM(require_jsx_runtime());
  var TestModeView = (props) => {
    const {
      compressorEnabled,
      frequencySeparationEnabled,
      pyinBias,
      pyinTolerance,
      pyinGateMode,
      noiseGateThreshold
    } = props;
    const testExercise = {
      id: 999,
      name: "Test Mode",
      desc: "Pitch Detection Test",
      pattern: [],
      // No notes
      duration: 1e3,
      bpm: 90,
      instructions: "Test your pitch detection",
      category: "test"
    };
    return /* @__PURE__ */ (0, import_jsx_runtime15.jsxs)("div", { className: "h-full w-full flex", children: [
      /* @__PURE__ */ (0, import_jsx_runtime15.jsxs)("div", { className: "absolute top-4 left-4 z-40 px-4 py-2 rounded-full bg-gradient-to-r from-violet-600 to-fuchsia-600 text-white font-bold text-sm shadow-lg", children: [
        /* @__PURE__ */ (0, import_jsx_runtime15.jsx)(Activity, { size: 16, className: "inline mr-2" }),
        "Test Mode"
      ] }),
      /* @__PURE__ */ (0, import_jsx_runtime15.jsx)("div", { className: "flex-1 overflow-hidden", children: /* @__PURE__ */ (0, import_jsx_runtime15.jsx)(
        ExerciseGameViewALTWrapper_default,
        {
          exercise: testExercise,
          vocalRange: props.vocalRange,
          userPitch: props.userPitch,
          micGain: props.micGain,
          isPlaying: props.micActive,
          isExerciseComplete: false,
          onStop: () => {
          },
          onComplete: () => {
          },
          onPlayPause: props.onToggleMic,
          onPreview: () => {
          },
          isPreviewing: false,
          playNote: props.playNote,
          centerSemitone: 60,
          visibleOctaves: 2,
          onNotePositionUpdate: () => {
          },
          currentRoutine: null,
          onNextInRoutine: () => {
          },
          onToggleFavoriteExercise: () => {
          },
          isExerciseFavorite: false,
          onToggleFavoriteRoutine: () => {
          },
          isRoutineFavorite: false,
          isFullscreen: false,
          onToggleFullscreen: () => {
          },
          onBack: props.onBack,
          compressorEnabled,
          frequencySeparationEnabled,
          pyinBias,
          pyinTolerance,
          pyinGateMode,
          noiseGateThreshold,
          checkAudioBuffers: async () => true
        }
      ) }),
      /* @__PURE__ */ (0, import_jsx_runtime15.jsxs)("div", { className: "hidden md:flex w-80 bg-white/90 dark:bg-slate-900/90 backdrop-blur-xl border-l border-slate-200/50 dark:border-slate-700/50 p-6 flex-col gap-6 overflow-y-auto z-50 shadow-2xl", children: [
        /* @__PURE__ */ (0, import_jsx_runtime15.jsxs)("div", { className: "flex items-center gap-2 text-slate-800 dark:text-slate-100 mb-2", children: [
          /* @__PURE__ */ (0, import_jsx_runtime15.jsx)(SlidersVertical, { size: 20, className: "text-violet-600" }),
          /* @__PURE__ */ (0, import_jsx_runtime15.jsx)("h3", { className: "font-bold text-lg", children: "Audio Settings" })
        ] }),
        /* @__PURE__ */ (0, import_jsx_runtime15.jsxs)("div", { className: "space-y-2", children: [
          /* @__PURE__ */ (0, import_jsx_runtime15.jsxs)("div", { className: "flex items-center justify-between", children: [
            /* @__PURE__ */ (0, import_jsx_runtime15.jsxs)("label", { className: "text-sm font-medium text-slate-700 dark:text-slate-300 flex items-center gap-2", children: [
              /* @__PURE__ */ (0, import_jsx_runtime15.jsx)(Zap, { size: 16, className: "text-amber-500" }),
              " Compressor"
            ] }),
            /* @__PURE__ */ (0, import_jsx_runtime15.jsx)(
              "button",
              {
                onClick: () => props.setCompressorEnabled(!compressorEnabled),
                className: `w-12 h-6 rounded-full transition-colors relative ${compressorEnabled ? "bg-violet-600" : "bg-slate-300 dark:bg-slate-600"}`,
                children: /* @__PURE__ */ (0, import_jsx_runtime15.jsx)("div", { className: `absolute top-1 w-4 h-4 rounded-full bg-white transition-transform ${compressorEnabled ? "left-7" : "left-1"}` })
              }
            )
          ] }),
          /* @__PURE__ */ (0, import_jsx_runtime15.jsx)("p", { className: "text-xs text-slate-500 dark:text-slate-400", children: "Balances volume levels automatically." })
        ] }),
        /* @__PURE__ */ (0, import_jsx_runtime15.jsxs)("div", { className: "space-y-2", children: [
          /* @__PURE__ */ (0, import_jsx_runtime15.jsxs)("div", { className: "flex items-center justify-between", children: [
            /* @__PURE__ */ (0, import_jsx_runtime15.jsxs)("label", { className: "text-sm font-medium text-slate-700 dark:text-slate-300 flex items-center gap-2", children: [
              /* @__PURE__ */ (0, import_jsx_runtime15.jsx)(Activity, { size: 16, className: "text-blue-500" }),
              " Freq. Separation"
            ] }),
            /* @__PURE__ */ (0, import_jsx_runtime15.jsx)(
              "button",
              {
                onClick: () => props.setFrequencySeparationEnabled(!frequencySeparationEnabled),
                className: `w-12 h-6 rounded-full transition-colors relative ${frequencySeparationEnabled ? "bg-violet-600" : "bg-slate-300 dark:bg-slate-600"}`,
                children: /* @__PURE__ */ (0, import_jsx_runtime15.jsx)("div", { className: `absolute top-1 w-4 h-4 rounded-full bg-white transition-transform ${frequencySeparationEnabled ? "left-7" : "left-1"}` })
              }
            )
          ] }),
          /* @__PURE__ */ (0, import_jsx_runtime15.jsx)("p", { className: "text-xs text-slate-500 dark:text-slate-400", children: "Prevents piano bass from interfering with voice detection." })
        ] }),
        /* @__PURE__ */ (0, import_jsx_runtime15.jsx)("div", { className: "h-px bg-slate-200 dark:bg-slate-700 my-2" }),
        /* @__PURE__ */ (0, import_jsx_runtime15.jsxs)("div", { className: "space-y-3", children: [
          /* @__PURE__ */ (0, import_jsx_runtime15.jsxs)("div", { className: "flex justify-between items-center", children: [
            /* @__PURE__ */ (0, import_jsx_runtime15.jsx)("label", { className: "text-sm font-medium text-slate-700 dark:text-slate-300", children: "Note Stickiness" }),
            /* @__PURE__ */ (0, import_jsx_runtime15.jsx)("span", { className: "text-xs font-mono bg-slate-100 dark:bg-slate-800 px-2 py-1 rounded text-violet-600 font-bold", children: pyinBias.toFixed(1) })
          ] }),
          /* @__PURE__ */ (0, import_jsx_runtime15.jsx)(
            "input",
            {
              type: "range",
              min: "0.1",
              max: "10.0",
              step: "0.1",
              value: pyinBias,
              onChange: (e) => props.setPyinBias(parseFloat(e.target.value)),
              className: "w-full h-2 bg-slate-200 dark:bg-slate-700 rounded-lg appearance-none cursor-pointer accent-violet-600"
            }
          ),
          /* @__PURE__ */ (0, import_jsx_runtime15.jsxs)("div", { className: "flex justify-between text-[10px] text-slate-400", children: [
            /* @__PURE__ */ (0, import_jsx_runtime15.jsx)("span", { children: "Loose (Fast)" }),
            /* @__PURE__ */ (0, import_jsx_runtime15.jsx)("span", { children: "Sticky (Stable)" })
          ] })
        ] }),
        /* @__PURE__ */ (0, import_jsx_runtime15.jsxs)("div", { className: "space-y-3", children: [
          /* @__PURE__ */ (0, import_jsx_runtime15.jsxs)("div", { className: "flex justify-between items-center", children: [
            /* @__PURE__ */ (0, import_jsx_runtime15.jsx)("label", { className: "text-sm font-medium text-slate-700 dark:text-slate-300", children: "Note Tolerance" }),
            /* @__PURE__ */ (0, import_jsx_runtime15.jsxs)("span", { className: "text-xs font-mono bg-slate-100 dark:bg-slate-800 px-2 py-1 rounded text-violet-600 font-bold", children: [
              (pyinTolerance * 100).toFixed(0),
              "%"
            ] })
          ] }),
          /* @__PURE__ */ (0, import_jsx_runtime15.jsx)(
            "input",
            {
              type: "range",
              min: "0.05",
              max: "0.5",
              step: "0.01",
              value: pyinTolerance,
              onChange: (e) => props.setPyinTolerance(parseFloat(e.target.value)),
              className: "w-full h-2 bg-slate-200 dark:bg-slate-700 rounded-lg appearance-none cursor-pointer accent-violet-600"
            }
          ),
          /* @__PURE__ */ (0, import_jsx_runtime15.jsxs)("div", { className: "flex justify-between text-[10px] text-slate-400", children: [
            /* @__PURE__ */ (0, import_jsx_runtime15.jsx)("span", { children: "Strict (5%)" }),
            /* @__PURE__ */ (0, import_jsx_runtime15.jsx)("span", { children: "Loose (50%)" })
          ] })
        ] }),
        /* @__PURE__ */ (0, import_jsx_runtime15.jsxs)("div", { className: "space-y-3", children: [
          /* @__PURE__ */ (0, import_jsx_runtime15.jsx)("label", { className: "text-sm font-medium text-slate-700 dark:text-slate-300", children: "Gate Mode" }),
          /* @__PURE__ */ (0, import_jsx_runtime15.jsxs)("div", { className: "flex bg-slate-100 dark:bg-slate-800 p-1 rounded-lg", children: [
            /* @__PURE__ */ (0, import_jsx_runtime15.jsx)(
              "button",
              {
                onClick: () => props.setPyinGateMode("smooth"),
                className: `flex-1 py-1.5 text-xs font-bold rounded-md transition-all ${pyinGateMode === "smooth" ? "bg-white dark:bg-slate-700 shadow-sm text-violet-600" : "text-slate-500 hover:text-slate-700 dark:hover:text-slate-300"}`,
                children: "Smooth"
              }
            ),
            /* @__PURE__ */ (0, import_jsx_runtime15.jsx)(
              "button",
              {
                onClick: () => props.setPyinGateMode("instant"),
                className: `flex-1 py-1.5 text-xs font-bold rounded-md transition-all ${pyinGateMode === "instant" ? "bg-white dark:bg-slate-700 shadow-sm text-violet-600" : "text-slate-500 hover:text-slate-700 dark:hover:text-slate-300"}`,
                children: "Instant"
              }
            )
          ] })
        ] }),
        /* @__PURE__ */ (0, import_jsx_runtime15.jsxs)("div", { className: "space-y-3", children: [
          /* @__PURE__ */ (0, import_jsx_runtime15.jsxs)("div", { className: "flex justify-between items-center", children: [
            /* @__PURE__ */ (0, import_jsx_runtime15.jsxs)("label", { className: "text-sm font-medium text-slate-700 dark:text-slate-300 flex items-center gap-2", children: [
              /* @__PURE__ */ (0, import_jsx_runtime15.jsx)(Volume2, { size: 16, className: "text-emerald-500" }),
              " Noise Gate"
            ] }),
            /* @__PURE__ */ (0, import_jsx_runtime15.jsxs)("span", { className: "text-xs font-mono bg-slate-100 dark:bg-slate-800 px-2 py-1 rounded text-violet-600 font-bold", children: [
              (noiseGateThreshold * 100).toFixed(1),
              "%"
            ] })
          ] }),
          /* @__PURE__ */ (0, import_jsx_runtime15.jsx)(
            "input",
            {
              type: "range",
              min: "0.001",
              max: "0.1",
              step: "0.001",
              value: noiseGateThreshold,
              onChange: (e) => props.setNoiseGateThreshold(parseFloat(e.target.value)),
              className: "w-full h-2 bg-slate-200 dark:bg-slate-700 rounded-lg appearance-none cursor-pointer accent-violet-600"
            }
          ),
          /* @__PURE__ */ (0, import_jsx_runtime15.jsxs)("div", { className: "flex justify-between text-[10px] text-slate-400", children: [
            /* @__PURE__ */ (0, import_jsx_runtime15.jsx)("span", { children: "Sensitive" }),
            /* @__PURE__ */ (0, import_jsx_runtime15.jsx)("span", { children: "Strict" })
          ] })
        ] })
      ] })
    ] });
  };
  var TestModeView_default = TestModeView;

  // components/FavoritesView.tsx
  var import_react13 = __toESM(require_react());
  var import_jsx_runtime16 = __toESM(require_jsx_runtime());
  var CATEGORY_STYLES = {
    warmup: { color: "text-amber-500", bg: "bg-amber-500/10" },
    technique: { color: "text-sky-500", bg: "bg-sky-500/10" },
    agility: { color: "text-emerald-500", bg: "bg-emerald-500/10" },
    ear: { color: "text-fuchsia-500", bg: "bg-fuchsia-500/10" },
    style: { color: "text-rose-500", bg: "bg-rose-500/10" }
  };
  var RoutineCard2 = ({ routine, onStart, onToggleFavorite, theme }) => {
    const { t } = useTranslation();
    return /* @__PURE__ */ (0, import_jsx_runtime16.jsxs)(
      "div",
      {
        onClick: onStart,
        className: "group relative p-5 rounded-2xl bg-gradient-to-br from-white/80 to-white/40 dark:from-slate-800/60 dark:to-slate-800/30 backdrop-blur-md border border-slate-200/50 dark:border-slate-700/50 shadow-sm hover:shadow-xl hover:scale-[1.02] transition-all duration-300 cursor-pointer overflow-hidden",
        children: [
          /* @__PURE__ */ (0, import_jsx_runtime16.jsx)("div", { className: `absolute inset-0 bg-gradient-to-br ${theme.button.from} ${theme.button.to} opacity-0 group-hover:opacity-5 transition-opacity duration-300` }),
          /* @__PURE__ */ (0, import_jsx_runtime16.jsx)(
            "button",
            {
              onClick: (e) => {
                e.stopPropagation();
                onToggleFavorite();
              },
              className: "absolute top-3 right-3 z-10 p-2 rounded-full bg-amber-400/20 hover:bg-amber-400/30 transition-all hover:scale-110",
              "aria-label": t("favorites"),
              children: /* @__PURE__ */ (0, import_jsx_runtime16.jsx)(Star, { size: 18, className: "text-amber-400 fill-amber-400" })
            }
          ),
          /* @__PURE__ */ (0, import_jsx_runtime16.jsxs)("div", { className: "flex items-center gap-3 mb-3", children: [
            /* @__PURE__ */ (0, import_jsx_runtime16.jsx)("div", { className: `p-2.5 rounded-xl bg-gradient-to-br ${theme.button.from} ${theme.button.to} shadow-lg`, children: /* @__PURE__ */ (0, import_jsx_runtime16.jsx)(ListMusic, { size: 20, className: "text-white" }) }),
            /* @__PURE__ */ (0, import_jsx_runtime16.jsx)("div", { children: /* @__PURE__ */ (0, import_jsx_runtime16.jsx)("span", { className: "text-xs font-medium text-slate-400 dark:text-slate-500 uppercase tracking-wide", children: t("routinesTitle") }) })
          ] }),
          /* @__PURE__ */ (0, import_jsx_runtime16.jsx)("h4", { className: `font-bold text-lg mb-2 bg-clip-text text-transparent bg-gradient-to-r ${theme.gradientText.from} ${theme.gradientText.to} ${theme.gradientText.darkFrom} ${theme.gradientText.darkTo} pr-8`, children: t(routine.name) }),
          /* @__PURE__ */ (0, import_jsx_runtime16.jsx)("p", { className: "text-sm text-slate-500 dark:text-slate-400 line-clamp-2 mb-3", children: t(routine.description) }),
          /* @__PURE__ */ (0, import_jsx_runtime16.jsxs)("div", { className: "flex items-center gap-4 text-xs text-slate-400 dark:text-slate-500", children: [
            routine.estimatedMinutes && /* @__PURE__ */ (0, import_jsx_runtime16.jsxs)("span", { className: "flex items-center gap-1", children: [
              /* @__PURE__ */ (0, import_jsx_runtime16.jsx)(Clock, { size: 12 }),
              "~",
              routine.estimatedMinutes,
              " min"
            ] }),
            /* @__PURE__ */ (0, import_jsx_runtime16.jsxs)("span", { className: "flex items-center gap-1", children: [
              /* @__PURE__ */ (0, import_jsx_runtime16.jsx)(Music, { size: 12 }),
              routine.exerciseIds.length,
              " exerc\xEDcios"
            ] })
          ] }),
          /* @__PURE__ */ (0, import_jsx_runtime16.jsx)("div", { className: "absolute bottom-3 right-3 p-2 rounded-full bg-slate-100 dark:bg-slate-700/50 opacity-0 group-hover:opacity-100 transition-all duration-300 translate-x-2 group-hover:translate-x-0", children: /* @__PURE__ */ (0, import_jsx_runtime16.jsx)(Play, { size: 14, className: "text-slate-600 dark:text-slate-300" }) })
        ]
      }
    );
  };
  var ExerciseCard = ({ exercise, onStart, onToggleFavorite, theme }) => {
    const { t } = useTranslation();
    const categoryStyle = CATEGORY_STYLES[exercise.category] || CATEGORY_STYLES.technique;
    return /* @__PURE__ */ (0, import_jsx_runtime16.jsxs)(
      "div",
      {
        onClick: onStart,
        className: "group relative p-4 rounded-xl bg-white/70 dark:bg-slate-800/40 backdrop-blur-md border border-slate-200/50 dark:border-slate-700/50 shadow-sm hover:shadow-lg hover:scale-[1.02] transition-all duration-300 cursor-pointer overflow-hidden",
        children: [
          /* @__PURE__ */ (0, import_jsx_runtime16.jsx)(
            "button",
            {
              onClick: (e) => {
                e.stopPropagation();
                onToggleFavorite();
              },
              className: "absolute top-2 right-2 z-10 p-1.5 rounded-full bg-amber-400/20 hover:bg-amber-400/30 transition-all hover:scale-110",
              "aria-label": t("favorites"),
              children: /* @__PURE__ */ (0, import_jsx_runtime16.jsx)(Star, { size: 14, className: "text-amber-400 fill-amber-400" })
            }
          ),
          /* @__PURE__ */ (0, import_jsx_runtime16.jsxs)("div", { className: "flex items-center gap-2 mb-2", children: [
            /* @__PURE__ */ (0, import_jsx_runtime16.jsx)("div", { className: `w-2 h-2 rounded-full ${categoryStyle.bg} ${categoryStyle.color.replace("text-", "bg-")}` }),
            /* @__PURE__ */ (0, import_jsx_runtime16.jsx)("span", { className: `text-[10px] font-bold uppercase tracking-wide ${categoryStyle.color}`, children: t(exercise.category) }),
            exercise.isAIGenerated && /* @__PURE__ */ (0, import_jsx_runtime16.jsx)(Sparkles, { size: 12, className: "text-violet-500" })
          ] }),
          /* @__PURE__ */ (0, import_jsx_runtime16.jsx)("h4", { className: "font-semibold text-slate-800 dark:text-slate-200 pr-6 mb-1 line-clamp-1", children: exercise.isAIGenerated ? exercise.name : t(exercise.name) }),
          /* @__PURE__ */ (0, import_jsx_runtime16.jsx)("p", { className: "text-xs text-slate-500 dark:text-slate-400 line-clamp-2", children: exercise.isAIGenerated ? exercise.desc : t(exercise.desc) }),
          /* @__PURE__ */ (0, import_jsx_runtime16.jsx)("div", { className: "absolute bottom-2 right-2 p-1.5 rounded-full bg-slate-100 dark:bg-slate-700/50 opacity-0 group-hover:opacity-100 transition-all duration-300", children: /* @__PURE__ */ (0, import_jsx_runtime16.jsx)(Play, { size: 12, className: "text-slate-600 dark:text-slate-300" }) })
        ]
      }
    );
  };
  var EmptyState = ({ type, theme }) => {
    const { t } = useTranslation();
    return /* @__PURE__ */ (0, import_jsx_runtime16.jsxs)("div", { className: "flex flex-col items-center justify-center py-12 px-6 rounded-2xl bg-slate-50/50 dark:bg-slate-800/20 border border-dashed border-slate-200 dark:border-slate-700", children: [
      /* @__PURE__ */ (0, import_jsx_runtime16.jsx)("div", { className: `p-4 rounded-full bg-gradient-to-br ${theme.button.from} ${theme.button.to} opacity-20 mb-4`, children: type === "routines" ? /* @__PURE__ */ (0, import_jsx_runtime16.jsx)(ListMusic, { size: 32, className: "text-white" }) : /* @__PURE__ */ (0, import_jsx_runtime16.jsx)(Music, { size: 32, className: "text-white" }) }),
      /* @__PURE__ */ (0, import_jsx_runtime16.jsx)("p", { className: "text-slate-400 dark:text-slate-500 text-sm text-center mb-2", children: t(type === "routines" ? "emptyFavoritesRoutines" : "emptyFavoritesExercises") }),
      /* @__PURE__ */ (0, import_jsx_runtime16.jsx)("p", { className: "text-slate-300 dark:text-slate-600 text-xs text-center", children: type === "routines" ? "Toque na \u2B50 em uma rotina para adicionar aqui" : "Toque na \u2B50 em um exerc\xEDcio para adicionar aqui" })
    ] });
  };
  var FavoritesView = ({
    currentTheme,
    favoriteRoutineIds,
    favoriteExerciseIds,
    savedAIExercises,
    onStartRoutine,
    onSelectExercise,
    onToggleFavoriteRoutine,
    onToggleFavoriteExercise
  }) => {
    const { t } = useTranslation();
    const [activeTab, setActiveTab] = (0, import_react13.useState)("routines");
    const allExercises = (0, import_react13.useMemo)(() => [...EXERCISES, ...savedAIExercises], [savedAIExercises]);
    const favoriteRoutines = (0, import_react13.useMemo)(() => {
      return ROUTINES.filter((routine) => favoriteRoutineIds.includes(routine.id));
    }, [favoriteRoutineIds]);
    const favoriteExercises = (0, import_react13.useMemo)(() => {
      return allExercises.filter((exercise) => favoriteExerciseIds.includes(exercise.exercise_id));
    }, [favoriteExerciseIds, allExercises]);
    const totalFavorites = favoriteRoutines.length + favoriteExercises.length;
    return /* @__PURE__ */ (0, import_jsx_runtime16.jsx)("section", { className: "flex-grow flex flex-col items-center justify-center w-full -mt-24 md:mt-0", children: /* @__PURE__ */ (0, import_jsx_runtime16.jsxs)("div", { className: "w-full space-y-6", children: [
      totalFavorites > 0 && /* @__PURE__ */ (0, import_jsx_runtime16.jsxs)("div", { className: "flex items-center gap-2 mb-6", children: [
        /* @__PURE__ */ (0, import_jsx_runtime16.jsx)(Star, { size: 16, className: "text-amber-400 fill-amber-400" }),
        /* @__PURE__ */ (0, import_jsx_runtime16.jsxs)("span", { className: "text-sm text-slate-500 dark:text-slate-400", children: [
          totalFavorites,
          " ",
          totalFavorites === 1 ? "favorito" : "favoritos"
        ] })
      ] }),
      /* @__PURE__ */ (0, import_jsx_runtime16.jsxs)("div", { className: "flex gap-3 mb-6", children: [
        /* @__PURE__ */ (0, import_jsx_runtime16.jsxs)(
          "button",
          {
            onClick: () => setActiveTab("routines"),
            className: `flex items-center gap-2 px-5 py-3 rounded-full font-semibold text-sm transition-all duration-300 ${activeTab === "routines" ? `bg-gradient-to-r ${currentTheme.button.from} ${currentTheme.button.via} ${currentTheme.button.to} text-white shadow-lg shadow-${currentTheme.button.shadow}` : "bg-white/60 dark:bg-slate-800/50 text-slate-500 dark:text-slate-400 hover:bg-white dark:hover:bg-slate-700/50 border border-slate-200/50 dark:border-slate-700"}`,
            children: [
              /* @__PURE__ */ (0, import_jsx_runtime16.jsx)(ListMusic, { size: 16 }),
              t("routinesTitle"),
              favoriteRoutines.length > 0 && /* @__PURE__ */ (0, import_jsx_runtime16.jsx)("span", { className: `px-2 py-0.5 rounded-full text-xs font-bold ${activeTab === "routines" ? "bg-white/25" : "bg-slate-100 dark:bg-slate-700"}`, children: favoriteRoutines.length })
            ]
          }
        ),
        /* @__PURE__ */ (0, import_jsx_runtime16.jsxs)(
          "button",
          {
            onClick: () => setActiveTab("exercises"),
            className: `flex items-center gap-2 px-5 py-3 rounded-full font-semibold text-sm transition-all duration-300 ${activeTab === "exercises" ? `bg-gradient-to-r ${currentTheme.button.from} ${currentTheme.button.via} ${currentTheme.button.to} text-white shadow-lg shadow-${currentTheme.button.shadow}` : "bg-white/60 dark:bg-slate-800/50 text-slate-500 dark:text-slate-400 hover:bg-white dark:hover:bg-slate-700/50 border border-slate-200/50 dark:border-slate-700"}`,
            children: [
              /* @__PURE__ */ (0, import_jsx_runtime16.jsx)(Music, { size: 16 }),
              t("exercisesTitle"),
              favoriteExercises.length > 0 && /* @__PURE__ */ (0, import_jsx_runtime16.jsx)("span", { className: `px-2 py-0.5 rounded-full text-xs font-bold ${activeTab === "exercises" ? "bg-white/25" : "bg-slate-100 dark:bg-slate-700"}`, children: favoriteExercises.length })
            ]
          }
        )
      ] }),
      /* @__PURE__ */ (0, import_jsx_runtime16.jsx)("div", { className: "flex-grow pb-32", children: activeTab === "routines" ? favoriteRoutines.length > 0 ? /* @__PURE__ */ (0, import_jsx_runtime16.jsx)("div", { className: "grid grid-cols-1 md:grid-cols-2 gap-4 animate-fade-in", children: favoriteRoutines.map((routine) => /* @__PURE__ */ (0, import_jsx_runtime16.jsx)(
        RoutineCard2,
        {
          routine,
          onStart: () => onStartRoutine(routine),
          onToggleFavorite: () => onToggleFavoriteRoutine(routine.id),
          theme: currentTheme
        },
        routine.id
      )) }) : /* @__PURE__ */ (0, import_jsx_runtime16.jsx)(EmptyState, { type: "routines", theme: currentTheme }) : favoriteExercises.length > 0 ? /* @__PURE__ */ (0, import_jsx_runtime16.jsx)("div", { className: "grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-3 animate-fade-in", children: favoriteExercises.map((exercise) => /* @__PURE__ */ (0, import_jsx_runtime16.jsx)(
        ExerciseCard,
        {
          exercise,
          onStart: () => onSelectExercise(exercise),
          onToggleFavorite: () => onToggleFavoriteExercise(exercise.exercise_id),
          theme: currentTheme
        },
        exercise.exercise_id
      )) }) : /* @__PURE__ */ (0, import_jsx_runtime16.jsx)(EmptyState, { type: "exercises", theme: currentTheme }) })
    ] }) });
  };
  var FavoritesView_default = FavoritesView;

  // components/FeedbackOverlay.tsx
  var import_react14 = __toESM(require_react());
  var import_jsx_runtime17 = __toESM(require_jsx_runtime());
  var FeedbackOverlay = ({ currentTheme, activeView, currentExercise, currentRoutine, uiView }) => {
    const { t } = useTranslation();
    const [isOpen, setIsOpen] = (0, import_react14.useState)(false);
    const [email, setEmail] = (0, import_react14.useState)("");
    const [feedback, setFeedback] = (0, import_react14.useState)("");
    const [status, setStatus] = (0, import_react14.useState)("idle");
    const handleSubmit = async (e) => {
      e.preventDefault();
      setStatus("submitting");
      const formData = new FormData();
      formData.append("form-name", "beta-feedback");
      formData.append("email", email);
      let contextInfo = `

--- Context ---
`;
      contextInfo += `View: ${activeView || "unknown"}
`;
      contextInfo += `UI State: ${uiView || "main"}
`;
      if (currentExercise) {
        contextInfo += `Exercise: ${currentExercise.name} (ID: ${currentExercise.id})
`;
      }
      if (currentRoutine) {
        contextInfo += `Routine: ${currentRoutine.routine.name} (Exercise ${currentRoutine.exerciseIndex + 1})
`;
      }
      contextInfo += `Device: ${/Mobi|Android/i.test(navigator.userAgent) ? "Mobile" : "Desktop"}
`;
      contextInfo += `Timestamp: ${(/* @__PURE__ */ new Date()).toISOString()}`;
      formData.append("feedback", feedback + contextInfo);
      try {
        await fetch("/", {
          method: "POST",
          headers: { "Content-Type": "application/x-www-form-urlencoded" },
          body: new URLSearchParams(formData).toString()
        });
        setStatus("success");
        setTimeout(() => {
          setIsOpen(false);
          setStatus("idle");
          setFeedback("");
          setEmail("");
        }, 2e3);
      } catch (error) {
        console.error("Feedback error:", error);
        setStatus("error");
      }
    };
    return /* @__PURE__ */ (0, import_jsx_runtime17.jsxs)(import_jsx_runtime17.Fragment, { children: [
      /* @__PURE__ */ (0, import_jsx_runtime17.jsx)(
        "button",
        {
          onClick: () => setIsOpen(true),
          className: "fixed top-24 right-4 z-[100] px-4 py-2 rounded-full bg-yellow-400/80 dark:bg-yellow-500/80 backdrop-blur-md border border-yellow-500/50 dark:border-yellow-400/50 text-sm font-bold text-yellow-900 dark:text-yellow-950 hover:bg-yellow-400 dark:hover:bg-yellow-500 transition-all duration-300 shadow-lg hover:shadow-xl hover:scale-105",
          children: t("feedback")
        }
      ),
      isOpen && /* @__PURE__ */ (0, import_jsx_runtime17.jsx)("div", { className: "fixed inset-0 z-[110] flex items-center justify-center p-4 bg-black/20 backdrop-blur-sm animate-fade-in", children: /* @__PURE__ */ (0, import_jsx_runtime17.jsxs)("div", { className: "bg-white/90 dark:bg-slate-900/90 backdrop-blur-xl rounded-2xl p-6 w-full max-w-sm shadow-2xl border border-white/50 dark:border-slate-700 animate-fade-in-scale", children: [
        /* @__PURE__ */ (0, import_jsx_runtime17.jsxs)("div", { className: "flex justify-between items-center mb-4", children: [
          /* @__PURE__ */ (0, import_jsx_runtime17.jsx)("h3", { className: "text-lg font-bold text-slate-800 dark:text-slate-100", children: t("sendFeedback") }),
          /* @__PURE__ */ (0, import_jsx_runtime17.jsx)(
            "button",
            {
              onClick: () => setIsOpen(false),
              className: "text-slate-400 hover:text-slate-600 dark:hover:text-slate-200 transition-colors",
              children: /* @__PURE__ */ (0, import_jsx_runtime17.jsx)("svg", { className: "w-5 h-5", fill: "none", viewBox: "0 0 24 24", stroke: "currentColor", children: /* @__PURE__ */ (0, import_jsx_runtime17.jsx)("path", { strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 2, d: "M6 18L18 6M6 6l12 12" }) })
            }
          )
        ] }),
        status === "success" ? /* @__PURE__ */ (0, import_jsx_runtime17.jsx)("div", { className: "text-center py-8 text-green-600 dark:text-green-400 font-medium animate-fade-in", children: t("feedbackSent") }) : /* @__PURE__ */ (0, import_jsx_runtime17.jsxs)("form", { onSubmit: handleSubmit, className: "space-y-4", name: "beta-feedback", "data-netlify": "true", "netlify-honeypot": "bot-field", children: [
          /* @__PURE__ */ (0, import_jsx_runtime17.jsx)("input", { type: "hidden", name: "form-name", value: "beta-feedback" }),
          /* @__PURE__ */ (0, import_jsx_runtime17.jsx)("p", { className: "hidden", children: /* @__PURE__ */ (0, import_jsx_runtime17.jsxs)("label", { children: [
            "Don\u2019t fill this out if you\u2019re human: ",
            /* @__PURE__ */ (0, import_jsx_runtime17.jsx)("input", { name: "bot-field" })
          ] }) }),
          /* @__PURE__ */ (0, import_jsx_runtime17.jsxs)("div", { children: [
            /* @__PURE__ */ (0, import_jsx_runtime17.jsx)("label", { className: "block text-xs font-semibold text-slate-600 dark:text-slate-400 mb-1", children: t("emailOptional") }),
            /* @__PURE__ */ (0, import_jsx_runtime17.jsx)(
              "input",
              {
                type: "email",
                name: "email",
                value: email,
                onChange: (e) => setEmail(e.target.value),
                className: "w-full px-3 py-2 rounded-lg bg-slate-100 dark:bg-slate-800 border-transparent focus:border-violet-500 focus:bg-white dark:focus:bg-slate-900 focus:ring-0 text-sm transition-colors",
                placeholder: "you@example.com"
              }
            )
          ] }),
          /* @__PURE__ */ (0, import_jsx_runtime17.jsxs)("div", { children: [
            /* @__PURE__ */ (0, import_jsx_runtime17.jsx)("label", { className: "block text-xs font-semibold text-slate-600 dark:text-slate-400 mb-1", children: t("yourFeedback") }),
            /* @__PURE__ */ (0, import_jsx_runtime17.jsx)(
              "textarea",
              {
                required: true,
                name: "feedback",
                value: feedback,
                onChange: (e) => setFeedback(e.target.value),
                rows: 4,
                className: "w-full px-3 py-2 rounded-lg bg-slate-100 dark:bg-slate-800 border-transparent focus:border-violet-500 focus:bg-white dark:focus:bg-slate-900 focus:ring-0 text-sm transition-colors resize-none",
                placeholder: "Tell us what you think..."
              }
            )
          ] }),
          status === "error" && /* @__PURE__ */ (0, import_jsx_runtime17.jsx)("p", { className: "text-xs text-red-500 text-center", children: t("feedbackError") }),
          /* @__PURE__ */ (0, import_jsx_runtime17.jsx)(
            ThemedButton_default,
            {
              theme: currentTheme,
              type: "submit",
              className: "w-full justify-center",
              disabled: status === "submitting",
              children: status === "submitting" ? t("processing") : t("sendFeedback")
            }
          )
        ] })
      ] }) })
    ] });
  };
  var FeedbackOverlay_default = FeedbackOverlay;

  // components/AIExerciseView.tsx
  var import_react15 = __toESM(require_react());
  var import_jsx_runtime18 = __toESM(require_jsx_runtime());
  var AIExerciseView = ({
    exercise,
    currentTheme,
    themeMode,
    language,
    vocalRange,
    onBack,
    onEdit
  }) => {
    const iframeRef = (0, import_react15.useRef)(null);
    (0, import_react15.useEffect)(() => {
      const sendExerciseData = () => {
        if (iframeRef.current?.contentWindow) {
          console.log("\u{1F4E4} Sending AI Exercise to Pitch Perfector...");
          iframeRef.current.contentWindow.postMessage({
            type: "VOXLAB_AI_EXERCISE",
            exercise,
            theme: currentTheme,
            mode: themeMode,
            language,
            vocalRange
          }, window.location.origin);
        }
      };
      const handleMessage = (event) => {
        if (event.origin !== window.location.origin)
          return;
        if (event.data.type === "PITCH_PERFECTOR_READY") {
          console.log("\u2705 Pitch Perfector is ready! Sending data...");
          sendExerciseData();
        } else if (event.data.type === "PP_BACK_TO_AI") {
          onBack();
        } else if (event.data.type === "PP_EDIT_EXERCISE") {
          onEdit();
        }
      };
      window.addEventListener("message", handleMessage);
      const intervalId = setInterval(sendExerciseData, 500);
      const timeoutId = setTimeout(() => clearInterval(intervalId), 2e3);
      return () => {
        window.removeEventListener("message", handleMessage);
        clearInterval(intervalId);
        clearTimeout(timeoutId);
      };
    }, [exercise, currentTheme, themeMode, language, vocalRange, onBack, onEdit]);
    return /* @__PURE__ */ (0, import_jsx_runtime18.jsx)(
      "div",
      {
        className: "fixed top-0 left-0 w-screen h-screen z-[9999]",
        style: {
          position: "fixed",
          top: 0,
          left: 0,
          width: "100vw",
          height: "100vh",
          margin: 0,
          padding: 0
        },
        children: /* @__PURE__ */ (0, import_jsx_runtime18.jsx)(
          "iframe",
          {
            ref: iframeRef,
            src: "/pitch-perfector2/index.html?mode=ai",
            className: "border-0",
            style: {
              position: "absolute",
              top: 0,
              left: 0,
              width: "100%",
              height: "100%",
              border: "none",
              margin: 0,
              padding: 0
            },
            title: "AI Exercise Player",
            allow: "microphone"
          }
        )
      }
    );
  };
  var AIExerciseView_default = AIExerciseView;

  // visuals/sphere_v2.mp4
  var sphere_v2_default = "./sphere_v2-UK2BZGZM.mp4";

  // App.tsx
  var import_jsx_runtime19 = __toESM(require_jsx_runtime());
  var CUSTOM_SAMPLES_URL = "/sounds/";
  var pitchProcessorCode = `
class PitchProcessor extends AudioWorkletProcessor {
    constructor(options) {
        super();
        this.analysisBufferSize = 2048;
        this.buffer = new Float32Array(this.analysisBufferSize);
        this.bufferPos = 0;
        this.lastGain = 0;
        this.noiseGateThreshold = options.processorOptions.noiseGateThreshold || 0.008;
        this.algorithm = options.processorOptions.algorithm || 'pyin'; // Default to pyin
        
        // pYIN-specific parameters
        this.pyinBias = options.processorOptions.pyinBias || 2.0;
        this.pyinGateMode = options.processorOptions.pyinGateMode || 'smooth';
        this.pyinHistory = null; // For temporal smoothing
        this.smoothRms = 0; // For smooth gate mode
        
        this.port.onmessage = (event) => {
            if (event.data.noiseGateThreshold !== undefined) {
                this.noiseGateThreshold = event.data.noiseGateThreshold;
            }
            if (event.data.algorithm) {
                this.algorithm = event.data.algorithm;
            }
            if (event.data.pyinBias !== undefined) {
                this.pyinBias = event.data.pyinBias;
            }
            if (event.data.pyinGateMode) {
                this.pyinGateMode = event.data.pyinGateMode;
            }
        };
    }


    static get parameterDescriptors() {
        return [];
    }
    
    // McLeod Pitch Method (MPM) - professional-grade pitch detection for voice
    mcleodPitchMethod(buffer, sampleRate) {
        const bufferSize = buffer.length;
        const minPeriod = Math.floor(sampleRate / 2000); // 2000 Hz max
        const maxPeriod = Math.floor(sampleRate / 30);   // 30 Hz min
        
        // Step 1: Normalized Square Difference Function (NSDF)
        const nsdf = new Array(maxPeriod + 1).fill(0);
        
        for (let tau = 0; tau <= maxPeriod; tau++) {
            let acf = 0;
            let divisorM = 0;
            
            for (let i = 0; i < bufferSize - tau; i++) {
                acf += buffer[i] * buffer[i + tau];
                divisorM += buffer[i] * buffer[i] + buffer[i + tau] * buffer[i + tau];
            }
            
            nsdf[tau] = divisorM > 0 ? (2 * acf) / divisorM : 0;
        }
        
        // Step 2: Peak picking - find positive zero crossings
        const peaks = [];
        for (let tau = minPeriod; tau < maxPeriod - 1; tau++) {
            if (nsdf[tau] > 0 && nsdf[tau] > nsdf[tau - 1] && nsdf[tau] >= nsdf[tau + 1]) {
                peaks.push({ period: tau, clarity: nsdf[tau] });
            }
        }
        
        if (peaks.length === 0) return -1;
        
        // Step 3: Find the best peak (highest clarity above threshold)
        peaks.sort((a, b) => b.clarity - a.clarity);
        const bestPeak = peaks[0];
        
        if (bestPeak.clarity < 0.90) return -1; // Very strong clarity threshold for stability
        
        // Step 4: Parabolic interpolation for sub-sample accuracy
        const tau = bestPeak.period;
        const y1 = nsdf[tau - 1];
        const y2 = nsdf[tau];
        const y3 = nsdf[tau + 1];
        
        const delta = 0.5 * (y3 - y1) / (2 * y2 - y1 - y3);
        const refinedPeriod = tau + delta;
        
        return sampleRate / refinedPeriod;
    }

    // YIN Algorithm - simpler, faster alternative
    yinPitchMethod(buffer, sampleRate) {
        const bufferSize = buffer.length;
        const threshold = 0.15; // Lower = more strict
        const minPeriod = Math.floor(sampleRate / 2000);
        const maxPeriod = Math.floor(sampleRate / 30);
        
        // Step 1: Difference function
        const diff = new Float32Array(maxPeriod + 1);
        for (let tau = 0; tau <= maxPeriod; tau++) {
            let sum = 0;
            for (let i = 0; i < bufferSize - tau; i++) {
                const delta = buffer[i] - buffer[i + tau];
                sum += delta * delta;
            }
            diff[tau] = sum;
        }
        
        // Step 2: Cumulative mean normalized difference
        const cmndf = new Float32Array(maxPeriod + 1);
        cmndf[0] = 1;
        let runningSum = 0;
        for (let tau = 1; tau <= maxPeriod; tau++) {
            runningSum += diff[tau];
            cmndf[tau] = diff[tau] / (runningSum / tau);
        }
        
        // Step 3: Absolute threshold
        let tau = minPeriod;
        while (tau < maxPeriod) {
            if (cmndf[tau] < threshold) {
                while (tau + 1 < maxPeriod && cmndf[tau + 1] < cmndf[tau]) {
                    tau++;
                }
                break;
            }
            tau++;
        }
        
        if (tau >= maxPeriod || cmndf[tau] >= threshold) return -1;
        
        // Step 4: Parabolic interpolation
        let betterTau = tau;
        if (tau > 0 && tau < maxPeriod) {
            const s0 = cmndf[tau - 1];
            const s1 = cmndf[tau];
            const s2 = cmndf[tau + 1];
            betterTau = tau + (s2 - s0) / (2 * (2 * s1 - s2 - s0));
        }
        
        return sampleRate / betterTau;
    }

    // PYIN Algorithm - Probabilistic YIN with better accuracy (IMPROVED VERSION)
    pyinPitchMethod(buffer, sampleRate) {
        const bufferSize = buffer.length;
        
        // 1. Instantaneous RMS Calculation
        let instantRms = 0;
        for (let i = 0; i < bufferSize; i++) {
            instantRms += buffer[i] * buffer[i];
        }
        instantRms = Math.sqrt(instantRms / bufferSize);

        // 2. Smoothed RMS (Attack/Release smoothing)
        const SMOOTHING_FACTOR = 0.95;
        this.smoothRms = (instantRms * (1 - SMOOTHING_FACTOR)) + (this.smoothRms * SMOOTHING_FACTOR);

        // 3. Noise Gate Logic
        let rmsToUse = this.pyinGateMode === 'smooth' ? this.smoothRms : instantRms;

        // The gate is only active if the threshold is > 0
        if (this.noiseGateThreshold > 0 && rmsToUse < this.noiseGateThreshold) {
            // Signal is too quiet
            this.pyinHistory = null;
            return -1;
        }

        // 4. YIN Steps 1 & 2: Difference & Cumulative Mean Normalization
        const yinBufferLength = Math.floor(bufferSize / 2);
        const yinBuffer = new Float32Array(yinBufferLength);

        for (let t = 0; t < yinBufferLength; t++) {
            yinBuffer[t] = 0;
            for (let i = 0; i < yinBufferLength; i++) {
                const delta = buffer[i] - buffer[i + t];
                yinBuffer[t] += delta * delta;
            }
        }
        yinBuffer[0] = 1;
        let runningSum = 0;
        for (let t = 1; t < yinBufferLength; t++) {
            runningSum += yinBuffer[t];
            // IMPROVED: Protect against division by zero
            if (runningSum === 0) {
                yinBuffer[t] = 1;
            } else {
                yinBuffer[t] *= t / runningSum;
            }
        }

        // 5. Candidate Collection (find all valleys)
        let candidates = [];
        for (let t = 2; t < yinBufferLength - 1; t++) {
            if (yinBuffer[t] < yinBuffer[t-1] && yinBuffer[t] < yinBuffer[t+1]) {
                if (yinBuffer[t] < 1.0) {
                    candidates.push({ tau: t, error: yinBuffer[t] });
                }
            }
        }

        if (candidates.length === 0) {
            this.pyinHistory = null;
            return -1;
        }

        // 6. Scoring: Combine Error Probability with Transition Probability
        let bestScore = -1;
        let bestTau = -1;

        candidates.forEach(cand => {
            // Base probability: lower error is better
            let prob = Math.pow(1 - cand.error, 4);

            // History Bias: Stick to previous note (Only apply if bias > 0)
            if (this.pyinHistory && this.pyinHistory > 0 && this.pyinBias > 0) {
                const prevTau = sampleRate / this.pyinHistory;
                const ratio = Math.abs(cand.tau - prevTau) / prevTau;
                
                if (ratio < 0.1) {
                    prob *= (1 + this.pyinBias); // Strongly prefer continuity
                } else if (Math.abs(ratio - 0.5) < 0.05) {
                    prob *= 0.5; // Penalize octave jumps
                }
            }

            if (prob > bestScore) {
                bestScore = prob;
                bestTau = cand.tau;
            }
        });

        if (bestScore < 0.01) {
            this.pyinHistory = null;
            return -1;
        }

        // 7. Parabolic refinement - IMPROVED: Bounds checking
        if (bestTau <= 0 || bestTau >= yinBufferLength - 1) {
            this.pyinHistory = null;
            return -1;
        }

        let s0 = yinBuffer[bestTau - 1];
        let s1 = yinBuffer[bestTau];
        let s2 = yinBuffer[bestTau + 1];
        let adjustment = (s2 - s0) / (2 * (2 * s1 - s2 - s0));
        const finalTau = bestTau + adjustment;

        const pitch = sampleRate / finalTau;
        this.pyinHistory = pitch;
        return pitch;
    }

    // SWIPE Algorithm - Sawtooth Waveform Inspired Pitch Estimator
    swipePitchMethod(buffer, sampleRate) {
        const bufferSize = buffer.length;
        const minFreq = 30;
        const maxFreq = 2000;
        const numCandidates = 100;
        
        // Generate candidate frequencies (log-spaced)
        const candidates = [];
        const logMin = Math.log(minFreq);
        const logMax = Math.log(maxFreq);
        for (let i = 0; i < numCandidates; i++) {
            const logFreq = logMin + (logMax - logMin) * i / (numCandidates - 1);
            candidates.push(Math.exp(logFreq));
        }
        
        // Calculate strength for each candidate
        let maxStrength = 0;
        let bestFreq = -1;
        
        for (const freq of candidates) {
            const period = sampleRate / freq;
            let strength = 0;
            let count = 0;
            
            // Prime-based subharmonic summation
            for (let k = 1; k <= 5; k++) {
                const tau = Math.round(period * k);
                if (tau < bufferSize) {
                    let localSum = 0;
                    for (let i = 0; i < bufferSize - tau; i++) {
                        localSum += buffer[i] * buffer[i + tau];
                    }
                    strength += localSum / k;
                    count++;
                }
            }
            
            if (count > 0) {
                strength /= count;
                if (strength > maxStrength) {
                    maxStrength = strength;
                    bestFreq = freq;
                }
            }
        }
        
        return maxStrength > 0.01 ? bestFreq : -1;
    }

    // HPS Algorithm - Harmonic Product Spectrum
    hpsPitchMethod(buffer, sampleRate) {
        const bufferSize = buffer.length;
        const fftSize = 2048;
        
        // Simple FFT approximation using autocorrelation
        const spectrum = new Float32Array(fftSize / 2);
        for (let k = 0; k < fftSize / 2; k++) {
            let real = 0, imag = 0;
            for (let n = 0; n < Math.min(bufferSize, fftSize); n++) {
                const angle = -2 * Math.PI * k * n / fftSize;
                real += buffer[n] * Math.cos(angle);
                imag += buffer[n] * Math.sin(angle);
            }
            spectrum[k] = Math.sqrt(real * real + imag * imag);
        }
        
        // Harmonic Product Spectrum (multiply downsampled versions)
        const hps = new Float32Array(fftSize / 2);
        for (let i = 0; i < fftSize / 2; i++) {
            hps[i] = spectrum[i];
        }
        
        // Multiply with 2nd, 3rd, 4th harmonics
        for (let harmonic = 2; harmonic <= 4; harmonic++) {
            for (let i = 0; i < fftSize / (2 * harmonic); i++) {
                hps[i] *= spectrum[i * harmonic];
            }
        }
        
        // Find peak in HPS
        let maxVal = 0;
        let maxIdx = 0;
        const minBin = Math.floor(30 * fftSize / sampleRate);
        const maxBin = Math.floor(2000 * fftSize / sampleRate);
        
        for (let i = minBin; i < maxBin && i < hps.length; i++) {
            if (hps[i] > maxVal) {
                maxVal = hps[i];
                maxIdx = i;
            }
        }
        
        if (maxVal < 0.01) return -1;
        
        // Convert bin to frequency
        return maxIdx * sampleRate / fftSize;
    }


    process(inputs, outputs, parameters) {
        const input = inputs[0];
        if (input.length > 0) {
            const channelData = input[0];
            let sum = 0;
            for (let i = 0; i < channelData.length; i++) {
                sum += channelData[i] * channelData[i];
            }
            this.lastGain = Math.sqrt(sum / channelData.length);
            const remainingSpace = this.analysisBufferSize - this.bufferPos;
            const toCopy = Math.min(channelData.length, remainingSpace);
            this.buffer.set(channelData.subarray(0, toCopy), this.bufferPos);
            this.bufferPos += toCopy;
            
            if (this.bufferPos >= this.analysisBufferSize) {
                let pitch = -1;
                if (this.lastGain > this.noiseGateThreshold) { 
                    // Select algorithm
                    if (this.algorithm === 'yin') {
                        pitch = this.yinPitchMethod(this.buffer, sampleRate);
                    } else if (this.algorithm === 'pyin') {
                        pitch = this.pyinPitchMethod(this.buffer, sampleRate);
                    } else if (this.algorithm === 'swipe') {
                        pitch = this.swipePitchMethod(this.buffer, sampleRate);
                    } else if (this.algorithm === 'hps') {
                        pitch = this.hpsPitchMethod(this.buffer, sampleRate);
                    } else {
                        pitch = this.mcleodPitchMethod(this.buffer, sampleRate);
                    }
                }
                this.port.postMessage({ pitch, gain: this.lastGain });
                this.bufferPos = 0;
            } else {
                 this.port.postMessage({ gain: this.lastGain });
            }
        }
        return true;
    }
}
try {
    registerProcessor('pitch-processor', PitchProcessor);
} catch (e) {
    // Processor already registered, this is fine

}
`;
  var VocalRangeDisplay = import_react16.default.memo(({ range, theme, onClick }) => {
    const { t } = useTranslation();
    const isSet = range.start && range.end;
    const rangeText = isSet ? `${range.start.name} - ${range.end.name}` : t("rangeNotSet");
    return /* @__PURE__ */ (0, import_jsx_runtime19.jsx)(
      "button",
      {
        onClick,
        className: `btn-interactive text-xs font-bold z-10 px-3 py-1.5 rounded-full shadow-sm backdrop-blur-sm ${isSet ? `bg-white/60 dark:bg-slate-800/30 border border-slate-200/50 dark:border-slate-700` : `text-slate-500 bg-slate-200/50 hover:bg-slate-200/80 dark:bg-slate-700/50 dark:hover:bg-slate-700/80 border border-slate-300/50 dark:border-slate-600`}`,
        children: /* @__PURE__ */ (0, import_jsx_runtime19.jsx)("span", { className: `bg-clip-text text-transparent bg-gradient-to-br ${theme.gradientText.from} ${theme.gradientText.to} ${theme.gradientText.darkFrom} ${theme.gradientText.darkTo}`, children: rangeText })
      }
    );
  });
  var RangeCheckModal = import_react16.default.memo(({ onDefine, onContinue, theme }) => {
    const { t } = useTranslation();
    const [show, setShow] = (0, import_react16.useState)(false);
    (0, import_react16.useEffect)(() => {
      const timer = requestAnimationFrame(() => setShow(true));
      return () => cancelAnimationFrame(timer);
    }, []);
    const handleClose = (0, import_react16.useCallback)((callback) => {
      setShow(false);
      setTimeout(callback, 300);
    }, []);
    return /* @__PURE__ */ (0, import_jsx_runtime19.jsx)("div", { className: `fixed inset-0 bg-black/20 backdrop-blur-md z-[100] flex items-center justify-center p-4 transition-opacity duration-300 ease-out ${show ? "opacity-100" : "opacity-0"}`, children: /* @__PURE__ */ (0, import_jsx_runtime19.jsxs)("div", { className: `bg-white/80 dark:bg-slate-900/80 backdrop-blur-xl rounded-2xl p-6 max-w-sm w-full shadow-lg text-center transition-all duration-300 ease-out ${show ? "opacity-100 scale-100" : "opacity-0 scale-95"}`, children: [
      /* @__PURE__ */ (0, import_jsx_runtime19.jsx)("h3", { className: "text-xl font-bold text-black dark:text-white mb-2", children: t("rangeCheckTitle") }),
      /* @__PURE__ */ (0, import_jsx_runtime19.jsx)("p", { className: "text-slate-600 dark:text-slate-300 mb-6", children: t("rangeCheckPrompt") }),
      /* @__PURE__ */ (0, import_jsx_runtime19.jsxs)("div", { className: "flex flex-col sm:flex-row gap-3", children: [
        /* @__PURE__ */ (0, import_jsx_runtime19.jsx)("button", { onClick: () => handleClose(onContinue), className: "btn-interactive flex-1 px-4 py-2.5 rounded-full font-semibold text-slate-700 dark:text-slate-200 bg-transparent backdrop-blur-sm border border-slate-400 dark:border-slate-500 shadow-sm hover:bg-slate-400/10 dark:hover:bg-slate-800/20", children: t("continueAnyway") }),
        /* @__PURE__ */ (0, import_jsx_runtime19.jsx)(ThemedButton_default, { theme, onClick: () => handleClose(onDefine), children: t("defineRange") })
      ] })
    ] }) });
  });
  var RoutineCompleteModal = import_react16.default.memo(({ onFinish, theme }) => {
    const { t } = useTranslation();
    const [show, setShow] = (0, import_react16.useState)(false);
    (0, import_react16.useEffect)(() => {
      const timer = requestAnimationFrame(() => setShow(true));
      return () => cancelAnimationFrame(timer);
    }, []);
    const handleClose = (0, import_react16.useCallback)(() => {
      setShow(false);
      setTimeout(onFinish, 300);
    }, [onFinish]);
    return /* @__PURE__ */ (0, import_jsx_runtime19.jsx)("div", { className: `fixed inset-0 bg-black/20 backdrop-blur-md z-[100] flex items-center justify-center p-4 transition-opacity duration-300 ease-out ${show ? "opacity-100" : "opacity-0"}`, children: /* @__PURE__ */ (0, import_jsx_runtime19.jsxs)("div", { className: `bg-white/80 dark:bg-slate-900/80 backdrop-blur-xl rounded-2xl p-6 max-w-sm w-full shadow-lg text-center transition-all duration-300 ease-out ${show ? "opacity-100 scale-100" : "opacity-0 scale-95"}`, children: [
      /* @__PURE__ */ (0, import_jsx_runtime19.jsx)("h3", { className: "text-xl font-bold text-black dark:text-white mb-2", children: t("routineComplete") }),
      /* @__PURE__ */ (0, import_jsx_runtime19.jsx)("p", { className: "text-slate-600 dark:text-slate-300 mb-6", children: t("drinkWaterSuggestion") }),
      /* @__PURE__ */ (0, import_jsx_runtime19.jsx)(ThemedButton_default, { onClick: handleClose, theme, className: "w-full", children: t("finish") })
    ] }) });
  });
  var NOTE_REGEX = /([a-gA-G])(#{1,2}|s|b{1,2})?\s*(-?\d+)$/;
  var MIDI_NOTE_REGEX = /(?:^|\D)(2[1-9]|[3-9]\d|10[0-8])(?:\D|$)/;
  var NORMALIZE_REGEX = /[_.-]/g;
  var SHARP_REGEX = /sharp/gi;
  var FLAT_REGEX = /flat/gi;
  var IS_BETA_MODE = false;
  function App() {
    const [showSplash, setShowSplash] = (0, import_react16.useState)(true);
    (0, import_react16.useEffect)(() => {
      const timer = setTimeout(() => setShowSplash(false), 2500);
      return () => clearTimeout(timer);
    }, []);
    const { t, language, setLanguage } = useTranslation();
    const [uiView, setUiView] = (0, import_react16.useState)("main");
    const uiViewRef = (0, import_react16.useRef)("main");
    const [isMenuVisible, setIsMenuVisible] = (0, import_react16.useState)(true);
    const [activeView, setActiveView] = (0, import_react16.useState)("home");
    const [vocalRange, setVocalRange] = (0, import_react16.useState)({ start: null, end: null });
    const [vocalRangeHistory, setVocalRangeHistory] = (0, import_react16.useState)([]);
    const [exerciseRange, setExerciseRange] = (0, import_react16.useState)({ start: null, end: null });
    const [showControls, setShowControls] = (0, import_react16.useState)(true);
    const [showSettings, setShowSettings] = (0, import_react16.useState)(false);
    const [showEngineSettings, setShowEngineSettings] = (0, import_react16.useState)(false);
    const [isTunerExpanded, setIsTunerExpanded] = (0, import_react16.useState)(false);
    const [showMicPermissionDialog, setShowMicPermissionDialog] = (0, import_react16.useState)(true);
    const [selectedExercise, setSelectedExercise] = (0, import_react16.useState)(null);
    const [isPlaying, setIsPlaying] = (0, import_react16.useState)(false);
    const [isExerciseComplete, setIsExerciseComplete] = (0, import_react16.useState)(false);
    const [isRoutineComplete, setIsRoutineComplete] = (0, import_react16.useState)(false);
    const [exerciseKey, setExerciseKey] = (0, import_react16.useState)(0);
    const [currentRoutine, setCurrentRoutine] = (0, import_react16.useState)(null);
    const [exerciseNoteVolume, setExerciseNoteVolume] = (0, import_react16.useState)(1);
    const [metronomeVolume, setMetronomeVolume] = (0, import_react16.useState)(0.3);
    const [micActive, setMicActive] = (0, import_react16.useState)(false);
    const [userPitch, setUserPitch] = (0, import_react16.useState)(null);
    const [micGain, setMicGain] = (0, import_react16.useState)(0);
    const [micStatus, setMicStatus] = (0, import_react16.useState)(t("micStatusActivate"));
    const [isRangeTestActive, setIsRangeTestActive] = (0, import_react16.useState)(false);
    const [showPianoForRangeSelection, setShowPianoForRangeSelection] = (0, import_react16.useState)(false);
    const [isSettingsOpen, setIsSettingsOpen] = (0, import_react16.useState)(false);
    const [themeId, setThemeId] = (0, import_react16.useState)(THEMES[0].id);
    const [themeMode, setThemeMode] = (0, import_react16.useState)("light");
    const [isRangeCheckModalOpen, setIsRangeCheckModalOpen] = (0, import_react16.useState)(false);
    const [pendingAction, setPendingAction] = (0, import_react16.useState)(null);
    const [postRangeTestAction, setPostRangeTestAction] = (0, import_react16.useState)(null);
    const [savedAIExercises, setSavedAIExercises] = (0, import_react16.useState)([]);
    const [aiResult, setAiResult] = (0, import_react16.useState)(null);
    const [favoriteExerciseIds, setFavoriteExerciseIds] = (0, import_react16.useState)([]);
    const [favoriteRoutineIds, setFavoriteRoutineIds] = (0, import_react16.useState)([]);
    const [isFullscreen, setIsFullscreen] = (0, import_react16.useState)(false);
    const [isPreviewing, setIsPreviewing] = (0, import_react16.useState)(false);
    const [loadedSampleCount, setLoadedSampleCount] = (0, import_react16.useState)(0);
    const audioCtxRef = (0, import_react16.useRef)(null);
    const micStreamRef = (0, import_react16.useRef)(null);
    const workletNodeRef = (0, import_react16.useRef)(null);
    const workletModuleAddedRef = (0, import_react16.useRef)(false);
    const masterGainRef = (0, import_react16.useRef)(null);
    const currentPlayingExerciseNoteNodesRef = (0, import_react16.useRef)(/* @__PURE__ */ new Set());
    const currentNonExerciseNoteNodesRef = (0, import_react16.useRef)(/* @__PURE__ */ new Set());
    const audioInitPromiseRef = (0, import_react16.useRef)(null);
    const previewTimersRef = (0, import_react16.useRef)([]);
    const latestPlayRequestRef = (0, import_react16.useRef)(0);
    const currentlyPlayingNotesRef = (0, import_react16.useRef)(/* @__PURE__ */ new Set());
    const instrumentLibraryRef = (0, import_react16.useRef)({});
    const failedSamplesRef = (0, import_react16.useRef)(/* @__PURE__ */ new Set());
    const [activeInstrument, setActiveInstrument] = (0, import_react16.useState)("Default");
    const [availableInstruments, setAvailableInstruments] = (0, import_react16.useState)([]);
    const [centerSemitone, setCenterSemitone] = (0, import_react16.useState)(0);
    const [visibleOctaves, setVisibleOctaves] = (0, import_react16.useState)(0.7);
    const [autoFitEnabled, setAutoFitEnabled] = (0, import_react16.useState)(false);
    const [isPitchGridExpanded, setIsPitchGridExpanded] = (0, import_react16.useState)(false);
    const [gainValue, setGainValue] = (0, import_react16.useState)(1);
    const [noiseGateThreshold, setNoiseGateThreshold] = (0, import_react16.useState)(8e-3);
    const [compressorThreshold, setCompressorThreshold] = (0, import_react16.useState)(-24);
    const [compressorRatio, setCompressorRatio] = (0, import_react16.useState)(4);
    const [compressorRelease, setCompressorRelease] = (0, import_react16.useState)(0.25);
    const [autoGainEnabled, setAutoGainEnabled] = (0, import_react16.useState)(true);
    const [eqLowGain, setEqLowGain] = (0, import_react16.useState)(0);
    const [eqMidGain, setEqMidGain] = (0, import_react16.useState)(0);
    const [eqHighGain, setEqHighGain] = (0, import_react16.useState)(0);
    const [pyinBias, setPyinBias] = (0, import_react16.useState)(2);
    const [pyinTolerance, setPyinTolerance] = (0, import_react16.useState)(0.3);
    const [pyinGateMode, setPyinGateMode] = (0, import_react16.useState)("smooth");
    const [compressorEnabled, setCompressorEnabled] = (0, import_react16.useState)(false);
    const frequencySeparationEnabled = true;
    const pitchAlgorithm = "yin";
    const lastPitchRef = (0, import_react16.useRef)(null);
    const [autoFitTarget, setAutoFitTarget] = (0, import_react16.useState)(null);
    const [exerciseNoteCenter, setExerciseNoteCenter] = (0, import_react16.useState)(null);
    const viewControlTargetsRef = (0, import_react16.useRef)({ center: 0, octaves: 0.7 });
    const needsCameraSnapRef = (0, import_react16.useRef)(false);
    const gainNodeRef = (0, import_react16.useRef)(null);
    const compressorNodeRef = (0, import_react16.useRef)(null);
    const eqLowNodeRef = (0, import_react16.useRef)(null);
    const eqMidNodeRef = (0, import_react16.useRef)(null);
    const eqHighNodeRef = (0, import_react16.useRef)(null);
    const lastSmoothedPitchRef = (0, import_react16.useRef)(null);
    const pitchBufferRef = (0, import_react16.useRef)([]);
    const activeTheme = (0, import_react16.useMemo)(() => THEMES.find((p) => p.id === themeId) || THEMES[0], [themeId]);
    const pianoNotes = (0, import_react16.useMemo)(() => generateNotes(-24, 24), []);
    (0, import_react16.useEffect)(() => {
      document.documentElement.classList.toggle("dark", themeMode === "dark");
    }, [themeMode]);
    (0, import_react16.useEffect)(() => {
      const handleFullscreenChange = () => {
        const docEl = document.documentElement;
        setIsFullscreen(!!(document.fullscreenElement || docEl.webkitFullscreenElement));
      };
      document.addEventListener("fullscreenchange", handleFullscreenChange);
      document.addEventListener("webkitfullscreenchange", handleFullscreenChange);
      return () => {
        document.removeEventListener("fullscreenchange", handleFullscreenChange);
        document.removeEventListener("webkitfullscreenchange", handleFullscreenChange);
      };
    }, []);
    (0, import_react16.useEffect)(() => {
      const load = (k, s, d) => {
        try {
          const v = localStorage.getItem(k);
          if (v) {
            const parsed = JSON.parse(v);
            if (k === "vocalRange" && parsed.start && parsed.start.semitone < 0) {
              console.warn("\u26A0\uFE0F Found legacy relative vocal range. Migrating to MIDI...");
              if (parsed.start.semitone < 24)
                parsed.start.semitone += 60;
              if (parsed.end && parsed.end.semitone < 24)
                parsed.end.semitone += 60;
              if (parsed.start.semitone < 0 || parsed.start.semitone > 127) {
                console.warn("\u26A0\uFE0F Vocal range still invalid after migration. Resetting.");
                s(d);
                return;
              }
            }
            s(parsed);
          }
        } catch (e) {
          console.error(`Failed to load ${k}`, e);
          s(d);
        }
      };
      load("vocalRange", setVocalRange, { start: null, end: null });
      load("savedAIExercises", setSavedAIExercises, []);
      load("favoriteExerciseIds", setFavoriteExerciseIds, []);
      load("favoriteRoutineIds", setFavoriteRoutineIds, []);
      load("themeMode", setThemeMode, "light");
    }, []);
    (0, import_react16.useEffect)(() => {
      const save = (k, v) => {
        try {
          if (v !== null && v !== void 0)
            localStorage.setItem(k, JSON.stringify(v));
        } catch (e) {
          console.error(`Failed to save ${k}`, e);
        }
      };
      if (vocalRange.start && vocalRange.end)
        save("vocalRange", vocalRange);
      save("savedAIExercises", savedAIExercises);
      save("favoriteExerciseIds", favoriteExerciseIds);
      save("favoriteRoutineIds", favoriteRoutineIds);
      save("themeMode", themeMode);
    }, [vocalRange, savedAIExercises, favoriteExerciseIds, favoriteRoutineIds, themeMode]);
    (0, import_react16.useEffect)(() => {
      if (!isRangeCheckModalOpen && vocalRange.start && pendingAction) {
        pendingAction();
        setPendingAction(null);
      }
    }, [isRangeCheckModalOpen, vocalRange, pendingAction]);
    (0, import_react16.useEffect)(() => {
      if (activeView !== "range")
        setShowPianoForRangeSelection(false);
      if (isSettingsOpen)
        setIsSettingsOpen(false);
    }, [activeView]);
    (0, import_react16.useEffect)(() => {
      setMicStatus(micActive ? t("micStatusListening") : t("micStatusActivate"));
    }, [micActive, t]);
    const initAudio = (0, import_react16.useCallback)(async () => {
      if (!audioCtxRef.current) {
        if (!audioInitPromiseRef.current) {
          audioInitPromiseRef.current = (async () => {
            try {
              const AudioContextClass = window.AudioContext || window.webkitAudioContext;
              if (!AudioContextClass) {
                console.error("\u274C AudioContext not supported");
                return false;
              }
              const context = new AudioContextClass();
              const gain = context.createGain();
              gain.gain.value = 0.8;
              masterGainRef.current = gain;
              masterGainRef.current.connect(context.destination);
              const blob = new Blob([pitchProcessorCode], { type: "application/javascript" });
              const url = URL.createObjectURL(blob);
              try {
                await context.audioWorklet.addModule(url);
              } catch (e) {
                console.error("\u274C AudioWorklet error:", e);
              }
              URL.revokeObjectURL(url);
              audioCtxRef.current = context;
              compressorNodeRef.current = context.createDynamicsCompressor();
              compressorNodeRef.current.threshold.value = compressorThreshold;
              compressorNodeRef.current.ratio.value = compressorRatio;
              compressorNodeRef.current.release.value = compressorRelease;
              return true;
            } catch (e) {
              console.error("\u274C Error initializing audio.", e);
              setMicStatus(t("micStatusError"));
              return false;
            }
          })();
        }
        await audioInitPromiseRef.current;
      }
      if (audioCtxRef.current) {
        if (audioCtxRef.current.state === "suspended") {
          try {
            await audioCtxRef.current.resume();
          } catch (e) {
            console.warn("\u274C Failed to resume audio context", e);
          }
        }
      }
      return !!audioCtxRef.current;
    }, [t, compressorThreshold, compressorRatio, compressorRelease]);
    const fetchAndDecodeSample = (0, import_react16.useCallback)(async (semitone) => {
      const defaultMap = instrumentLibraryRef.current["Default"];
      if (defaultMap && defaultMap.has(semitone))
        return defaultMap.get(semitone);
      if (failedSamplesRef.current.has(semitone))
        return null;
      const noteName = semitoneToNoteName(semitone);
      const encodedName = encodeURIComponent(noteName);
      const safeName = noteName.replace("#", "s");
      const urlsToTry = [
        `${CUSTOM_SAMPLES_URL}${encodedName}.flac`,
        `${CUSTOM_SAMPLES_URL}${encodedName}.mp3`,
        `${CUSTOM_SAMPLES_URL}${safeName}.flac`,
        `${CUSTOM_SAMPLES_URL}${safeName}.mp3`
      ];
      const controller = new AbortController();
      const timeoutId = setTimeout(() => controller.abort(), 2e3);
      try {
        for (const url of urlsToTry) {
          try {
            const response = await fetch(url, { signal: controller.signal });
            if (response.ok) {
              const arrayBuffer = await response.arrayBuffer();
              clearTimeout(timeoutId);
              if (!audioCtxRef.current)
                return null;
              const audioBuffer = await audioCtxRef.current.decodeAudioData(arrayBuffer);
              if (!instrumentLibraryRef.current["Default"]) {
                instrumentLibraryRef.current["Default"] = /* @__PURE__ */ new Map();
              }
              instrumentLibraryRef.current["Default"].set(semitone, audioBuffer);
              return audioBuffer;
            }
          } catch (error) {
          }
        }
      } catch (e) {
      } finally {
        clearTimeout(timeoutId);
      }
      failedSamplesRef.current.add(semitone);
      return null;
    }, []);
    const checkAudioBuffers = (0, import_react16.useCallback)(async (semitones) => {
      const audioReady = await initAudio();
      if (!audioReady)
        return;
      if (activeInstrument === "Default" && (!instrumentLibraryRef.current["Default"] || instrumentLibraryRef.current["Default"].size === 0)) {
        const uniqueSemitones = [...new Set(semitones)];
        const needed = uniqueSemitones.filter(
          (s) => !(instrumentLibraryRef.current["Default"] && instrumentLibraryRef.current["Default"].has(s)) && !failedSamplesRef.current.has(s)
        );
        if (needed.length > 0) {
          await Promise.all(needed.map((s) => fetchAndDecodeSample(s)));
        }
      }
    }, [initAudio, fetchAndDecodeSample, activeInstrument]);
    const parseSampleInfo = (0, import_react16.useCallback)((filename) => {
      let name = filename.replace(/\.[^/.]+$/, "");
      const normalized = name.replace(NORMALIZE_REGEX, " ").replace(//g, "#").replace(//g, "b").replace(SHARP_REGEX, "#").replace(FLAT_REGEX, "b");
      const match = normalized.match(NOTE_REGEX);
      let semitone = null;
      let instrument = "Custom";
      if (match) {
        const fullNoteString = match[0];
        const letter = match[1].toUpperCase();
        const accidentalRaw = (match[2] || "").toLowerCase();
        const octave = parseInt(match[3], 10);
        const baseOffsets = { C: 0, D: 2, E: 4, F: 5, G: 7, A: 9, B: 11 };
        let semitoneOffset = baseOffsets[letter];
        if (accidentalRaw.includes("#") || accidentalRaw === "s")
          semitoneOffset += 1;
        else if (accidentalRaw === "##")
          semitoneOffset += 2;
        else if (accidentalRaw.includes("b"))
          semitoneOffset -= 1;
        else if (accidentalRaw === "bb")
          semitoneOffset -= 2;
        semitone = (octave - 4) * 12 + semitoneOffset;
        const splitIndex = match.index;
        if (splitIndex !== void 0 && splitIndex > 0) {
          let prefix = normalized.substring(0, splitIndex).trim();
          prefix = prefix.replace(/[_.-]+$/, "").trim();
          if (prefix.length > 0) {
            instrument = prefix;
          }
        }
      } else {
        const midiMatch = name.match(MIDI_NOTE_REGEX);
        if (midiMatch) {
          semitone = parseInt(midiMatch[1], 10) - 60;
          const splitIndex = midiMatch.index;
          if (splitIndex !== void 0 && splitIndex > 0) {
            let prefix = name.substring(0, splitIndex).replace(/[_.-]+$/, "").trim();
            if (prefix.length > 0)
              instrument = prefix;
          }
        }
      }
      return { semitone, instrument };
    }, []);
    const handleLoadLocalSamples = (0, import_react16.useCallback)(async (fileList) => {
      const audioReady = await initAudio();
      if (!audioReady || !audioCtxRef.current)
        return { loaded: 0, errors: 0 };
      let loadedCount = 0;
      let errors = 0;
      const newInstruments = /* @__PURE__ */ new Set();
      for (let i = 0; i < fileList.length; i++) {
        const file = fileList[i];
        if (file.name.match(/\.(flac|mp3|wav|ogg|m4a|aac)$/i) || file.type.startsWith("audio/")) {
          const { semitone, instrument } = parseSampleInfo(file.name);
          if (semitone !== null) {
            try {
              const arrayBuffer = await file.arrayBuffer();
              const audioBuffer = await audioCtxRef.current.decodeAudioData(arrayBuffer);
              if (!instrumentLibraryRef.current[instrument]) {
                instrumentLibraryRef.current[instrument] = /* @__PURE__ */ new Map();
              }
              instrumentLibraryRef.current[instrument].set(semitone, audioBuffer);
              newInstruments.add(instrument);
              loadedCount++;
            } catch (e) {
              console.error(`Failed to decode ${file.name}`, e);
              errors++;
            }
          }
        }
      }
      const allKeys = Object.keys(instrumentLibraryRef.current);
      setAvailableInstruments(allKeys);
      if (newInstruments.size > 0 && (activeInstrument === "Default" || !instrumentLibraryRef.current[activeInstrument])) {
        const firstNew = Array.from(newInstruments)[0];
        setActiveInstrument(firstNew);
      }
      setLoadedSampleCount((prev) => prev + loadedCount);
      return { loaded: loadedCount, errors };
    }, [initAudio, parseSampleInfo, activeInstrument]);
    const loadBuiltInPianoSamples = (0, import_react16.useCallback)(async () => {
      const audioReady = await initAudio();
      if (!audioReady || !audioCtxRef.current)
        return { loaded: 0, errors: 0 };
      const pianoSamples = [];
      const notes = ["C", "Ds", "Fs", "A"];
      const noteOffsets = { "C": 0, "Ds": 3, "Fs": 6, "A": 9 };
      for (let octave = 1; octave <= 7; octave++) {
        for (const note of notes) {
          const noteOffset = noteOffsets[note];
          const midi = (octave + 1) * 12 + noteOffset;
          const semitone = midi - 60;
          pianoSamples.push({
            filename: `${note}${octave}.mp3`,
            semitone
          });
        }
      }
      let loadedCount = 0;
      let errors = 0;
      if (!instrumentLibraryRef.current["Piano"]) {
        instrumentLibraryRef.current["Piano"] = /* @__PURE__ */ new Map();
      }
      for (const sample of pianoSamples) {
        try {
          const response = await fetch(`/sounds/Salamander_Piano/${sample.filename}`);
          if (response.ok) {
            const arrayBuffer = await response.arrayBuffer();
            const audioBuffer = await audioCtxRef.current.decodeAudioData(arrayBuffer);
            instrumentLibraryRef.current["Piano"].set(sample.semitone, audioBuffer);
            loadedCount++;
          } else {
            console.warn(`Failed to load ${sample.filename}: ${response.status}`);
            errors++;
          }
        } catch (e) {
          console.error(`Error loading ${sample.filename}:`, e);
          errors++;
        }
      }
      const allKeys = Object.keys(instrumentLibraryRef.current);
      setAvailableInstruments(allKeys);
      if (loadedCount > 0) {
        setActiveInstrument("Piano");
        setLoadedSampleCount((prev) => prev + loadedCount);
      }
      return { loaded: loadedCount, errors };
    }, [initAudio]);
    const playNote = (0, import_react16.useCallback)(async (semitone, duration, forExercise = false) => {
      const audioReady = await initAudio();
      const audioCtx = audioCtxRef.current;
      const masterGain = masterGainRef.current;
      if (!audioReady || !audioCtx || !masterGain)
        return;
      const now = audioCtx.currentTime;
      const noteSet = forExercise ? currentPlayingExerciseNoteNodesRef.current : currentNonExerciseNoteNodesRef.current;
      noteSet.forEach((existingNode) => {
        if (existingNode.semitone === semitone) {
          existingNode.gainNodes.forEach((g) => {
            try {
              g.gain.cancelScheduledValues(now);
              g.gain.setValueAtTime(g.gain.value, now);
              g.gain.exponentialRampToValueAtTime(1e-3, now + 0.05);
            } catch (e) {
            }
          });
          existingNode.allNodes.forEach((node) => {
            if (node instanceof OscillatorNode || node instanceof AudioBufferSourceNode) {
              try {
                node.stop(now + 0.06);
              } catch (e) {
              }
            }
          });
          setTimeout(() => {
            existingNode.allNodes.forEach((node) => {
              try {
                node.disconnect();
              } catch (e) {
              }
            });
            noteSet.delete(existingNode);
          }, 70);
        }
      });
      const currentMap = instrumentLibraryRef.current[activeInstrument];
      let buffer = null;
      let playbackRate = 1;
      if (currentMap && currentMap.size > 0) {
        if (currentMap.has(semitone)) {
          buffer = currentMap.get(semitone);
        } else {
          let closestSemitone = null;
          let minDistance = Infinity;
          for (const key of currentMap.keys()) {
            const dist = Math.abs(semitone - key);
            if (dist < minDistance) {
              minDistance = dist;
              closestSemitone = key;
            }
          }
          if (closestSemitone !== null) {
            buffer = currentMap.get(closestSemitone);
            playbackRate = Math.pow(2, (semitone - closestSemitone) / 12);
          }
        }
      } else if (activeInstrument === "Default") {
        try {
          const fetched = await fetchAndDecodeSample(semitone);
          if (fetched)
            buffer = fetched;
        } catch (e) {
        }
      }
      if (buffer) {
        const source = audioCtx.createBufferSource();
        source.buffer = buffer;
        source.playbackRate.value = playbackRate;
        const sampleGain = audioCtx.createGain();
        sampleGain.gain.setValueAtTime(forExercise ? exerciseNoteVolume * 1.5 : 0.8, now);
        sampleGain.gain.exponentialRampToValueAtTime(1e-3, now + duration / 1e3 + 0.5);
        source.connect(sampleGain);
        const nodes = { oscillators: [], gainNodes: [sampleGain], allNodes: [source, sampleGain] };
        if (frequencySeparationEnabled) {
          const lowPassFilter = audioCtx.createBiquadFilter();
          lowPassFilter.type = "lowpass";
          lowPassFilter.frequency.value = 600;
          lowPassFilter.Q.value = 1;
          sampleGain.connect(lowPassFilter);
          lowPassFilter.connect(masterGain);
          nodes.allNodes.push(lowPassFilter);
        } else {
          sampleGain.connect(masterGain);
        }
        source.start(now);
        try {
          const adjustedDuration = duration / 1e3 / playbackRate;
          source.stop(now + adjustedDuration + 2);
        } catch (e) {
        }
        nodes.semitone = semitone;
        source.onended = () => {
          nodes.allNodes.forEach((node) => {
            try {
              node.disconnect();
            } catch (e) {
            }
          });
          noteSet.delete(nodes);
        };
        noteSet.add(nodes);
      } else {
        const freq = noteToFrequency(semitone);
        const totalDurationSecs = duration / 1e3;
        const ATTACK_TIME = 0.01;
        const DECAY_TIME = 0.1;
        const SUSTAIN_LEVEL = 0.1;
        const mainGainNode = audioCtx.createGain();
        mainGainNode.gain.setValueAtTime(0, now);
        mainGainNode.gain.linearRampToValueAtTime(forExercise ? exerciseNoteVolume * 1.5 : 0.8, now + ATTACK_TIME);
        mainGainNode.gain.exponentialRampToValueAtTime(SUSTAIN_LEVEL, now + ATTACK_TIME + DECAY_TIME);
        mainGainNode.gain.exponentialRampToValueAtTime(1e-4, now + totalDurationSecs);
        const nodes = { oscillators: [], gainNodes: [mainGainNode], allNodes: [mainGainNode] };
        if (frequencySeparationEnabled) {
          const lowPassFilter = audioCtx.createBiquadFilter();
          lowPassFilter.type = "lowpass";
          lowPassFilter.frequency.value = 600;
          lowPassFilter.Q.value = 1;
          mainGainNode.connect(lowPassFilter);
          lowPassFilter.connect(masterGain);
          nodes.allNodes.push(lowPassFilter);
        } else {
          mainGainNode.connect(masterGain);
        }
        nodes.semitone = semitone;
        const osc1 = audioCtx.createOscillator();
        osc1.type = "sine";
        osc1.frequency.setValueAtTime(freq, now);
        osc1.connect(mainGainNode);
        nodes.oscillators.push(osc1);
        nodes.allNodes.push(osc1);
        const brightOscGain = audioCtx.createGain();
        brightOscGain.gain.setValueAtTime(0, now);
        brightOscGain.gain.linearRampToValueAtTime(0.1, now + 5e-3);
        brightOscGain.gain.exponentialRampToValueAtTime(1e-4, now + 0.05);
        brightOscGain.connect(mainGainNode);
        nodes.gainNodes.push(brightOscGain);
        nodes.allNodes.push(brightOscGain);
        const osc2 = audioCtx.createOscillator();
        osc2.type = "square";
        osc2.frequency.setValueAtTime(freq * 2, now);
        osc2.connect(brightOscGain);
        nodes.oscillators.push(osc2);
        nodes.allNodes.push(osc2);
        nodes.oscillators.forEach((osc) => {
          osc.start(now);
          try {
            osc.stop(now + totalDurationSecs);
          } catch (e) {
          }
        });
        osc1.onended = () => {
          nodes.allNodes.forEach((node) => {
            try {
              node.disconnect();
            } catch (e) {
            }
          });
          noteSet.delete(nodes);
        };
        noteSet.add(nodes);
      }
    }, [initAudio, exerciseNoteVolume, fetchAndDecodeSample, activeInstrument, frequencySeparationEnabled]);
    const playMetronomeClick = (0, import_react16.useCallback)(async () => {
      const audioReady = await initAudio();
      const audioCtx = audioCtxRef.current;
      if (!audioReady || !audioCtx || !masterGainRef.current)
        return;
      const now = audioCtx.currentTime;
      const clickGain = audioCtx.createGain();
      clickGain.gain.setValueAtTime(metronomeVolume, now);
      clickGain.gain.exponentialRampToValueAtTime(1e-4, now + 0.1);
      clickGain.connect(masterGainRef.current);
      const osc = audioCtx.createOscillator();
      osc.type = "sine";
      osc.frequency.setValueAtTime(1200, now);
      osc.connect(clickGain);
      osc.start(now);
      osc.stop(now + 0.1);
      osc.onended = () => {
        try {
          osc.disconnect();
          clickGain.disconnect();
        } catch (e) {
        }
      };
    }, [initAudio, metronomeVolume]);
    const stopAllExerciseNotes = (0, import_react16.useCallback)(() => {
      const audioCtx = audioCtxRef.current;
      if (!audioCtx)
        return;
      currentPlayingExerciseNoteNodesRef.current.forEach((n) => {
        const now = audioCtx.currentTime;
        n.gainNodes.forEach((g) => {
          try {
            g.gain.cancelScheduledValues(now);
            g.gain.setValueAtTime(g.gain.value, now);
            g.gain.exponentialRampToValueAtTime(1e-3, now + 0.1);
          } catch (e) {
          }
        });
        n.allNodes.forEach((node) => {
          if (node instanceof OscillatorNode || node instanceof AudioBufferSourceNode) {
            try {
              node.stop(now + 0.15);
            } catch (e) {
            }
          }
        });
        setTimeout(() => {
          n.allNodes.forEach((node) => {
            try {
              node.disconnect();
            } catch (e) {
            }
          });
        }, 200);
      });
      currentPlayingExerciseNoteNodesRef.current.clear();
    }, []);
    const stopAllNonExerciseNotes = (0, import_react16.useCallback)(() => {
      const audioCtx = audioCtxRef.current;
      if (!audioCtx)
        return;
      currentNonExerciseNoteNodesRef.current.forEach((n) => {
        n.allNodes.forEach((node) => {
          if (node instanceof OscillatorNode || node instanceof AudioBufferSourceNode) {
            try {
              node.stop(audioCtx.currentTime);
            } catch (e) {
            }
          }
          try {
            node.disconnect();
          } catch (e) {
          }
        });
      });
      currentNonExerciseNoteNodesRef.current.clear();
    }, []);
    const startPitchDetection = (0, import_react16.useCallback)(async () => {
      const audioReady = await initAudio();
      const audioCtx = audioCtxRef.current;
      if (!audioReady || !audioCtx) {
        setMicStatus(t("micStatusError"));
        return false;
      }
      try {
        const stream = await navigator.mediaDevices.getUserMedia({
          audio: {
            //  AGGRESSIVE ECHO CANCELLATION for feedback prevention
            echoCancellation: { ideal: true },
            noiseSuppression: { ideal: true },
            autoGainControl: { ideal: autoGainEnabled },
            // @ts-ignore - Chrome/Chromium specific constraints for stronger echo cancellation
            googEchoCancellation: { exact: true },
            // @ts-ignore
            googExperimentalEchoCancellation: { exact: true },
            // @ts-ignore
            googAutoGainControl: { exact: autoGainEnabled },
            // @ts-ignore
            googNoiseSuppression: { exact: true },
            // @ts-ignore
            googExperimentalNoiseSuppression: { exact: true },
            // @ts-ignore
            googHighpassFilter: { exact: true },
            // @ts-ignore - Safari-specific constraint
            echoCancelation: { ideal: true }
          }
        });
        micStreamRef.current = stream;
        const source = audioCtx.createMediaStreamSource(stream);
        if (audioCtx.state === "suspended") {
          await audioCtx.resume();
        }
        if (!workletModuleAddedRef.current) {
          try {
            await audioCtx.audioWorklet.addModule(URL.createObjectURL(new Blob([pitchProcessorCode], { type: "application/javascript" })));
            workletModuleAddedRef.current = true;
          } catch (e) {
            console.error("\u274C Failed to register pitch processor:", e);
            setMicStatus(t("micStatusError"));
            return false;
          }
        }
        const workletNode = new AudioWorkletNode(audioCtx, "pitch-processor", {
          processorOptions: {
            noiseGateThreshold,
            algorithm: pitchAlgorithm,
            pyinBias,
            pyinGateMode
          }
        });
        workletNodeRef.current = workletNode;
        let micInputNode = source;
        if (frequencySeparationEnabled) {
          const highPassFilter = audioCtx.createBiquadFilter();
          highPassFilter.type = "highpass";
          highPassFilter.frequency.value = 750;
          highPassFilter.Q.value = 1;
          source.connect(highPassFilter);
          micInputNode = highPassFilter;
        }
        micInputNode.connect(workletNode);
        workletNode.port.onmessage = (event) => {
          const { pitch, gain } = event.data;
          const adjustedGain = gain;
          setMicGain(Math.min(1, adjustedGain * 100) * 100);
          if (pitch !== void 0 && pitch > 60) {
            if (lastPitchRef.current !== null) {
              const semitoneJump = Math.abs(12 * Math.log2(pitch / lastPitchRef.current));
              if (semitoneJump > 36) {
                return;
              }
            }
            setUserPitch(pitch);
            lastPitchRef.current = pitch;
          } else {
          }
        };
        setMicActive(true);
        return true;
      } catch (err) {
        console.error("Mic Error:", err);
        setMicStatus(t("micStatusPermissionDenied"));
      }
      return false;
    }, [initAudio, t, autoGainEnabled, noiseGateThreshold, gainValue, compressorEnabled, frequencySeparationEnabled, pyinBias, pyinGateMode, pitchAlgorithm]);
    (0, import_react16.useEffect)(() => {
      if (gainNodeRef.current)
        gainNodeRef.current.gain.value = autoGainEnabled ? 1 : gainValue;
    }, [gainValue, autoGainEnabled]);
    (0, import_react16.useEffect)(() => {
      if (workletNodeRef.current) {
        console.log("\u{1F39B}\uFE0F Sending noiseGateThreshold to worklet:", noiseGateThreshold);
        workletNodeRef.current.port.postMessage({ noiseGateThreshold });
      }
    }, [noiseGateThreshold]);
    (0, import_react16.useEffect)(() => {
      if (workletNodeRef.current)
        workletNodeRef.current.port.postMessage({ algorithm: pitchAlgorithm });
    }, [pitchAlgorithm]);
    (0, import_react16.useEffect)(() => {
      if (workletNodeRef.current) {
        console.log("\u{1F39B}\uFE0F Sending pyinBias to worklet:", pyinBias);
        workletNodeRef.current.port.postMessage({ pyinBias });
      }
    }, [pyinBias]);
    (0, import_react16.useEffect)(() => {
      if (workletNodeRef.current) {
        console.log("\u{1F39B}\uFE0F Sending pyinGateMode to worklet:", pyinGateMode);
        workletNodeRef.current.port.postMessage({ pyinGateMode });
      }
    }, [pyinGateMode]);
    (0, import_react16.useEffect)(() => {
      if (compressorNodeRef.current) {
        compressorNodeRef.current.threshold.value = compressorThreshold;
        compressorNodeRef.current.ratio.value = compressorRatio;
        compressorNodeRef.current.release.value = compressorRelease;
      }
    }, [compressorThreshold, compressorRatio, compressorRelease]);
    (0, import_react16.useEffect)(() => {
      if (eqLowNodeRef.current)
        eqLowNodeRef.current.gain.value = eqLowGain;
    }, [eqLowGain]);
    (0, import_react16.useEffect)(() => {
      if (eqMidNodeRef.current)
        eqMidNodeRef.current.gain.value = eqMidGain;
    }, [eqMidGain]);
    (0, import_react16.useEffect)(() => {
      if (eqHighNodeRef.current)
        eqHighNodeRef.current.gain.value = eqHighGain;
    }, [eqHighGain]);
    const stopPitchDetection = (0, import_react16.useCallback)(() => {
      micStreamRef.current?.getTracks().forEach((track) => track.stop());
      if (workletNodeRef.current) {
        workletNodeRef.current.port.onmessage = null;
        workletNodeRef.current.disconnect();
        workletNodeRef.current = null;
      }
      workletModuleAddedRef.current = false;
      setMicActive(false);
      setUserPitch(null);
      setMicGain(0);
      lastSmoothedPitchRef.current = null;
      pitchBufferRef.current = [];
    }, []);
    (0, import_react16.useEffect)(() => () => stopPitchDetection(), [stopPitchDetection]);
    const handleMicToggle = (0, import_react16.useCallback)(() => {
      micActive ? stopPitchDetection() : startPitchDetection();
    }, [micActive, startPitchDetection, stopPitchDetection]);
    const handlePianoKeyClick = (0, import_react16.useCallback)((note) => {
      stopAllNonExerciseNotes();
      playNote(note.semitone, 300, false);
      setVocalRange((prev) => {
        if (!prev.start || prev.end)
          return { start: note, end: null };
        return note.semitone > prev.start.semitone ? { start: prev.start, end: note } : { start: note, end: prev.start };
      });
    }, [playNote, stopAllNonExerciseNotes]);
    const getSafeExerciseRange = (0, import_react16.useCallback)((fullRange) => {
      const { start, end } = fullRange;
      if (!start || !end) {
        return {
          start: { semitone: -9, name: "E3", isSharp: false },
          end: { semitone: 7, name: "G4", isSharp: false }
        };
      }
      return fullRange;
    }, []);
    const executeExerciseAction = (0, import_react16.useCallback)((action) => {
      action();
    }, []);
    const selectExercise = (0, import_react16.useCallback)((ex) => {
      if (uiViewRef.current === "exercise" && selectedExercise && getExerciseId(selectedExercise) === getExerciseId(ex)) {
        return;
      }
      let currentExerciseRange;
      if (vocalRange.start && vocalRange.end && vocalRange.start.semitone >= 0 && vocalRange.end.semitone >= 0) {
        currentExerciseRange = getSafeExerciseRange(vocalRange);
      } else {
        currentExerciseRange = {
          start: { semitone: -9, name: "E3", isSharp: false },
          end: { semitone: 7, name: "G4", isSharp: false }
        };
      }
      setExerciseRange(currentExerciseRange);
      executeExerciseAction(() => {
        const isSameExercise = selectedExercise && getExerciseId(selectedExercise) === getExerciseId(ex);
        setIsPlaying(false);
        setIsExerciseComplete(false);
        if (isSameExercise) {
          setExerciseKey((prev) => prev + 1);
        }
        setSelectedExercise(ex);
        uiViewRef.current = "exercise";
        setUiView("exercise");
        setIsMenuVisible(false);
        const startSemitone = currentExerciseRange.start?.semitone ?? 52;
        const endSemitone = currentExerciseRange.end?.semitone ?? 67;
        const rangeSpan = endSemitone - startSemitone;
        const rangeMidpoint = startSemitone + Math.floor(rangeSpan / 2);
        const comfortableStart = rangeMidpoint - 6;
        const pattern = getExercisePattern(ex);
        const firstNoteSemitone = pattern && pattern.length > 0 ? comfortableStart + pattern[0] : rangeMidpoint;
        viewControlTargetsRef.current.center = firstNoteSemitone;
        viewControlTargetsRef.current.octaves = 1.5;
        needsCameraSnapRef.current = true;
      });
    }, [vocalRange, executeExerciseAction, selectedExercise, getSafeExerciseRange]);
    const handleStartGeneratedExercise = (0, import_react16.useCallback)((ex) => selectExercise(ex), [selectExercise]);
    const handleRefineExercise = (0, import_react16.useCallback)(async (currentExercise, refinePrompt) => {
      try {
        const { GoogleGenAI: GoogleGenAI2, Type: Type2 } = await Promise.resolve().then(() => (init_web(), web_exports));
        const envKey = "AIzaSyD0JEm3fqse7TQZ1ri2UWMmdtJigyX3fpo";
        const apiKey = envKey && envKey.length > 0 && envKey !== "undefined" ? envKey : "";
        if (!apiKey) {
          console.error("No API key available for refinement");
          return;
        }
        const ai = new GoogleGenAI2({ apiKey });
        const fullPrompt = `
                I have a vocal exercise defined in JSON: ${JSON.stringify(currentExercise)}.
                Please modify this exercise based on this request: "${refinePrompt}".
                
                IMPORTANT FORMAT RULES:
                1. Use the "notes" array, NOT "pattern".
                2. Each note must have: type ("note" or "rest"), semitone (0-12+), duration (in beats), lyric (optional).
                3. Use "tempo_bpm" for speed.
                
                Keep the pedagogical goal but adjust parameters as requested.
            `;
        const noteSchema = {
          type: Type2.OBJECT,
          properties: {
            type: { type: Type2.STRING, description: "Either 'note' or 'rest'" },
            semitone: { type: Type2.INTEGER, description: "Semitones from root (0-12+)" },
            duration: { type: Type2.NUMBER, description: "Duration in BEATS" },
            lyric: { type: Type2.STRING, description: "Optional syllable" }
          },
          required: ["type", "duration"]
        };
        const schema = {
          type: Type2.OBJECT,
          properties: {
            name: { type: Type2.STRING },
            desc: { type: Type2.STRING },
            category: { type: Type2.STRING },
            instructions: { type: Type2.STRING },
            notes: { type: Type2.ARRAY, items: noteSchema },
            tempo_bpm: { type: Type2.INTEGER }
          },
          required: ["name", "desc", "category", "instructions", "notes", "tempo_bpm"]
        };
        const response = await ai.models.generateContent({
          model: "gemini-2.0-flash",
          contents: fullPrompt,
          config: {
            responseMimeType: "application/json",
            responseSchema: schema
          }
        });
        const jsonResult = JSON.parse(response.text);
        const refinedExercise = {
          ...jsonResult,
          // Keep same ID - use exercise_id for MIDI, id for Legacy
          ...isMidiExercise(currentExercise) ? { exercise_id: currentExercise.exercise_id } : { id: currentExercise.id },
          isAIGenerated: true
        };
        setAiResult(refinedExercise);
        setSelectedExercise(refinedExercise);
        setExerciseKey((prev) => prev + 1);
      } catch (e) {
        console.error("Error refining exercise:", e);
      }
    }, [setAiResult, setSelectedExercise, setExerciseKey]);
    const resetCameraToDefault = (0, import_react16.useCallback)(() => {
      viewControlTargetsRef.current.center = 0;
      setAutoFitTarget(null);
      needsCameraSnapRef.current = true;
    }, []);
    const handleStop = (0, import_react16.useCallback)(() => {
      if (isPreviewing)
        stopPreview();
      setIsPlaying(false);
      setIsExerciseComplete(false);
      stopAllExerciseNotes();
      stopAllNonExerciseNotes();
      const isAIExercise = selectedExercise?.isAIGenerated;
      setSelectedExercise(null);
      setExerciseRange({ start: null, end: null });
      setExerciseNoteCenter(null);
      uiViewRef.current = "main";
      setUiView("main");
      setIsMenuVisible(true);
      if (currentRoutine) {
        setCurrentRoutine(null);
        setActiveView("routines");
      } else if (isAIExercise) {
        setActiveView("voxlabai");
      }
      resetCameraToDefault();
    }, [currentRoutine, selectedExercise, stopAllExerciseNotes, stopAllNonExerciseNotes, isPreviewing, resetCameraToDefault]);
    const handleNextExerciseInRoutine = (0, import_react16.useCallback)(() => {
      if (!currentRoutine)
        return;
      const nextIndex = currentRoutine.exerciseIndex + 1;
      if (nextIndex < currentRoutine.routine.exerciseIds.length) {
        const nextExId = currentRoutine.routine.exerciseIds[nextIndex];
        const nextEx = EXERCISES.find((ex) => getExerciseId(ex) === nextExId);
        if (nextEx) {
          setCurrentRoutine({ ...currentRoutine, exerciseIndex: nextIndex });
          selectExercise(nextEx);
          setTimeout(() => setIsPlaying(true), 200);
        } else
          handleStop();
      } else {
        setIsPlaying(false);
        setIsExerciseComplete(false);
        setIsRoutineComplete(true);
      }
    }, [currentRoutine, selectExercise, handleStop]);
    const handleStartRoutine = (0, import_react16.useCallback)((routine) => {
      const firstEx = EXERCISES.find((ex) => getExerciseId(ex) === routine.exerciseIds[0]);
      if (firstEx) {
        setCurrentRoutine({ routine, exerciseIndex: 0 });
        selectExercise(firstEx);
      }
    }, [selectExercise]);
    const handleExerciseComplete = (0, import_react16.useCallback)(() => {
      setIsPlaying(false);
      setIsExerciseComplete(true);
    }, []);
    const handlePlayPause = (0, import_react16.useCallback)(() => {
      if (isExerciseComplete) {
        setIsExerciseComplete(false);
        setExerciseKey((k) => k + 1);
        setIsPlaying(true);
      } else {
        const newPlayingState = !isPlaying;
        setIsPlaying(newPlayingState);
        if (!newPlayingState) {
          stopAllExerciseNotes();
        }
      }
    }, [isExerciseComplete, isPlaying, stopAllExerciseNotes]);
    const stopPreview = (0, import_react16.useCallback)(() => {
      previewTimersRef.current.forEach(clearTimeout);
      previewTimersRef.current = [];
      stopAllExerciseNotes();
      setIsPreviewing(false);
    }, [stopAllExerciseNotes]);
    const handlePreview = (0, import_react16.useCallback)(async () => {
      if (!selectedExercise || !exerciseRange.start)
        return;
      if (isPreviewing) {
        stopPreview();
        return;
      }
      await initAudio();
      setIsPreviewing(true);
      const timers = [];
      let delay = 0;
      selectedExercise.pattern.forEach((offset) => {
        const timer = window.setTimeout(() => {
          playNote(exerciseRange.start.semitone + offset, selectedExercise.duration, true);
        }, delay);
        timers.push(timer);
        delay += selectedExercise.duration;
      });
      const finalTimer = window.setTimeout(() => {
        setIsPreviewing(false);
        previewTimersRef.current = [];
      }, delay + 100);
      timers.push(finalTimer);
      previewTimersRef.current = timers;
    }, [selectedExercise, exerciseRange, initAudio, playNote, isPreviewing, stopPreview]);
    const handleSaveAIExercise = (0, import_react16.useCallback)((ex) => {
      setSavedAIExercises((p) => p.some((e) => getExerciseId(e) === getExerciseId(ex)) ? p : [...p, ex]);
    }, []);
    const handleToggleFavoriteExercise = (0, import_react16.useCallback)((exId) => {
      console.log("Toggle favorite called with:", exId);
      if (!exId)
        return;
      setFavoriteExerciseIds((prev) => {
        const newIds = prev.includes(exId) ? prev.filter((id) => id !== exId) : [...prev, exId];
        console.log("New favorite IDs:", newIds);
        return newIds;
      });
    }, []);
    const handleToggleFavoriteRoutine = (0, import_react16.useCallback)((rId) => {
      setFavoriteRoutineIds((p) => p.includes(rId) ? p.filter((id) => id !== rId) : [...p, rId]);
    }, []);
    const handleToggleFullscreen = (0, import_react16.useCallback)(() => {
      const isMobile = /iPhone|iPad|iPod|Android/i.test(navigator.userAgent);
      if (!isFullscreen) {
        if (isMobile) {
          setIsFullscreen(true);
          window.scrollTo(0, 1);
          return;
        }
        const docEl = document.documentElement;
        const requestFullscreen = docEl.requestFullscreen || docEl.webkitRequestFullscreen || docEl.mozRequestFullScreen || docEl.msRequestFullscreen;
        if (requestFullscreen) {
          requestFullscreen.call(docEl).then(() => {
            setIsFullscreen(true);
          }).catch(() => {
            setIsFullscreen(true);
          });
        } else {
          setIsFullscreen(true);
        }
      } else {
        if (isMobile) {
          setIsFullscreen(false);
          return;
        }
        const doc = document;
        const exitFullscreen = doc.exitFullscreen || doc.webkitExitFullscreen || doc.mozCancelFullScreen || doc.msExitFullscreen;
        if (exitFullscreen) {
          exitFullscreen.call(doc).then(() => {
            setIsFullscreen(false);
          }).catch(() => {
            setIsFullscreen(false);
          });
        } else {
          setIsFullscreen(false);
        }
      }
    }, [isFullscreen]);
    (0, import_react16.useEffect)(() => {
      const handleFullscreenChange = () => {
        const isCurrentlyFullscreen = !!(document.fullscreenElement || document.webkitFullscreenElement || document.mozFullScreenElement || document.msFullscreenElement);
        setIsFullscreen(isCurrentlyFullscreen);
      };
      document.addEventListener("fullscreenchange", handleFullscreenChange);
      document.addEventListener("webkitfullscreenchange", handleFullscreenChange);
      document.addEventListener("mozfullscreenchange", handleFullscreenChange);
      document.addEventListener("MSFullscreenChange", handleFullscreenChange);
      return () => {
        document.removeEventListener("fullscreenchange", handleFullscreenChange);
        document.removeEventListener("webkitfullscreenchange", handleFullscreenChange);
        document.removeEventListener("mozfullscreenchange", handleFullscreenChange);
        document.removeEventListener("MSFullscreenChange", handleFullscreenChange);
      };
    }, []);
    (0, import_react16.useEffect)(() => {
      const detectedNote = userPitch ? frequencyToNote(userPitch) : null;
      if (detectedNote) {
        const newPitch = detectedNote.preciseSemitone;
        if (activeView === "pitch" || uiView === "exercise" && autoFitEnabled) {
          const targetSmooth = 0.25;
          setAutoFitTarget((p) => p === null ? newPitch : targetSmooth * newPitch + (1 - targetSmooth) * p);
        }
      }
    }, [userPitch, activeView, uiView, autoFitEnabled]);
    (0, import_react16.useEffect)(() => {
      const animId = requestAnimationFrame(animateView);
      function animateView() {
        let finalTargetCenter = viewControlTargetsRef.current.center;
        let finalTargetOctaves = viewControlTargetsRef.current.octaves;
        if (needsCameraSnapRef.current) {
          setCenterSemitone(finalTargetCenter);
          setVisibleOctaves(finalTargetOctaves);
          needsCameraSnapRef.current = false;
          setAutoFitTarget(null);
        } else {
          if (autoFitEnabled && autoFitTarget !== null) {
            if (uiView === "exercise" && exerciseNoteCenter !== null) {
              finalTargetCenter = exerciseNoteCenter;
            } else {
              finalTargetCenter = autoFitTarget;
            }
          }
          setCenterSemitone((p) => lerp(p, finalTargetCenter, 0.25));
          setVisibleOctaves((p) => lerp(p, finalTargetOctaves, 0.03));
        }
        requestAnimationFrame(animateView);
      }
      return () => cancelAnimationFrame(animId);
    }, [autoFitEnabled, autoFitTarget, uiView, exerciseNoteCenter]);
    const handleManualCenterChange = (0, import_react16.useCallback)((v) => {
      setAutoFitEnabled(false);
      viewControlTargetsRef.current.center = v;
    }, []);
    const handleManualOctaveChange = (0, import_react16.useCallback)((v) => {
      viewControlTargetsRef.current.octaves = v;
    }, []);
    const handleStartRangeTest = (0, import_react16.useCallback)(async (isModal = false) => {
      if (!micActive) {
        const micOk = await startPitchDetection();
        if (!micOk)
          return;
      }
      if (isModal && pendingAction)
        setPostRangeTestAction(() => pendingAction);
      setIsRangeTestActive(true);
    }, [micActive, startPitchDetection, pendingAction]);
    const handleCompleteRangeDetection = (0, import_react16.useCallback)((start, end) => {
      const newRange = { start, end };
      setVocalRange(newRange);
      setVocalRangeHistory((p) => [...p, { ...newRange, timestamp: Date.now() }]);
      setIsRangeTestActive(false);
      if (postRangeTestAction) {
        postRangeTestAction();
        setPostRangeTestAction(null);
        setPendingAction(null);
      }
    }, [postRangeTestAction]);
    const handleCancelRangeTest = (0, import_react16.useCallback)(() => {
      setIsRangeTestActive(false);
      setPostRangeTestAction(null);
      setPendingAction(null);
    }, []);
    const handleGoHomeFromRangeTest = (0, import_react16.useCallback)(() => {
      setIsRangeTestActive(false);
      setActiveView("home");
    }, []);
    const handleViewChange = (0, import_react16.useCallback)((view) => {
      if (uiView === "exercise") {
        handleStop();
      }
      if (isRangeTestActive) {
        handleCancelRangeTest();
      }
      setActiveView(view);
    }, [uiView, isRangeTestActive, handleCancelRangeTest, handleStop]);
    const titleMap = { home: "VoxLab", range: "vocalRangeTitle", routines: "routinesTitle", exercises: "exercisesTitle", favorites: "favorites", pitch: "livePitchDetector", voxlabai: "voxlabaiTitle", instrumentTuner: "instrumentTuner", studies: "studiesTitle", tokens: "tokensTitle" };
    const currentTitle = titleMap[activeView] || "";
    (0, import_react16.useEffect)(() => {
      loadBuiltInPianoSamples();
    }, [loadBuiltInPianoSamples]);
    return /* @__PURE__ */ (0, import_jsx_runtime19.jsxs)(import_jsx_runtime19.Fragment, { children: [
      showSplash && /* @__PURE__ */ (0, import_jsx_runtime19.jsx)(
        "div",
        {
          style: {
            position: "fixed",
            inset: 0,
            display: "flex",
            alignItems: "center",
            justifyContent: "center",
            zIndex: 9999,
            backgroundColor: "#F3F4F6",
            opacity: showSplash ? 1 : 0,
            transition: "opacity 1s ease-out",
            pointerEvents: showSplash ? "auto" : "none"
          },
          children: /* @__PURE__ */ (0, import_jsx_runtime19.jsx)(
            "video",
            {
              src: sphere_v2_default,
              autoPlay: true,
              muted: true,
              playsInline: true,
              onLoadedData: () => console.log("Splash video loaded"),
              onError: (e) => console.error("Splash video error:", e),
              onEnded: () => console.log("Splash video ended"),
              style: {
                width: "100%",
                height: "100%",
                objectFit: "contain"
              }
            }
          )
        }
      ),
      /* @__PURE__ */ (0, import_jsx_runtime19.jsxs)(
        "div",
        {
          className: "relative h-full text-slate-800 transition-colors duration-300",
          style: {
            opacity: showSplash ? 0 : 1,
            transition: "opacity 1.5s ease-in",
            transitionDelay: "0.3s"
          },
          children: [
            /* @__PURE__ */ (0, import_jsx_runtime19.jsxs)("div", { className: "relative z-10 flex flex-col h-full", children: [
              isSettingsOpen && /* @__PURE__ */ (0, import_jsx_runtime19.jsx)(SettingsOverlay_default, { ...{ setIsSettingsOpen, setActiveView: handleViewChange, language, setLanguage, activeTheme, setThemeId, themeMode, setThemeMode, onLoadSamples: handleLoadLocalSamples, loadedSampleCount, availableInstruments, activeInstrument, setActiveInstrument, compressorEnabled, setCompressorEnabled, pyinBias, setPyinBias, pyinGateMode, setPyinGateMode, noiseGateThreshold, setNoiseGateThreshold } }),
              isRangeCheckModalOpen && /* @__PURE__ */ (0, import_jsx_runtime19.jsx)(RangeCheckModal, { theme: activeTheme, onDefine: () => {
                setIsRangeCheckModalOpen(false);
                handleStartRangeTest(true);
              }, onContinue: () => {
                setVocalRange({ start: { semitone: -12, name: "C3", isSharp: false }, end: { semitone: 12, name: "C5", isSharp: false } });
                setIsRangeCheckModalOpen(false);
              } }),
              isRoutineComplete && /* @__PURE__ */ (0, import_jsx_runtime19.jsx)(RoutineCompleteModal, { onFinish: handleStop, theme: activeTheme }),
              isRangeTestActive && /* @__PURE__ */ (0, import_jsx_runtime19.jsx)(VocalRangeTestScreen_default, { onCancel: handleCancelRangeTest, onComplete: handleCompleteRangeDetection, currentTheme: activeTheme, pyinBias, pyinTolerance, pyinGateMode, noiseGateThreshold }),
              uiView !== "exercise" && !isRangeTestActive && /* @__PURE__ */ (0, import_jsx_runtime19.jsx)(
                "header",
                {
                  className: "sticky top-0 z-40 flex items-end px-4 sm:px-6 lg:px-8 bg-white/20 dark:bg-slate-900/20 backdrop-blur-md",
                  style: {
                    paddingTop: "max(1rem, env(safe-area-inset-top))",
                    paddingBottom: "0.5rem"
                  },
                  children: /* @__PURE__ */ (0, import_jsx_runtime19.jsx)("h1", { className: "text-4xl sm:text-5xl font-black text-slate-800 dark:text-slate-200", children: activeView === "home" ? "VoxLab" : t(currentTitle) })
                }
              ),
              /* @__PURE__ */ (0, import_jsx_runtime19.jsxs)("main", { className: `flex-grow w-full ${activeView !== "test" ? "max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 pt-0 md:pt-4 pb-8" : ""} flex flex-col ${isRangeTestActive ? "hidden" : ""}`, style: { maxWidth: uiView === "exercise" ? "100%" : "1280px" }, children: [
                uiView === "main" && /* @__PURE__ */ (0, import_jsx_runtime19.jsxs)("div", { className: "flex-grow flex flex-col animate-fade-in", children: [
                  activeView === "home" && /* @__PURE__ */ (0, import_jsx_runtime19.jsx)("section", { className: "relative flex-grow flex flex-col items-center justify-center text-center -mt-24 md:mt-0", children: /* @__PURE__ */ (0, import_jsx_runtime19.jsxs)("div", { className: "relative z-10", children: [
                    /* @__PURE__ */ (0, import_jsx_runtime19.jsx)("h1", { className: `text-5xl md:text-6xl font-black bg-gradient-to-br ${activeTheme.gradientText.from} ${activeTheme.gradientText.to} ${activeTheme.gradientText.darkFrom} ${activeTheme.gradientText.darkTo} bg-clip-text text-transparent`, children: IS_BETA_MODE ? t("helloSinger") : "Ol\xE1, vocalista!" }),
                    IS_BETA_MODE && /* @__PURE__ */ (0, import_jsx_runtime19.jsx)("div", { className: "mt-4 flex flex-col items-center", children: /* @__PURE__ */ (0, import_jsx_runtime19.jsx)("p", { className: "text-sm text-slate-500 dark:text-slate-400 mb-3 max-w-xs mx-auto", children: t("betaTestInvite") }) }),
                    !IS_BETA_MODE && /* @__PURE__ */ (0, import_jsx_runtime19.jsx)("p", { className: "mt-2 text-slate-600/60 dark:text-slate-400/60 text-xl", children: t("letsPractice") })
                  ] }) }),
                  activeView === "range" && /* @__PURE__ */ (0, import_jsx_runtime19.jsx)("section", { className: "flex-grow flex flex-col items-center justify-center -mt-24 md:mt-0", children: showPianoForRangeSelection ? /* @__PURE__ */ (0, import_jsx_runtime19.jsxs)(import_jsx_runtime19.Fragment, { children: [
                    /* @__PURE__ */ (0, import_jsx_runtime19.jsx)(Piano_default, { notes: pianoNotes, onKeyClick: handlePianoKeyClick, vocalRange, currentTheme: activeTheme }),
                    /* @__PURE__ */ (0, import_jsx_runtime19.jsxs)("div", { className: "flex flex-col items-center text-center mt-8", children: [
                      /* @__PURE__ */ (0, import_jsx_runtime19.jsx)("p", { className: "text-slate-600 dark:text-slate-300 text-lg mb-4", children: t("selectRangeOnPiano") }),
                      /* @__PURE__ */ (0, import_jsx_runtime19.jsx)("button", { onClick: () => {
                        setShowPianoForRangeSelection(false);
                        setVocalRange({ start: null, end: null });
                      }, className: "btn-interactive px-6 py-2 rounded-full font-semibold text-slate-700 dark:text-slate-200 bg-white/60 dark:bg-slate-800/50 backdrop-blur-sm border border-slate-300/50 dark:border-slate-600 shadow-sm", children: t("goBack") })
                    ] })
                  ] }) : /* @__PURE__ */ (0, import_jsx_runtime19.jsxs)("div", { className: "flex flex-col items-center text-center", children: [
                    /* @__PURE__ */ (0, import_jsx_runtime19.jsx)("p", { className: "text-slate-600 dark:text-slate-300 text-lg mb-4", children: t("vocalRangePrompt") }),
                    /* @__PURE__ */ (0, import_jsx_runtime19.jsxs)("div", { className: "flex flex-col sm:flex-row gap-4", children: [
                      /* @__PURE__ */ (0, import_jsx_runtime19.jsx)(ThemedButton_default, { onClick: () => handleStartRangeTest(), theme: activeTheme, children: t("detectMyRange") }),
                      /* @__PURE__ */ (0, import_jsx_runtime19.jsx)("button", { onClick: () => setShowPianoForRangeSelection(true), className: "btn-interactive px-6 py-2.5 rounded-full font-semibold text-slate-700 dark:text-slate-200 bg-white/60 dark:bg-slate-800/50 backdrop-blur-sm border border-slate-300/50 dark:border-slate-600 shadow-sm", children: t("iKnowMyRange") })
                    ] })
                  ] }) }),
                  activeView === "routines" && /* @__PURE__ */ (0, import_jsx_runtime19.jsx)(RoutineView_default, { onStartRoutine: handleStartRoutine, currentTheme: activeTheme, favoriteRoutineIds, onToggleFavorite: handleToggleFavoriteRoutine }),
                  activeView === "exercises" && /* @__PURE__ */ (0, import_jsx_runtime19.jsx)(ExerciseView_default, { onSelectExercise: selectExercise, currentTheme: activeTheme, savedAIExercises, favoriteExerciseIds, onToggleFavorite: handleToggleFavoriteExercise }),
                  activeView === "favorites" && /* @__PURE__ */ (0, import_jsx_runtime19.jsx)(FavoritesView_default, { ...{ currentTheme: activeTheme, favoriteRoutineIds, favoriteExerciseIds, savedAIExercises, onStartRoutine: handleStartRoutine, onSelectExercise: selectExercise, onToggleFavoriteRoutine: handleToggleFavoriteRoutine, onToggleFavoriteExercise: handleToggleFavoriteExercise } }),
                  activeView === "voxlabai" && /* @__PURE__ */ (0, import_jsx_runtime19.jsx)(AIStudioView_default, { currentTheme: activeTheme, onStartExercise: handleStartGeneratedExercise, onSave: handleSaveAIExercise, savedAIExercises, favoriteExerciseIds, onToggleFavorite: handleToggleFavoriteExercise, playNote, aiResult, setAiResult }),
                  activeView === "test" && /* @__PURE__ */ (0, import_jsx_runtime19.jsx)(TestModeView_default, { currentTheme: activeTheme, vocalRange: exerciseRange, userPitch, micGain, playNote, onToggleMic: handleMicToggle, micActive, compressorEnabled, setCompressorEnabled, pyinBias, setPyinBias, pyinTolerance, setPyinTolerance, pyinGateMode, setPyinGateMode, noiseGateThreshold, setNoiseGateThreshold, onBack: () => setActiveView("home") }),
                  activeView === "studies" && /* @__PURE__ */ (0, import_jsx_runtime19.jsx)(ComingSoonView_default, { title: t("studiesTitle"), description: t("studiesDesc"), currentTheme: activeTheme }),
                  activeView === "tokens" && /* @__PURE__ */ (0, import_jsx_runtime19.jsx)(ComingSoonView_default, { title: t("tokensTitle"), description: t("tokensDesc"), currentTheme: activeTheme })
                ] }, activeView),
                uiView === "exercise" && selectedExercise && (selectedExercise.isAIGenerated ? (
                  // Use Pitch Perfector for AI exercises
                  /* @__PURE__ */ (0, import_jsx_runtime19.jsx)(
                    AIExerciseView_default,
                    {
                      exercise: selectedExercise,
                      currentTheme: activeTheme,
                      themeMode,
                      language,
                      vocalRange,
                      onBack: () => {
                        handleStop();
                        setActiveView("voxlabai");
                      },
                      onEdit: () => {
                        handleStop();
                        setActiveView("voxlabai");
                      }
                    }
                  )
                ) : (
                  // Use regular view for normal exercises
                  /* @__PURE__ */ (0, import_jsx_runtime19.jsx)(
                    ExerciseGameViewALTWrapper_default,
                    {
                      exercise: selectedExercise,
                      vocalRange: exerciseRange,
                      userPitch,
                      micGain,
                      isPlaying,
                      isExerciseComplete,
                      onStop: handleStop,
                      onBack: handleStop,
                      onComplete: handleExerciseComplete,
                      onPlayPause: handlePlayPause,
                      onPreview: handlePreview,
                      isPreviewing,
                      playNote,
                      centerSemitone,
                      visibleOctaves,
                      currentTheme: activeTheme,
                      onNotePositionUpdate: setExerciseNoteCenter,
                      currentRoutine,
                      onNextInRoutine: handleNextExerciseInRoutine,
                      onToggleFavoriteExercise: handleToggleFavoriteExercise,
                      isExerciseFavorite: favoriteExerciseIds.includes(getExerciseId(selectedExercise)),
                      onToggleFavoriteRoutine: handleToggleFavoriteRoutine,
                      isRoutineFavorite: !!currentRoutine && favoriteRoutineIds.includes(currentRoutine.routine.id),
                      isFullscreen,
                      onToggleFullscreen: handleToggleFullscreen,
                      onRestart: () => setExerciseKey((prev) => prev + 1),
                      checkAudioBuffers,
                      pyinBias,
                      pyinTolerance,
                      pyinGateMode,
                      noiseGateThreshold
                    },
                    exerciseKey
                  )
                ))
              ] }),
              /* @__PURE__ */ (0, import_jsx_runtime19.jsx)(
                FloatingMenu_default,
                {
                  activeView,
                  setActiveView: handleViewChange,
                  setIsSettingsOpen,
                  currentTheme: activeTheme,
                  uiView,
                  isVisible: isMenuVisible
                }
              )
            ] }),
            IS_BETA_MODE && /* @__PURE__ */ (0, import_jsx_runtime19.jsx)(FeedbackOverlay_default, { currentTheme: activeTheme, activeView, currentExercise: selectedExercise, currentRoutine, uiView })
          ]
        }
      )
    ] });
  }

  // index.tsx
  var import_jsx_runtime20 = __toESM(require_jsx_runtime());
  var rootElement = document.getElementById("root");
  if (!rootElement) {
    throw new Error("Could not find root element to mount to");
  }
  var root = import_client.default.createRoot(rootElement);
  root.render(
    /* @__PURE__ */ (0, import_jsx_runtime20.jsx)(import_react17.default.StrictMode, { children: /* @__PURE__ */ (0, import_jsx_runtime20.jsx)(LanguageProvider, { children: /* @__PURE__ */ (0, import_jsx_runtime20.jsx)(App, {}) }) })
  );
})();
/*! Bundled license information:

react/cjs/react.production.js:
  (**
   * @license React
   * react.production.js
   *
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

scheduler/cjs/scheduler.production.js:
  (**
   * @license React
   * scheduler.production.js
   *
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

react-dom/cjs/react-dom.production.js:
  (**
   * @license React
   * react-dom.production.js
   *
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

react-dom/cjs/react-dom-client.production.js:
  (**
   * @license React
   * react-dom-client.production.js
   *
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

react/cjs/react-jsx-runtime.production.js:
  (**
   * @license React
   * react-jsx-runtime.production.js
   *
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

@google/genai/dist/web/index.mjs:
  (**
   * @license
   * Copyright 2025 Google LLC
   * SPDX-License-Identifier: Apache-2.0
   *)

lucide-react/dist/esm/shared/src/utils.js:
  (**
   * @license lucide-react v0.554.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   *)

lucide-react/dist/esm/defaultAttributes.js:
  (**
   * @license lucide-react v0.554.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   *)

lucide-react/dist/esm/Icon.js:
  (**
   * @license lucide-react v0.554.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   *)

lucide-react/dist/esm/createLucideIcon.js:
  (**
   * @license lucide-react v0.554.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   *)

lucide-react/dist/esm/icons/activity.js:
  (**
   * @license lucide-react v0.554.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   *)

lucide-react/dist/esm/icons/chevron-down.js:
  (**
   * @license lucide-react v0.554.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   *)

lucide-react/dist/esm/icons/chevron-left.js:
  (**
   * @license lucide-react v0.554.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   *)

lucide-react/dist/esm/icons/clock.js:
  (**
   * @license lucide-react v0.554.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   *)

lucide-react/dist/esm/icons/list-music.js:
  (**
   * @license lucide-react v0.554.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   *)

lucide-react/dist/esm/icons/mic.js:
  (**
   * @license lucide-react v0.554.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   *)

lucide-react/dist/esm/icons/music.js:
  (**
   * @license lucide-react v0.554.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   *)

lucide-react/dist/esm/icons/pause.js:
  (**
   * @license lucide-react v0.554.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   *)

lucide-react/dist/esm/icons/play.js:
  (**
   * @license lucide-react v0.554.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   *)

lucide-react/dist/esm/icons/rotate-ccw.js:
  (**
   * @license lucide-react v0.554.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   *)

lucide-react/dist/esm/icons/settings.js:
  (**
   * @license lucide-react v0.554.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   *)

lucide-react/dist/esm/icons/sliders-vertical.js:
  (**
   * @license lucide-react v0.554.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   *)

lucide-react/dist/esm/icons/sparkles.js:
  (**
   * @license lucide-react v0.554.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   *)

lucide-react/dist/esm/icons/square.js:
  (**
   * @license lucide-react v0.554.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   *)

lucide-react/dist/esm/icons/star.js:
  (**
   * @license lucide-react v0.554.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   *)

lucide-react/dist/esm/icons/volume-2.js:
  (**
   * @license lucide-react v0.554.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   *)

lucide-react/dist/esm/icons/zap.js:
  (**
   * @license lucide-react v0.554.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   *)

lucide-react/dist/esm/lucide-react.js:
  (**
   * @license lucide-react v0.554.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   *)
*/
